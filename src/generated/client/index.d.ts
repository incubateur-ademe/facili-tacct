
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model north_star_metric
 * 
 */
export type north_star_metric = $Result.DefaultSelection<Prisma.$north_star_metricPayload>
/**
 * Model sandbox_users
 * 
 */
export type sandbox_users = $Result.DefaultSelection<Prisma.$sandbox_usersPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model all_autocapture_raw
 * 
 */
export type all_autocapture_raw = $Result.DefaultSelection<Prisma.$all_autocapture_rawPayload>
/**
 * Model all_pageview_raw
 * 
 */
export type all_pageview_raw = $Result.DefaultSelection<Prisma.$all_pageview_rawPayload>
/**
 * Model baserow_evenements
 * 
 */
export type baserow_evenements = $Result.DefaultSelection<Prisma.$baserow_evenementsPayload>
/**
 * Model baserow_territoires
 * 
 */
export type baserow_territoires = $Result.DefaultSelection<Prisma.$baserow_territoiresPayload>
/**
 * Model boutons_export_raw
 * 
 */
export type boutons_export_raw = $Result.DefaultSelection<Prisma.$boutons_export_rawPayload>
/**
 * Model boutons_homepage
 * 
 */
export type boutons_homepage = $Result.DefaultSelection<Prisma.$boutons_homepagePayload>
/**
 * Model couverture_population
 * 
 */
export type couverture_population = $Result.DefaultSelection<Prisma.$couverture_populationPayload>
/**
 * Model ressources_consultees
 * 
 */
export type ressources_consultees = $Result.DefaultSelection<Prisma.$ressources_consulteesPayload>
/**
 * Model thematique
 * 
 */
export type thematique = $Result.DefaultSelection<Prisma.$thematiquePayload>
/**
 * Model agriculture
 * 
 */
export type agriculture = $Result.DefaultSelection<Prisma.$agriculturePayload>
/**
 * Model agriculture_bio
 * 
 */
export type agriculture_bio = $Result.DefaultSelection<Prisma.$agriculture_bioPayload>
/**
 * Model aot_40
 * 
 */
export type aot_40 = $Result.DefaultSelection<Prisma.$aot_40Payload>
/**
 * Model arretes_catnat
 * 
 */
export type arretes_catnat = $Result.DefaultSelection<Prisma.$arretes_catnatPayload>
/**
 * Model atlas_biodiversite
 * 
 */
export type atlas_biodiversite = $Result.DefaultSelection<Prisma.$atlas_biodiversitePayload>
/**
 * Model collectivites_searchbar
 * 
 */
export type collectivites_searchbar = $Result.DefaultSelection<Prisma.$collectivites_searchbarPayload>
/**
 * Model confort_thermique
 * 
 */
export type confort_thermique = $Result.DefaultSelection<Prisma.$confort_thermiquePayload>
/**
 * Model consommation_espaces_naf
 * 
 */
export type consommation_espaces_naf = $Result.DefaultSelection<Prisma.$consommation_espaces_nafPayload>
/**
 * Model export_cours_d_eau
 * 
 */
export type export_cours_d_eau = $Result.DefaultSelection<Prisma.$export_cours_d_eauPayload>
/**
 * Model feux_foret
 * 
 */
export type feux_foret = $Result.DefaultSelection<Prisma.$feux_foretPayload>
/**
 * Model lcz_couverture
 * 
 */
export type lcz_couverture = $Result.DefaultSelection<Prisma.$lcz_couverturePayload>
/**
 * Model patch4c
 * 
 */
export type patch4c = $Result.DefaultSelection<Prisma.$patch4cPayload>
/**
 * Model prelevements_eau
 * 
 */
export type prelevements_eau = $Result.DefaultSelection<Prisma.$prelevements_eauPayload>
/**
 * Model qualite_sites_baignade
 * 
 */
export type qualite_sites_baignade = $Result.DefaultSelection<Prisma.$qualite_sites_baignadePayload>
/**
 * Model ressources_eau
 * 
 */
export type ressources_eau = $Result.DefaultSelection<Prisma.$ressources_eauPayload>
/**
 * Model rga
 * 
 */
export type rga = $Result.DefaultSelection<Prisma.$rgaPayload>
/**
 * Model surfaces_agricoles
 * 
 */
export type surfaces_agricoles = $Result.DefaultSelection<Prisma.$surfaces_agricolesPayload>
/**
 * Model surfaces_protegees
 * 
 */
export type surfaces_protegees = $Result.DefaultSelection<Prisma.$surfaces_protegeesPayload>
/**
 * Model table_commune
 * 
 */
export type table_commune = $Result.DefaultSelection<Prisma.$table_communePayload>
/**
 * Model table_territoires
 * 
 */
export type table_territoires = $Result.DefaultSelection<Prisma.$table_territoiresPayload>
/**
 * Model communes_drom
 * 
 */
export type communes_drom = $Result.DefaultSelection<Prisma.$communes_dromPayload>
/**
 * Model erosion_cotiere
 * 
 */
export type erosion_cotiere = $Result.DefaultSelection<Prisma.$erosion_cotierePayload>
/**
 * Model etat_cours_d_eau
 * 
 */
export type etat_cours_d_eau = $Result.DefaultSelection<Prisma.$etat_cours_d_eauPayload>
/**
 * Model spatial_ref_sys
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type spatial_ref_sys = $Result.DefaultSelection<Prisma.$spatial_ref_sysPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more North_star_metrics
 * const north_star_metrics = await prisma.north_star_metric.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more North_star_metrics
   * const north_star_metrics = await prisma.north_star_metric.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.north_star_metric`: Exposes CRUD operations for the **north_star_metric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more North_star_metrics
    * const north_star_metrics = await prisma.north_star_metric.findMany()
    * ```
    */
  get north_star_metric(): Prisma.north_star_metricDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sandbox_users`: Exposes CRUD operations for the **sandbox_users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sandbox_users
    * const sandbox_users = await prisma.sandbox_users.findMany()
    * ```
    */
  get sandbox_users(): Prisma.sandbox_usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.all_autocapture_raw`: Exposes CRUD operations for the **all_autocapture_raw** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more All_autocapture_raws
    * const all_autocapture_raws = await prisma.all_autocapture_raw.findMany()
    * ```
    */
  get all_autocapture_raw(): Prisma.all_autocapture_rawDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.all_pageview_raw`: Exposes CRUD operations for the **all_pageview_raw** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more All_pageview_raws
    * const all_pageview_raws = await prisma.all_pageview_raw.findMany()
    * ```
    */
  get all_pageview_raw(): Prisma.all_pageview_rawDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.baserow_evenements`: Exposes CRUD operations for the **baserow_evenements** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Baserow_evenements
    * const baserow_evenements = await prisma.baserow_evenements.findMany()
    * ```
    */
  get baserow_evenements(): Prisma.baserow_evenementsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.baserow_territoires`: Exposes CRUD operations for the **baserow_territoires** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Baserow_territoires
    * const baserow_territoires = await prisma.baserow_territoires.findMany()
    * ```
    */
  get baserow_territoires(): Prisma.baserow_territoiresDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.boutons_export_raw`: Exposes CRUD operations for the **boutons_export_raw** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Boutons_export_raws
    * const boutons_export_raws = await prisma.boutons_export_raw.findMany()
    * ```
    */
  get boutons_export_raw(): Prisma.boutons_export_rawDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.boutons_homepage`: Exposes CRUD operations for the **boutons_homepage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Boutons_homepages
    * const boutons_homepages = await prisma.boutons_homepage.findMany()
    * ```
    */
  get boutons_homepage(): Prisma.boutons_homepageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.couverture_population`: Exposes CRUD operations for the **couverture_population** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Couverture_populations
    * const couverture_populations = await prisma.couverture_population.findMany()
    * ```
    */
  get couverture_population(): Prisma.couverture_populationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ressources_consultees`: Exposes CRUD operations for the **ressources_consultees** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ressources_consultees
    * const ressources_consultees = await prisma.ressources_consultees.findMany()
    * ```
    */
  get ressources_consultees(): Prisma.ressources_consulteesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.thematique`: Exposes CRUD operations for the **thematique** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Thematiques
    * const thematiques = await prisma.thematique.findMany()
    * ```
    */
  get thematique(): Prisma.thematiqueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agriculture`: Exposes CRUD operations for the **agriculture** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agricultures
    * const agricultures = await prisma.agriculture.findMany()
    * ```
    */
  get agriculture(): Prisma.agricultureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agriculture_bio`: Exposes CRUD operations for the **agriculture_bio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agriculture_bios
    * const agriculture_bios = await prisma.agriculture_bio.findMany()
    * ```
    */
  get agriculture_bio(): Prisma.agriculture_bioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aot_40`: Exposes CRUD operations for the **aot_40** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Aot_40s
    * const aot_40s = await prisma.aot_40.findMany()
    * ```
    */
  get aot_40(): Prisma.aot_40Delegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.arretes_catnat`: Exposes CRUD operations for the **arretes_catnat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Arretes_catnats
    * const arretes_catnats = await prisma.arretes_catnat.findMany()
    * ```
    */
  get arretes_catnat(): Prisma.arretes_catnatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.atlas_biodiversite`: Exposes CRUD operations for the **atlas_biodiversite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Atlas_biodiversites
    * const atlas_biodiversites = await prisma.atlas_biodiversite.findMany()
    * ```
    */
  get atlas_biodiversite(): Prisma.atlas_biodiversiteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.collectivites_searchbar`: Exposes CRUD operations for the **collectivites_searchbar** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Collectivites_searchbars
    * const collectivites_searchbars = await prisma.collectivites_searchbar.findMany()
    * ```
    */
  get collectivites_searchbar(): Prisma.collectivites_searchbarDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.confort_thermique`: Exposes CRUD operations for the **confort_thermique** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Confort_thermiques
    * const confort_thermiques = await prisma.confort_thermique.findMany()
    * ```
    */
  get confort_thermique(): Prisma.confort_thermiqueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.consommation_espaces_naf`: Exposes CRUD operations for the **consommation_espaces_naf** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Consommation_espaces_nafs
    * const consommation_espaces_nafs = await prisma.consommation_espaces_naf.findMany()
    * ```
    */
  get consommation_espaces_naf(): Prisma.consommation_espaces_nafDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.export_cours_d_eau`: Exposes CRUD operations for the **export_cours_d_eau** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Export_cours_d_eaus
    * const export_cours_d_eaus = await prisma.export_cours_d_eau.findMany()
    * ```
    */
  get export_cours_d_eau(): Prisma.export_cours_d_eauDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feux_foret`: Exposes CRUD operations for the **feux_foret** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Feux_forets
    * const feux_forets = await prisma.feux_foret.findMany()
    * ```
    */
  get feux_foret(): Prisma.feux_foretDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lcz_couverture`: Exposes CRUD operations for the **lcz_couverture** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lcz_couvertures
    * const lcz_couvertures = await prisma.lcz_couverture.findMany()
    * ```
    */
  get lcz_couverture(): Prisma.lcz_couvertureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patch4c`: Exposes CRUD operations for the **patch4c** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patch4cs
    * const patch4cs = await prisma.patch4c.findMany()
    * ```
    */
  get patch4c(): Prisma.patch4cDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.prelevements_eau`: Exposes CRUD operations for the **prelevements_eau** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prelevements_eaus
    * const prelevements_eaus = await prisma.prelevements_eau.findMany()
    * ```
    */
  get prelevements_eau(): Prisma.prelevements_eauDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.qualite_sites_baignade`: Exposes CRUD operations for the **qualite_sites_baignade** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Qualite_sites_baignades
    * const qualite_sites_baignades = await prisma.qualite_sites_baignade.findMany()
    * ```
    */
  get qualite_sites_baignade(): Prisma.qualite_sites_baignadeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ressources_eau`: Exposes CRUD operations for the **ressources_eau** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ressources_eaus
    * const ressources_eaus = await prisma.ressources_eau.findMany()
    * ```
    */
  get ressources_eau(): Prisma.ressources_eauDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rga`: Exposes CRUD operations for the **rga** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rgas
    * const rgas = await prisma.rga.findMany()
    * ```
    */
  get rga(): Prisma.rgaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.surfaces_agricoles`: Exposes CRUD operations for the **surfaces_agricoles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Surfaces_agricoles
    * const surfaces_agricoles = await prisma.surfaces_agricoles.findMany()
    * ```
    */
  get surfaces_agricoles(): Prisma.surfaces_agricolesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.surfaces_protegees`: Exposes CRUD operations for the **surfaces_protegees** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Surfaces_protegees
    * const surfaces_protegees = await prisma.surfaces_protegees.findMany()
    * ```
    */
  get surfaces_protegees(): Prisma.surfaces_protegeesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.table_commune`: Exposes CRUD operations for the **table_commune** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Table_communes
    * const table_communes = await prisma.table_commune.findMany()
    * ```
    */
  get table_commune(): Prisma.table_communeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.table_territoires`: Exposes CRUD operations for the **table_territoires** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Table_territoires
    * const table_territoires = await prisma.table_territoires.findMany()
    * ```
    */
  get table_territoires(): Prisma.table_territoiresDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.communes_drom`: Exposes CRUD operations for the **communes_drom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Communes_droms
    * const communes_droms = await prisma.communes_drom.findMany()
    * ```
    */
  get communes_drom(): Prisma.communes_dromDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.erosion_cotiere`: Exposes CRUD operations for the **erosion_cotiere** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Erosion_cotieres
    * const erosion_cotieres = await prisma.erosion_cotiere.findMany()
    * ```
    */
  get erosion_cotiere(): Prisma.erosion_cotiereDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.etat_cours_d_eau`: Exposes CRUD operations for the **etat_cours_d_eau** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Etat_cours_d_eaus
    * const etat_cours_d_eaus = await prisma.etat_cours_d_eau.findMany()
    * ```
    */
  get etat_cours_d_eau(): Prisma.etat_cours_d_eauDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.spatial_ref_sys`: Exposes CRUD operations for the **spatial_ref_sys** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Spatial_ref_sys
    * const spatial_ref_sys = await prisma.spatial_ref_sys.findMany()
    * ```
    */
  get spatial_ref_sys(): Prisma.spatial_ref_sysDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
<<<<<<< HEAD
   * Prisma Client JS version: 6.15.0
   * Query Engine version: 85179d7826409ee107a6ba334b5e305ae3fba9fb
=======
   * Prisma Client JS version: 7.0.0
   * Query Engine version: 0c19ccc313cf9911a90d99d2ac2eb0280c76c513
>>>>>>> dev
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    north_star_metric: 'north_star_metric',
    sandbox_users: 'sandbox_users',
    users: 'users',
    all_autocapture_raw: 'all_autocapture_raw',
    all_pageview_raw: 'all_pageview_raw',
    baserow_evenements: 'baserow_evenements',
    baserow_territoires: 'baserow_territoires',
    boutons_export_raw: 'boutons_export_raw',
    boutons_homepage: 'boutons_homepage',
    couverture_population: 'couverture_population',
    ressources_consultees: 'ressources_consultees',
    thematique: 'thematique',
    agriculture: 'agriculture',
    agriculture_bio: 'agriculture_bio',
    aot_40: 'aot_40',
    arretes_catnat: 'arretes_catnat',
    atlas_biodiversite: 'atlas_biodiversite',
    collectivites_searchbar: 'collectivites_searchbar',
    confort_thermique: 'confort_thermique',
    consommation_espaces_naf: 'consommation_espaces_naf',
    export_cours_d_eau: 'export_cours_d_eau',
    feux_foret: 'feux_foret',
    lcz_couverture: 'lcz_couverture',
    patch4c: 'patch4c',
    prelevements_eau: 'prelevements_eau',
    qualite_sites_baignade: 'qualite_sites_baignade',
    ressources_eau: 'ressources_eau',
    rga: 'rga',
    surfaces_agricoles: 'surfaces_agricoles',
    surfaces_protegees: 'surfaces_protegees',
    table_commune: 'table_commune',
    table_territoires: 'table_territoires',
    communes_drom: 'communes_drom',
    erosion_cotiere: 'erosion_cotiere',
    etat_cours_d_eau: 'etat_cours_d_eau',
    spatial_ref_sys: 'spatial_ref_sys'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "north_star_metric" | "sandbox_users" | "users" | "all_autocapture_raw" | "all_pageview_raw" | "baserow_evenements" | "baserow_territoires" | "boutons_export_raw" | "boutons_homepage" | "couverture_population" | "ressources_consultees" | "thematique" | "agriculture" | "agriculture_bio" | "aot_40" | "arretes_catnat" | "atlas_biodiversite" | "collectivites_searchbar" | "confort_thermique" | "consommation_espaces_naf" | "export_cours_d_eau" | "feux_foret" | "lcz_couverture" | "patch4c" | "prelevements_eau" | "qualite_sites_baignade" | "ressources_eau" | "rga" | "surfaces_agricoles" | "surfaces_protegees" | "table_commune" | "table_territoires" | "communes_drom" | "erosion_cotiere" | "etat_cours_d_eau" | "spatial_ref_sys"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      north_star_metric: {
        payload: Prisma.$north_star_metricPayload<ExtArgs>
        fields: Prisma.north_star_metricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.north_star_metricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$north_star_metricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.north_star_metricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$north_star_metricPayload>
          }
          findFirst: {
            args: Prisma.north_star_metricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$north_star_metricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.north_star_metricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$north_star_metricPayload>
          }
          findMany: {
            args: Prisma.north_star_metricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$north_star_metricPayload>[]
          }
          create: {
            args: Prisma.north_star_metricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$north_star_metricPayload>
          }
          createMany: {
            args: Prisma.north_star_metricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.north_star_metricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$north_star_metricPayload>[]
          }
          delete: {
            args: Prisma.north_star_metricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$north_star_metricPayload>
          }
          update: {
            args: Prisma.north_star_metricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$north_star_metricPayload>
          }
          deleteMany: {
            args: Prisma.north_star_metricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.north_star_metricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.north_star_metricUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$north_star_metricPayload>[]
          }
          upsert: {
            args: Prisma.north_star_metricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$north_star_metricPayload>
          }
          aggregate: {
            args: Prisma.North_star_metricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNorth_star_metric>
          }
          groupBy: {
            args: Prisma.north_star_metricGroupByArgs<ExtArgs>
            result: $Utils.Optional<North_star_metricGroupByOutputType>[]
          }
          count: {
            args: Prisma.north_star_metricCountArgs<ExtArgs>
            result: $Utils.Optional<North_star_metricCountAggregateOutputType> | number
          }
        }
      }
      sandbox_users: {
        payload: Prisma.$sandbox_usersPayload<ExtArgs>
        fields: Prisma.sandbox_usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sandbox_usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sandbox_usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sandbox_usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sandbox_usersPayload>
          }
          findFirst: {
            args: Prisma.sandbox_usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sandbox_usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sandbox_usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sandbox_usersPayload>
          }
          findMany: {
            args: Prisma.sandbox_usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sandbox_usersPayload>[]
          }
          create: {
            args: Prisma.sandbox_usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sandbox_usersPayload>
          }
          createMany: {
            args: Prisma.sandbox_usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.sandbox_usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sandbox_usersPayload>[]
          }
          delete: {
            args: Prisma.sandbox_usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sandbox_usersPayload>
          }
          update: {
            args: Prisma.sandbox_usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sandbox_usersPayload>
          }
          deleteMany: {
            args: Prisma.sandbox_usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sandbox_usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.sandbox_usersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sandbox_usersPayload>[]
          }
          upsert: {
            args: Prisma.sandbox_usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sandbox_usersPayload>
          }
          aggregate: {
            args: Prisma.Sandbox_usersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSandbox_users>
          }
          groupBy: {
            args: Prisma.sandbox_usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Sandbox_usersGroupByOutputType>[]
          }
          count: {
            args: Prisma.sandbox_usersCountArgs<ExtArgs>
            result: $Utils.Optional<Sandbox_usersCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      all_autocapture_raw: {
        payload: Prisma.$all_autocapture_rawPayload<ExtArgs>
        fields: Prisma.all_autocapture_rawFieldRefs
        operations: {
          findUnique: {
            args: Prisma.all_autocapture_rawFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$all_autocapture_rawPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.all_autocapture_rawFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$all_autocapture_rawPayload>
          }
          findFirst: {
            args: Prisma.all_autocapture_rawFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$all_autocapture_rawPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.all_autocapture_rawFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$all_autocapture_rawPayload>
          }
          findMany: {
            args: Prisma.all_autocapture_rawFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$all_autocapture_rawPayload>[]
          }
          create: {
            args: Prisma.all_autocapture_rawCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$all_autocapture_rawPayload>
          }
          createMany: {
            args: Prisma.all_autocapture_rawCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.all_autocapture_rawCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$all_autocapture_rawPayload>[]
          }
          delete: {
            args: Prisma.all_autocapture_rawDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$all_autocapture_rawPayload>
          }
          update: {
            args: Prisma.all_autocapture_rawUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$all_autocapture_rawPayload>
          }
          deleteMany: {
            args: Prisma.all_autocapture_rawDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.all_autocapture_rawUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.all_autocapture_rawUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$all_autocapture_rawPayload>[]
          }
          upsert: {
            args: Prisma.all_autocapture_rawUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$all_autocapture_rawPayload>
          }
          aggregate: {
            args: Prisma.All_autocapture_rawAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAll_autocapture_raw>
          }
          groupBy: {
            args: Prisma.all_autocapture_rawGroupByArgs<ExtArgs>
            result: $Utils.Optional<All_autocapture_rawGroupByOutputType>[]
          }
          count: {
            args: Prisma.all_autocapture_rawCountArgs<ExtArgs>
            result: $Utils.Optional<All_autocapture_rawCountAggregateOutputType> | number
          }
        }
      }
      all_pageview_raw: {
        payload: Prisma.$all_pageview_rawPayload<ExtArgs>
        fields: Prisma.all_pageview_rawFieldRefs
        operations: {
          findUnique: {
            args: Prisma.all_pageview_rawFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$all_pageview_rawPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.all_pageview_rawFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$all_pageview_rawPayload>
          }
          findFirst: {
            args: Prisma.all_pageview_rawFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$all_pageview_rawPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.all_pageview_rawFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$all_pageview_rawPayload>
          }
          findMany: {
            args: Prisma.all_pageview_rawFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$all_pageview_rawPayload>[]
          }
          create: {
            args: Prisma.all_pageview_rawCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$all_pageview_rawPayload>
          }
          createMany: {
            args: Prisma.all_pageview_rawCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.all_pageview_rawCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$all_pageview_rawPayload>[]
          }
          delete: {
            args: Prisma.all_pageview_rawDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$all_pageview_rawPayload>
          }
          update: {
            args: Prisma.all_pageview_rawUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$all_pageview_rawPayload>
          }
          deleteMany: {
            args: Prisma.all_pageview_rawDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.all_pageview_rawUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.all_pageview_rawUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$all_pageview_rawPayload>[]
          }
          upsert: {
            args: Prisma.all_pageview_rawUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$all_pageview_rawPayload>
          }
          aggregate: {
            args: Prisma.All_pageview_rawAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAll_pageview_raw>
          }
          groupBy: {
            args: Prisma.all_pageview_rawGroupByArgs<ExtArgs>
            result: $Utils.Optional<All_pageview_rawGroupByOutputType>[]
          }
          count: {
            args: Prisma.all_pageview_rawCountArgs<ExtArgs>
            result: $Utils.Optional<All_pageview_rawCountAggregateOutputType> | number
          }
        }
      }
      baserow_evenements: {
        payload: Prisma.$baserow_evenementsPayload<ExtArgs>
        fields: Prisma.baserow_evenementsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.baserow_evenementsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$baserow_evenementsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.baserow_evenementsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$baserow_evenementsPayload>
          }
          findFirst: {
            args: Prisma.baserow_evenementsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$baserow_evenementsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.baserow_evenementsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$baserow_evenementsPayload>
          }
          findMany: {
            args: Prisma.baserow_evenementsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$baserow_evenementsPayload>[]
          }
          create: {
            args: Prisma.baserow_evenementsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$baserow_evenementsPayload>
          }
          createMany: {
            args: Prisma.baserow_evenementsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.baserow_evenementsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$baserow_evenementsPayload>[]
          }
          delete: {
            args: Prisma.baserow_evenementsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$baserow_evenementsPayload>
          }
          update: {
            args: Prisma.baserow_evenementsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$baserow_evenementsPayload>
          }
          deleteMany: {
            args: Prisma.baserow_evenementsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.baserow_evenementsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.baserow_evenementsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$baserow_evenementsPayload>[]
          }
          upsert: {
            args: Prisma.baserow_evenementsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$baserow_evenementsPayload>
          }
          aggregate: {
            args: Prisma.Baserow_evenementsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBaserow_evenements>
          }
          groupBy: {
            args: Prisma.baserow_evenementsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Baserow_evenementsGroupByOutputType>[]
          }
          count: {
            args: Prisma.baserow_evenementsCountArgs<ExtArgs>
            result: $Utils.Optional<Baserow_evenementsCountAggregateOutputType> | number
          }
        }
      }
      baserow_territoires: {
        payload: Prisma.$baserow_territoiresPayload<ExtArgs>
        fields: Prisma.baserow_territoiresFieldRefs
        operations: {
          findUnique: {
            args: Prisma.baserow_territoiresFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$baserow_territoiresPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.baserow_territoiresFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$baserow_territoiresPayload>
          }
          findFirst: {
            args: Prisma.baserow_territoiresFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$baserow_territoiresPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.baserow_territoiresFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$baserow_territoiresPayload>
          }
          findMany: {
            args: Prisma.baserow_territoiresFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$baserow_territoiresPayload>[]
          }
          create: {
            args: Prisma.baserow_territoiresCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$baserow_territoiresPayload>
          }
          createMany: {
            args: Prisma.baserow_territoiresCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.baserow_territoiresCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$baserow_territoiresPayload>[]
          }
          delete: {
            args: Prisma.baserow_territoiresDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$baserow_territoiresPayload>
          }
          update: {
            args: Prisma.baserow_territoiresUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$baserow_territoiresPayload>
          }
          deleteMany: {
            args: Prisma.baserow_territoiresDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.baserow_territoiresUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.baserow_territoiresUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$baserow_territoiresPayload>[]
          }
          upsert: {
            args: Prisma.baserow_territoiresUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$baserow_territoiresPayload>
          }
          aggregate: {
            args: Prisma.Baserow_territoiresAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBaserow_territoires>
          }
          groupBy: {
            args: Prisma.baserow_territoiresGroupByArgs<ExtArgs>
            result: $Utils.Optional<Baserow_territoiresGroupByOutputType>[]
          }
          count: {
            args: Prisma.baserow_territoiresCountArgs<ExtArgs>
            result: $Utils.Optional<Baserow_territoiresCountAggregateOutputType> | number
          }
        }
      }
      boutons_export_raw: {
        payload: Prisma.$boutons_export_rawPayload<ExtArgs>
        fields: Prisma.boutons_export_rawFieldRefs
        operations: {
          findUnique: {
            args: Prisma.boutons_export_rawFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boutons_export_rawPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.boutons_export_rawFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boutons_export_rawPayload>
          }
          findFirst: {
            args: Prisma.boutons_export_rawFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boutons_export_rawPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.boutons_export_rawFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boutons_export_rawPayload>
          }
          findMany: {
            args: Prisma.boutons_export_rawFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boutons_export_rawPayload>[]
          }
          create: {
            args: Prisma.boutons_export_rawCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boutons_export_rawPayload>
          }
          createMany: {
            args: Prisma.boutons_export_rawCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.boutons_export_rawCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boutons_export_rawPayload>[]
          }
          delete: {
            args: Prisma.boutons_export_rawDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boutons_export_rawPayload>
          }
          update: {
            args: Prisma.boutons_export_rawUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boutons_export_rawPayload>
          }
          deleteMany: {
            args: Prisma.boutons_export_rawDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.boutons_export_rawUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.boutons_export_rawUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boutons_export_rawPayload>[]
          }
          upsert: {
            args: Prisma.boutons_export_rawUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boutons_export_rawPayload>
          }
          aggregate: {
            args: Prisma.Boutons_export_rawAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBoutons_export_raw>
          }
          groupBy: {
            args: Prisma.boutons_export_rawGroupByArgs<ExtArgs>
            result: $Utils.Optional<Boutons_export_rawGroupByOutputType>[]
          }
          count: {
            args: Prisma.boutons_export_rawCountArgs<ExtArgs>
            result: $Utils.Optional<Boutons_export_rawCountAggregateOutputType> | number
          }
        }
      }
      boutons_homepage: {
        payload: Prisma.$boutons_homepagePayload<ExtArgs>
        fields: Prisma.boutons_homepageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.boutons_homepageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boutons_homepagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.boutons_homepageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boutons_homepagePayload>
          }
          findFirst: {
            args: Prisma.boutons_homepageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boutons_homepagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.boutons_homepageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boutons_homepagePayload>
          }
          findMany: {
            args: Prisma.boutons_homepageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boutons_homepagePayload>[]
          }
          create: {
            args: Prisma.boutons_homepageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boutons_homepagePayload>
          }
          createMany: {
            args: Prisma.boutons_homepageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.boutons_homepageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boutons_homepagePayload>[]
          }
          delete: {
            args: Prisma.boutons_homepageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boutons_homepagePayload>
          }
          update: {
            args: Prisma.boutons_homepageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boutons_homepagePayload>
          }
          deleteMany: {
            args: Prisma.boutons_homepageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.boutons_homepageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.boutons_homepageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boutons_homepagePayload>[]
          }
          upsert: {
            args: Prisma.boutons_homepageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boutons_homepagePayload>
          }
          aggregate: {
            args: Prisma.Boutons_homepageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBoutons_homepage>
          }
          groupBy: {
            args: Prisma.boutons_homepageGroupByArgs<ExtArgs>
            result: $Utils.Optional<Boutons_homepageGroupByOutputType>[]
          }
          count: {
            args: Prisma.boutons_homepageCountArgs<ExtArgs>
            result: $Utils.Optional<Boutons_homepageCountAggregateOutputType> | number
          }
        }
      }
      couverture_population: {
        payload: Prisma.$couverture_populationPayload<ExtArgs>
        fields: Prisma.couverture_populationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.couverture_populationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couverture_populationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.couverture_populationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couverture_populationPayload>
          }
          findFirst: {
            args: Prisma.couverture_populationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couverture_populationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.couverture_populationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couverture_populationPayload>
          }
          findMany: {
            args: Prisma.couverture_populationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couverture_populationPayload>[]
          }
          create: {
            args: Prisma.couverture_populationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couverture_populationPayload>
          }
          createMany: {
            args: Prisma.couverture_populationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.couverture_populationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couverture_populationPayload>[]
          }
          delete: {
            args: Prisma.couverture_populationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couverture_populationPayload>
          }
          update: {
            args: Prisma.couverture_populationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couverture_populationPayload>
          }
          deleteMany: {
            args: Prisma.couverture_populationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.couverture_populationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.couverture_populationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couverture_populationPayload>[]
          }
          upsert: {
            args: Prisma.couverture_populationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$couverture_populationPayload>
          }
          aggregate: {
            args: Prisma.Couverture_populationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCouverture_population>
          }
          groupBy: {
            args: Prisma.couverture_populationGroupByArgs<ExtArgs>
            result: $Utils.Optional<Couverture_populationGroupByOutputType>[]
          }
          count: {
            args: Prisma.couverture_populationCountArgs<ExtArgs>
            result: $Utils.Optional<Couverture_populationCountAggregateOutputType> | number
          }
        }
      }
      ressources_consultees: {
        payload: Prisma.$ressources_consulteesPayload<ExtArgs>
        fields: Prisma.ressources_consulteesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ressources_consulteesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ressources_consulteesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ressources_consulteesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ressources_consulteesPayload>
          }
          findFirst: {
            args: Prisma.ressources_consulteesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ressources_consulteesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ressources_consulteesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ressources_consulteesPayload>
          }
          findMany: {
            args: Prisma.ressources_consulteesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ressources_consulteesPayload>[]
          }
          create: {
            args: Prisma.ressources_consulteesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ressources_consulteesPayload>
          }
          createMany: {
            args: Prisma.ressources_consulteesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ressources_consulteesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ressources_consulteesPayload>[]
          }
          delete: {
            args: Prisma.ressources_consulteesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ressources_consulteesPayload>
          }
          update: {
            args: Prisma.ressources_consulteesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ressources_consulteesPayload>
          }
          deleteMany: {
            args: Prisma.ressources_consulteesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ressources_consulteesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ressources_consulteesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ressources_consulteesPayload>[]
          }
          upsert: {
            args: Prisma.ressources_consulteesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ressources_consulteesPayload>
          }
          aggregate: {
            args: Prisma.Ressources_consulteesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRessources_consultees>
          }
          groupBy: {
            args: Prisma.ressources_consulteesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ressources_consulteesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ressources_consulteesCountArgs<ExtArgs>
            result: $Utils.Optional<Ressources_consulteesCountAggregateOutputType> | number
          }
        }
      }
      thematique: {
        payload: Prisma.$thematiquePayload<ExtArgs>
        fields: Prisma.thematiqueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.thematiqueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$thematiquePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.thematiqueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$thematiquePayload>
          }
          findFirst: {
            args: Prisma.thematiqueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$thematiquePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.thematiqueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$thematiquePayload>
          }
          findMany: {
            args: Prisma.thematiqueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$thematiquePayload>[]
          }
          create: {
            args: Prisma.thematiqueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$thematiquePayload>
          }
          createMany: {
            args: Prisma.thematiqueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.thematiqueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$thematiquePayload>[]
          }
          delete: {
            args: Prisma.thematiqueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$thematiquePayload>
          }
          update: {
            args: Prisma.thematiqueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$thematiquePayload>
          }
          deleteMany: {
            args: Prisma.thematiqueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.thematiqueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.thematiqueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$thematiquePayload>[]
          }
          upsert: {
            args: Prisma.thematiqueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$thematiquePayload>
          }
          aggregate: {
            args: Prisma.ThematiqueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateThematique>
          }
          groupBy: {
            args: Prisma.thematiqueGroupByArgs<ExtArgs>
            result: $Utils.Optional<ThematiqueGroupByOutputType>[]
          }
          count: {
            args: Prisma.thematiqueCountArgs<ExtArgs>
            result: $Utils.Optional<ThematiqueCountAggregateOutputType> | number
          }
        }
      }
      agriculture: {
        payload: Prisma.$agriculturePayload<ExtArgs>
        fields: Prisma.agricultureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.agricultureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agriculturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.agricultureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agriculturePayload>
          }
          findFirst: {
            args: Prisma.agricultureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agriculturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.agricultureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agriculturePayload>
          }
          findMany: {
            args: Prisma.agricultureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agriculturePayload>[]
          }
          create: {
            args: Prisma.agricultureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agriculturePayload>
          }
          createMany: {
            args: Prisma.agricultureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.agricultureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agriculturePayload>[]
          }
          delete: {
            args: Prisma.agricultureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agriculturePayload>
          }
          update: {
            args: Prisma.agricultureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agriculturePayload>
          }
          deleteMany: {
            args: Prisma.agricultureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.agricultureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.agricultureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agriculturePayload>[]
          }
          upsert: {
            args: Prisma.agricultureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agriculturePayload>
          }
          aggregate: {
            args: Prisma.AgricultureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgriculture>
          }
          groupBy: {
            args: Prisma.agricultureGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgricultureGroupByOutputType>[]
          }
          count: {
            args: Prisma.agricultureCountArgs<ExtArgs>
            result: $Utils.Optional<AgricultureCountAggregateOutputType> | number
          }
        }
      }
      agriculture_bio: {
        payload: Prisma.$agriculture_bioPayload<ExtArgs>
        fields: Prisma.agriculture_bioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.agriculture_bioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agriculture_bioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.agriculture_bioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agriculture_bioPayload>
          }
          findFirst: {
            args: Prisma.agriculture_bioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agriculture_bioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.agriculture_bioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agriculture_bioPayload>
          }
          findMany: {
            args: Prisma.agriculture_bioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agriculture_bioPayload>[]
          }
          create: {
            args: Prisma.agriculture_bioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agriculture_bioPayload>
          }
          createMany: {
            args: Prisma.agriculture_bioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.agriculture_bioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agriculture_bioPayload>[]
          }
          delete: {
            args: Prisma.agriculture_bioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agriculture_bioPayload>
          }
          update: {
            args: Prisma.agriculture_bioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agriculture_bioPayload>
          }
          deleteMany: {
            args: Prisma.agriculture_bioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.agriculture_bioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.agriculture_bioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agriculture_bioPayload>[]
          }
          upsert: {
            args: Prisma.agriculture_bioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agriculture_bioPayload>
          }
          aggregate: {
            args: Prisma.Agriculture_bioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgriculture_bio>
          }
          groupBy: {
            args: Prisma.agriculture_bioGroupByArgs<ExtArgs>
            result: $Utils.Optional<Agriculture_bioGroupByOutputType>[]
          }
          count: {
            args: Prisma.agriculture_bioCountArgs<ExtArgs>
            result: $Utils.Optional<Agriculture_bioCountAggregateOutputType> | number
          }
        }
      }
      aot_40: {
        payload: Prisma.$aot_40Payload<ExtArgs>
        fields: Prisma.aot_40FieldRefs
        operations: {
          findUnique: {
            args: Prisma.aot_40FindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aot_40Payload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.aot_40FindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aot_40Payload>
          }
          findFirst: {
            args: Prisma.aot_40FindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aot_40Payload> | null
          }
          findFirstOrThrow: {
            args: Prisma.aot_40FindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aot_40Payload>
          }
          findMany: {
            args: Prisma.aot_40FindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aot_40Payload>[]
          }
          create: {
            args: Prisma.aot_40CreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aot_40Payload>
          }
          createMany: {
            args: Prisma.aot_40CreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.aot_40CreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aot_40Payload>[]
          }
          delete: {
            args: Prisma.aot_40DeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aot_40Payload>
          }
          update: {
            args: Prisma.aot_40UpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aot_40Payload>
          }
          deleteMany: {
            args: Prisma.aot_40DeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.aot_40UpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.aot_40UpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aot_40Payload>[]
          }
          upsert: {
            args: Prisma.aot_40UpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aot_40Payload>
          }
          aggregate: {
            args: Prisma.Aot_40AggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAot_40>
          }
          groupBy: {
            args: Prisma.aot_40GroupByArgs<ExtArgs>
            result: $Utils.Optional<Aot_40GroupByOutputType>[]
          }
          count: {
            args: Prisma.aot_40CountArgs<ExtArgs>
            result: $Utils.Optional<Aot_40CountAggregateOutputType> | number
          }
        }
      }
      arretes_catnat: {
        payload: Prisma.$arretes_catnatPayload<ExtArgs>
        fields: Prisma.arretes_catnatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.arretes_catnatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$arretes_catnatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.arretes_catnatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$arretes_catnatPayload>
          }
          findFirst: {
            args: Prisma.arretes_catnatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$arretes_catnatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.arretes_catnatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$arretes_catnatPayload>
          }
          findMany: {
            args: Prisma.arretes_catnatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$arretes_catnatPayload>[]
          }
          create: {
            args: Prisma.arretes_catnatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$arretes_catnatPayload>
          }
          createMany: {
            args: Prisma.arretes_catnatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.arretes_catnatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$arretes_catnatPayload>[]
          }
          delete: {
            args: Prisma.arretes_catnatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$arretes_catnatPayload>
          }
          update: {
            args: Prisma.arretes_catnatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$arretes_catnatPayload>
          }
          deleteMany: {
            args: Prisma.arretes_catnatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.arretes_catnatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.arretes_catnatUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$arretes_catnatPayload>[]
          }
          upsert: {
            args: Prisma.arretes_catnatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$arretes_catnatPayload>
          }
          aggregate: {
            args: Prisma.Arretes_catnatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArretes_catnat>
          }
          groupBy: {
            args: Prisma.arretes_catnatGroupByArgs<ExtArgs>
            result: $Utils.Optional<Arretes_catnatGroupByOutputType>[]
          }
          count: {
            args: Prisma.arretes_catnatCountArgs<ExtArgs>
            result: $Utils.Optional<Arretes_catnatCountAggregateOutputType> | number
          }
        }
      }
      atlas_biodiversite: {
        payload: Prisma.$atlas_biodiversitePayload<ExtArgs>
        fields: Prisma.atlas_biodiversiteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.atlas_biodiversiteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$atlas_biodiversitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.atlas_biodiversiteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$atlas_biodiversitePayload>
          }
          findFirst: {
            args: Prisma.atlas_biodiversiteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$atlas_biodiversitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.atlas_biodiversiteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$atlas_biodiversitePayload>
          }
          findMany: {
            args: Prisma.atlas_biodiversiteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$atlas_biodiversitePayload>[]
          }
          create: {
            args: Prisma.atlas_biodiversiteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$atlas_biodiversitePayload>
          }
          createMany: {
            args: Prisma.atlas_biodiversiteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.atlas_biodiversiteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$atlas_biodiversitePayload>[]
          }
          delete: {
            args: Prisma.atlas_biodiversiteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$atlas_biodiversitePayload>
          }
          update: {
            args: Prisma.atlas_biodiversiteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$atlas_biodiversitePayload>
          }
          deleteMany: {
            args: Prisma.atlas_biodiversiteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.atlas_biodiversiteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.atlas_biodiversiteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$atlas_biodiversitePayload>[]
          }
          upsert: {
            args: Prisma.atlas_biodiversiteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$atlas_biodiversitePayload>
          }
          aggregate: {
            args: Prisma.Atlas_biodiversiteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAtlas_biodiversite>
          }
          groupBy: {
            args: Prisma.atlas_biodiversiteGroupByArgs<ExtArgs>
            result: $Utils.Optional<Atlas_biodiversiteGroupByOutputType>[]
          }
          count: {
            args: Prisma.atlas_biodiversiteCountArgs<ExtArgs>
            result: $Utils.Optional<Atlas_biodiversiteCountAggregateOutputType> | number
          }
        }
      }
      collectivites_searchbar: {
        payload: Prisma.$collectivites_searchbarPayload<ExtArgs>
        fields: Prisma.collectivites_searchbarFieldRefs
        operations: {
          findUnique: {
            args: Prisma.collectivites_searchbarFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collectivites_searchbarPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.collectivites_searchbarFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collectivites_searchbarPayload>
          }
          findFirst: {
            args: Prisma.collectivites_searchbarFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collectivites_searchbarPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.collectivites_searchbarFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collectivites_searchbarPayload>
          }
          findMany: {
            args: Prisma.collectivites_searchbarFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collectivites_searchbarPayload>[]
          }
          create: {
            args: Prisma.collectivites_searchbarCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collectivites_searchbarPayload>
          }
          createMany: {
            args: Prisma.collectivites_searchbarCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.collectivites_searchbarCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collectivites_searchbarPayload>[]
          }
          delete: {
            args: Prisma.collectivites_searchbarDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collectivites_searchbarPayload>
          }
          update: {
            args: Prisma.collectivites_searchbarUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collectivites_searchbarPayload>
          }
          deleteMany: {
            args: Prisma.collectivites_searchbarDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.collectivites_searchbarUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.collectivites_searchbarUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collectivites_searchbarPayload>[]
          }
          upsert: {
            args: Prisma.collectivites_searchbarUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$collectivites_searchbarPayload>
          }
          aggregate: {
            args: Prisma.Collectivites_searchbarAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCollectivites_searchbar>
          }
          groupBy: {
            args: Prisma.collectivites_searchbarGroupByArgs<ExtArgs>
            result: $Utils.Optional<Collectivites_searchbarGroupByOutputType>[]
          }
          count: {
            args: Prisma.collectivites_searchbarCountArgs<ExtArgs>
            result: $Utils.Optional<Collectivites_searchbarCountAggregateOutputType> | number
          }
        }
      }
      confort_thermique: {
        payload: Prisma.$confort_thermiquePayload<ExtArgs>
        fields: Prisma.confort_thermiqueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.confort_thermiqueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$confort_thermiquePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.confort_thermiqueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$confort_thermiquePayload>
          }
          findFirst: {
            args: Prisma.confort_thermiqueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$confort_thermiquePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.confort_thermiqueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$confort_thermiquePayload>
          }
          findMany: {
            args: Prisma.confort_thermiqueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$confort_thermiquePayload>[]
          }
          create: {
            args: Prisma.confort_thermiqueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$confort_thermiquePayload>
          }
          createMany: {
            args: Prisma.confort_thermiqueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.confort_thermiqueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$confort_thermiquePayload>[]
          }
          delete: {
            args: Prisma.confort_thermiqueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$confort_thermiquePayload>
          }
          update: {
            args: Prisma.confort_thermiqueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$confort_thermiquePayload>
          }
          deleteMany: {
            args: Prisma.confort_thermiqueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.confort_thermiqueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.confort_thermiqueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$confort_thermiquePayload>[]
          }
          upsert: {
            args: Prisma.confort_thermiqueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$confort_thermiquePayload>
          }
          aggregate: {
            args: Prisma.Confort_thermiqueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConfort_thermique>
          }
          groupBy: {
            args: Prisma.confort_thermiqueGroupByArgs<ExtArgs>
            result: $Utils.Optional<Confort_thermiqueGroupByOutputType>[]
          }
          count: {
            args: Prisma.confort_thermiqueCountArgs<ExtArgs>
            result: $Utils.Optional<Confort_thermiqueCountAggregateOutputType> | number
          }
        }
      }
      consommation_espaces_naf: {
        payload: Prisma.$consommation_espaces_nafPayload<ExtArgs>
        fields: Prisma.consommation_espaces_nafFieldRefs
        operations: {
          findUnique: {
            args: Prisma.consommation_espaces_nafFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consommation_espaces_nafPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.consommation_espaces_nafFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consommation_espaces_nafPayload>
          }
          findFirst: {
            args: Prisma.consommation_espaces_nafFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consommation_espaces_nafPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.consommation_espaces_nafFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consommation_espaces_nafPayload>
          }
          findMany: {
            args: Prisma.consommation_espaces_nafFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consommation_espaces_nafPayload>[]
          }
          create: {
            args: Prisma.consommation_espaces_nafCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consommation_espaces_nafPayload>
          }
          createMany: {
            args: Prisma.consommation_espaces_nafCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.consommation_espaces_nafCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consommation_espaces_nafPayload>[]
          }
          delete: {
            args: Prisma.consommation_espaces_nafDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consommation_espaces_nafPayload>
          }
          update: {
            args: Prisma.consommation_espaces_nafUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consommation_espaces_nafPayload>
          }
          deleteMany: {
            args: Prisma.consommation_espaces_nafDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.consommation_espaces_nafUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.consommation_espaces_nafUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consommation_espaces_nafPayload>[]
          }
          upsert: {
            args: Prisma.consommation_espaces_nafUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$consommation_espaces_nafPayload>
          }
          aggregate: {
            args: Prisma.Consommation_espaces_nafAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConsommation_espaces_naf>
          }
          groupBy: {
            args: Prisma.consommation_espaces_nafGroupByArgs<ExtArgs>
            result: $Utils.Optional<Consommation_espaces_nafGroupByOutputType>[]
          }
          count: {
            args: Prisma.consommation_espaces_nafCountArgs<ExtArgs>
            result: $Utils.Optional<Consommation_espaces_nafCountAggregateOutputType> | number
          }
        }
      }
      export_cours_d_eau: {
        payload: Prisma.$export_cours_d_eauPayload<ExtArgs>
        fields: Prisma.export_cours_d_eauFieldRefs
        operations: {
          findUnique: {
            args: Prisma.export_cours_d_eauFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$export_cours_d_eauPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.export_cours_d_eauFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$export_cours_d_eauPayload>
          }
          findFirst: {
            args: Prisma.export_cours_d_eauFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$export_cours_d_eauPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.export_cours_d_eauFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$export_cours_d_eauPayload>
          }
          findMany: {
            args: Prisma.export_cours_d_eauFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$export_cours_d_eauPayload>[]
          }
          create: {
            args: Prisma.export_cours_d_eauCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$export_cours_d_eauPayload>
          }
          createMany: {
            args: Prisma.export_cours_d_eauCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.export_cours_d_eauCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$export_cours_d_eauPayload>[]
          }
          delete: {
            args: Prisma.export_cours_d_eauDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$export_cours_d_eauPayload>
          }
          update: {
            args: Prisma.export_cours_d_eauUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$export_cours_d_eauPayload>
          }
          deleteMany: {
            args: Prisma.export_cours_d_eauDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.export_cours_d_eauUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.export_cours_d_eauUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$export_cours_d_eauPayload>[]
          }
          upsert: {
            args: Prisma.export_cours_d_eauUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$export_cours_d_eauPayload>
          }
          aggregate: {
            args: Prisma.Export_cours_d_eauAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExport_cours_d_eau>
          }
          groupBy: {
            args: Prisma.export_cours_d_eauGroupByArgs<ExtArgs>
            result: $Utils.Optional<Export_cours_d_eauGroupByOutputType>[]
          }
          count: {
            args: Prisma.export_cours_d_eauCountArgs<ExtArgs>
            result: $Utils.Optional<Export_cours_d_eauCountAggregateOutputType> | number
          }
        }
      }
      feux_foret: {
        payload: Prisma.$feux_foretPayload<ExtArgs>
        fields: Prisma.feux_foretFieldRefs
        operations: {
          findUnique: {
            args: Prisma.feux_foretFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feux_foretPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.feux_foretFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feux_foretPayload>
          }
          findFirst: {
            args: Prisma.feux_foretFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feux_foretPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.feux_foretFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feux_foretPayload>
          }
          findMany: {
            args: Prisma.feux_foretFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feux_foretPayload>[]
          }
          create: {
            args: Prisma.feux_foretCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feux_foretPayload>
          }
          createMany: {
            args: Prisma.feux_foretCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.feux_foretCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feux_foretPayload>[]
          }
          delete: {
            args: Prisma.feux_foretDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feux_foretPayload>
          }
          update: {
            args: Prisma.feux_foretUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feux_foretPayload>
          }
          deleteMany: {
            args: Prisma.feux_foretDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.feux_foretUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.feux_foretUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feux_foretPayload>[]
          }
          upsert: {
            args: Prisma.feux_foretUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feux_foretPayload>
          }
          aggregate: {
            args: Prisma.Feux_foretAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeux_foret>
          }
          groupBy: {
            args: Prisma.feux_foretGroupByArgs<ExtArgs>
            result: $Utils.Optional<Feux_foretGroupByOutputType>[]
          }
          count: {
            args: Prisma.feux_foretCountArgs<ExtArgs>
            result: $Utils.Optional<Feux_foretCountAggregateOutputType> | number
          }
        }
      }
      lcz_couverture: {
        payload: Prisma.$lcz_couverturePayload<ExtArgs>
        fields: Prisma.lcz_couvertureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.lcz_couvertureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lcz_couverturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.lcz_couvertureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lcz_couverturePayload>
          }
          findFirst: {
            args: Prisma.lcz_couvertureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lcz_couverturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.lcz_couvertureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lcz_couverturePayload>
          }
          findMany: {
            args: Prisma.lcz_couvertureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lcz_couverturePayload>[]
          }
          create: {
            args: Prisma.lcz_couvertureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lcz_couverturePayload>
          }
          createMany: {
            args: Prisma.lcz_couvertureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.lcz_couvertureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lcz_couverturePayload>[]
          }
          delete: {
            args: Prisma.lcz_couvertureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lcz_couverturePayload>
          }
          update: {
            args: Prisma.lcz_couvertureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lcz_couverturePayload>
          }
          deleteMany: {
            args: Prisma.lcz_couvertureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.lcz_couvertureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.lcz_couvertureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lcz_couverturePayload>[]
          }
          upsert: {
            args: Prisma.lcz_couvertureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lcz_couverturePayload>
          }
          aggregate: {
            args: Prisma.Lcz_couvertureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLcz_couverture>
          }
          groupBy: {
            args: Prisma.lcz_couvertureGroupByArgs<ExtArgs>
            result: $Utils.Optional<Lcz_couvertureGroupByOutputType>[]
          }
          count: {
            args: Prisma.lcz_couvertureCountArgs<ExtArgs>
            result: $Utils.Optional<Lcz_couvertureCountAggregateOutputType> | number
          }
        }
      }
      patch4c: {
        payload: Prisma.$patch4cPayload<ExtArgs>
        fields: Prisma.patch4cFieldRefs
        operations: {
          findUnique: {
            args: Prisma.patch4cFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patch4cPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.patch4cFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patch4cPayload>
          }
          findFirst: {
            args: Prisma.patch4cFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patch4cPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.patch4cFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patch4cPayload>
          }
          findMany: {
            args: Prisma.patch4cFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patch4cPayload>[]
          }
          create: {
            args: Prisma.patch4cCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patch4cPayload>
          }
          createMany: {
            args: Prisma.patch4cCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.patch4cCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patch4cPayload>[]
          }
          delete: {
            args: Prisma.patch4cDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patch4cPayload>
          }
          update: {
            args: Prisma.patch4cUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patch4cPayload>
          }
          deleteMany: {
            args: Prisma.patch4cDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.patch4cUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.patch4cUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patch4cPayload>[]
          }
          upsert: {
            args: Prisma.patch4cUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patch4cPayload>
          }
          aggregate: {
            args: Prisma.Patch4cAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatch4c>
          }
          groupBy: {
            args: Prisma.patch4cGroupByArgs<ExtArgs>
            result: $Utils.Optional<Patch4cGroupByOutputType>[]
          }
          count: {
            args: Prisma.patch4cCountArgs<ExtArgs>
            result: $Utils.Optional<Patch4cCountAggregateOutputType> | number
          }
        }
      }
      prelevements_eau: {
        payload: Prisma.$prelevements_eauPayload<ExtArgs>
        fields: Prisma.prelevements_eauFieldRefs
        operations: {
          findUnique: {
            args: Prisma.prelevements_eauFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prelevements_eauPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.prelevements_eauFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prelevements_eauPayload>
          }
          findFirst: {
            args: Prisma.prelevements_eauFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prelevements_eauPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.prelevements_eauFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prelevements_eauPayload>
          }
          findMany: {
            args: Prisma.prelevements_eauFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prelevements_eauPayload>[]
          }
          create: {
            args: Prisma.prelevements_eauCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prelevements_eauPayload>
          }
          createMany: {
            args: Prisma.prelevements_eauCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.prelevements_eauCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prelevements_eauPayload>[]
          }
          delete: {
            args: Prisma.prelevements_eauDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prelevements_eauPayload>
          }
          update: {
            args: Prisma.prelevements_eauUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prelevements_eauPayload>
          }
          deleteMany: {
            args: Prisma.prelevements_eauDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.prelevements_eauUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.prelevements_eauUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prelevements_eauPayload>[]
          }
          upsert: {
            args: Prisma.prelevements_eauUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$prelevements_eauPayload>
          }
          aggregate: {
            args: Prisma.Prelevements_eauAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrelevements_eau>
          }
          groupBy: {
            args: Prisma.prelevements_eauGroupByArgs<ExtArgs>
            result: $Utils.Optional<Prelevements_eauGroupByOutputType>[]
          }
          count: {
            args: Prisma.prelevements_eauCountArgs<ExtArgs>
            result: $Utils.Optional<Prelevements_eauCountAggregateOutputType> | number
          }
        }
      }
      qualite_sites_baignade: {
        payload: Prisma.$qualite_sites_baignadePayload<ExtArgs>
        fields: Prisma.qualite_sites_baignadeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.qualite_sites_baignadeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qualite_sites_baignadePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.qualite_sites_baignadeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qualite_sites_baignadePayload>
          }
          findFirst: {
            args: Prisma.qualite_sites_baignadeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qualite_sites_baignadePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.qualite_sites_baignadeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qualite_sites_baignadePayload>
          }
          findMany: {
            args: Prisma.qualite_sites_baignadeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qualite_sites_baignadePayload>[]
          }
          create: {
            args: Prisma.qualite_sites_baignadeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qualite_sites_baignadePayload>
          }
          createMany: {
            args: Prisma.qualite_sites_baignadeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.qualite_sites_baignadeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qualite_sites_baignadePayload>[]
          }
          delete: {
            args: Prisma.qualite_sites_baignadeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qualite_sites_baignadePayload>
          }
          update: {
            args: Prisma.qualite_sites_baignadeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qualite_sites_baignadePayload>
          }
          deleteMany: {
            args: Prisma.qualite_sites_baignadeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.qualite_sites_baignadeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.qualite_sites_baignadeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qualite_sites_baignadePayload>[]
          }
          upsert: {
            args: Prisma.qualite_sites_baignadeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$qualite_sites_baignadePayload>
          }
          aggregate: {
            args: Prisma.Qualite_sites_baignadeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQualite_sites_baignade>
          }
          groupBy: {
            args: Prisma.qualite_sites_baignadeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Qualite_sites_baignadeGroupByOutputType>[]
          }
          count: {
            args: Prisma.qualite_sites_baignadeCountArgs<ExtArgs>
            result: $Utils.Optional<Qualite_sites_baignadeCountAggregateOutputType> | number
          }
        }
      }
      ressources_eau: {
        payload: Prisma.$ressources_eauPayload<ExtArgs>
        fields: Prisma.ressources_eauFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ressources_eauFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ressources_eauPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ressources_eauFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ressources_eauPayload>
          }
          findFirst: {
            args: Prisma.ressources_eauFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ressources_eauPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ressources_eauFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ressources_eauPayload>
          }
          findMany: {
            args: Prisma.ressources_eauFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ressources_eauPayload>[]
          }
          create: {
            args: Prisma.ressources_eauCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ressources_eauPayload>
          }
          createMany: {
            args: Prisma.ressources_eauCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ressources_eauCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ressources_eauPayload>[]
          }
          delete: {
            args: Prisma.ressources_eauDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ressources_eauPayload>
          }
          update: {
            args: Prisma.ressources_eauUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ressources_eauPayload>
          }
          deleteMany: {
            args: Prisma.ressources_eauDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ressources_eauUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ressources_eauUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ressources_eauPayload>[]
          }
          upsert: {
            args: Prisma.ressources_eauUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ressources_eauPayload>
          }
          aggregate: {
            args: Prisma.Ressources_eauAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRessources_eau>
          }
          groupBy: {
            args: Prisma.ressources_eauGroupByArgs<ExtArgs>
            result: $Utils.Optional<Ressources_eauGroupByOutputType>[]
          }
          count: {
            args: Prisma.ressources_eauCountArgs<ExtArgs>
            result: $Utils.Optional<Ressources_eauCountAggregateOutputType> | number
          }
        }
      }
      rga: {
        payload: Prisma.$rgaPayload<ExtArgs>
        fields: Prisma.rgaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rgaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rgaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rgaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rgaPayload>
          }
          findFirst: {
            args: Prisma.rgaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rgaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rgaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rgaPayload>
          }
          findMany: {
            args: Prisma.rgaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rgaPayload>[]
          }
          create: {
            args: Prisma.rgaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rgaPayload>
          }
          createMany: {
            args: Prisma.rgaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.rgaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rgaPayload>[]
          }
          delete: {
            args: Prisma.rgaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rgaPayload>
          }
          update: {
            args: Prisma.rgaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rgaPayload>
          }
          deleteMany: {
            args: Prisma.rgaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rgaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.rgaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rgaPayload>[]
          }
          upsert: {
            args: Prisma.rgaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rgaPayload>
          }
          aggregate: {
            args: Prisma.RgaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRga>
          }
          groupBy: {
            args: Prisma.rgaGroupByArgs<ExtArgs>
            result: $Utils.Optional<RgaGroupByOutputType>[]
          }
          count: {
            args: Prisma.rgaCountArgs<ExtArgs>
            result: $Utils.Optional<RgaCountAggregateOutputType> | number
          }
        }
      }
      surfaces_agricoles: {
        payload: Prisma.$surfaces_agricolesPayload<ExtArgs>
        fields: Prisma.surfaces_agricolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.surfaces_agricolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surfaces_agricolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.surfaces_agricolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surfaces_agricolesPayload>
          }
          findFirst: {
            args: Prisma.surfaces_agricolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surfaces_agricolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.surfaces_agricolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surfaces_agricolesPayload>
          }
          findMany: {
            args: Prisma.surfaces_agricolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surfaces_agricolesPayload>[]
          }
          create: {
            args: Prisma.surfaces_agricolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surfaces_agricolesPayload>
          }
          createMany: {
            args: Prisma.surfaces_agricolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.surfaces_agricolesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surfaces_agricolesPayload>[]
          }
          delete: {
            args: Prisma.surfaces_agricolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surfaces_agricolesPayload>
          }
          update: {
            args: Prisma.surfaces_agricolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surfaces_agricolesPayload>
          }
          deleteMany: {
            args: Prisma.surfaces_agricolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.surfaces_agricolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.surfaces_agricolesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surfaces_agricolesPayload>[]
          }
          upsert: {
            args: Prisma.surfaces_agricolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surfaces_agricolesPayload>
          }
          aggregate: {
            args: Prisma.Surfaces_agricolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSurfaces_agricoles>
          }
          groupBy: {
            args: Prisma.surfaces_agricolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Surfaces_agricolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.surfaces_agricolesCountArgs<ExtArgs>
            result: $Utils.Optional<Surfaces_agricolesCountAggregateOutputType> | number
          }
        }
      }
      surfaces_protegees: {
        payload: Prisma.$surfaces_protegeesPayload<ExtArgs>
        fields: Prisma.surfaces_protegeesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.surfaces_protegeesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surfaces_protegeesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.surfaces_protegeesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surfaces_protegeesPayload>
          }
          findFirst: {
            args: Prisma.surfaces_protegeesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surfaces_protegeesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.surfaces_protegeesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surfaces_protegeesPayload>
          }
          findMany: {
            args: Prisma.surfaces_protegeesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surfaces_protegeesPayload>[]
          }
          create: {
            args: Prisma.surfaces_protegeesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surfaces_protegeesPayload>
          }
          createMany: {
            args: Prisma.surfaces_protegeesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.surfaces_protegeesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surfaces_protegeesPayload>[]
          }
          delete: {
            args: Prisma.surfaces_protegeesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surfaces_protegeesPayload>
          }
          update: {
            args: Prisma.surfaces_protegeesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surfaces_protegeesPayload>
          }
          deleteMany: {
            args: Prisma.surfaces_protegeesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.surfaces_protegeesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.surfaces_protegeesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surfaces_protegeesPayload>[]
          }
          upsert: {
            args: Prisma.surfaces_protegeesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$surfaces_protegeesPayload>
          }
          aggregate: {
            args: Prisma.Surfaces_protegeesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSurfaces_protegees>
          }
          groupBy: {
            args: Prisma.surfaces_protegeesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Surfaces_protegeesGroupByOutputType>[]
          }
          count: {
            args: Prisma.surfaces_protegeesCountArgs<ExtArgs>
            result: $Utils.Optional<Surfaces_protegeesCountAggregateOutputType> | number
          }
        }
      }
      table_commune: {
        payload: Prisma.$table_communePayload<ExtArgs>
        fields: Prisma.table_communeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.table_communeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$table_communePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.table_communeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$table_communePayload>
          }
          findFirst: {
            args: Prisma.table_communeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$table_communePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.table_communeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$table_communePayload>
          }
          findMany: {
            args: Prisma.table_communeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$table_communePayload>[]
          }
          create: {
            args: Prisma.table_communeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$table_communePayload>
          }
          createMany: {
            args: Prisma.table_communeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.table_communeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$table_communePayload>[]
          }
          delete: {
            args: Prisma.table_communeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$table_communePayload>
          }
          update: {
            args: Prisma.table_communeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$table_communePayload>
          }
          deleteMany: {
            args: Prisma.table_communeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.table_communeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.table_communeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$table_communePayload>[]
          }
          upsert: {
            args: Prisma.table_communeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$table_communePayload>
          }
          aggregate: {
            args: Prisma.Table_communeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTable_commune>
          }
          groupBy: {
            args: Prisma.table_communeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Table_communeGroupByOutputType>[]
          }
          count: {
            args: Prisma.table_communeCountArgs<ExtArgs>
            result: $Utils.Optional<Table_communeCountAggregateOutputType> | number
          }
        }
      }
      table_territoires: {
        payload: Prisma.$table_territoiresPayload<ExtArgs>
        fields: Prisma.table_territoiresFieldRefs
        operations: {
          findUnique: {
            args: Prisma.table_territoiresFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$table_territoiresPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.table_territoiresFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$table_territoiresPayload>
          }
          findFirst: {
            args: Prisma.table_territoiresFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$table_territoiresPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.table_territoiresFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$table_territoiresPayload>
          }
          findMany: {
            args: Prisma.table_territoiresFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$table_territoiresPayload>[]
          }
          create: {
            args: Prisma.table_territoiresCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$table_territoiresPayload>
          }
          createMany: {
            args: Prisma.table_territoiresCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.table_territoiresCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$table_territoiresPayload>[]
          }
          delete: {
            args: Prisma.table_territoiresDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$table_territoiresPayload>
          }
          update: {
            args: Prisma.table_territoiresUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$table_territoiresPayload>
          }
          deleteMany: {
            args: Prisma.table_territoiresDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.table_territoiresUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.table_territoiresUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$table_territoiresPayload>[]
          }
          upsert: {
            args: Prisma.table_territoiresUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$table_territoiresPayload>
          }
          aggregate: {
            args: Prisma.Table_territoiresAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTable_territoires>
          }
          groupBy: {
            args: Prisma.table_territoiresGroupByArgs<ExtArgs>
            result: $Utils.Optional<Table_territoiresGroupByOutputType>[]
          }
          count: {
            args: Prisma.table_territoiresCountArgs<ExtArgs>
            result: $Utils.Optional<Table_territoiresCountAggregateOutputType> | number
          }
        }
      }
      communes_drom: {
        payload: Prisma.$communes_dromPayload<ExtArgs>
        fields: Prisma.communes_dromFieldRefs
        operations: {
          findUnique: {
            args: Prisma.communes_dromFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$communes_dromPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.communes_dromFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$communes_dromPayload>
          }
          findFirst: {
            args: Prisma.communes_dromFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$communes_dromPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.communes_dromFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$communes_dromPayload>
          }
          findMany: {
            args: Prisma.communes_dromFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$communes_dromPayload>[]
          }
          create: {
            args: Prisma.communes_dromCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$communes_dromPayload>
          }
          createMany: {
            args: Prisma.communes_dromCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.communes_dromCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$communes_dromPayload>[]
          }
          delete: {
            args: Prisma.communes_dromDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$communes_dromPayload>
          }
          update: {
            args: Prisma.communes_dromUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$communes_dromPayload>
          }
          deleteMany: {
            args: Prisma.communes_dromDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.communes_dromUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.communes_dromUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$communes_dromPayload>[]
          }
          upsert: {
            args: Prisma.communes_dromUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$communes_dromPayload>
          }
          aggregate: {
            args: Prisma.Communes_dromAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommunes_drom>
          }
          groupBy: {
            args: Prisma.communes_dromGroupByArgs<ExtArgs>
            result: $Utils.Optional<Communes_dromGroupByOutputType>[]
          }
          count: {
            args: Prisma.communes_dromCountArgs<ExtArgs>
            result: $Utils.Optional<Communes_dromCountAggregateOutputType> | number
          }
        }
      }
      erosion_cotiere: {
        payload: Prisma.$erosion_cotierePayload<ExtArgs>
        fields: Prisma.erosion_cotiereFieldRefs
        operations: {
          findUnique: {
            args: Prisma.erosion_cotiereFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$erosion_cotierePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.erosion_cotiereFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$erosion_cotierePayload>
          }
          findFirst: {
            args: Prisma.erosion_cotiereFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$erosion_cotierePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.erosion_cotiereFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$erosion_cotierePayload>
          }
          findMany: {
            args: Prisma.erosion_cotiereFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$erosion_cotierePayload>[]
          }
          delete: {
            args: Prisma.erosion_cotiereDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$erosion_cotierePayload>
          }
          update: {
            args: Prisma.erosion_cotiereUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$erosion_cotierePayload>
          }
          deleteMany: {
            args: Prisma.erosion_cotiereDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.erosion_cotiereUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.erosion_cotiereUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$erosion_cotierePayload>[]
          }
          aggregate: {
            args: Prisma.Erosion_cotiereAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateErosion_cotiere>
          }
          groupBy: {
            args: Prisma.erosion_cotiereGroupByArgs<ExtArgs>
            result: $Utils.Optional<Erosion_cotiereGroupByOutputType>[]
          }
          count: {
            args: Prisma.erosion_cotiereCountArgs<ExtArgs>
            result: $Utils.Optional<Erosion_cotiereCountAggregateOutputType> | number
          }
        }
      }
      etat_cours_d_eau: {
        payload: Prisma.$etat_cours_d_eauPayload<ExtArgs>
        fields: Prisma.etat_cours_d_eauFieldRefs
        operations: {
          findUnique: {
            args: Prisma.etat_cours_d_eauFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$etat_cours_d_eauPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.etat_cours_d_eauFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$etat_cours_d_eauPayload>
          }
          findFirst: {
            args: Prisma.etat_cours_d_eauFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$etat_cours_d_eauPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.etat_cours_d_eauFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$etat_cours_d_eauPayload>
          }
          findMany: {
            args: Prisma.etat_cours_d_eauFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$etat_cours_d_eauPayload>[]
          }
          delete: {
            args: Prisma.etat_cours_d_eauDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$etat_cours_d_eauPayload>
          }
          update: {
            args: Prisma.etat_cours_d_eauUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$etat_cours_d_eauPayload>
          }
          deleteMany: {
            args: Prisma.etat_cours_d_eauDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.etat_cours_d_eauUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.etat_cours_d_eauUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$etat_cours_d_eauPayload>[]
          }
          aggregate: {
            args: Prisma.Etat_cours_d_eauAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEtat_cours_d_eau>
          }
          groupBy: {
            args: Prisma.etat_cours_d_eauGroupByArgs<ExtArgs>
            result: $Utils.Optional<Etat_cours_d_eauGroupByOutputType>[]
          }
          count: {
            args: Prisma.etat_cours_d_eauCountArgs<ExtArgs>
            result: $Utils.Optional<Etat_cours_d_eauCountAggregateOutputType> | number
          }
        }
      }
      spatial_ref_sys: {
        payload: Prisma.$spatial_ref_sysPayload<ExtArgs>
        fields: Prisma.spatial_ref_sysFieldRefs
        operations: {
          findUnique: {
            args: Prisma.spatial_ref_sysFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.spatial_ref_sysFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload>
          }
          findFirst: {
            args: Prisma.spatial_ref_sysFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.spatial_ref_sysFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload>
          }
          findMany: {
            args: Prisma.spatial_ref_sysFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload>[]
          }
          create: {
            args: Prisma.spatial_ref_sysCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload>
          }
          createMany: {
            args: Prisma.spatial_ref_sysCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.spatial_ref_sysCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload>[]
          }
          delete: {
            args: Prisma.spatial_ref_sysDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload>
          }
          update: {
            args: Prisma.spatial_ref_sysUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload>
          }
          deleteMany: {
            args: Prisma.spatial_ref_sysDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.spatial_ref_sysUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.spatial_ref_sysUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload>[]
          }
          upsert: {
            args: Prisma.spatial_ref_sysUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$spatial_ref_sysPayload>
          }
          aggregate: {
            args: Prisma.Spatial_ref_sysAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpatial_ref_sys>
          }
          groupBy: {
            args: Prisma.spatial_ref_sysGroupByArgs<ExtArgs>
            result: $Utils.Optional<Spatial_ref_sysGroupByOutputType>[]
          }
          count: {
            args: Prisma.spatial_ref_sysCountArgs<ExtArgs>
            result: $Utils.Optional<Spatial_ref_sysCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
<<<<<<< HEAD
=======
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
>>>>>>> dev
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    north_star_metric?: north_star_metricOmit
    sandbox_users?: sandbox_usersOmit
    users?: usersOmit
    all_autocapture_raw?: all_autocapture_rawOmit
    all_pageview_raw?: all_pageview_rawOmit
    baserow_evenements?: baserow_evenementsOmit
    baserow_territoires?: baserow_territoiresOmit
    boutons_export_raw?: boutons_export_rawOmit
    boutons_homepage?: boutons_homepageOmit
    couverture_population?: couverture_populationOmit
    ressources_consultees?: ressources_consulteesOmit
    thematique?: thematiqueOmit
    agriculture?: agricultureOmit
    agriculture_bio?: agriculture_bioOmit
    aot_40?: aot_40Omit
    arretes_catnat?: arretes_catnatOmit
    atlas_biodiversite?: atlas_biodiversiteOmit
    collectivites_searchbar?: collectivites_searchbarOmit
    confort_thermique?: confort_thermiqueOmit
    consommation_espaces_naf?: consommation_espaces_nafOmit
    export_cours_d_eau?: export_cours_d_eauOmit
    feux_foret?: feux_foretOmit
    lcz_couverture?: lcz_couvertureOmit
    patch4c?: patch4cOmit
    prelevements_eau?: prelevements_eauOmit
    qualite_sites_baignade?: qualite_sites_baignadeOmit
    ressources_eau?: ressources_eauOmit
    rga?: rgaOmit
    surfaces_agricoles?: surfaces_agricolesOmit
    surfaces_protegees?: surfaces_protegeesOmit
    table_commune?: table_communeOmit
    table_territoires?: table_territoiresOmit
    communes_drom?: communes_dromOmit
    erosion_cotiere?: erosion_cotiereOmit
    etat_cours_d_eau?: etat_cours_d_eauOmit
    spatial_ref_sys?: spatial_ref_sysOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model north_star_metric
   */

  export type AggregateNorth_star_metric = {
    _count: North_star_metricCountAggregateOutputType | null
    _avg: North_star_metricAvgAggregateOutputType | null
    _sum: North_star_metricSumAggregateOutputType | null
    _min: North_star_metricMinAggregateOutputType | null
    _max: North_star_metricMaxAggregateOutputType | null
  }

  export type North_star_metricAvgAggregateOutputType = {
    pk: number | null
  }

  export type North_star_metricSumAggregateOutputType = {
    pk: number | null
  }

  export type North_star_metricMinAggregateOutputType = {
    value: string | null
    date: Date | null
    pk: number | null
  }

  export type North_star_metricMaxAggregateOutputType = {
    value: string | null
    date: Date | null
    pk: number | null
  }

  export type North_star_metricCountAggregateOutputType = {
    value: number
    date: number
    pk: number
    _all: number
  }


  export type North_star_metricAvgAggregateInputType = {
    pk?: true
  }

  export type North_star_metricSumAggregateInputType = {
    pk?: true
  }

  export type North_star_metricMinAggregateInputType = {
    value?: true
    date?: true
    pk?: true
  }

  export type North_star_metricMaxAggregateInputType = {
    value?: true
    date?: true
    pk?: true
  }

  export type North_star_metricCountAggregateInputType = {
    value?: true
    date?: true
    pk?: true
    _all?: true
  }

  export type North_star_metricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which north_star_metric to aggregate.
     */
    where?: north_star_metricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of north_star_metrics to fetch.
     */
    orderBy?: north_star_metricOrderByWithRelationInput | north_star_metricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: north_star_metricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` north_star_metrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` north_star_metrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned north_star_metrics
    **/
    _count?: true | North_star_metricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: North_star_metricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: North_star_metricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: North_star_metricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: North_star_metricMaxAggregateInputType
  }

  export type GetNorth_star_metricAggregateType<T extends North_star_metricAggregateArgs> = {
        [P in keyof T & keyof AggregateNorth_star_metric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNorth_star_metric[P]>
      : GetScalarType<T[P], AggregateNorth_star_metric[P]>
  }




  export type north_star_metricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: north_star_metricWhereInput
    orderBy?: north_star_metricOrderByWithAggregationInput | north_star_metricOrderByWithAggregationInput[]
    by: North_star_metricScalarFieldEnum[] | North_star_metricScalarFieldEnum
    having?: north_star_metricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: North_star_metricCountAggregateInputType | true
    _avg?: North_star_metricAvgAggregateInputType
    _sum?: North_star_metricSumAggregateInputType
    _min?: North_star_metricMinAggregateInputType
    _max?: North_star_metricMaxAggregateInputType
  }

  export type North_star_metricGroupByOutputType = {
    value: string
    date: Date
    pk: number
    _count: North_star_metricCountAggregateOutputType | null
    _avg: North_star_metricAvgAggregateOutputType | null
    _sum: North_star_metricSumAggregateOutputType | null
    _min: North_star_metricMinAggregateOutputType | null
    _max: North_star_metricMaxAggregateOutputType | null
  }

  type GetNorth_star_metricGroupByPayload<T extends north_star_metricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<North_star_metricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof North_star_metricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], North_star_metricGroupByOutputType[P]>
            : GetScalarType<T[P], North_star_metricGroupByOutputType[P]>
        }
      >
    >


  export type north_star_metricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    value?: boolean
    date?: boolean
    pk?: boolean
  }, ExtArgs["result"]["north_star_metric"]>

  export type north_star_metricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    value?: boolean
    date?: boolean
    pk?: boolean
  }, ExtArgs["result"]["north_star_metric"]>

  export type north_star_metricSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    value?: boolean
    date?: boolean
    pk?: boolean
  }, ExtArgs["result"]["north_star_metric"]>

  export type north_star_metricSelectScalar = {
    value?: boolean
    date?: boolean
    pk?: boolean
  }

  export type north_star_metricOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"value" | "date" | "pk", ExtArgs["result"]["north_star_metric"]>

  export type $north_star_metricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "north_star_metric"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      value: string
      date: Date
      pk: number
    }, ExtArgs["result"]["north_star_metric"]>
    composites: {}
  }

  type north_star_metricGetPayload<S extends boolean | null | undefined | north_star_metricDefaultArgs> = $Result.GetResult<Prisma.$north_star_metricPayload, S>

  type north_star_metricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<north_star_metricFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: North_star_metricCountAggregateInputType | true
    }

  export interface north_star_metricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['north_star_metric'], meta: { name: 'north_star_metric' } }
    /**
     * Find zero or one North_star_metric that matches the filter.
     * @param {north_star_metricFindUniqueArgs} args - Arguments to find a North_star_metric
     * @example
     * // Get one North_star_metric
     * const north_star_metric = await prisma.north_star_metric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends north_star_metricFindUniqueArgs>(args: SelectSubset<T, north_star_metricFindUniqueArgs<ExtArgs>>): Prisma__north_star_metricClient<$Result.GetResult<Prisma.$north_star_metricPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one North_star_metric that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {north_star_metricFindUniqueOrThrowArgs} args - Arguments to find a North_star_metric
     * @example
     * // Get one North_star_metric
     * const north_star_metric = await prisma.north_star_metric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends north_star_metricFindUniqueOrThrowArgs>(args: SelectSubset<T, north_star_metricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__north_star_metricClient<$Result.GetResult<Prisma.$north_star_metricPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first North_star_metric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {north_star_metricFindFirstArgs} args - Arguments to find a North_star_metric
     * @example
     * // Get one North_star_metric
     * const north_star_metric = await prisma.north_star_metric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends north_star_metricFindFirstArgs>(args?: SelectSubset<T, north_star_metricFindFirstArgs<ExtArgs>>): Prisma__north_star_metricClient<$Result.GetResult<Prisma.$north_star_metricPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first North_star_metric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {north_star_metricFindFirstOrThrowArgs} args - Arguments to find a North_star_metric
     * @example
     * // Get one North_star_metric
     * const north_star_metric = await prisma.north_star_metric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends north_star_metricFindFirstOrThrowArgs>(args?: SelectSubset<T, north_star_metricFindFirstOrThrowArgs<ExtArgs>>): Prisma__north_star_metricClient<$Result.GetResult<Prisma.$north_star_metricPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more North_star_metrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {north_star_metricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all North_star_metrics
     * const north_star_metrics = await prisma.north_star_metric.findMany()
     * 
     * // Get first 10 North_star_metrics
     * const north_star_metrics = await prisma.north_star_metric.findMany({ take: 10 })
     * 
     * // Only select the `value`
     * const north_star_metricWithValueOnly = await prisma.north_star_metric.findMany({ select: { value: true } })
     * 
     */
    findMany<T extends north_star_metricFindManyArgs>(args?: SelectSubset<T, north_star_metricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$north_star_metricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a North_star_metric.
     * @param {north_star_metricCreateArgs} args - Arguments to create a North_star_metric.
     * @example
     * // Create one North_star_metric
     * const North_star_metric = await prisma.north_star_metric.create({
     *   data: {
     *     // ... data to create a North_star_metric
     *   }
     * })
     * 
     */
    create<T extends north_star_metricCreateArgs>(args: SelectSubset<T, north_star_metricCreateArgs<ExtArgs>>): Prisma__north_star_metricClient<$Result.GetResult<Prisma.$north_star_metricPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many North_star_metrics.
     * @param {north_star_metricCreateManyArgs} args - Arguments to create many North_star_metrics.
     * @example
     * // Create many North_star_metrics
     * const north_star_metric = await prisma.north_star_metric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends north_star_metricCreateManyArgs>(args?: SelectSubset<T, north_star_metricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many North_star_metrics and returns the data saved in the database.
     * @param {north_star_metricCreateManyAndReturnArgs} args - Arguments to create many North_star_metrics.
     * @example
     * // Create many North_star_metrics
     * const north_star_metric = await prisma.north_star_metric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many North_star_metrics and only return the `value`
     * const north_star_metricWithValueOnly = await prisma.north_star_metric.createManyAndReturn({
     *   select: { value: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends north_star_metricCreateManyAndReturnArgs>(args?: SelectSubset<T, north_star_metricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$north_star_metricPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a North_star_metric.
     * @param {north_star_metricDeleteArgs} args - Arguments to delete one North_star_metric.
     * @example
     * // Delete one North_star_metric
     * const North_star_metric = await prisma.north_star_metric.delete({
     *   where: {
     *     // ... filter to delete one North_star_metric
     *   }
     * })
     * 
     */
    delete<T extends north_star_metricDeleteArgs>(args: SelectSubset<T, north_star_metricDeleteArgs<ExtArgs>>): Prisma__north_star_metricClient<$Result.GetResult<Prisma.$north_star_metricPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one North_star_metric.
     * @param {north_star_metricUpdateArgs} args - Arguments to update one North_star_metric.
     * @example
     * // Update one North_star_metric
     * const north_star_metric = await prisma.north_star_metric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends north_star_metricUpdateArgs>(args: SelectSubset<T, north_star_metricUpdateArgs<ExtArgs>>): Prisma__north_star_metricClient<$Result.GetResult<Prisma.$north_star_metricPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more North_star_metrics.
     * @param {north_star_metricDeleteManyArgs} args - Arguments to filter North_star_metrics to delete.
     * @example
     * // Delete a few North_star_metrics
     * const { count } = await prisma.north_star_metric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends north_star_metricDeleteManyArgs>(args?: SelectSubset<T, north_star_metricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more North_star_metrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {north_star_metricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many North_star_metrics
     * const north_star_metric = await prisma.north_star_metric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends north_star_metricUpdateManyArgs>(args: SelectSubset<T, north_star_metricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more North_star_metrics and returns the data updated in the database.
     * @param {north_star_metricUpdateManyAndReturnArgs} args - Arguments to update many North_star_metrics.
     * @example
     * // Update many North_star_metrics
     * const north_star_metric = await prisma.north_star_metric.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more North_star_metrics and only return the `value`
     * const north_star_metricWithValueOnly = await prisma.north_star_metric.updateManyAndReturn({
     *   select: { value: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends north_star_metricUpdateManyAndReturnArgs>(args: SelectSubset<T, north_star_metricUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$north_star_metricPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one North_star_metric.
     * @param {north_star_metricUpsertArgs} args - Arguments to update or create a North_star_metric.
     * @example
     * // Update or create a North_star_metric
     * const north_star_metric = await prisma.north_star_metric.upsert({
     *   create: {
     *     // ... data to create a North_star_metric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the North_star_metric we want to update
     *   }
     * })
     */
    upsert<T extends north_star_metricUpsertArgs>(args: SelectSubset<T, north_star_metricUpsertArgs<ExtArgs>>): Prisma__north_star_metricClient<$Result.GetResult<Prisma.$north_star_metricPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of North_star_metrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {north_star_metricCountArgs} args - Arguments to filter North_star_metrics to count.
     * @example
     * // Count the number of North_star_metrics
     * const count = await prisma.north_star_metric.count({
     *   where: {
     *     // ... the filter for the North_star_metrics we want to count
     *   }
     * })
    **/
    count<T extends north_star_metricCountArgs>(
      args?: Subset<T, north_star_metricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], North_star_metricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a North_star_metric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {North_star_metricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends North_star_metricAggregateArgs>(args: Subset<T, North_star_metricAggregateArgs>): Prisma.PrismaPromise<GetNorth_star_metricAggregateType<T>>

    /**
     * Group by North_star_metric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {north_star_metricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends north_star_metricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: north_star_metricGroupByArgs['orderBy'] }
        : { orderBy?: north_star_metricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, north_star_metricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNorth_star_metricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the north_star_metric model
   */
  readonly fields: north_star_metricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for north_star_metric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__north_star_metricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the north_star_metric model
   */
  interface north_star_metricFieldRefs {
    readonly value: FieldRef<"north_star_metric", 'String'>
    readonly date: FieldRef<"north_star_metric", 'DateTime'>
    readonly pk: FieldRef<"north_star_metric", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * north_star_metric findUnique
   */
  export type north_star_metricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the north_star_metric
     */
    select?: north_star_metricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the north_star_metric
     */
    omit?: north_star_metricOmit<ExtArgs> | null
    /**
     * Filter, which north_star_metric to fetch.
     */
    where: north_star_metricWhereUniqueInput
  }

  /**
   * north_star_metric findUniqueOrThrow
   */
  export type north_star_metricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the north_star_metric
     */
    select?: north_star_metricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the north_star_metric
     */
    omit?: north_star_metricOmit<ExtArgs> | null
    /**
     * Filter, which north_star_metric to fetch.
     */
    where: north_star_metricWhereUniqueInput
  }

  /**
   * north_star_metric findFirst
   */
  export type north_star_metricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the north_star_metric
     */
    select?: north_star_metricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the north_star_metric
     */
    omit?: north_star_metricOmit<ExtArgs> | null
    /**
     * Filter, which north_star_metric to fetch.
     */
    where?: north_star_metricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of north_star_metrics to fetch.
     */
    orderBy?: north_star_metricOrderByWithRelationInput | north_star_metricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for north_star_metrics.
     */
    cursor?: north_star_metricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` north_star_metrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` north_star_metrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of north_star_metrics.
     */
    distinct?: North_star_metricScalarFieldEnum | North_star_metricScalarFieldEnum[]
  }

  /**
   * north_star_metric findFirstOrThrow
   */
  export type north_star_metricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the north_star_metric
     */
    select?: north_star_metricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the north_star_metric
     */
    omit?: north_star_metricOmit<ExtArgs> | null
    /**
     * Filter, which north_star_metric to fetch.
     */
    where?: north_star_metricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of north_star_metrics to fetch.
     */
    orderBy?: north_star_metricOrderByWithRelationInput | north_star_metricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for north_star_metrics.
     */
    cursor?: north_star_metricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` north_star_metrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` north_star_metrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of north_star_metrics.
     */
    distinct?: North_star_metricScalarFieldEnum | North_star_metricScalarFieldEnum[]
  }

  /**
   * north_star_metric findMany
   */
  export type north_star_metricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the north_star_metric
     */
    select?: north_star_metricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the north_star_metric
     */
    omit?: north_star_metricOmit<ExtArgs> | null
    /**
     * Filter, which north_star_metrics to fetch.
     */
    where?: north_star_metricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of north_star_metrics to fetch.
     */
    orderBy?: north_star_metricOrderByWithRelationInput | north_star_metricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing north_star_metrics.
     */
    cursor?: north_star_metricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` north_star_metrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` north_star_metrics.
     */
    skip?: number
    distinct?: North_star_metricScalarFieldEnum | North_star_metricScalarFieldEnum[]
  }

  /**
   * north_star_metric create
   */
  export type north_star_metricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the north_star_metric
     */
    select?: north_star_metricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the north_star_metric
     */
    omit?: north_star_metricOmit<ExtArgs> | null
    /**
     * The data needed to create a north_star_metric.
     */
    data: XOR<north_star_metricCreateInput, north_star_metricUncheckedCreateInput>
  }

  /**
   * north_star_metric createMany
   */
  export type north_star_metricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many north_star_metrics.
     */
    data: north_star_metricCreateManyInput | north_star_metricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * north_star_metric createManyAndReturn
   */
  export type north_star_metricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the north_star_metric
     */
    select?: north_star_metricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the north_star_metric
     */
    omit?: north_star_metricOmit<ExtArgs> | null
    /**
     * The data used to create many north_star_metrics.
     */
    data: north_star_metricCreateManyInput | north_star_metricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * north_star_metric update
   */
  export type north_star_metricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the north_star_metric
     */
    select?: north_star_metricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the north_star_metric
     */
    omit?: north_star_metricOmit<ExtArgs> | null
    /**
     * The data needed to update a north_star_metric.
     */
    data: XOR<north_star_metricUpdateInput, north_star_metricUncheckedUpdateInput>
    /**
     * Choose, which north_star_metric to update.
     */
    where: north_star_metricWhereUniqueInput
  }

  /**
   * north_star_metric updateMany
   */
  export type north_star_metricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update north_star_metrics.
     */
    data: XOR<north_star_metricUpdateManyMutationInput, north_star_metricUncheckedUpdateManyInput>
    /**
     * Filter which north_star_metrics to update
     */
    where?: north_star_metricWhereInput
    /**
     * Limit how many north_star_metrics to update.
     */
    limit?: number
  }

  /**
   * north_star_metric updateManyAndReturn
   */
  export type north_star_metricUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the north_star_metric
     */
    select?: north_star_metricSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the north_star_metric
     */
    omit?: north_star_metricOmit<ExtArgs> | null
    /**
     * The data used to update north_star_metrics.
     */
    data: XOR<north_star_metricUpdateManyMutationInput, north_star_metricUncheckedUpdateManyInput>
    /**
     * Filter which north_star_metrics to update
     */
    where?: north_star_metricWhereInput
    /**
     * Limit how many north_star_metrics to update.
     */
    limit?: number
  }

  /**
   * north_star_metric upsert
   */
  export type north_star_metricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the north_star_metric
     */
    select?: north_star_metricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the north_star_metric
     */
    omit?: north_star_metricOmit<ExtArgs> | null
    /**
     * The filter to search for the north_star_metric to update in case it exists.
     */
    where: north_star_metricWhereUniqueInput
    /**
     * In case the north_star_metric found by the `where` argument doesn't exist, create a new north_star_metric with this data.
     */
    create: XOR<north_star_metricCreateInput, north_star_metricUncheckedCreateInput>
    /**
     * In case the north_star_metric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<north_star_metricUpdateInput, north_star_metricUncheckedUpdateInput>
  }

  /**
   * north_star_metric delete
   */
  export type north_star_metricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the north_star_metric
     */
    select?: north_star_metricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the north_star_metric
     */
    omit?: north_star_metricOmit<ExtArgs> | null
    /**
     * Filter which north_star_metric to delete.
     */
    where: north_star_metricWhereUniqueInput
  }

  /**
   * north_star_metric deleteMany
   */
  export type north_star_metricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which north_star_metrics to delete
     */
    where?: north_star_metricWhereInput
    /**
     * Limit how many north_star_metrics to delete.
     */
    limit?: number
  }

  /**
   * north_star_metric without action
   */
  export type north_star_metricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the north_star_metric
     */
    select?: north_star_metricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the north_star_metric
     */
    omit?: north_star_metricOmit<ExtArgs> | null
  }


  /**
   * Model sandbox_users
   */

  export type AggregateSandbox_users = {
    _count: Sandbox_usersCountAggregateOutputType | null
    _avg: Sandbox_usersAvgAggregateOutputType | null
    _sum: Sandbox_usersSumAggregateOutputType | null
    _min: Sandbox_usersMinAggregateOutputType | null
    _max: Sandbox_usersMaxAggregateOutputType | null
  }

  export type Sandbox_usersAvgAggregateOutputType = {
    pk: number | null
  }

  export type Sandbox_usersSumAggregateOutputType = {
    pk: number | null
  }

  export type Sandbox_usersMinAggregateOutputType = {
    username: string | null
    pk: number | null
    password: string | null
    created_at: Date | null
  }

  export type Sandbox_usersMaxAggregateOutputType = {
    username: string | null
    pk: number | null
    password: string | null
    created_at: Date | null
  }

  export type Sandbox_usersCountAggregateOutputType = {
    username: number
    pk: number
    password: number
    created_at: number
    _all: number
  }


  export type Sandbox_usersAvgAggregateInputType = {
    pk?: true
  }

  export type Sandbox_usersSumAggregateInputType = {
    pk?: true
  }

  export type Sandbox_usersMinAggregateInputType = {
    username?: true
    pk?: true
    password?: true
    created_at?: true
  }

  export type Sandbox_usersMaxAggregateInputType = {
    username?: true
    pk?: true
    password?: true
    created_at?: true
  }

  export type Sandbox_usersCountAggregateInputType = {
    username?: true
    pk?: true
    password?: true
    created_at?: true
    _all?: true
  }

  export type Sandbox_usersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sandbox_users to aggregate.
     */
    where?: sandbox_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sandbox_users to fetch.
     */
    orderBy?: sandbox_usersOrderByWithRelationInput | sandbox_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sandbox_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sandbox_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sandbox_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sandbox_users
    **/
    _count?: true | Sandbox_usersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Sandbox_usersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Sandbox_usersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Sandbox_usersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Sandbox_usersMaxAggregateInputType
  }

  export type GetSandbox_usersAggregateType<T extends Sandbox_usersAggregateArgs> = {
        [P in keyof T & keyof AggregateSandbox_users]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSandbox_users[P]>
      : GetScalarType<T[P], AggregateSandbox_users[P]>
  }




  export type sandbox_usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sandbox_usersWhereInput
    orderBy?: sandbox_usersOrderByWithAggregationInput | sandbox_usersOrderByWithAggregationInput[]
    by: Sandbox_usersScalarFieldEnum[] | Sandbox_usersScalarFieldEnum
    having?: sandbox_usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Sandbox_usersCountAggregateInputType | true
    _avg?: Sandbox_usersAvgAggregateInputType
    _sum?: Sandbox_usersSumAggregateInputType
    _min?: Sandbox_usersMinAggregateInputType
    _max?: Sandbox_usersMaxAggregateInputType
  }

  export type Sandbox_usersGroupByOutputType = {
    username: string
    pk: number
    password: string
    created_at: Date
    _count: Sandbox_usersCountAggregateOutputType | null
    _avg: Sandbox_usersAvgAggregateOutputType | null
    _sum: Sandbox_usersSumAggregateOutputType | null
    _min: Sandbox_usersMinAggregateOutputType | null
    _max: Sandbox_usersMaxAggregateOutputType | null
  }

  type GetSandbox_usersGroupByPayload<T extends sandbox_usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Sandbox_usersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Sandbox_usersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Sandbox_usersGroupByOutputType[P]>
            : GetScalarType<T[P], Sandbox_usersGroupByOutputType[P]>
        }
      >
    >


  export type sandbox_usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    username?: boolean
    pk?: boolean
    password?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["sandbox_users"]>

  export type sandbox_usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    username?: boolean
    pk?: boolean
    password?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["sandbox_users"]>

  export type sandbox_usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    username?: boolean
    pk?: boolean
    password?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["sandbox_users"]>

  export type sandbox_usersSelectScalar = {
    username?: boolean
    pk?: boolean
    password?: boolean
    created_at?: boolean
  }

  export type sandbox_usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"username" | "pk" | "password" | "created_at", ExtArgs["result"]["sandbox_users"]>

  export type $sandbox_usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sandbox_users"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      username: string
      pk: number
      password: string
      created_at: Date
    }, ExtArgs["result"]["sandbox_users"]>
    composites: {}
  }

  type sandbox_usersGetPayload<S extends boolean | null | undefined | sandbox_usersDefaultArgs> = $Result.GetResult<Prisma.$sandbox_usersPayload, S>

  type sandbox_usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sandbox_usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Sandbox_usersCountAggregateInputType | true
    }

  export interface sandbox_usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sandbox_users'], meta: { name: 'sandbox_users' } }
    /**
     * Find zero or one Sandbox_users that matches the filter.
     * @param {sandbox_usersFindUniqueArgs} args - Arguments to find a Sandbox_users
     * @example
     * // Get one Sandbox_users
     * const sandbox_users = await prisma.sandbox_users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sandbox_usersFindUniqueArgs>(args: SelectSubset<T, sandbox_usersFindUniqueArgs<ExtArgs>>): Prisma__sandbox_usersClient<$Result.GetResult<Prisma.$sandbox_usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sandbox_users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sandbox_usersFindUniqueOrThrowArgs} args - Arguments to find a Sandbox_users
     * @example
     * // Get one Sandbox_users
     * const sandbox_users = await prisma.sandbox_users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sandbox_usersFindUniqueOrThrowArgs>(args: SelectSubset<T, sandbox_usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sandbox_usersClient<$Result.GetResult<Prisma.$sandbox_usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sandbox_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sandbox_usersFindFirstArgs} args - Arguments to find a Sandbox_users
     * @example
     * // Get one Sandbox_users
     * const sandbox_users = await prisma.sandbox_users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sandbox_usersFindFirstArgs>(args?: SelectSubset<T, sandbox_usersFindFirstArgs<ExtArgs>>): Prisma__sandbox_usersClient<$Result.GetResult<Prisma.$sandbox_usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sandbox_users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sandbox_usersFindFirstOrThrowArgs} args - Arguments to find a Sandbox_users
     * @example
     * // Get one Sandbox_users
     * const sandbox_users = await prisma.sandbox_users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sandbox_usersFindFirstOrThrowArgs>(args?: SelectSubset<T, sandbox_usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__sandbox_usersClient<$Result.GetResult<Prisma.$sandbox_usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sandbox_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sandbox_usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sandbox_users
     * const sandbox_users = await prisma.sandbox_users.findMany()
     * 
     * // Get first 10 Sandbox_users
     * const sandbox_users = await prisma.sandbox_users.findMany({ take: 10 })
     * 
     * // Only select the `username`
     * const sandbox_usersWithUsernameOnly = await prisma.sandbox_users.findMany({ select: { username: true } })
     * 
     */
    findMany<T extends sandbox_usersFindManyArgs>(args?: SelectSubset<T, sandbox_usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sandbox_usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sandbox_users.
     * @param {sandbox_usersCreateArgs} args - Arguments to create a Sandbox_users.
     * @example
     * // Create one Sandbox_users
     * const Sandbox_users = await prisma.sandbox_users.create({
     *   data: {
     *     // ... data to create a Sandbox_users
     *   }
     * })
     * 
     */
    create<T extends sandbox_usersCreateArgs>(args: SelectSubset<T, sandbox_usersCreateArgs<ExtArgs>>): Prisma__sandbox_usersClient<$Result.GetResult<Prisma.$sandbox_usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sandbox_users.
     * @param {sandbox_usersCreateManyArgs} args - Arguments to create many Sandbox_users.
     * @example
     * // Create many Sandbox_users
     * const sandbox_users = await prisma.sandbox_users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sandbox_usersCreateManyArgs>(args?: SelectSubset<T, sandbox_usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sandbox_users and returns the data saved in the database.
     * @param {sandbox_usersCreateManyAndReturnArgs} args - Arguments to create many Sandbox_users.
     * @example
     * // Create many Sandbox_users
     * const sandbox_users = await prisma.sandbox_users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sandbox_users and only return the `username`
     * const sandbox_usersWithUsernameOnly = await prisma.sandbox_users.createManyAndReturn({
     *   select: { username: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends sandbox_usersCreateManyAndReturnArgs>(args?: SelectSubset<T, sandbox_usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sandbox_usersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sandbox_users.
     * @param {sandbox_usersDeleteArgs} args - Arguments to delete one Sandbox_users.
     * @example
     * // Delete one Sandbox_users
     * const Sandbox_users = await prisma.sandbox_users.delete({
     *   where: {
     *     // ... filter to delete one Sandbox_users
     *   }
     * })
     * 
     */
    delete<T extends sandbox_usersDeleteArgs>(args: SelectSubset<T, sandbox_usersDeleteArgs<ExtArgs>>): Prisma__sandbox_usersClient<$Result.GetResult<Prisma.$sandbox_usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sandbox_users.
     * @param {sandbox_usersUpdateArgs} args - Arguments to update one Sandbox_users.
     * @example
     * // Update one Sandbox_users
     * const sandbox_users = await prisma.sandbox_users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sandbox_usersUpdateArgs>(args: SelectSubset<T, sandbox_usersUpdateArgs<ExtArgs>>): Prisma__sandbox_usersClient<$Result.GetResult<Prisma.$sandbox_usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sandbox_users.
     * @param {sandbox_usersDeleteManyArgs} args - Arguments to filter Sandbox_users to delete.
     * @example
     * // Delete a few Sandbox_users
     * const { count } = await prisma.sandbox_users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sandbox_usersDeleteManyArgs>(args?: SelectSubset<T, sandbox_usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sandbox_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sandbox_usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sandbox_users
     * const sandbox_users = await prisma.sandbox_users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sandbox_usersUpdateManyArgs>(args: SelectSubset<T, sandbox_usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sandbox_users and returns the data updated in the database.
     * @param {sandbox_usersUpdateManyAndReturnArgs} args - Arguments to update many Sandbox_users.
     * @example
     * // Update many Sandbox_users
     * const sandbox_users = await prisma.sandbox_users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sandbox_users and only return the `username`
     * const sandbox_usersWithUsernameOnly = await prisma.sandbox_users.updateManyAndReturn({
     *   select: { username: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends sandbox_usersUpdateManyAndReturnArgs>(args: SelectSubset<T, sandbox_usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sandbox_usersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sandbox_users.
     * @param {sandbox_usersUpsertArgs} args - Arguments to update or create a Sandbox_users.
     * @example
     * // Update or create a Sandbox_users
     * const sandbox_users = await prisma.sandbox_users.upsert({
     *   create: {
     *     // ... data to create a Sandbox_users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sandbox_users we want to update
     *   }
     * })
     */
    upsert<T extends sandbox_usersUpsertArgs>(args: SelectSubset<T, sandbox_usersUpsertArgs<ExtArgs>>): Prisma__sandbox_usersClient<$Result.GetResult<Prisma.$sandbox_usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sandbox_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sandbox_usersCountArgs} args - Arguments to filter Sandbox_users to count.
     * @example
     * // Count the number of Sandbox_users
     * const count = await prisma.sandbox_users.count({
     *   where: {
     *     // ... the filter for the Sandbox_users we want to count
     *   }
     * })
    **/
    count<T extends sandbox_usersCountArgs>(
      args?: Subset<T, sandbox_usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Sandbox_usersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sandbox_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Sandbox_usersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Sandbox_usersAggregateArgs>(args: Subset<T, Sandbox_usersAggregateArgs>): Prisma.PrismaPromise<GetSandbox_usersAggregateType<T>>

    /**
     * Group by Sandbox_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sandbox_usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sandbox_usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sandbox_usersGroupByArgs['orderBy'] }
        : { orderBy?: sandbox_usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sandbox_usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSandbox_usersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sandbox_users model
   */
  readonly fields: sandbox_usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sandbox_users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sandbox_usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sandbox_users model
   */
  interface sandbox_usersFieldRefs {
    readonly username: FieldRef<"sandbox_users", 'String'>
    readonly pk: FieldRef<"sandbox_users", 'Int'>
    readonly password: FieldRef<"sandbox_users", 'String'>
    readonly created_at: FieldRef<"sandbox_users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * sandbox_users findUnique
   */
  export type sandbox_usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sandbox_users
     */
    select?: sandbox_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sandbox_users
     */
    omit?: sandbox_usersOmit<ExtArgs> | null
    /**
     * Filter, which sandbox_users to fetch.
     */
    where: sandbox_usersWhereUniqueInput
  }

  /**
   * sandbox_users findUniqueOrThrow
   */
  export type sandbox_usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sandbox_users
     */
    select?: sandbox_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sandbox_users
     */
    omit?: sandbox_usersOmit<ExtArgs> | null
    /**
     * Filter, which sandbox_users to fetch.
     */
    where: sandbox_usersWhereUniqueInput
  }

  /**
   * sandbox_users findFirst
   */
  export type sandbox_usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sandbox_users
     */
    select?: sandbox_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sandbox_users
     */
    omit?: sandbox_usersOmit<ExtArgs> | null
    /**
     * Filter, which sandbox_users to fetch.
     */
    where?: sandbox_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sandbox_users to fetch.
     */
    orderBy?: sandbox_usersOrderByWithRelationInput | sandbox_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sandbox_users.
     */
    cursor?: sandbox_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sandbox_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sandbox_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sandbox_users.
     */
    distinct?: Sandbox_usersScalarFieldEnum | Sandbox_usersScalarFieldEnum[]
  }

  /**
   * sandbox_users findFirstOrThrow
   */
  export type sandbox_usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sandbox_users
     */
    select?: sandbox_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sandbox_users
     */
    omit?: sandbox_usersOmit<ExtArgs> | null
    /**
     * Filter, which sandbox_users to fetch.
     */
    where?: sandbox_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sandbox_users to fetch.
     */
    orderBy?: sandbox_usersOrderByWithRelationInput | sandbox_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sandbox_users.
     */
    cursor?: sandbox_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sandbox_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sandbox_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sandbox_users.
     */
    distinct?: Sandbox_usersScalarFieldEnum | Sandbox_usersScalarFieldEnum[]
  }

  /**
   * sandbox_users findMany
   */
  export type sandbox_usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sandbox_users
     */
    select?: sandbox_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sandbox_users
     */
    omit?: sandbox_usersOmit<ExtArgs> | null
    /**
     * Filter, which sandbox_users to fetch.
     */
    where?: sandbox_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sandbox_users to fetch.
     */
    orderBy?: sandbox_usersOrderByWithRelationInput | sandbox_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sandbox_users.
     */
    cursor?: sandbox_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sandbox_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sandbox_users.
     */
    skip?: number
    distinct?: Sandbox_usersScalarFieldEnum | Sandbox_usersScalarFieldEnum[]
  }

  /**
   * sandbox_users create
   */
  export type sandbox_usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sandbox_users
     */
    select?: sandbox_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sandbox_users
     */
    omit?: sandbox_usersOmit<ExtArgs> | null
    /**
     * The data needed to create a sandbox_users.
     */
    data: XOR<sandbox_usersCreateInput, sandbox_usersUncheckedCreateInput>
  }

  /**
   * sandbox_users createMany
   */
  export type sandbox_usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sandbox_users.
     */
    data: sandbox_usersCreateManyInput | sandbox_usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sandbox_users createManyAndReturn
   */
  export type sandbox_usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sandbox_users
     */
    select?: sandbox_usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sandbox_users
     */
    omit?: sandbox_usersOmit<ExtArgs> | null
    /**
     * The data used to create many sandbox_users.
     */
    data: sandbox_usersCreateManyInput | sandbox_usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sandbox_users update
   */
  export type sandbox_usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sandbox_users
     */
    select?: sandbox_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sandbox_users
     */
    omit?: sandbox_usersOmit<ExtArgs> | null
    /**
     * The data needed to update a sandbox_users.
     */
    data: XOR<sandbox_usersUpdateInput, sandbox_usersUncheckedUpdateInput>
    /**
     * Choose, which sandbox_users to update.
     */
    where: sandbox_usersWhereUniqueInput
  }

  /**
   * sandbox_users updateMany
   */
  export type sandbox_usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sandbox_users.
     */
    data: XOR<sandbox_usersUpdateManyMutationInput, sandbox_usersUncheckedUpdateManyInput>
    /**
     * Filter which sandbox_users to update
     */
    where?: sandbox_usersWhereInput
    /**
     * Limit how many sandbox_users to update.
     */
    limit?: number
  }

  /**
   * sandbox_users updateManyAndReturn
   */
  export type sandbox_usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sandbox_users
     */
    select?: sandbox_usersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sandbox_users
     */
    omit?: sandbox_usersOmit<ExtArgs> | null
    /**
     * The data used to update sandbox_users.
     */
    data: XOR<sandbox_usersUpdateManyMutationInput, sandbox_usersUncheckedUpdateManyInput>
    /**
     * Filter which sandbox_users to update
     */
    where?: sandbox_usersWhereInput
    /**
     * Limit how many sandbox_users to update.
     */
    limit?: number
  }

  /**
   * sandbox_users upsert
   */
  export type sandbox_usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sandbox_users
     */
    select?: sandbox_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sandbox_users
     */
    omit?: sandbox_usersOmit<ExtArgs> | null
    /**
     * The filter to search for the sandbox_users to update in case it exists.
     */
    where: sandbox_usersWhereUniqueInput
    /**
     * In case the sandbox_users found by the `where` argument doesn't exist, create a new sandbox_users with this data.
     */
    create: XOR<sandbox_usersCreateInput, sandbox_usersUncheckedCreateInput>
    /**
     * In case the sandbox_users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sandbox_usersUpdateInput, sandbox_usersUncheckedUpdateInput>
  }

  /**
   * sandbox_users delete
   */
  export type sandbox_usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sandbox_users
     */
    select?: sandbox_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sandbox_users
     */
    omit?: sandbox_usersOmit<ExtArgs> | null
    /**
     * Filter which sandbox_users to delete.
     */
    where: sandbox_usersWhereUniqueInput
  }

  /**
   * sandbox_users deleteMany
   */
  export type sandbox_usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sandbox_users to delete
     */
    where?: sandbox_usersWhereInput
    /**
     * Limit how many sandbox_users to delete.
     */
    limit?: number
  }

  /**
   * sandbox_users without action
   */
  export type sandbox_usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sandbox_users
     */
    select?: sandbox_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sandbox_users
     */
    omit?: sandbox_usersOmit<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    pk: number | null
  }

  export type UsersSumAggregateOutputType = {
    pk: number | null
  }

  export type UsersMinAggregateOutputType = {
    pk: number | null
    email: string | null
    username: string | null
    password: string | null
    created_at: Date | null
    last_connection: Date | null
    role: string | null
  }

  export type UsersMaxAggregateOutputType = {
    pk: number | null
    email: string | null
    username: string | null
    password: string | null
    created_at: Date | null
    last_connection: Date | null
    role: string | null
  }

  export type UsersCountAggregateOutputType = {
    pk: number
    email: number
    username: number
    password: number
    created_at: number
    last_connection: number
    role: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    pk?: true
  }

  export type UsersSumAggregateInputType = {
    pk?: true
  }

  export type UsersMinAggregateInputType = {
    pk?: true
    email?: true
    username?: true
    password?: true
    created_at?: true
    last_connection?: true
    role?: true
  }

  export type UsersMaxAggregateInputType = {
    pk?: true
    email?: true
    username?: true
    password?: true
    created_at?: true
    last_connection?: true
    role?: true
  }

  export type UsersCountAggregateInputType = {
    pk?: true
    email?: true
    username?: true
    password?: true
    created_at?: true
    last_connection?: true
    role?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    pk: number
    email: string
    username: string
    password: string
    created_at: Date
    last_connection: Date | null
    role: string
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pk?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    created_at?: boolean
    last_connection?: boolean
    role?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pk?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    created_at?: boolean
    last_connection?: boolean
    role?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pk?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    created_at?: boolean
    last_connection?: boolean
    role?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    pk?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    created_at?: boolean
    last_connection?: boolean
    role?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"pk" | "email" | "username" | "password" | "created_at" | "last_connection" | "role", ExtArgs["result"]["users"]>

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      pk: number
      email: string
      username: string
      password: string
      created_at: Date
      last_connection: Date | null
      role: string
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `pk`
     * const usersWithPkOnly = await prisma.users.findMany({ select: { pk: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `pk`
     * const usersWithPkOnly = await prisma.users.createManyAndReturn({
     *   select: { pk: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {usersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `pk`
     * const usersWithPkOnly = await prisma.users.updateManyAndReturn({
     *   select: { pk: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usersUpdateManyAndReturnArgs>(args: SelectSubset<T, usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly pk: FieldRef<"users", 'Int'>
    readonly email: FieldRef<"users", 'String'>
    readonly username: FieldRef<"users", 'String'>
    readonly password: FieldRef<"users", 'String'>
    readonly created_at: FieldRef<"users", 'DateTime'>
    readonly last_connection: FieldRef<"users", 'DateTime'>
    readonly role: FieldRef<"users", 'String'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users updateManyAndReturn
   */
  export type usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
  }


  /**
   * Model all_autocapture_raw
   */

  export type AggregateAll_autocapture_raw = {
    _count: All_autocapture_rawCountAggregateOutputType | null
    _avg: All_autocapture_rawAvgAggregateOutputType | null
    _sum: All_autocapture_rawSumAggregateOutputType | null
    _min: All_autocapture_rawMinAggregateOutputType | null
    _max: All_autocapture_rawMaxAggregateOutputType | null
  }

  export type All_autocapture_rawAvgAggregateOutputType = {
    id: number | null
  }

  export type All_autocapture_rawSumAggregateOutputType = {
    id: bigint | null
  }

  export type All_autocapture_rawMinAggregateOutputType = {
    id: bigint | null
    event_timestamp: Date | null
    distinct_id: string | null
    session_id: string | null
    current_url: string | null
    person_id: string | null
    ingested_at: Date | null
  }

  export type All_autocapture_rawMaxAggregateOutputType = {
    id: bigint | null
    event_timestamp: Date | null
    distinct_id: string | null
    session_id: string | null
    current_url: string | null
    person_id: string | null
    ingested_at: Date | null
  }

  export type All_autocapture_rawCountAggregateOutputType = {
    id: number
    event_timestamp: number
    properties: number
    distinct_id: number
    session_id: number
    current_url: number
    person_id: number
    ingested_at: number
    _all: number
  }


  export type All_autocapture_rawAvgAggregateInputType = {
    id?: true
  }

  export type All_autocapture_rawSumAggregateInputType = {
    id?: true
  }

  export type All_autocapture_rawMinAggregateInputType = {
    id?: true
    event_timestamp?: true
    distinct_id?: true
    session_id?: true
    current_url?: true
    person_id?: true
    ingested_at?: true
  }

  export type All_autocapture_rawMaxAggregateInputType = {
    id?: true
    event_timestamp?: true
    distinct_id?: true
    session_id?: true
    current_url?: true
    person_id?: true
    ingested_at?: true
  }

  export type All_autocapture_rawCountAggregateInputType = {
    id?: true
    event_timestamp?: true
    properties?: true
    distinct_id?: true
    session_id?: true
    current_url?: true
    person_id?: true
    ingested_at?: true
    _all?: true
  }

  export type All_autocapture_rawAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which all_autocapture_raw to aggregate.
     */
    where?: all_autocapture_rawWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of all_autocapture_raws to fetch.
     */
    orderBy?: all_autocapture_rawOrderByWithRelationInput | all_autocapture_rawOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: all_autocapture_rawWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` all_autocapture_raws from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` all_autocapture_raws.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned all_autocapture_raws
    **/
    _count?: true | All_autocapture_rawCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: All_autocapture_rawAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: All_autocapture_rawSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: All_autocapture_rawMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: All_autocapture_rawMaxAggregateInputType
  }

  export type GetAll_autocapture_rawAggregateType<T extends All_autocapture_rawAggregateArgs> = {
        [P in keyof T & keyof AggregateAll_autocapture_raw]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAll_autocapture_raw[P]>
      : GetScalarType<T[P], AggregateAll_autocapture_raw[P]>
  }




  export type all_autocapture_rawGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: all_autocapture_rawWhereInput
    orderBy?: all_autocapture_rawOrderByWithAggregationInput | all_autocapture_rawOrderByWithAggregationInput[]
    by: All_autocapture_rawScalarFieldEnum[] | All_autocapture_rawScalarFieldEnum
    having?: all_autocapture_rawScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: All_autocapture_rawCountAggregateInputType | true
    _avg?: All_autocapture_rawAvgAggregateInputType
    _sum?: All_autocapture_rawSumAggregateInputType
    _min?: All_autocapture_rawMinAggregateInputType
    _max?: All_autocapture_rawMaxAggregateInputType
  }

  export type All_autocapture_rawGroupByOutputType = {
    id: bigint
    event_timestamp: Date
    properties: JsonValue | null
    distinct_id: string | null
    session_id: string | null
    current_url: string | null
    person_id: string | null
    ingested_at: Date
    _count: All_autocapture_rawCountAggregateOutputType | null
    _avg: All_autocapture_rawAvgAggregateOutputType | null
    _sum: All_autocapture_rawSumAggregateOutputType | null
    _min: All_autocapture_rawMinAggregateOutputType | null
    _max: All_autocapture_rawMaxAggregateOutputType | null
  }

  type GetAll_autocapture_rawGroupByPayload<T extends all_autocapture_rawGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<All_autocapture_rawGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof All_autocapture_rawGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], All_autocapture_rawGroupByOutputType[P]>
            : GetScalarType<T[P], All_autocapture_rawGroupByOutputType[P]>
        }
      >
    >


  export type all_autocapture_rawSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    event_timestamp?: boolean
    properties?: boolean
    distinct_id?: boolean
    session_id?: boolean
    current_url?: boolean
    person_id?: boolean
    ingested_at?: boolean
  }, ExtArgs["result"]["all_autocapture_raw"]>

  export type all_autocapture_rawSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    event_timestamp?: boolean
    properties?: boolean
    distinct_id?: boolean
    session_id?: boolean
    current_url?: boolean
    person_id?: boolean
    ingested_at?: boolean
  }, ExtArgs["result"]["all_autocapture_raw"]>

  export type all_autocapture_rawSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    event_timestamp?: boolean
    properties?: boolean
    distinct_id?: boolean
    session_id?: boolean
    current_url?: boolean
    person_id?: boolean
    ingested_at?: boolean
  }, ExtArgs["result"]["all_autocapture_raw"]>

  export type all_autocapture_rawSelectScalar = {
    id?: boolean
    event_timestamp?: boolean
    properties?: boolean
    distinct_id?: boolean
    session_id?: boolean
    current_url?: boolean
    person_id?: boolean
    ingested_at?: boolean
  }

  export type all_autocapture_rawOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "event_timestamp" | "properties" | "distinct_id" | "session_id" | "current_url" | "person_id" | "ingested_at", ExtArgs["result"]["all_autocapture_raw"]>

  export type $all_autocapture_rawPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "all_autocapture_raw"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      event_timestamp: Date
      properties: Prisma.JsonValue | null
      distinct_id: string | null
      session_id: string | null
      current_url: string | null
      person_id: string | null
      ingested_at: Date
    }, ExtArgs["result"]["all_autocapture_raw"]>
    composites: {}
  }

  type all_autocapture_rawGetPayload<S extends boolean | null | undefined | all_autocapture_rawDefaultArgs> = $Result.GetResult<Prisma.$all_autocapture_rawPayload, S>

  type all_autocapture_rawCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<all_autocapture_rawFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: All_autocapture_rawCountAggregateInputType | true
    }

  export interface all_autocapture_rawDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['all_autocapture_raw'], meta: { name: 'all_autocapture_raw' } }
    /**
     * Find zero or one All_autocapture_raw that matches the filter.
     * @param {all_autocapture_rawFindUniqueArgs} args - Arguments to find a All_autocapture_raw
     * @example
     * // Get one All_autocapture_raw
     * const all_autocapture_raw = await prisma.all_autocapture_raw.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends all_autocapture_rawFindUniqueArgs>(args: SelectSubset<T, all_autocapture_rawFindUniqueArgs<ExtArgs>>): Prisma__all_autocapture_rawClient<$Result.GetResult<Prisma.$all_autocapture_rawPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one All_autocapture_raw that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {all_autocapture_rawFindUniqueOrThrowArgs} args - Arguments to find a All_autocapture_raw
     * @example
     * // Get one All_autocapture_raw
     * const all_autocapture_raw = await prisma.all_autocapture_raw.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends all_autocapture_rawFindUniqueOrThrowArgs>(args: SelectSubset<T, all_autocapture_rawFindUniqueOrThrowArgs<ExtArgs>>): Prisma__all_autocapture_rawClient<$Result.GetResult<Prisma.$all_autocapture_rawPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first All_autocapture_raw that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {all_autocapture_rawFindFirstArgs} args - Arguments to find a All_autocapture_raw
     * @example
     * // Get one All_autocapture_raw
     * const all_autocapture_raw = await prisma.all_autocapture_raw.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends all_autocapture_rawFindFirstArgs>(args?: SelectSubset<T, all_autocapture_rawFindFirstArgs<ExtArgs>>): Prisma__all_autocapture_rawClient<$Result.GetResult<Prisma.$all_autocapture_rawPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first All_autocapture_raw that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {all_autocapture_rawFindFirstOrThrowArgs} args - Arguments to find a All_autocapture_raw
     * @example
     * // Get one All_autocapture_raw
     * const all_autocapture_raw = await prisma.all_autocapture_raw.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends all_autocapture_rawFindFirstOrThrowArgs>(args?: SelectSubset<T, all_autocapture_rawFindFirstOrThrowArgs<ExtArgs>>): Prisma__all_autocapture_rawClient<$Result.GetResult<Prisma.$all_autocapture_rawPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more All_autocapture_raws that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {all_autocapture_rawFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all All_autocapture_raws
     * const all_autocapture_raws = await prisma.all_autocapture_raw.findMany()
     * 
     * // Get first 10 All_autocapture_raws
     * const all_autocapture_raws = await prisma.all_autocapture_raw.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const all_autocapture_rawWithIdOnly = await prisma.all_autocapture_raw.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends all_autocapture_rawFindManyArgs>(args?: SelectSubset<T, all_autocapture_rawFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$all_autocapture_rawPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a All_autocapture_raw.
     * @param {all_autocapture_rawCreateArgs} args - Arguments to create a All_autocapture_raw.
     * @example
     * // Create one All_autocapture_raw
     * const All_autocapture_raw = await prisma.all_autocapture_raw.create({
     *   data: {
     *     // ... data to create a All_autocapture_raw
     *   }
     * })
     * 
     */
    create<T extends all_autocapture_rawCreateArgs>(args: SelectSubset<T, all_autocapture_rawCreateArgs<ExtArgs>>): Prisma__all_autocapture_rawClient<$Result.GetResult<Prisma.$all_autocapture_rawPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many All_autocapture_raws.
     * @param {all_autocapture_rawCreateManyArgs} args - Arguments to create many All_autocapture_raws.
     * @example
     * // Create many All_autocapture_raws
     * const all_autocapture_raw = await prisma.all_autocapture_raw.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends all_autocapture_rawCreateManyArgs>(args?: SelectSubset<T, all_autocapture_rawCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many All_autocapture_raws and returns the data saved in the database.
     * @param {all_autocapture_rawCreateManyAndReturnArgs} args - Arguments to create many All_autocapture_raws.
     * @example
     * // Create many All_autocapture_raws
     * const all_autocapture_raw = await prisma.all_autocapture_raw.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many All_autocapture_raws and only return the `id`
     * const all_autocapture_rawWithIdOnly = await prisma.all_autocapture_raw.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends all_autocapture_rawCreateManyAndReturnArgs>(args?: SelectSubset<T, all_autocapture_rawCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$all_autocapture_rawPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a All_autocapture_raw.
     * @param {all_autocapture_rawDeleteArgs} args - Arguments to delete one All_autocapture_raw.
     * @example
     * // Delete one All_autocapture_raw
     * const All_autocapture_raw = await prisma.all_autocapture_raw.delete({
     *   where: {
     *     // ... filter to delete one All_autocapture_raw
     *   }
     * })
     * 
     */
    delete<T extends all_autocapture_rawDeleteArgs>(args: SelectSubset<T, all_autocapture_rawDeleteArgs<ExtArgs>>): Prisma__all_autocapture_rawClient<$Result.GetResult<Prisma.$all_autocapture_rawPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one All_autocapture_raw.
     * @param {all_autocapture_rawUpdateArgs} args - Arguments to update one All_autocapture_raw.
     * @example
     * // Update one All_autocapture_raw
     * const all_autocapture_raw = await prisma.all_autocapture_raw.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends all_autocapture_rawUpdateArgs>(args: SelectSubset<T, all_autocapture_rawUpdateArgs<ExtArgs>>): Prisma__all_autocapture_rawClient<$Result.GetResult<Prisma.$all_autocapture_rawPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more All_autocapture_raws.
     * @param {all_autocapture_rawDeleteManyArgs} args - Arguments to filter All_autocapture_raws to delete.
     * @example
     * // Delete a few All_autocapture_raws
     * const { count } = await prisma.all_autocapture_raw.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends all_autocapture_rawDeleteManyArgs>(args?: SelectSubset<T, all_autocapture_rawDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more All_autocapture_raws.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {all_autocapture_rawUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many All_autocapture_raws
     * const all_autocapture_raw = await prisma.all_autocapture_raw.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends all_autocapture_rawUpdateManyArgs>(args: SelectSubset<T, all_autocapture_rawUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more All_autocapture_raws and returns the data updated in the database.
     * @param {all_autocapture_rawUpdateManyAndReturnArgs} args - Arguments to update many All_autocapture_raws.
     * @example
     * // Update many All_autocapture_raws
     * const all_autocapture_raw = await prisma.all_autocapture_raw.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more All_autocapture_raws and only return the `id`
     * const all_autocapture_rawWithIdOnly = await prisma.all_autocapture_raw.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends all_autocapture_rawUpdateManyAndReturnArgs>(args: SelectSubset<T, all_autocapture_rawUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$all_autocapture_rawPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one All_autocapture_raw.
     * @param {all_autocapture_rawUpsertArgs} args - Arguments to update or create a All_autocapture_raw.
     * @example
     * // Update or create a All_autocapture_raw
     * const all_autocapture_raw = await prisma.all_autocapture_raw.upsert({
     *   create: {
     *     // ... data to create a All_autocapture_raw
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the All_autocapture_raw we want to update
     *   }
     * })
     */
    upsert<T extends all_autocapture_rawUpsertArgs>(args: SelectSubset<T, all_autocapture_rawUpsertArgs<ExtArgs>>): Prisma__all_autocapture_rawClient<$Result.GetResult<Prisma.$all_autocapture_rawPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of All_autocapture_raws.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {all_autocapture_rawCountArgs} args - Arguments to filter All_autocapture_raws to count.
     * @example
     * // Count the number of All_autocapture_raws
     * const count = await prisma.all_autocapture_raw.count({
     *   where: {
     *     // ... the filter for the All_autocapture_raws we want to count
     *   }
     * })
    **/
    count<T extends all_autocapture_rawCountArgs>(
      args?: Subset<T, all_autocapture_rawCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], All_autocapture_rawCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a All_autocapture_raw.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {All_autocapture_rawAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends All_autocapture_rawAggregateArgs>(args: Subset<T, All_autocapture_rawAggregateArgs>): Prisma.PrismaPromise<GetAll_autocapture_rawAggregateType<T>>

    /**
     * Group by All_autocapture_raw.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {all_autocapture_rawGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends all_autocapture_rawGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: all_autocapture_rawGroupByArgs['orderBy'] }
        : { orderBy?: all_autocapture_rawGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, all_autocapture_rawGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAll_autocapture_rawGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the all_autocapture_raw model
   */
  readonly fields: all_autocapture_rawFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for all_autocapture_raw.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__all_autocapture_rawClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the all_autocapture_raw model
   */
  interface all_autocapture_rawFieldRefs {
    readonly id: FieldRef<"all_autocapture_raw", 'BigInt'>
    readonly event_timestamp: FieldRef<"all_autocapture_raw", 'DateTime'>
    readonly properties: FieldRef<"all_autocapture_raw", 'Json'>
    readonly distinct_id: FieldRef<"all_autocapture_raw", 'String'>
    readonly session_id: FieldRef<"all_autocapture_raw", 'String'>
    readonly current_url: FieldRef<"all_autocapture_raw", 'String'>
    readonly person_id: FieldRef<"all_autocapture_raw", 'String'>
    readonly ingested_at: FieldRef<"all_autocapture_raw", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * all_autocapture_raw findUnique
   */
  export type all_autocapture_rawFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the all_autocapture_raw
     */
    select?: all_autocapture_rawSelect<ExtArgs> | null
    /**
     * Omit specific fields from the all_autocapture_raw
     */
    omit?: all_autocapture_rawOmit<ExtArgs> | null
    /**
     * Filter, which all_autocapture_raw to fetch.
     */
    where: all_autocapture_rawWhereUniqueInput
  }

  /**
   * all_autocapture_raw findUniqueOrThrow
   */
  export type all_autocapture_rawFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the all_autocapture_raw
     */
    select?: all_autocapture_rawSelect<ExtArgs> | null
    /**
     * Omit specific fields from the all_autocapture_raw
     */
    omit?: all_autocapture_rawOmit<ExtArgs> | null
    /**
     * Filter, which all_autocapture_raw to fetch.
     */
    where: all_autocapture_rawWhereUniqueInput
  }

  /**
   * all_autocapture_raw findFirst
   */
  export type all_autocapture_rawFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the all_autocapture_raw
     */
    select?: all_autocapture_rawSelect<ExtArgs> | null
    /**
     * Omit specific fields from the all_autocapture_raw
     */
    omit?: all_autocapture_rawOmit<ExtArgs> | null
    /**
     * Filter, which all_autocapture_raw to fetch.
     */
    where?: all_autocapture_rawWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of all_autocapture_raws to fetch.
     */
    orderBy?: all_autocapture_rawOrderByWithRelationInput | all_autocapture_rawOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for all_autocapture_raws.
     */
    cursor?: all_autocapture_rawWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` all_autocapture_raws from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` all_autocapture_raws.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of all_autocapture_raws.
     */
    distinct?: All_autocapture_rawScalarFieldEnum | All_autocapture_rawScalarFieldEnum[]
  }

  /**
   * all_autocapture_raw findFirstOrThrow
   */
  export type all_autocapture_rawFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the all_autocapture_raw
     */
    select?: all_autocapture_rawSelect<ExtArgs> | null
    /**
     * Omit specific fields from the all_autocapture_raw
     */
    omit?: all_autocapture_rawOmit<ExtArgs> | null
    /**
     * Filter, which all_autocapture_raw to fetch.
     */
    where?: all_autocapture_rawWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of all_autocapture_raws to fetch.
     */
    orderBy?: all_autocapture_rawOrderByWithRelationInput | all_autocapture_rawOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for all_autocapture_raws.
     */
    cursor?: all_autocapture_rawWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` all_autocapture_raws from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` all_autocapture_raws.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of all_autocapture_raws.
     */
    distinct?: All_autocapture_rawScalarFieldEnum | All_autocapture_rawScalarFieldEnum[]
  }

  /**
   * all_autocapture_raw findMany
   */
  export type all_autocapture_rawFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the all_autocapture_raw
     */
    select?: all_autocapture_rawSelect<ExtArgs> | null
    /**
     * Omit specific fields from the all_autocapture_raw
     */
    omit?: all_autocapture_rawOmit<ExtArgs> | null
    /**
     * Filter, which all_autocapture_raws to fetch.
     */
    where?: all_autocapture_rawWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of all_autocapture_raws to fetch.
     */
    orderBy?: all_autocapture_rawOrderByWithRelationInput | all_autocapture_rawOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing all_autocapture_raws.
     */
    cursor?: all_autocapture_rawWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` all_autocapture_raws from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` all_autocapture_raws.
     */
    skip?: number
    distinct?: All_autocapture_rawScalarFieldEnum | All_autocapture_rawScalarFieldEnum[]
  }

  /**
   * all_autocapture_raw create
   */
  export type all_autocapture_rawCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the all_autocapture_raw
     */
    select?: all_autocapture_rawSelect<ExtArgs> | null
    /**
     * Omit specific fields from the all_autocapture_raw
     */
    omit?: all_autocapture_rawOmit<ExtArgs> | null
    /**
     * The data needed to create a all_autocapture_raw.
     */
    data: XOR<all_autocapture_rawCreateInput, all_autocapture_rawUncheckedCreateInput>
  }

  /**
   * all_autocapture_raw createMany
   */
  export type all_autocapture_rawCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many all_autocapture_raws.
     */
    data: all_autocapture_rawCreateManyInput | all_autocapture_rawCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * all_autocapture_raw createManyAndReturn
   */
  export type all_autocapture_rawCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the all_autocapture_raw
     */
    select?: all_autocapture_rawSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the all_autocapture_raw
     */
    omit?: all_autocapture_rawOmit<ExtArgs> | null
    /**
     * The data used to create many all_autocapture_raws.
     */
    data: all_autocapture_rawCreateManyInput | all_autocapture_rawCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * all_autocapture_raw update
   */
  export type all_autocapture_rawUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the all_autocapture_raw
     */
    select?: all_autocapture_rawSelect<ExtArgs> | null
    /**
     * Omit specific fields from the all_autocapture_raw
     */
    omit?: all_autocapture_rawOmit<ExtArgs> | null
    /**
     * The data needed to update a all_autocapture_raw.
     */
    data: XOR<all_autocapture_rawUpdateInput, all_autocapture_rawUncheckedUpdateInput>
    /**
     * Choose, which all_autocapture_raw to update.
     */
    where: all_autocapture_rawWhereUniqueInput
  }

  /**
   * all_autocapture_raw updateMany
   */
  export type all_autocapture_rawUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update all_autocapture_raws.
     */
    data: XOR<all_autocapture_rawUpdateManyMutationInput, all_autocapture_rawUncheckedUpdateManyInput>
    /**
     * Filter which all_autocapture_raws to update
     */
    where?: all_autocapture_rawWhereInput
    /**
     * Limit how many all_autocapture_raws to update.
     */
    limit?: number
  }

  /**
   * all_autocapture_raw updateManyAndReturn
   */
  export type all_autocapture_rawUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the all_autocapture_raw
     */
    select?: all_autocapture_rawSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the all_autocapture_raw
     */
    omit?: all_autocapture_rawOmit<ExtArgs> | null
    /**
     * The data used to update all_autocapture_raws.
     */
    data: XOR<all_autocapture_rawUpdateManyMutationInput, all_autocapture_rawUncheckedUpdateManyInput>
    /**
     * Filter which all_autocapture_raws to update
     */
    where?: all_autocapture_rawWhereInput
    /**
     * Limit how many all_autocapture_raws to update.
     */
    limit?: number
  }

  /**
   * all_autocapture_raw upsert
   */
  export type all_autocapture_rawUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the all_autocapture_raw
     */
    select?: all_autocapture_rawSelect<ExtArgs> | null
    /**
     * Omit specific fields from the all_autocapture_raw
     */
    omit?: all_autocapture_rawOmit<ExtArgs> | null
    /**
     * The filter to search for the all_autocapture_raw to update in case it exists.
     */
    where: all_autocapture_rawWhereUniqueInput
    /**
     * In case the all_autocapture_raw found by the `where` argument doesn't exist, create a new all_autocapture_raw with this data.
     */
    create: XOR<all_autocapture_rawCreateInput, all_autocapture_rawUncheckedCreateInput>
    /**
     * In case the all_autocapture_raw was found with the provided `where` argument, update it with this data.
     */
    update: XOR<all_autocapture_rawUpdateInput, all_autocapture_rawUncheckedUpdateInput>
  }

  /**
   * all_autocapture_raw delete
   */
  export type all_autocapture_rawDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the all_autocapture_raw
     */
    select?: all_autocapture_rawSelect<ExtArgs> | null
    /**
     * Omit specific fields from the all_autocapture_raw
     */
    omit?: all_autocapture_rawOmit<ExtArgs> | null
    /**
     * Filter which all_autocapture_raw to delete.
     */
    where: all_autocapture_rawWhereUniqueInput
  }

  /**
   * all_autocapture_raw deleteMany
   */
  export type all_autocapture_rawDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which all_autocapture_raws to delete
     */
    where?: all_autocapture_rawWhereInput
    /**
     * Limit how many all_autocapture_raws to delete.
     */
    limit?: number
  }

  /**
   * all_autocapture_raw without action
   */
  export type all_autocapture_rawDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the all_autocapture_raw
     */
    select?: all_autocapture_rawSelect<ExtArgs> | null
    /**
     * Omit specific fields from the all_autocapture_raw
     */
    omit?: all_autocapture_rawOmit<ExtArgs> | null
  }


  /**
   * Model all_pageview_raw
   */

  export type AggregateAll_pageview_raw = {
    _count: All_pageview_rawCountAggregateOutputType | null
    _avg: All_pageview_rawAvgAggregateOutputType | null
    _sum: All_pageview_rawSumAggregateOutputType | null
    _min: All_pageview_rawMinAggregateOutputType | null
    _max: All_pageview_rawMaxAggregateOutputType | null
  }

  export type All_pageview_rawAvgAggregateOutputType = {
    id: number | null
  }

  export type All_pageview_rawSumAggregateOutputType = {
    id: bigint | null
  }

  export type All_pageview_rawMinAggregateOutputType = {
    id: bigint | null
    event_timestamp: Date | null
    distinct_id: string | null
    session_id: string | null
    current_url: string | null
    person_id: string | null
    ingested_at: Date | null
  }

  export type All_pageview_rawMaxAggregateOutputType = {
    id: bigint | null
    event_timestamp: Date | null
    distinct_id: string | null
    session_id: string | null
    current_url: string | null
    person_id: string | null
    ingested_at: Date | null
  }

  export type All_pageview_rawCountAggregateOutputType = {
    id: number
    event_timestamp: number
    properties: number
    distinct_id: number
    session_id: number
    current_url: number
    person_id: number
    ingested_at: number
    _all: number
  }


  export type All_pageview_rawAvgAggregateInputType = {
    id?: true
  }

  export type All_pageview_rawSumAggregateInputType = {
    id?: true
  }

  export type All_pageview_rawMinAggregateInputType = {
    id?: true
    event_timestamp?: true
    distinct_id?: true
    session_id?: true
    current_url?: true
    person_id?: true
    ingested_at?: true
  }

  export type All_pageview_rawMaxAggregateInputType = {
    id?: true
    event_timestamp?: true
    distinct_id?: true
    session_id?: true
    current_url?: true
    person_id?: true
    ingested_at?: true
  }

  export type All_pageview_rawCountAggregateInputType = {
    id?: true
    event_timestamp?: true
    properties?: true
    distinct_id?: true
    session_id?: true
    current_url?: true
    person_id?: true
    ingested_at?: true
    _all?: true
  }

  export type All_pageview_rawAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which all_pageview_raw to aggregate.
     */
    where?: all_pageview_rawWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of all_pageview_raws to fetch.
     */
    orderBy?: all_pageview_rawOrderByWithRelationInput | all_pageview_rawOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: all_pageview_rawWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` all_pageview_raws from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` all_pageview_raws.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned all_pageview_raws
    **/
    _count?: true | All_pageview_rawCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: All_pageview_rawAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: All_pageview_rawSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: All_pageview_rawMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: All_pageview_rawMaxAggregateInputType
  }

  export type GetAll_pageview_rawAggregateType<T extends All_pageview_rawAggregateArgs> = {
        [P in keyof T & keyof AggregateAll_pageview_raw]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAll_pageview_raw[P]>
      : GetScalarType<T[P], AggregateAll_pageview_raw[P]>
  }




  export type all_pageview_rawGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: all_pageview_rawWhereInput
    orderBy?: all_pageview_rawOrderByWithAggregationInput | all_pageview_rawOrderByWithAggregationInput[]
    by: All_pageview_rawScalarFieldEnum[] | All_pageview_rawScalarFieldEnum
    having?: all_pageview_rawScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: All_pageview_rawCountAggregateInputType | true
    _avg?: All_pageview_rawAvgAggregateInputType
    _sum?: All_pageview_rawSumAggregateInputType
    _min?: All_pageview_rawMinAggregateInputType
    _max?: All_pageview_rawMaxAggregateInputType
  }

  export type All_pageview_rawGroupByOutputType = {
    id: bigint
    event_timestamp: Date
    properties: JsonValue | null
    distinct_id: string | null
    session_id: string | null
    current_url: string | null
    person_id: string | null
    ingested_at: Date
    _count: All_pageview_rawCountAggregateOutputType | null
    _avg: All_pageview_rawAvgAggregateOutputType | null
    _sum: All_pageview_rawSumAggregateOutputType | null
    _min: All_pageview_rawMinAggregateOutputType | null
    _max: All_pageview_rawMaxAggregateOutputType | null
  }

  type GetAll_pageview_rawGroupByPayload<T extends all_pageview_rawGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<All_pageview_rawGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof All_pageview_rawGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], All_pageview_rawGroupByOutputType[P]>
            : GetScalarType<T[P], All_pageview_rawGroupByOutputType[P]>
        }
      >
    >


  export type all_pageview_rawSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    event_timestamp?: boolean
    properties?: boolean
    distinct_id?: boolean
    session_id?: boolean
    current_url?: boolean
    person_id?: boolean
    ingested_at?: boolean
  }, ExtArgs["result"]["all_pageview_raw"]>

  export type all_pageview_rawSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    event_timestamp?: boolean
    properties?: boolean
    distinct_id?: boolean
    session_id?: boolean
    current_url?: boolean
    person_id?: boolean
    ingested_at?: boolean
  }, ExtArgs["result"]["all_pageview_raw"]>

  export type all_pageview_rawSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    event_timestamp?: boolean
    properties?: boolean
    distinct_id?: boolean
    session_id?: boolean
    current_url?: boolean
    person_id?: boolean
    ingested_at?: boolean
  }, ExtArgs["result"]["all_pageview_raw"]>

  export type all_pageview_rawSelectScalar = {
    id?: boolean
    event_timestamp?: boolean
    properties?: boolean
    distinct_id?: boolean
    session_id?: boolean
    current_url?: boolean
    person_id?: boolean
    ingested_at?: boolean
  }

  export type all_pageview_rawOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "event_timestamp" | "properties" | "distinct_id" | "session_id" | "current_url" | "person_id" | "ingested_at", ExtArgs["result"]["all_pageview_raw"]>

  export type $all_pageview_rawPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "all_pageview_raw"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      event_timestamp: Date
      properties: Prisma.JsonValue | null
      distinct_id: string | null
      session_id: string | null
      current_url: string | null
      person_id: string | null
      ingested_at: Date
    }, ExtArgs["result"]["all_pageview_raw"]>
    composites: {}
  }

  type all_pageview_rawGetPayload<S extends boolean | null | undefined | all_pageview_rawDefaultArgs> = $Result.GetResult<Prisma.$all_pageview_rawPayload, S>

  type all_pageview_rawCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<all_pageview_rawFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: All_pageview_rawCountAggregateInputType | true
    }

  export interface all_pageview_rawDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['all_pageview_raw'], meta: { name: 'all_pageview_raw' } }
    /**
     * Find zero or one All_pageview_raw that matches the filter.
     * @param {all_pageview_rawFindUniqueArgs} args - Arguments to find a All_pageview_raw
     * @example
     * // Get one All_pageview_raw
     * const all_pageview_raw = await prisma.all_pageview_raw.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends all_pageview_rawFindUniqueArgs>(args: SelectSubset<T, all_pageview_rawFindUniqueArgs<ExtArgs>>): Prisma__all_pageview_rawClient<$Result.GetResult<Prisma.$all_pageview_rawPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one All_pageview_raw that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {all_pageview_rawFindUniqueOrThrowArgs} args - Arguments to find a All_pageview_raw
     * @example
     * // Get one All_pageview_raw
     * const all_pageview_raw = await prisma.all_pageview_raw.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends all_pageview_rawFindUniqueOrThrowArgs>(args: SelectSubset<T, all_pageview_rawFindUniqueOrThrowArgs<ExtArgs>>): Prisma__all_pageview_rawClient<$Result.GetResult<Prisma.$all_pageview_rawPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first All_pageview_raw that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {all_pageview_rawFindFirstArgs} args - Arguments to find a All_pageview_raw
     * @example
     * // Get one All_pageview_raw
     * const all_pageview_raw = await prisma.all_pageview_raw.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends all_pageview_rawFindFirstArgs>(args?: SelectSubset<T, all_pageview_rawFindFirstArgs<ExtArgs>>): Prisma__all_pageview_rawClient<$Result.GetResult<Prisma.$all_pageview_rawPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first All_pageview_raw that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {all_pageview_rawFindFirstOrThrowArgs} args - Arguments to find a All_pageview_raw
     * @example
     * // Get one All_pageview_raw
     * const all_pageview_raw = await prisma.all_pageview_raw.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends all_pageview_rawFindFirstOrThrowArgs>(args?: SelectSubset<T, all_pageview_rawFindFirstOrThrowArgs<ExtArgs>>): Prisma__all_pageview_rawClient<$Result.GetResult<Prisma.$all_pageview_rawPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more All_pageview_raws that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {all_pageview_rawFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all All_pageview_raws
     * const all_pageview_raws = await prisma.all_pageview_raw.findMany()
     * 
     * // Get first 10 All_pageview_raws
     * const all_pageview_raws = await prisma.all_pageview_raw.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const all_pageview_rawWithIdOnly = await prisma.all_pageview_raw.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends all_pageview_rawFindManyArgs>(args?: SelectSubset<T, all_pageview_rawFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$all_pageview_rawPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a All_pageview_raw.
     * @param {all_pageview_rawCreateArgs} args - Arguments to create a All_pageview_raw.
     * @example
     * // Create one All_pageview_raw
     * const All_pageview_raw = await prisma.all_pageview_raw.create({
     *   data: {
     *     // ... data to create a All_pageview_raw
     *   }
     * })
     * 
     */
    create<T extends all_pageview_rawCreateArgs>(args: SelectSubset<T, all_pageview_rawCreateArgs<ExtArgs>>): Prisma__all_pageview_rawClient<$Result.GetResult<Prisma.$all_pageview_rawPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many All_pageview_raws.
     * @param {all_pageview_rawCreateManyArgs} args - Arguments to create many All_pageview_raws.
     * @example
     * // Create many All_pageview_raws
     * const all_pageview_raw = await prisma.all_pageview_raw.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends all_pageview_rawCreateManyArgs>(args?: SelectSubset<T, all_pageview_rawCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many All_pageview_raws and returns the data saved in the database.
     * @param {all_pageview_rawCreateManyAndReturnArgs} args - Arguments to create many All_pageview_raws.
     * @example
     * // Create many All_pageview_raws
     * const all_pageview_raw = await prisma.all_pageview_raw.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many All_pageview_raws and only return the `id`
     * const all_pageview_rawWithIdOnly = await prisma.all_pageview_raw.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends all_pageview_rawCreateManyAndReturnArgs>(args?: SelectSubset<T, all_pageview_rawCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$all_pageview_rawPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a All_pageview_raw.
     * @param {all_pageview_rawDeleteArgs} args - Arguments to delete one All_pageview_raw.
     * @example
     * // Delete one All_pageview_raw
     * const All_pageview_raw = await prisma.all_pageview_raw.delete({
     *   where: {
     *     // ... filter to delete one All_pageview_raw
     *   }
     * })
     * 
     */
    delete<T extends all_pageview_rawDeleteArgs>(args: SelectSubset<T, all_pageview_rawDeleteArgs<ExtArgs>>): Prisma__all_pageview_rawClient<$Result.GetResult<Prisma.$all_pageview_rawPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one All_pageview_raw.
     * @param {all_pageview_rawUpdateArgs} args - Arguments to update one All_pageview_raw.
     * @example
     * // Update one All_pageview_raw
     * const all_pageview_raw = await prisma.all_pageview_raw.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends all_pageview_rawUpdateArgs>(args: SelectSubset<T, all_pageview_rawUpdateArgs<ExtArgs>>): Prisma__all_pageview_rawClient<$Result.GetResult<Prisma.$all_pageview_rawPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more All_pageview_raws.
     * @param {all_pageview_rawDeleteManyArgs} args - Arguments to filter All_pageview_raws to delete.
     * @example
     * // Delete a few All_pageview_raws
     * const { count } = await prisma.all_pageview_raw.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends all_pageview_rawDeleteManyArgs>(args?: SelectSubset<T, all_pageview_rawDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more All_pageview_raws.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {all_pageview_rawUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many All_pageview_raws
     * const all_pageview_raw = await prisma.all_pageview_raw.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends all_pageview_rawUpdateManyArgs>(args: SelectSubset<T, all_pageview_rawUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more All_pageview_raws and returns the data updated in the database.
     * @param {all_pageview_rawUpdateManyAndReturnArgs} args - Arguments to update many All_pageview_raws.
     * @example
     * // Update many All_pageview_raws
     * const all_pageview_raw = await prisma.all_pageview_raw.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more All_pageview_raws and only return the `id`
     * const all_pageview_rawWithIdOnly = await prisma.all_pageview_raw.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends all_pageview_rawUpdateManyAndReturnArgs>(args: SelectSubset<T, all_pageview_rawUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$all_pageview_rawPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one All_pageview_raw.
     * @param {all_pageview_rawUpsertArgs} args - Arguments to update or create a All_pageview_raw.
     * @example
     * // Update or create a All_pageview_raw
     * const all_pageview_raw = await prisma.all_pageview_raw.upsert({
     *   create: {
     *     // ... data to create a All_pageview_raw
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the All_pageview_raw we want to update
     *   }
     * })
     */
    upsert<T extends all_pageview_rawUpsertArgs>(args: SelectSubset<T, all_pageview_rawUpsertArgs<ExtArgs>>): Prisma__all_pageview_rawClient<$Result.GetResult<Prisma.$all_pageview_rawPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of All_pageview_raws.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {all_pageview_rawCountArgs} args - Arguments to filter All_pageview_raws to count.
     * @example
     * // Count the number of All_pageview_raws
     * const count = await prisma.all_pageview_raw.count({
     *   where: {
     *     // ... the filter for the All_pageview_raws we want to count
     *   }
     * })
    **/
    count<T extends all_pageview_rawCountArgs>(
      args?: Subset<T, all_pageview_rawCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], All_pageview_rawCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a All_pageview_raw.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {All_pageview_rawAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends All_pageview_rawAggregateArgs>(args: Subset<T, All_pageview_rawAggregateArgs>): Prisma.PrismaPromise<GetAll_pageview_rawAggregateType<T>>

    /**
     * Group by All_pageview_raw.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {all_pageview_rawGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends all_pageview_rawGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: all_pageview_rawGroupByArgs['orderBy'] }
        : { orderBy?: all_pageview_rawGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, all_pageview_rawGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAll_pageview_rawGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the all_pageview_raw model
   */
  readonly fields: all_pageview_rawFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for all_pageview_raw.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__all_pageview_rawClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the all_pageview_raw model
   */
  interface all_pageview_rawFieldRefs {
    readonly id: FieldRef<"all_pageview_raw", 'BigInt'>
    readonly event_timestamp: FieldRef<"all_pageview_raw", 'DateTime'>
    readonly properties: FieldRef<"all_pageview_raw", 'Json'>
    readonly distinct_id: FieldRef<"all_pageview_raw", 'String'>
    readonly session_id: FieldRef<"all_pageview_raw", 'String'>
    readonly current_url: FieldRef<"all_pageview_raw", 'String'>
    readonly person_id: FieldRef<"all_pageview_raw", 'String'>
    readonly ingested_at: FieldRef<"all_pageview_raw", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * all_pageview_raw findUnique
   */
  export type all_pageview_rawFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the all_pageview_raw
     */
    select?: all_pageview_rawSelect<ExtArgs> | null
    /**
     * Omit specific fields from the all_pageview_raw
     */
    omit?: all_pageview_rawOmit<ExtArgs> | null
    /**
     * Filter, which all_pageview_raw to fetch.
     */
    where: all_pageview_rawWhereUniqueInput
  }

  /**
   * all_pageview_raw findUniqueOrThrow
   */
  export type all_pageview_rawFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the all_pageview_raw
     */
    select?: all_pageview_rawSelect<ExtArgs> | null
    /**
     * Omit specific fields from the all_pageview_raw
     */
    omit?: all_pageview_rawOmit<ExtArgs> | null
    /**
     * Filter, which all_pageview_raw to fetch.
     */
    where: all_pageview_rawWhereUniqueInput
  }

  /**
   * all_pageview_raw findFirst
   */
  export type all_pageview_rawFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the all_pageview_raw
     */
    select?: all_pageview_rawSelect<ExtArgs> | null
    /**
     * Omit specific fields from the all_pageview_raw
     */
    omit?: all_pageview_rawOmit<ExtArgs> | null
    /**
     * Filter, which all_pageview_raw to fetch.
     */
    where?: all_pageview_rawWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of all_pageview_raws to fetch.
     */
    orderBy?: all_pageview_rawOrderByWithRelationInput | all_pageview_rawOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for all_pageview_raws.
     */
    cursor?: all_pageview_rawWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` all_pageview_raws from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` all_pageview_raws.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of all_pageview_raws.
     */
    distinct?: All_pageview_rawScalarFieldEnum | All_pageview_rawScalarFieldEnum[]
  }

  /**
   * all_pageview_raw findFirstOrThrow
   */
  export type all_pageview_rawFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the all_pageview_raw
     */
    select?: all_pageview_rawSelect<ExtArgs> | null
    /**
     * Omit specific fields from the all_pageview_raw
     */
    omit?: all_pageview_rawOmit<ExtArgs> | null
    /**
     * Filter, which all_pageview_raw to fetch.
     */
    where?: all_pageview_rawWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of all_pageview_raws to fetch.
     */
    orderBy?: all_pageview_rawOrderByWithRelationInput | all_pageview_rawOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for all_pageview_raws.
     */
    cursor?: all_pageview_rawWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` all_pageview_raws from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` all_pageview_raws.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of all_pageview_raws.
     */
    distinct?: All_pageview_rawScalarFieldEnum | All_pageview_rawScalarFieldEnum[]
  }

  /**
   * all_pageview_raw findMany
   */
  export type all_pageview_rawFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the all_pageview_raw
     */
    select?: all_pageview_rawSelect<ExtArgs> | null
    /**
     * Omit specific fields from the all_pageview_raw
     */
    omit?: all_pageview_rawOmit<ExtArgs> | null
    /**
     * Filter, which all_pageview_raws to fetch.
     */
    where?: all_pageview_rawWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of all_pageview_raws to fetch.
     */
    orderBy?: all_pageview_rawOrderByWithRelationInput | all_pageview_rawOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing all_pageview_raws.
     */
    cursor?: all_pageview_rawWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` all_pageview_raws from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` all_pageview_raws.
     */
    skip?: number
    distinct?: All_pageview_rawScalarFieldEnum | All_pageview_rawScalarFieldEnum[]
  }

  /**
   * all_pageview_raw create
   */
  export type all_pageview_rawCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the all_pageview_raw
     */
    select?: all_pageview_rawSelect<ExtArgs> | null
    /**
     * Omit specific fields from the all_pageview_raw
     */
    omit?: all_pageview_rawOmit<ExtArgs> | null
    /**
     * The data needed to create a all_pageview_raw.
     */
    data: XOR<all_pageview_rawCreateInput, all_pageview_rawUncheckedCreateInput>
  }

  /**
   * all_pageview_raw createMany
   */
  export type all_pageview_rawCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many all_pageview_raws.
     */
    data: all_pageview_rawCreateManyInput | all_pageview_rawCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * all_pageview_raw createManyAndReturn
   */
  export type all_pageview_rawCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the all_pageview_raw
     */
    select?: all_pageview_rawSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the all_pageview_raw
     */
    omit?: all_pageview_rawOmit<ExtArgs> | null
    /**
     * The data used to create many all_pageview_raws.
     */
    data: all_pageview_rawCreateManyInput | all_pageview_rawCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * all_pageview_raw update
   */
  export type all_pageview_rawUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the all_pageview_raw
     */
    select?: all_pageview_rawSelect<ExtArgs> | null
    /**
     * Omit specific fields from the all_pageview_raw
     */
    omit?: all_pageview_rawOmit<ExtArgs> | null
    /**
     * The data needed to update a all_pageview_raw.
     */
    data: XOR<all_pageview_rawUpdateInput, all_pageview_rawUncheckedUpdateInput>
    /**
     * Choose, which all_pageview_raw to update.
     */
    where: all_pageview_rawWhereUniqueInput
  }

  /**
   * all_pageview_raw updateMany
   */
  export type all_pageview_rawUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update all_pageview_raws.
     */
    data: XOR<all_pageview_rawUpdateManyMutationInput, all_pageview_rawUncheckedUpdateManyInput>
    /**
     * Filter which all_pageview_raws to update
     */
    where?: all_pageview_rawWhereInput
    /**
     * Limit how many all_pageview_raws to update.
     */
    limit?: number
  }

  /**
   * all_pageview_raw updateManyAndReturn
   */
  export type all_pageview_rawUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the all_pageview_raw
     */
    select?: all_pageview_rawSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the all_pageview_raw
     */
    omit?: all_pageview_rawOmit<ExtArgs> | null
    /**
     * The data used to update all_pageview_raws.
     */
    data: XOR<all_pageview_rawUpdateManyMutationInput, all_pageview_rawUncheckedUpdateManyInput>
    /**
     * Filter which all_pageview_raws to update
     */
    where?: all_pageview_rawWhereInput
    /**
     * Limit how many all_pageview_raws to update.
     */
    limit?: number
  }

  /**
   * all_pageview_raw upsert
   */
  export type all_pageview_rawUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the all_pageview_raw
     */
    select?: all_pageview_rawSelect<ExtArgs> | null
    /**
     * Omit specific fields from the all_pageview_raw
     */
    omit?: all_pageview_rawOmit<ExtArgs> | null
    /**
     * The filter to search for the all_pageview_raw to update in case it exists.
     */
    where: all_pageview_rawWhereUniqueInput
    /**
     * In case the all_pageview_raw found by the `where` argument doesn't exist, create a new all_pageview_raw with this data.
     */
    create: XOR<all_pageview_rawCreateInput, all_pageview_rawUncheckedCreateInput>
    /**
     * In case the all_pageview_raw was found with the provided `where` argument, update it with this data.
     */
    update: XOR<all_pageview_rawUpdateInput, all_pageview_rawUncheckedUpdateInput>
  }

  /**
   * all_pageview_raw delete
   */
  export type all_pageview_rawDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the all_pageview_raw
     */
    select?: all_pageview_rawSelect<ExtArgs> | null
    /**
     * Omit specific fields from the all_pageview_raw
     */
    omit?: all_pageview_rawOmit<ExtArgs> | null
    /**
     * Filter which all_pageview_raw to delete.
     */
    where: all_pageview_rawWhereUniqueInput
  }

  /**
   * all_pageview_raw deleteMany
   */
  export type all_pageview_rawDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which all_pageview_raws to delete
     */
    where?: all_pageview_rawWhereInput
    /**
     * Limit how many all_pageview_raws to delete.
     */
    limit?: number
  }

  /**
   * all_pageview_raw without action
   */
  export type all_pageview_rawDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the all_pageview_raw
     */
    select?: all_pageview_rawSelect<ExtArgs> | null
    /**
     * Omit specific fields from the all_pageview_raw
     */
    omit?: all_pageview_rawOmit<ExtArgs> | null
  }


  /**
   * Model baserow_evenements
   */

  export type AggregateBaserow_evenements = {
    _count: Baserow_evenementsCountAggregateOutputType | null
    _avg: Baserow_evenementsAvgAggregateOutputType | null
    _sum: Baserow_evenementsSumAggregateOutputType | null
    _min: Baserow_evenementsMinAggregateOutputType | null
    _max: Baserow_evenementsMaxAggregateOutputType | null
  }

  export type Baserow_evenementsAvgAggregateOutputType = {
    id: number | null
  }

  export type Baserow_evenementsSumAggregateOutputType = {
    id: bigint | null
  }

  export type Baserow_evenementsMinAggregateOutputType = {
    id: bigint | null
    ordre: string | null
    nom: string | null
    date: string | null
    compte_rendu: string | null
    ingested_at: Date | null
  }

  export type Baserow_evenementsMaxAggregateOutputType = {
    id: bigint | null
    ordre: string | null
    nom: string | null
    date: string | null
    compte_rendu: string | null
    ingested_at: Date | null
  }

  export type Baserow_evenementsCountAggregateOutputType = {
    id: number
    ordre: number
    nom: number
    date: number
    type: number
    qui_anime_evenement: number
    compte_rendu: number
    nom_participants: number
    nom_territoires: number
    propos_nom_evenement: number
    campagne_test_utilisateur: number
    champs_rapporte: number
    fichier: number
    ingested_at: number
    _all: number
  }


  export type Baserow_evenementsAvgAggregateInputType = {
    id?: true
  }

  export type Baserow_evenementsSumAggregateInputType = {
    id?: true
  }

  export type Baserow_evenementsMinAggregateInputType = {
    id?: true
    ordre?: true
    nom?: true
    date?: true
    compte_rendu?: true
    ingested_at?: true
  }

  export type Baserow_evenementsMaxAggregateInputType = {
    id?: true
    ordre?: true
    nom?: true
    date?: true
    compte_rendu?: true
    ingested_at?: true
  }

  export type Baserow_evenementsCountAggregateInputType = {
    id?: true
    ordre?: true
    nom?: true
    date?: true
    type?: true
    qui_anime_evenement?: true
    compte_rendu?: true
    nom_participants?: true
    nom_territoires?: true
    propos_nom_evenement?: true
    campagne_test_utilisateur?: true
    champs_rapporte?: true
    fichier?: true
    ingested_at?: true
    _all?: true
  }

  export type Baserow_evenementsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which baserow_evenements to aggregate.
     */
    where?: baserow_evenementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of baserow_evenements to fetch.
     */
    orderBy?: baserow_evenementsOrderByWithRelationInput | baserow_evenementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: baserow_evenementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` baserow_evenements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` baserow_evenements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned baserow_evenements
    **/
    _count?: true | Baserow_evenementsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Baserow_evenementsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Baserow_evenementsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Baserow_evenementsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Baserow_evenementsMaxAggregateInputType
  }

  export type GetBaserow_evenementsAggregateType<T extends Baserow_evenementsAggregateArgs> = {
        [P in keyof T & keyof AggregateBaserow_evenements]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBaserow_evenements[P]>
      : GetScalarType<T[P], AggregateBaserow_evenements[P]>
  }




  export type baserow_evenementsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: baserow_evenementsWhereInput
    orderBy?: baserow_evenementsOrderByWithAggregationInput | baserow_evenementsOrderByWithAggregationInput[]
    by: Baserow_evenementsScalarFieldEnum[] | Baserow_evenementsScalarFieldEnum
    having?: baserow_evenementsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Baserow_evenementsCountAggregateInputType | true
    _avg?: Baserow_evenementsAvgAggregateInputType
    _sum?: Baserow_evenementsSumAggregateInputType
    _min?: Baserow_evenementsMinAggregateInputType
    _max?: Baserow_evenementsMaxAggregateInputType
  }

  export type Baserow_evenementsGroupByOutputType = {
    id: bigint
    ordre: string | null
    nom: string | null
    date: string | null
    type: JsonValue | null
    qui_anime_evenement: string[]
    compte_rendu: string | null
    nom_participants: string[]
    nom_territoires: string[]
    propos_nom_evenement: string[]
    campagne_test_utilisateur: JsonValue | null
    champs_rapporte: string[]
    fichier: string[]
    ingested_at: Date
    _count: Baserow_evenementsCountAggregateOutputType | null
    _avg: Baserow_evenementsAvgAggregateOutputType | null
    _sum: Baserow_evenementsSumAggregateOutputType | null
    _min: Baserow_evenementsMinAggregateOutputType | null
    _max: Baserow_evenementsMaxAggregateOutputType | null
  }

  type GetBaserow_evenementsGroupByPayload<T extends baserow_evenementsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Baserow_evenementsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Baserow_evenementsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Baserow_evenementsGroupByOutputType[P]>
            : GetScalarType<T[P], Baserow_evenementsGroupByOutputType[P]>
        }
      >
    >


  export type baserow_evenementsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ordre?: boolean
    nom?: boolean
    date?: boolean
    type?: boolean
    qui_anime_evenement?: boolean
    compte_rendu?: boolean
    nom_participants?: boolean
    nom_territoires?: boolean
    propos_nom_evenement?: boolean
    campagne_test_utilisateur?: boolean
    champs_rapporte?: boolean
    fichier?: boolean
    ingested_at?: boolean
  }, ExtArgs["result"]["baserow_evenements"]>

  export type baserow_evenementsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ordre?: boolean
    nom?: boolean
    date?: boolean
    type?: boolean
    qui_anime_evenement?: boolean
    compte_rendu?: boolean
    nom_participants?: boolean
    nom_territoires?: boolean
    propos_nom_evenement?: boolean
    campagne_test_utilisateur?: boolean
    champs_rapporte?: boolean
    fichier?: boolean
    ingested_at?: boolean
  }, ExtArgs["result"]["baserow_evenements"]>

  export type baserow_evenementsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ordre?: boolean
    nom?: boolean
    date?: boolean
    type?: boolean
    qui_anime_evenement?: boolean
    compte_rendu?: boolean
    nom_participants?: boolean
    nom_territoires?: boolean
    propos_nom_evenement?: boolean
    campagne_test_utilisateur?: boolean
    champs_rapporte?: boolean
    fichier?: boolean
    ingested_at?: boolean
  }, ExtArgs["result"]["baserow_evenements"]>

  export type baserow_evenementsSelectScalar = {
    id?: boolean
    ordre?: boolean
    nom?: boolean
    date?: boolean
    type?: boolean
    qui_anime_evenement?: boolean
    compte_rendu?: boolean
    nom_participants?: boolean
    nom_territoires?: boolean
    propos_nom_evenement?: boolean
    campagne_test_utilisateur?: boolean
    champs_rapporte?: boolean
    fichier?: boolean
    ingested_at?: boolean
  }

  export type baserow_evenementsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ordre" | "nom" | "date" | "type" | "qui_anime_evenement" | "compte_rendu" | "nom_participants" | "nom_territoires" | "propos_nom_evenement" | "campagne_test_utilisateur" | "champs_rapporte" | "fichier" | "ingested_at", ExtArgs["result"]["baserow_evenements"]>

  export type $baserow_evenementsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "baserow_evenements"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      ordre: string | null
      nom: string | null
      date: string | null
      type: Prisma.JsonValue | null
      qui_anime_evenement: string[]
      compte_rendu: string | null
      nom_participants: string[]
      nom_territoires: string[]
      propos_nom_evenement: string[]
      campagne_test_utilisateur: Prisma.JsonValue | null
      champs_rapporte: string[]
      fichier: string[]
      ingested_at: Date
    }, ExtArgs["result"]["baserow_evenements"]>
    composites: {}
  }

  type baserow_evenementsGetPayload<S extends boolean | null | undefined | baserow_evenementsDefaultArgs> = $Result.GetResult<Prisma.$baserow_evenementsPayload, S>

  type baserow_evenementsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<baserow_evenementsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Baserow_evenementsCountAggregateInputType | true
    }

  export interface baserow_evenementsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['baserow_evenements'], meta: { name: 'baserow_evenements' } }
    /**
     * Find zero or one Baserow_evenements that matches the filter.
     * @param {baserow_evenementsFindUniqueArgs} args - Arguments to find a Baserow_evenements
     * @example
     * // Get one Baserow_evenements
     * const baserow_evenements = await prisma.baserow_evenements.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends baserow_evenementsFindUniqueArgs>(args: SelectSubset<T, baserow_evenementsFindUniqueArgs<ExtArgs>>): Prisma__baserow_evenementsClient<$Result.GetResult<Prisma.$baserow_evenementsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Baserow_evenements that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {baserow_evenementsFindUniqueOrThrowArgs} args - Arguments to find a Baserow_evenements
     * @example
     * // Get one Baserow_evenements
     * const baserow_evenements = await prisma.baserow_evenements.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends baserow_evenementsFindUniqueOrThrowArgs>(args: SelectSubset<T, baserow_evenementsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__baserow_evenementsClient<$Result.GetResult<Prisma.$baserow_evenementsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Baserow_evenements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {baserow_evenementsFindFirstArgs} args - Arguments to find a Baserow_evenements
     * @example
     * // Get one Baserow_evenements
     * const baserow_evenements = await prisma.baserow_evenements.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends baserow_evenementsFindFirstArgs>(args?: SelectSubset<T, baserow_evenementsFindFirstArgs<ExtArgs>>): Prisma__baserow_evenementsClient<$Result.GetResult<Prisma.$baserow_evenementsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Baserow_evenements that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {baserow_evenementsFindFirstOrThrowArgs} args - Arguments to find a Baserow_evenements
     * @example
     * // Get one Baserow_evenements
     * const baserow_evenements = await prisma.baserow_evenements.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends baserow_evenementsFindFirstOrThrowArgs>(args?: SelectSubset<T, baserow_evenementsFindFirstOrThrowArgs<ExtArgs>>): Prisma__baserow_evenementsClient<$Result.GetResult<Prisma.$baserow_evenementsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Baserow_evenements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {baserow_evenementsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Baserow_evenements
     * const baserow_evenements = await prisma.baserow_evenements.findMany()
     * 
     * // Get first 10 Baserow_evenements
     * const baserow_evenements = await prisma.baserow_evenements.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const baserow_evenementsWithIdOnly = await prisma.baserow_evenements.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends baserow_evenementsFindManyArgs>(args?: SelectSubset<T, baserow_evenementsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$baserow_evenementsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Baserow_evenements.
     * @param {baserow_evenementsCreateArgs} args - Arguments to create a Baserow_evenements.
     * @example
     * // Create one Baserow_evenements
     * const Baserow_evenements = await prisma.baserow_evenements.create({
     *   data: {
     *     // ... data to create a Baserow_evenements
     *   }
     * })
     * 
     */
    create<T extends baserow_evenementsCreateArgs>(args: SelectSubset<T, baserow_evenementsCreateArgs<ExtArgs>>): Prisma__baserow_evenementsClient<$Result.GetResult<Prisma.$baserow_evenementsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Baserow_evenements.
     * @param {baserow_evenementsCreateManyArgs} args - Arguments to create many Baserow_evenements.
     * @example
     * // Create many Baserow_evenements
     * const baserow_evenements = await prisma.baserow_evenements.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends baserow_evenementsCreateManyArgs>(args?: SelectSubset<T, baserow_evenementsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Baserow_evenements and returns the data saved in the database.
     * @param {baserow_evenementsCreateManyAndReturnArgs} args - Arguments to create many Baserow_evenements.
     * @example
     * // Create many Baserow_evenements
     * const baserow_evenements = await prisma.baserow_evenements.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Baserow_evenements and only return the `id`
     * const baserow_evenementsWithIdOnly = await prisma.baserow_evenements.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends baserow_evenementsCreateManyAndReturnArgs>(args?: SelectSubset<T, baserow_evenementsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$baserow_evenementsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Baserow_evenements.
     * @param {baserow_evenementsDeleteArgs} args - Arguments to delete one Baserow_evenements.
     * @example
     * // Delete one Baserow_evenements
     * const Baserow_evenements = await prisma.baserow_evenements.delete({
     *   where: {
     *     // ... filter to delete one Baserow_evenements
     *   }
     * })
     * 
     */
    delete<T extends baserow_evenementsDeleteArgs>(args: SelectSubset<T, baserow_evenementsDeleteArgs<ExtArgs>>): Prisma__baserow_evenementsClient<$Result.GetResult<Prisma.$baserow_evenementsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Baserow_evenements.
     * @param {baserow_evenementsUpdateArgs} args - Arguments to update one Baserow_evenements.
     * @example
     * // Update one Baserow_evenements
     * const baserow_evenements = await prisma.baserow_evenements.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends baserow_evenementsUpdateArgs>(args: SelectSubset<T, baserow_evenementsUpdateArgs<ExtArgs>>): Prisma__baserow_evenementsClient<$Result.GetResult<Prisma.$baserow_evenementsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Baserow_evenements.
     * @param {baserow_evenementsDeleteManyArgs} args - Arguments to filter Baserow_evenements to delete.
     * @example
     * // Delete a few Baserow_evenements
     * const { count } = await prisma.baserow_evenements.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends baserow_evenementsDeleteManyArgs>(args?: SelectSubset<T, baserow_evenementsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Baserow_evenements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {baserow_evenementsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Baserow_evenements
     * const baserow_evenements = await prisma.baserow_evenements.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends baserow_evenementsUpdateManyArgs>(args: SelectSubset<T, baserow_evenementsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Baserow_evenements and returns the data updated in the database.
     * @param {baserow_evenementsUpdateManyAndReturnArgs} args - Arguments to update many Baserow_evenements.
     * @example
     * // Update many Baserow_evenements
     * const baserow_evenements = await prisma.baserow_evenements.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Baserow_evenements and only return the `id`
     * const baserow_evenementsWithIdOnly = await prisma.baserow_evenements.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends baserow_evenementsUpdateManyAndReturnArgs>(args: SelectSubset<T, baserow_evenementsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$baserow_evenementsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Baserow_evenements.
     * @param {baserow_evenementsUpsertArgs} args - Arguments to update or create a Baserow_evenements.
     * @example
     * // Update or create a Baserow_evenements
     * const baserow_evenements = await prisma.baserow_evenements.upsert({
     *   create: {
     *     // ... data to create a Baserow_evenements
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Baserow_evenements we want to update
     *   }
     * })
     */
    upsert<T extends baserow_evenementsUpsertArgs>(args: SelectSubset<T, baserow_evenementsUpsertArgs<ExtArgs>>): Prisma__baserow_evenementsClient<$Result.GetResult<Prisma.$baserow_evenementsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Baserow_evenements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {baserow_evenementsCountArgs} args - Arguments to filter Baserow_evenements to count.
     * @example
     * // Count the number of Baserow_evenements
     * const count = await prisma.baserow_evenements.count({
     *   where: {
     *     // ... the filter for the Baserow_evenements we want to count
     *   }
     * })
    **/
    count<T extends baserow_evenementsCountArgs>(
      args?: Subset<T, baserow_evenementsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Baserow_evenementsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Baserow_evenements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Baserow_evenementsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Baserow_evenementsAggregateArgs>(args: Subset<T, Baserow_evenementsAggregateArgs>): Prisma.PrismaPromise<GetBaserow_evenementsAggregateType<T>>

    /**
     * Group by Baserow_evenements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {baserow_evenementsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends baserow_evenementsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: baserow_evenementsGroupByArgs['orderBy'] }
        : { orderBy?: baserow_evenementsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, baserow_evenementsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBaserow_evenementsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the baserow_evenements model
   */
  readonly fields: baserow_evenementsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for baserow_evenements.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__baserow_evenementsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the baserow_evenements model
   */
  interface baserow_evenementsFieldRefs {
    readonly id: FieldRef<"baserow_evenements", 'BigInt'>
    readonly ordre: FieldRef<"baserow_evenements", 'String'>
    readonly nom: FieldRef<"baserow_evenements", 'String'>
    readonly date: FieldRef<"baserow_evenements", 'String'>
    readonly type: FieldRef<"baserow_evenements", 'Json'>
    readonly qui_anime_evenement: FieldRef<"baserow_evenements", 'String[]'>
    readonly compte_rendu: FieldRef<"baserow_evenements", 'String'>
    readonly nom_participants: FieldRef<"baserow_evenements", 'String[]'>
    readonly nom_territoires: FieldRef<"baserow_evenements", 'String[]'>
    readonly propos_nom_evenement: FieldRef<"baserow_evenements", 'String[]'>
    readonly campagne_test_utilisateur: FieldRef<"baserow_evenements", 'Json'>
    readonly champs_rapporte: FieldRef<"baserow_evenements", 'String[]'>
    readonly fichier: FieldRef<"baserow_evenements", 'String[]'>
    readonly ingested_at: FieldRef<"baserow_evenements", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * baserow_evenements findUnique
   */
  export type baserow_evenementsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the baserow_evenements
     */
    select?: baserow_evenementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the baserow_evenements
     */
    omit?: baserow_evenementsOmit<ExtArgs> | null
    /**
     * Filter, which baserow_evenements to fetch.
     */
    where: baserow_evenementsWhereUniqueInput
  }

  /**
   * baserow_evenements findUniqueOrThrow
   */
  export type baserow_evenementsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the baserow_evenements
     */
    select?: baserow_evenementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the baserow_evenements
     */
    omit?: baserow_evenementsOmit<ExtArgs> | null
    /**
     * Filter, which baserow_evenements to fetch.
     */
    where: baserow_evenementsWhereUniqueInput
  }

  /**
   * baserow_evenements findFirst
   */
  export type baserow_evenementsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the baserow_evenements
     */
    select?: baserow_evenementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the baserow_evenements
     */
    omit?: baserow_evenementsOmit<ExtArgs> | null
    /**
     * Filter, which baserow_evenements to fetch.
     */
    where?: baserow_evenementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of baserow_evenements to fetch.
     */
    orderBy?: baserow_evenementsOrderByWithRelationInput | baserow_evenementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for baserow_evenements.
     */
    cursor?: baserow_evenementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` baserow_evenements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` baserow_evenements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of baserow_evenements.
     */
    distinct?: Baserow_evenementsScalarFieldEnum | Baserow_evenementsScalarFieldEnum[]
  }

  /**
   * baserow_evenements findFirstOrThrow
   */
  export type baserow_evenementsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the baserow_evenements
     */
    select?: baserow_evenementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the baserow_evenements
     */
    omit?: baserow_evenementsOmit<ExtArgs> | null
    /**
     * Filter, which baserow_evenements to fetch.
     */
    where?: baserow_evenementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of baserow_evenements to fetch.
     */
    orderBy?: baserow_evenementsOrderByWithRelationInput | baserow_evenementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for baserow_evenements.
     */
    cursor?: baserow_evenementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` baserow_evenements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` baserow_evenements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of baserow_evenements.
     */
    distinct?: Baserow_evenementsScalarFieldEnum | Baserow_evenementsScalarFieldEnum[]
  }

  /**
   * baserow_evenements findMany
   */
  export type baserow_evenementsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the baserow_evenements
     */
    select?: baserow_evenementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the baserow_evenements
     */
    omit?: baserow_evenementsOmit<ExtArgs> | null
    /**
     * Filter, which baserow_evenements to fetch.
     */
    where?: baserow_evenementsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of baserow_evenements to fetch.
     */
    orderBy?: baserow_evenementsOrderByWithRelationInput | baserow_evenementsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing baserow_evenements.
     */
    cursor?: baserow_evenementsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` baserow_evenements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` baserow_evenements.
     */
    skip?: number
    distinct?: Baserow_evenementsScalarFieldEnum | Baserow_evenementsScalarFieldEnum[]
  }

  /**
   * baserow_evenements create
   */
  export type baserow_evenementsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the baserow_evenements
     */
    select?: baserow_evenementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the baserow_evenements
     */
    omit?: baserow_evenementsOmit<ExtArgs> | null
    /**
     * The data needed to create a baserow_evenements.
     */
    data?: XOR<baserow_evenementsCreateInput, baserow_evenementsUncheckedCreateInput>
  }

  /**
   * baserow_evenements createMany
   */
  export type baserow_evenementsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many baserow_evenements.
     */
    data: baserow_evenementsCreateManyInput | baserow_evenementsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * baserow_evenements createManyAndReturn
   */
  export type baserow_evenementsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the baserow_evenements
     */
    select?: baserow_evenementsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the baserow_evenements
     */
    omit?: baserow_evenementsOmit<ExtArgs> | null
    /**
     * The data used to create many baserow_evenements.
     */
    data: baserow_evenementsCreateManyInput | baserow_evenementsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * baserow_evenements update
   */
  export type baserow_evenementsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the baserow_evenements
     */
    select?: baserow_evenementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the baserow_evenements
     */
    omit?: baserow_evenementsOmit<ExtArgs> | null
    /**
     * The data needed to update a baserow_evenements.
     */
    data: XOR<baserow_evenementsUpdateInput, baserow_evenementsUncheckedUpdateInput>
    /**
     * Choose, which baserow_evenements to update.
     */
    where: baserow_evenementsWhereUniqueInput
  }

  /**
   * baserow_evenements updateMany
   */
  export type baserow_evenementsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update baserow_evenements.
     */
    data: XOR<baserow_evenementsUpdateManyMutationInput, baserow_evenementsUncheckedUpdateManyInput>
    /**
     * Filter which baserow_evenements to update
     */
    where?: baserow_evenementsWhereInput
    /**
     * Limit how many baserow_evenements to update.
     */
    limit?: number
  }

  /**
   * baserow_evenements updateManyAndReturn
   */
  export type baserow_evenementsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the baserow_evenements
     */
    select?: baserow_evenementsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the baserow_evenements
     */
    omit?: baserow_evenementsOmit<ExtArgs> | null
    /**
     * The data used to update baserow_evenements.
     */
    data: XOR<baserow_evenementsUpdateManyMutationInput, baserow_evenementsUncheckedUpdateManyInput>
    /**
     * Filter which baserow_evenements to update
     */
    where?: baserow_evenementsWhereInput
    /**
     * Limit how many baserow_evenements to update.
     */
    limit?: number
  }

  /**
   * baserow_evenements upsert
   */
  export type baserow_evenementsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the baserow_evenements
     */
    select?: baserow_evenementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the baserow_evenements
     */
    omit?: baserow_evenementsOmit<ExtArgs> | null
    /**
     * The filter to search for the baserow_evenements to update in case it exists.
     */
    where: baserow_evenementsWhereUniqueInput
    /**
     * In case the baserow_evenements found by the `where` argument doesn't exist, create a new baserow_evenements with this data.
     */
    create: XOR<baserow_evenementsCreateInput, baserow_evenementsUncheckedCreateInput>
    /**
     * In case the baserow_evenements was found with the provided `where` argument, update it with this data.
     */
    update: XOR<baserow_evenementsUpdateInput, baserow_evenementsUncheckedUpdateInput>
  }

  /**
   * baserow_evenements delete
   */
  export type baserow_evenementsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the baserow_evenements
     */
    select?: baserow_evenementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the baserow_evenements
     */
    omit?: baserow_evenementsOmit<ExtArgs> | null
    /**
     * Filter which baserow_evenements to delete.
     */
    where: baserow_evenementsWhereUniqueInput
  }

  /**
   * baserow_evenements deleteMany
   */
  export type baserow_evenementsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which baserow_evenements to delete
     */
    where?: baserow_evenementsWhereInput
    /**
     * Limit how many baserow_evenements to delete.
     */
    limit?: number
  }

  /**
   * baserow_evenements without action
   */
  export type baserow_evenementsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the baserow_evenements
     */
    select?: baserow_evenementsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the baserow_evenements
     */
    omit?: baserow_evenementsOmit<ExtArgs> | null
  }


  /**
   * Model baserow_territoires
   */

  export type AggregateBaserow_territoires = {
    _count: Baserow_territoiresCountAggregateOutputType | null
    _avg: Baserow_territoiresAvgAggregateOutputType | null
    _sum: Baserow_territoiresSumAggregateOutputType | null
    _min: Baserow_territoiresMinAggregateOutputType | null
    _max: Baserow_territoiresMaxAggregateOutputType | null
  }

  export type Baserow_territoiresAvgAggregateOutputType = {
    id: number | null
  }

  export type Baserow_territoiresSumAggregateOutputType = {
    id: bigint | null
  }

  export type Baserow_territoiresMinAggregateOutputType = {
    id: bigint | null
    ordre: string | null
    nom_territoire: string | null
    notes_ouvertes: string | null
    be: boolean | null
    soumis_a_pcaet: boolean | null
    suivi_evaluation: boolean | null
    date_validation: string | null
    date_revision_estimee: string | null
    siren: string | null
    ingested_at: Date | null
  }

  export type Baserow_territoiresMaxAggregateOutputType = {
    id: bigint | null
    ordre: string | null
    nom_territoire: string | null
    notes_ouvertes: string | null
    be: boolean | null
    soumis_a_pcaet: boolean | null
    suivi_evaluation: boolean | null
    date_validation: string | null
    date_revision_estimee: string | null
    siren: string | null
    ingested_at: Date | null
  }

  export type Baserow_territoiresCountAggregateOutputType = {
    id: number
    ordre: number
    nom_territoire: number
    notes_ouvertes: number
    typologie_territoire: number
    thematique_prioritaire: number
    be: number
    soumis_a_pcaet: number
    demarches_et_programmes: number
    documents_de_planification: number
    avancee_sur_le_ddv: number
    avancee_sur_la_strategie: number
    suivi_evaluation: number
    date_validation: number
    date_revision_estimee: number
    propos: number
    attente_session_accueil: number
    role_be: number
    cdm: number
    siren: number
    ingested_at: number
    _all: number
  }


  export type Baserow_territoiresAvgAggregateInputType = {
    id?: true
  }

  export type Baserow_territoiresSumAggregateInputType = {
    id?: true
  }

  export type Baserow_territoiresMinAggregateInputType = {
    id?: true
    ordre?: true
    nom_territoire?: true
    notes_ouvertes?: true
    be?: true
    soumis_a_pcaet?: true
    suivi_evaluation?: true
    date_validation?: true
    date_revision_estimee?: true
    siren?: true
    ingested_at?: true
  }

  export type Baserow_territoiresMaxAggregateInputType = {
    id?: true
    ordre?: true
    nom_territoire?: true
    notes_ouvertes?: true
    be?: true
    soumis_a_pcaet?: true
    suivi_evaluation?: true
    date_validation?: true
    date_revision_estimee?: true
    siren?: true
    ingested_at?: true
  }

  export type Baserow_territoiresCountAggregateInputType = {
    id?: true
    ordre?: true
    nom_territoire?: true
    notes_ouvertes?: true
    typologie_territoire?: true
    thematique_prioritaire?: true
    be?: true
    soumis_a_pcaet?: true
    demarches_et_programmes?: true
    documents_de_planification?: true
    avancee_sur_le_ddv?: true
    avancee_sur_la_strategie?: true
    suivi_evaluation?: true
    date_validation?: true
    date_revision_estimee?: true
    propos?: true
    attente_session_accueil?: true
    role_be?: true
    cdm?: true
    siren?: true
    ingested_at?: true
    _all?: true
  }

  export type Baserow_territoiresAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which baserow_territoires to aggregate.
     */
    where?: baserow_territoiresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of baserow_territoires to fetch.
     */
    orderBy?: baserow_territoiresOrderByWithRelationInput | baserow_territoiresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: baserow_territoiresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` baserow_territoires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` baserow_territoires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned baserow_territoires
    **/
    _count?: true | Baserow_territoiresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Baserow_territoiresAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Baserow_territoiresSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Baserow_territoiresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Baserow_territoiresMaxAggregateInputType
  }

  export type GetBaserow_territoiresAggregateType<T extends Baserow_territoiresAggregateArgs> = {
        [P in keyof T & keyof AggregateBaserow_territoires]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBaserow_territoires[P]>
      : GetScalarType<T[P], AggregateBaserow_territoires[P]>
  }




  export type baserow_territoiresGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: baserow_territoiresWhereInput
    orderBy?: baserow_territoiresOrderByWithAggregationInput | baserow_territoiresOrderByWithAggregationInput[]
    by: Baserow_territoiresScalarFieldEnum[] | Baserow_territoiresScalarFieldEnum
    having?: baserow_territoiresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Baserow_territoiresCountAggregateInputType | true
    _avg?: Baserow_territoiresAvgAggregateInputType
    _sum?: Baserow_territoiresSumAggregateInputType
    _min?: Baserow_territoiresMinAggregateInputType
    _max?: Baserow_territoiresMaxAggregateInputType
  }

  export type Baserow_territoiresGroupByOutputType = {
    id: bigint
    ordre: string | null
    nom_territoire: string | null
    notes_ouvertes: string | null
    typologie_territoire: string[]
    thematique_prioritaire: string[]
    be: boolean | null
    soumis_a_pcaet: boolean | null
    demarches_et_programmes: string[]
    documents_de_planification: string[]
    avancee_sur_le_ddv: string[]
    avancee_sur_la_strategie: string[]
    suivi_evaluation: boolean | null
    date_validation: string | null
    date_revision_estimee: string | null
    propos: string[]
    attente_session_accueil: string[]
    role_be: string[]
    cdm: string[]
    siren: string | null
    ingested_at: Date
    _count: Baserow_territoiresCountAggregateOutputType | null
    _avg: Baserow_territoiresAvgAggregateOutputType | null
    _sum: Baserow_territoiresSumAggregateOutputType | null
    _min: Baserow_territoiresMinAggregateOutputType | null
    _max: Baserow_territoiresMaxAggregateOutputType | null
  }

  type GetBaserow_territoiresGroupByPayload<T extends baserow_territoiresGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Baserow_territoiresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Baserow_territoiresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Baserow_territoiresGroupByOutputType[P]>
            : GetScalarType<T[P], Baserow_territoiresGroupByOutputType[P]>
        }
      >
    >


  export type baserow_territoiresSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ordre?: boolean
    nom_territoire?: boolean
    notes_ouvertes?: boolean
    typologie_territoire?: boolean
    thematique_prioritaire?: boolean
    be?: boolean
    soumis_a_pcaet?: boolean
    demarches_et_programmes?: boolean
    documents_de_planification?: boolean
    avancee_sur_le_ddv?: boolean
    avancee_sur_la_strategie?: boolean
    suivi_evaluation?: boolean
    date_validation?: boolean
    date_revision_estimee?: boolean
    propos?: boolean
    attente_session_accueil?: boolean
    role_be?: boolean
    cdm?: boolean
    siren?: boolean
    ingested_at?: boolean
  }, ExtArgs["result"]["baserow_territoires"]>

  export type baserow_territoiresSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ordre?: boolean
    nom_territoire?: boolean
    notes_ouvertes?: boolean
    typologie_territoire?: boolean
    thematique_prioritaire?: boolean
    be?: boolean
    soumis_a_pcaet?: boolean
    demarches_et_programmes?: boolean
    documents_de_planification?: boolean
    avancee_sur_le_ddv?: boolean
    avancee_sur_la_strategie?: boolean
    suivi_evaluation?: boolean
    date_validation?: boolean
    date_revision_estimee?: boolean
    propos?: boolean
    attente_session_accueil?: boolean
    role_be?: boolean
    cdm?: boolean
    siren?: boolean
    ingested_at?: boolean
  }, ExtArgs["result"]["baserow_territoires"]>

  export type baserow_territoiresSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ordre?: boolean
    nom_territoire?: boolean
    notes_ouvertes?: boolean
    typologie_territoire?: boolean
    thematique_prioritaire?: boolean
    be?: boolean
    soumis_a_pcaet?: boolean
    demarches_et_programmes?: boolean
    documents_de_planification?: boolean
    avancee_sur_le_ddv?: boolean
    avancee_sur_la_strategie?: boolean
    suivi_evaluation?: boolean
    date_validation?: boolean
    date_revision_estimee?: boolean
    propos?: boolean
    attente_session_accueil?: boolean
    role_be?: boolean
    cdm?: boolean
    siren?: boolean
    ingested_at?: boolean
  }, ExtArgs["result"]["baserow_territoires"]>

  export type baserow_territoiresSelectScalar = {
    id?: boolean
    ordre?: boolean
    nom_territoire?: boolean
    notes_ouvertes?: boolean
    typologie_territoire?: boolean
    thematique_prioritaire?: boolean
    be?: boolean
    soumis_a_pcaet?: boolean
    demarches_et_programmes?: boolean
    documents_de_planification?: boolean
    avancee_sur_le_ddv?: boolean
    avancee_sur_la_strategie?: boolean
    suivi_evaluation?: boolean
    date_validation?: boolean
    date_revision_estimee?: boolean
    propos?: boolean
    attente_session_accueil?: boolean
    role_be?: boolean
    cdm?: boolean
    siren?: boolean
    ingested_at?: boolean
  }

  export type baserow_territoiresOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ordre" | "nom_territoire" | "notes_ouvertes" | "typologie_territoire" | "thematique_prioritaire" | "be" | "soumis_a_pcaet" | "demarches_et_programmes" | "documents_de_planification" | "avancee_sur_le_ddv" | "avancee_sur_la_strategie" | "suivi_evaluation" | "date_validation" | "date_revision_estimee" | "propos" | "attente_session_accueil" | "role_be" | "cdm" | "siren" | "ingested_at", ExtArgs["result"]["baserow_territoires"]>

  export type $baserow_territoiresPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "baserow_territoires"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      ordre: string | null
      nom_territoire: string | null
      notes_ouvertes: string | null
      typologie_territoire: string[]
      thematique_prioritaire: string[]
      be: boolean | null
      soumis_a_pcaet: boolean | null
      demarches_et_programmes: string[]
      documents_de_planification: string[]
      avancee_sur_le_ddv: string[]
      avancee_sur_la_strategie: string[]
      suivi_evaluation: boolean | null
      date_validation: string | null
      date_revision_estimee: string | null
      propos: string[]
      attente_session_accueil: string[]
      role_be: string[]
      cdm: string[]
      siren: string | null
      ingested_at: Date
    }, ExtArgs["result"]["baserow_territoires"]>
    composites: {}
  }

  type baserow_territoiresGetPayload<S extends boolean | null | undefined | baserow_territoiresDefaultArgs> = $Result.GetResult<Prisma.$baserow_territoiresPayload, S>

  type baserow_territoiresCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<baserow_territoiresFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Baserow_territoiresCountAggregateInputType | true
    }

  export interface baserow_territoiresDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['baserow_territoires'], meta: { name: 'baserow_territoires' } }
    /**
     * Find zero or one Baserow_territoires that matches the filter.
     * @param {baserow_territoiresFindUniqueArgs} args - Arguments to find a Baserow_territoires
     * @example
     * // Get one Baserow_territoires
     * const baserow_territoires = await prisma.baserow_territoires.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends baserow_territoiresFindUniqueArgs>(args: SelectSubset<T, baserow_territoiresFindUniqueArgs<ExtArgs>>): Prisma__baserow_territoiresClient<$Result.GetResult<Prisma.$baserow_territoiresPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Baserow_territoires that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {baserow_territoiresFindUniqueOrThrowArgs} args - Arguments to find a Baserow_territoires
     * @example
     * // Get one Baserow_territoires
     * const baserow_territoires = await prisma.baserow_territoires.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends baserow_territoiresFindUniqueOrThrowArgs>(args: SelectSubset<T, baserow_territoiresFindUniqueOrThrowArgs<ExtArgs>>): Prisma__baserow_territoiresClient<$Result.GetResult<Prisma.$baserow_territoiresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Baserow_territoires that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {baserow_territoiresFindFirstArgs} args - Arguments to find a Baserow_territoires
     * @example
     * // Get one Baserow_territoires
     * const baserow_territoires = await prisma.baserow_territoires.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends baserow_territoiresFindFirstArgs>(args?: SelectSubset<T, baserow_territoiresFindFirstArgs<ExtArgs>>): Prisma__baserow_territoiresClient<$Result.GetResult<Prisma.$baserow_territoiresPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Baserow_territoires that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {baserow_territoiresFindFirstOrThrowArgs} args - Arguments to find a Baserow_territoires
     * @example
     * // Get one Baserow_territoires
     * const baserow_territoires = await prisma.baserow_territoires.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends baserow_territoiresFindFirstOrThrowArgs>(args?: SelectSubset<T, baserow_territoiresFindFirstOrThrowArgs<ExtArgs>>): Prisma__baserow_territoiresClient<$Result.GetResult<Prisma.$baserow_territoiresPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Baserow_territoires that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {baserow_territoiresFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Baserow_territoires
     * const baserow_territoires = await prisma.baserow_territoires.findMany()
     * 
     * // Get first 10 Baserow_territoires
     * const baserow_territoires = await prisma.baserow_territoires.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const baserow_territoiresWithIdOnly = await prisma.baserow_territoires.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends baserow_territoiresFindManyArgs>(args?: SelectSubset<T, baserow_territoiresFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$baserow_territoiresPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Baserow_territoires.
     * @param {baserow_territoiresCreateArgs} args - Arguments to create a Baserow_territoires.
     * @example
     * // Create one Baserow_territoires
     * const Baserow_territoires = await prisma.baserow_territoires.create({
     *   data: {
     *     // ... data to create a Baserow_territoires
     *   }
     * })
     * 
     */
    create<T extends baserow_territoiresCreateArgs>(args: SelectSubset<T, baserow_territoiresCreateArgs<ExtArgs>>): Prisma__baserow_territoiresClient<$Result.GetResult<Prisma.$baserow_territoiresPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Baserow_territoires.
     * @param {baserow_territoiresCreateManyArgs} args - Arguments to create many Baserow_territoires.
     * @example
     * // Create many Baserow_territoires
     * const baserow_territoires = await prisma.baserow_territoires.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends baserow_territoiresCreateManyArgs>(args?: SelectSubset<T, baserow_territoiresCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Baserow_territoires and returns the data saved in the database.
     * @param {baserow_territoiresCreateManyAndReturnArgs} args - Arguments to create many Baserow_territoires.
     * @example
     * // Create many Baserow_territoires
     * const baserow_territoires = await prisma.baserow_territoires.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Baserow_territoires and only return the `id`
     * const baserow_territoiresWithIdOnly = await prisma.baserow_territoires.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends baserow_territoiresCreateManyAndReturnArgs>(args?: SelectSubset<T, baserow_territoiresCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$baserow_territoiresPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Baserow_territoires.
     * @param {baserow_territoiresDeleteArgs} args - Arguments to delete one Baserow_territoires.
     * @example
     * // Delete one Baserow_territoires
     * const Baserow_territoires = await prisma.baserow_territoires.delete({
     *   where: {
     *     // ... filter to delete one Baserow_territoires
     *   }
     * })
     * 
     */
    delete<T extends baserow_territoiresDeleteArgs>(args: SelectSubset<T, baserow_territoiresDeleteArgs<ExtArgs>>): Prisma__baserow_territoiresClient<$Result.GetResult<Prisma.$baserow_territoiresPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Baserow_territoires.
     * @param {baserow_territoiresUpdateArgs} args - Arguments to update one Baserow_territoires.
     * @example
     * // Update one Baserow_territoires
     * const baserow_territoires = await prisma.baserow_territoires.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends baserow_territoiresUpdateArgs>(args: SelectSubset<T, baserow_territoiresUpdateArgs<ExtArgs>>): Prisma__baserow_territoiresClient<$Result.GetResult<Prisma.$baserow_territoiresPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Baserow_territoires.
     * @param {baserow_territoiresDeleteManyArgs} args - Arguments to filter Baserow_territoires to delete.
     * @example
     * // Delete a few Baserow_territoires
     * const { count } = await prisma.baserow_territoires.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends baserow_territoiresDeleteManyArgs>(args?: SelectSubset<T, baserow_territoiresDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Baserow_territoires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {baserow_territoiresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Baserow_territoires
     * const baserow_territoires = await prisma.baserow_territoires.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends baserow_territoiresUpdateManyArgs>(args: SelectSubset<T, baserow_territoiresUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Baserow_territoires and returns the data updated in the database.
     * @param {baserow_territoiresUpdateManyAndReturnArgs} args - Arguments to update many Baserow_territoires.
     * @example
     * // Update many Baserow_territoires
     * const baserow_territoires = await prisma.baserow_territoires.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Baserow_territoires and only return the `id`
     * const baserow_territoiresWithIdOnly = await prisma.baserow_territoires.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends baserow_territoiresUpdateManyAndReturnArgs>(args: SelectSubset<T, baserow_territoiresUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$baserow_territoiresPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Baserow_territoires.
     * @param {baserow_territoiresUpsertArgs} args - Arguments to update or create a Baserow_territoires.
     * @example
     * // Update or create a Baserow_territoires
     * const baserow_territoires = await prisma.baserow_territoires.upsert({
     *   create: {
     *     // ... data to create a Baserow_territoires
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Baserow_territoires we want to update
     *   }
     * })
     */
    upsert<T extends baserow_territoiresUpsertArgs>(args: SelectSubset<T, baserow_territoiresUpsertArgs<ExtArgs>>): Prisma__baserow_territoiresClient<$Result.GetResult<Prisma.$baserow_territoiresPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Baserow_territoires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {baserow_territoiresCountArgs} args - Arguments to filter Baserow_territoires to count.
     * @example
     * // Count the number of Baserow_territoires
     * const count = await prisma.baserow_territoires.count({
     *   where: {
     *     // ... the filter for the Baserow_territoires we want to count
     *   }
     * })
    **/
    count<T extends baserow_territoiresCountArgs>(
      args?: Subset<T, baserow_territoiresCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Baserow_territoiresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Baserow_territoires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Baserow_territoiresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Baserow_territoiresAggregateArgs>(args: Subset<T, Baserow_territoiresAggregateArgs>): Prisma.PrismaPromise<GetBaserow_territoiresAggregateType<T>>

    /**
     * Group by Baserow_territoires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {baserow_territoiresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends baserow_territoiresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: baserow_territoiresGroupByArgs['orderBy'] }
        : { orderBy?: baserow_territoiresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, baserow_territoiresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBaserow_territoiresGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the baserow_territoires model
   */
  readonly fields: baserow_territoiresFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for baserow_territoires.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__baserow_territoiresClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the baserow_territoires model
   */
  interface baserow_territoiresFieldRefs {
    readonly id: FieldRef<"baserow_territoires", 'BigInt'>
    readonly ordre: FieldRef<"baserow_territoires", 'String'>
    readonly nom_territoire: FieldRef<"baserow_territoires", 'String'>
    readonly notes_ouvertes: FieldRef<"baserow_territoires", 'String'>
    readonly typologie_territoire: FieldRef<"baserow_territoires", 'String[]'>
    readonly thematique_prioritaire: FieldRef<"baserow_territoires", 'String[]'>
    readonly be: FieldRef<"baserow_territoires", 'Boolean'>
    readonly soumis_a_pcaet: FieldRef<"baserow_territoires", 'Boolean'>
    readonly demarches_et_programmes: FieldRef<"baserow_territoires", 'String[]'>
    readonly documents_de_planification: FieldRef<"baserow_territoires", 'String[]'>
    readonly avancee_sur_le_ddv: FieldRef<"baserow_territoires", 'String[]'>
    readonly avancee_sur_la_strategie: FieldRef<"baserow_territoires", 'String[]'>
    readonly suivi_evaluation: FieldRef<"baserow_territoires", 'Boolean'>
    readonly date_validation: FieldRef<"baserow_territoires", 'String'>
    readonly date_revision_estimee: FieldRef<"baserow_territoires", 'String'>
    readonly propos: FieldRef<"baserow_territoires", 'String[]'>
    readonly attente_session_accueil: FieldRef<"baserow_territoires", 'String[]'>
    readonly role_be: FieldRef<"baserow_territoires", 'String[]'>
    readonly cdm: FieldRef<"baserow_territoires", 'String[]'>
    readonly siren: FieldRef<"baserow_territoires", 'String'>
    readonly ingested_at: FieldRef<"baserow_territoires", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * baserow_territoires findUnique
   */
  export type baserow_territoiresFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the baserow_territoires
     */
    select?: baserow_territoiresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the baserow_territoires
     */
    omit?: baserow_territoiresOmit<ExtArgs> | null
    /**
     * Filter, which baserow_territoires to fetch.
     */
    where: baserow_territoiresWhereUniqueInput
  }

  /**
   * baserow_territoires findUniqueOrThrow
   */
  export type baserow_territoiresFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the baserow_territoires
     */
    select?: baserow_territoiresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the baserow_territoires
     */
    omit?: baserow_territoiresOmit<ExtArgs> | null
    /**
     * Filter, which baserow_territoires to fetch.
     */
    where: baserow_territoiresWhereUniqueInput
  }

  /**
   * baserow_territoires findFirst
   */
  export type baserow_territoiresFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the baserow_territoires
     */
    select?: baserow_territoiresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the baserow_territoires
     */
    omit?: baserow_territoiresOmit<ExtArgs> | null
    /**
     * Filter, which baserow_territoires to fetch.
     */
    where?: baserow_territoiresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of baserow_territoires to fetch.
     */
    orderBy?: baserow_territoiresOrderByWithRelationInput | baserow_territoiresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for baserow_territoires.
     */
    cursor?: baserow_territoiresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` baserow_territoires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` baserow_territoires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of baserow_territoires.
     */
    distinct?: Baserow_territoiresScalarFieldEnum | Baserow_territoiresScalarFieldEnum[]
  }

  /**
   * baserow_territoires findFirstOrThrow
   */
  export type baserow_territoiresFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the baserow_territoires
     */
    select?: baserow_territoiresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the baserow_territoires
     */
    omit?: baserow_territoiresOmit<ExtArgs> | null
    /**
     * Filter, which baserow_territoires to fetch.
     */
    where?: baserow_territoiresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of baserow_territoires to fetch.
     */
    orderBy?: baserow_territoiresOrderByWithRelationInput | baserow_territoiresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for baserow_territoires.
     */
    cursor?: baserow_territoiresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` baserow_territoires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` baserow_territoires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of baserow_territoires.
     */
    distinct?: Baserow_territoiresScalarFieldEnum | Baserow_territoiresScalarFieldEnum[]
  }

  /**
   * baserow_territoires findMany
   */
  export type baserow_territoiresFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the baserow_territoires
     */
    select?: baserow_territoiresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the baserow_territoires
     */
    omit?: baserow_territoiresOmit<ExtArgs> | null
    /**
     * Filter, which baserow_territoires to fetch.
     */
    where?: baserow_territoiresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of baserow_territoires to fetch.
     */
    orderBy?: baserow_territoiresOrderByWithRelationInput | baserow_territoiresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing baserow_territoires.
     */
    cursor?: baserow_territoiresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` baserow_territoires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` baserow_territoires.
     */
    skip?: number
    distinct?: Baserow_territoiresScalarFieldEnum | Baserow_territoiresScalarFieldEnum[]
  }

  /**
   * baserow_territoires create
   */
  export type baserow_territoiresCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the baserow_territoires
     */
    select?: baserow_territoiresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the baserow_territoires
     */
    omit?: baserow_territoiresOmit<ExtArgs> | null
    /**
     * The data needed to create a baserow_territoires.
     */
    data?: XOR<baserow_territoiresCreateInput, baserow_territoiresUncheckedCreateInput>
  }

  /**
   * baserow_territoires createMany
   */
  export type baserow_territoiresCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many baserow_territoires.
     */
    data: baserow_territoiresCreateManyInput | baserow_territoiresCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * baserow_territoires createManyAndReturn
   */
  export type baserow_territoiresCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the baserow_territoires
     */
    select?: baserow_territoiresSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the baserow_territoires
     */
    omit?: baserow_territoiresOmit<ExtArgs> | null
    /**
     * The data used to create many baserow_territoires.
     */
    data: baserow_territoiresCreateManyInput | baserow_territoiresCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * baserow_territoires update
   */
  export type baserow_territoiresUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the baserow_territoires
     */
    select?: baserow_territoiresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the baserow_territoires
     */
    omit?: baserow_territoiresOmit<ExtArgs> | null
    /**
     * The data needed to update a baserow_territoires.
     */
    data: XOR<baserow_territoiresUpdateInput, baserow_territoiresUncheckedUpdateInput>
    /**
     * Choose, which baserow_territoires to update.
     */
    where: baserow_territoiresWhereUniqueInput
  }

  /**
   * baserow_territoires updateMany
   */
  export type baserow_territoiresUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update baserow_territoires.
     */
    data: XOR<baserow_territoiresUpdateManyMutationInput, baserow_territoiresUncheckedUpdateManyInput>
    /**
     * Filter which baserow_territoires to update
     */
    where?: baserow_territoiresWhereInput
    /**
     * Limit how many baserow_territoires to update.
     */
    limit?: number
  }

  /**
   * baserow_territoires updateManyAndReturn
   */
  export type baserow_territoiresUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the baserow_territoires
     */
    select?: baserow_territoiresSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the baserow_territoires
     */
    omit?: baserow_territoiresOmit<ExtArgs> | null
    /**
     * The data used to update baserow_territoires.
     */
    data: XOR<baserow_territoiresUpdateManyMutationInput, baserow_territoiresUncheckedUpdateManyInput>
    /**
     * Filter which baserow_territoires to update
     */
    where?: baserow_territoiresWhereInput
    /**
     * Limit how many baserow_territoires to update.
     */
    limit?: number
  }

  /**
   * baserow_territoires upsert
   */
  export type baserow_territoiresUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the baserow_territoires
     */
    select?: baserow_territoiresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the baserow_territoires
     */
    omit?: baserow_territoiresOmit<ExtArgs> | null
    /**
     * The filter to search for the baserow_territoires to update in case it exists.
     */
    where: baserow_territoiresWhereUniqueInput
    /**
     * In case the baserow_territoires found by the `where` argument doesn't exist, create a new baserow_territoires with this data.
     */
    create: XOR<baserow_territoiresCreateInput, baserow_territoiresUncheckedCreateInput>
    /**
     * In case the baserow_territoires was found with the provided `where` argument, update it with this data.
     */
    update: XOR<baserow_territoiresUpdateInput, baserow_territoiresUncheckedUpdateInput>
  }

  /**
   * baserow_territoires delete
   */
  export type baserow_territoiresDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the baserow_territoires
     */
    select?: baserow_territoiresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the baserow_territoires
     */
    omit?: baserow_territoiresOmit<ExtArgs> | null
    /**
     * Filter which baserow_territoires to delete.
     */
    where: baserow_territoiresWhereUniqueInput
  }

  /**
   * baserow_territoires deleteMany
   */
  export type baserow_territoiresDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which baserow_territoires to delete
     */
    where?: baserow_territoiresWhereInput
    /**
     * Limit how many baserow_territoires to delete.
     */
    limit?: number
  }

  /**
   * baserow_territoires without action
   */
  export type baserow_territoiresDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the baserow_territoires
     */
    select?: baserow_territoiresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the baserow_territoires
     */
    omit?: baserow_territoiresOmit<ExtArgs> | null
  }


  /**
   * Model boutons_export_raw
   */

  export type AggregateBoutons_export_raw = {
    _count: Boutons_export_rawCountAggregateOutputType | null
    _avg: Boutons_export_rawAvgAggregateOutputType | null
    _sum: Boutons_export_rawSumAggregateOutputType | null
    _min: Boutons_export_rawMinAggregateOutputType | null
    _max: Boutons_export_rawMaxAggregateOutputType | null
  }

  export type Boutons_export_rawAvgAggregateOutputType = {
    id: number | null
  }

  export type Boutons_export_rawSumAggregateOutputType = {
    id: bigint | null
  }

  export type Boutons_export_rawMinAggregateOutputType = {
    id: bigint | null
    event: string | null
    event_timestamp: Date | null
    session_id: string | null
    person_id: string | null
    code_geographique: string | null
    libelle_geographique: string | null
    thematique: string | null
    ingested_at: Date | null
  }

  export type Boutons_export_rawMaxAggregateOutputType = {
    id: bigint | null
    event: string | null
    event_timestamp: Date | null
    session_id: string | null
    person_id: string | null
    code_geographique: string | null
    libelle_geographique: string | null
    thematique: string | null
    ingested_at: Date | null
  }

  export type Boutons_export_rawCountAggregateOutputType = {
    id: number
    event: number
    event_timestamp: number
    session_id: number
    person_id: number
    code_geographique: number
    libelle_geographique: number
    thematique: number
    ingested_at: number
    _all: number
  }


  export type Boutons_export_rawAvgAggregateInputType = {
    id?: true
  }

  export type Boutons_export_rawSumAggregateInputType = {
    id?: true
  }

  export type Boutons_export_rawMinAggregateInputType = {
    id?: true
    event?: true
    event_timestamp?: true
    session_id?: true
    person_id?: true
    code_geographique?: true
    libelle_geographique?: true
    thematique?: true
    ingested_at?: true
  }

  export type Boutons_export_rawMaxAggregateInputType = {
    id?: true
    event?: true
    event_timestamp?: true
    session_id?: true
    person_id?: true
    code_geographique?: true
    libelle_geographique?: true
    thematique?: true
    ingested_at?: true
  }

  export type Boutons_export_rawCountAggregateInputType = {
    id?: true
    event?: true
    event_timestamp?: true
    session_id?: true
    person_id?: true
    code_geographique?: true
    libelle_geographique?: true
    thematique?: true
    ingested_at?: true
    _all?: true
  }

  export type Boutons_export_rawAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which boutons_export_raw to aggregate.
     */
    where?: boutons_export_rawWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of boutons_export_raws to fetch.
     */
    orderBy?: boutons_export_rawOrderByWithRelationInput | boutons_export_rawOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: boutons_export_rawWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` boutons_export_raws from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` boutons_export_raws.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned boutons_export_raws
    **/
    _count?: true | Boutons_export_rawCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Boutons_export_rawAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Boutons_export_rawSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Boutons_export_rawMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Boutons_export_rawMaxAggregateInputType
  }

  export type GetBoutons_export_rawAggregateType<T extends Boutons_export_rawAggregateArgs> = {
        [P in keyof T & keyof AggregateBoutons_export_raw]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBoutons_export_raw[P]>
      : GetScalarType<T[P], AggregateBoutons_export_raw[P]>
  }




  export type boutons_export_rawGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: boutons_export_rawWhereInput
    orderBy?: boutons_export_rawOrderByWithAggregationInput | boutons_export_rawOrderByWithAggregationInput[]
    by: Boutons_export_rawScalarFieldEnum[] | Boutons_export_rawScalarFieldEnum
    having?: boutons_export_rawScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Boutons_export_rawCountAggregateInputType | true
    _avg?: Boutons_export_rawAvgAggregateInputType
    _sum?: Boutons_export_rawSumAggregateInputType
    _min?: Boutons_export_rawMinAggregateInputType
    _max?: Boutons_export_rawMaxAggregateInputType
  }

  export type Boutons_export_rawGroupByOutputType = {
    id: bigint
    event: string
    event_timestamp: Date
    session_id: string | null
    person_id: string | null
    code_geographique: string | null
    libelle_geographique: string | null
    thematique: string | null
    ingested_at: Date
    _count: Boutons_export_rawCountAggregateOutputType | null
    _avg: Boutons_export_rawAvgAggregateOutputType | null
    _sum: Boutons_export_rawSumAggregateOutputType | null
    _min: Boutons_export_rawMinAggregateOutputType | null
    _max: Boutons_export_rawMaxAggregateOutputType | null
  }

  type GetBoutons_export_rawGroupByPayload<T extends boutons_export_rawGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Boutons_export_rawGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Boutons_export_rawGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Boutons_export_rawGroupByOutputType[P]>
            : GetScalarType<T[P], Boutons_export_rawGroupByOutputType[P]>
        }
      >
    >


  export type boutons_export_rawSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    event?: boolean
    event_timestamp?: boolean
    session_id?: boolean
    person_id?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    thematique?: boolean
    ingested_at?: boolean
  }, ExtArgs["result"]["boutons_export_raw"]>

  export type boutons_export_rawSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    event?: boolean
    event_timestamp?: boolean
    session_id?: boolean
    person_id?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    thematique?: boolean
    ingested_at?: boolean
  }, ExtArgs["result"]["boutons_export_raw"]>

  export type boutons_export_rawSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    event?: boolean
    event_timestamp?: boolean
    session_id?: boolean
    person_id?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    thematique?: boolean
    ingested_at?: boolean
  }, ExtArgs["result"]["boutons_export_raw"]>

  export type boutons_export_rawSelectScalar = {
    id?: boolean
    event?: boolean
    event_timestamp?: boolean
    session_id?: boolean
    person_id?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    thematique?: boolean
    ingested_at?: boolean
  }

  export type boutons_export_rawOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "event" | "event_timestamp" | "session_id" | "person_id" | "code_geographique" | "libelle_geographique" | "thematique" | "ingested_at", ExtArgs["result"]["boutons_export_raw"]>

  export type $boutons_export_rawPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "boutons_export_raw"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      event: string
      event_timestamp: Date
      session_id: string | null
      person_id: string | null
      code_geographique: string | null
      libelle_geographique: string | null
      thematique: string | null
      ingested_at: Date
    }, ExtArgs["result"]["boutons_export_raw"]>
    composites: {}
  }

  type boutons_export_rawGetPayload<S extends boolean | null | undefined | boutons_export_rawDefaultArgs> = $Result.GetResult<Prisma.$boutons_export_rawPayload, S>

  type boutons_export_rawCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<boutons_export_rawFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Boutons_export_rawCountAggregateInputType | true
    }

  export interface boutons_export_rawDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['boutons_export_raw'], meta: { name: 'boutons_export_raw' } }
    /**
     * Find zero or one Boutons_export_raw that matches the filter.
     * @param {boutons_export_rawFindUniqueArgs} args - Arguments to find a Boutons_export_raw
     * @example
     * // Get one Boutons_export_raw
     * const boutons_export_raw = await prisma.boutons_export_raw.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends boutons_export_rawFindUniqueArgs>(args: SelectSubset<T, boutons_export_rawFindUniqueArgs<ExtArgs>>): Prisma__boutons_export_rawClient<$Result.GetResult<Prisma.$boutons_export_rawPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Boutons_export_raw that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {boutons_export_rawFindUniqueOrThrowArgs} args - Arguments to find a Boutons_export_raw
     * @example
     * // Get one Boutons_export_raw
     * const boutons_export_raw = await prisma.boutons_export_raw.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends boutons_export_rawFindUniqueOrThrowArgs>(args: SelectSubset<T, boutons_export_rawFindUniqueOrThrowArgs<ExtArgs>>): Prisma__boutons_export_rawClient<$Result.GetResult<Prisma.$boutons_export_rawPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Boutons_export_raw that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {boutons_export_rawFindFirstArgs} args - Arguments to find a Boutons_export_raw
     * @example
     * // Get one Boutons_export_raw
     * const boutons_export_raw = await prisma.boutons_export_raw.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends boutons_export_rawFindFirstArgs>(args?: SelectSubset<T, boutons_export_rawFindFirstArgs<ExtArgs>>): Prisma__boutons_export_rawClient<$Result.GetResult<Prisma.$boutons_export_rawPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Boutons_export_raw that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {boutons_export_rawFindFirstOrThrowArgs} args - Arguments to find a Boutons_export_raw
     * @example
     * // Get one Boutons_export_raw
     * const boutons_export_raw = await prisma.boutons_export_raw.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends boutons_export_rawFindFirstOrThrowArgs>(args?: SelectSubset<T, boutons_export_rawFindFirstOrThrowArgs<ExtArgs>>): Prisma__boutons_export_rawClient<$Result.GetResult<Prisma.$boutons_export_rawPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Boutons_export_raws that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {boutons_export_rawFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Boutons_export_raws
     * const boutons_export_raws = await prisma.boutons_export_raw.findMany()
     * 
     * // Get first 10 Boutons_export_raws
     * const boutons_export_raws = await prisma.boutons_export_raw.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const boutons_export_rawWithIdOnly = await prisma.boutons_export_raw.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends boutons_export_rawFindManyArgs>(args?: SelectSubset<T, boutons_export_rawFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$boutons_export_rawPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Boutons_export_raw.
     * @param {boutons_export_rawCreateArgs} args - Arguments to create a Boutons_export_raw.
     * @example
     * // Create one Boutons_export_raw
     * const Boutons_export_raw = await prisma.boutons_export_raw.create({
     *   data: {
     *     // ... data to create a Boutons_export_raw
     *   }
     * })
     * 
     */
    create<T extends boutons_export_rawCreateArgs>(args: SelectSubset<T, boutons_export_rawCreateArgs<ExtArgs>>): Prisma__boutons_export_rawClient<$Result.GetResult<Prisma.$boutons_export_rawPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Boutons_export_raws.
     * @param {boutons_export_rawCreateManyArgs} args - Arguments to create many Boutons_export_raws.
     * @example
     * // Create many Boutons_export_raws
     * const boutons_export_raw = await prisma.boutons_export_raw.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends boutons_export_rawCreateManyArgs>(args?: SelectSubset<T, boutons_export_rawCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Boutons_export_raws and returns the data saved in the database.
     * @param {boutons_export_rawCreateManyAndReturnArgs} args - Arguments to create many Boutons_export_raws.
     * @example
     * // Create many Boutons_export_raws
     * const boutons_export_raw = await prisma.boutons_export_raw.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Boutons_export_raws and only return the `id`
     * const boutons_export_rawWithIdOnly = await prisma.boutons_export_raw.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends boutons_export_rawCreateManyAndReturnArgs>(args?: SelectSubset<T, boutons_export_rawCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$boutons_export_rawPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Boutons_export_raw.
     * @param {boutons_export_rawDeleteArgs} args - Arguments to delete one Boutons_export_raw.
     * @example
     * // Delete one Boutons_export_raw
     * const Boutons_export_raw = await prisma.boutons_export_raw.delete({
     *   where: {
     *     // ... filter to delete one Boutons_export_raw
     *   }
     * })
     * 
     */
    delete<T extends boutons_export_rawDeleteArgs>(args: SelectSubset<T, boutons_export_rawDeleteArgs<ExtArgs>>): Prisma__boutons_export_rawClient<$Result.GetResult<Prisma.$boutons_export_rawPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Boutons_export_raw.
     * @param {boutons_export_rawUpdateArgs} args - Arguments to update one Boutons_export_raw.
     * @example
     * // Update one Boutons_export_raw
     * const boutons_export_raw = await prisma.boutons_export_raw.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends boutons_export_rawUpdateArgs>(args: SelectSubset<T, boutons_export_rawUpdateArgs<ExtArgs>>): Prisma__boutons_export_rawClient<$Result.GetResult<Prisma.$boutons_export_rawPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Boutons_export_raws.
     * @param {boutons_export_rawDeleteManyArgs} args - Arguments to filter Boutons_export_raws to delete.
     * @example
     * // Delete a few Boutons_export_raws
     * const { count } = await prisma.boutons_export_raw.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends boutons_export_rawDeleteManyArgs>(args?: SelectSubset<T, boutons_export_rawDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Boutons_export_raws.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {boutons_export_rawUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Boutons_export_raws
     * const boutons_export_raw = await prisma.boutons_export_raw.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends boutons_export_rawUpdateManyArgs>(args: SelectSubset<T, boutons_export_rawUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Boutons_export_raws and returns the data updated in the database.
     * @param {boutons_export_rawUpdateManyAndReturnArgs} args - Arguments to update many Boutons_export_raws.
     * @example
     * // Update many Boutons_export_raws
     * const boutons_export_raw = await prisma.boutons_export_raw.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Boutons_export_raws and only return the `id`
     * const boutons_export_rawWithIdOnly = await prisma.boutons_export_raw.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends boutons_export_rawUpdateManyAndReturnArgs>(args: SelectSubset<T, boutons_export_rawUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$boutons_export_rawPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Boutons_export_raw.
     * @param {boutons_export_rawUpsertArgs} args - Arguments to update or create a Boutons_export_raw.
     * @example
     * // Update or create a Boutons_export_raw
     * const boutons_export_raw = await prisma.boutons_export_raw.upsert({
     *   create: {
     *     // ... data to create a Boutons_export_raw
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Boutons_export_raw we want to update
     *   }
     * })
     */
    upsert<T extends boutons_export_rawUpsertArgs>(args: SelectSubset<T, boutons_export_rawUpsertArgs<ExtArgs>>): Prisma__boutons_export_rawClient<$Result.GetResult<Prisma.$boutons_export_rawPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Boutons_export_raws.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {boutons_export_rawCountArgs} args - Arguments to filter Boutons_export_raws to count.
     * @example
     * // Count the number of Boutons_export_raws
     * const count = await prisma.boutons_export_raw.count({
     *   where: {
     *     // ... the filter for the Boutons_export_raws we want to count
     *   }
     * })
    **/
    count<T extends boutons_export_rawCountArgs>(
      args?: Subset<T, boutons_export_rawCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Boutons_export_rawCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Boutons_export_raw.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Boutons_export_rawAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Boutons_export_rawAggregateArgs>(args: Subset<T, Boutons_export_rawAggregateArgs>): Prisma.PrismaPromise<GetBoutons_export_rawAggregateType<T>>

    /**
     * Group by Boutons_export_raw.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {boutons_export_rawGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends boutons_export_rawGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: boutons_export_rawGroupByArgs['orderBy'] }
        : { orderBy?: boutons_export_rawGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, boutons_export_rawGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBoutons_export_rawGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the boutons_export_raw model
   */
  readonly fields: boutons_export_rawFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for boutons_export_raw.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__boutons_export_rawClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the boutons_export_raw model
   */
  interface boutons_export_rawFieldRefs {
    readonly id: FieldRef<"boutons_export_raw", 'BigInt'>
    readonly event: FieldRef<"boutons_export_raw", 'String'>
    readonly event_timestamp: FieldRef<"boutons_export_raw", 'DateTime'>
    readonly session_id: FieldRef<"boutons_export_raw", 'String'>
    readonly person_id: FieldRef<"boutons_export_raw", 'String'>
    readonly code_geographique: FieldRef<"boutons_export_raw", 'String'>
    readonly libelle_geographique: FieldRef<"boutons_export_raw", 'String'>
    readonly thematique: FieldRef<"boutons_export_raw", 'String'>
    readonly ingested_at: FieldRef<"boutons_export_raw", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * boutons_export_raw findUnique
   */
  export type boutons_export_rawFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boutons_export_raw
     */
    select?: boutons_export_rawSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boutons_export_raw
     */
    omit?: boutons_export_rawOmit<ExtArgs> | null
    /**
     * Filter, which boutons_export_raw to fetch.
     */
    where: boutons_export_rawWhereUniqueInput
  }

  /**
   * boutons_export_raw findUniqueOrThrow
   */
  export type boutons_export_rawFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boutons_export_raw
     */
    select?: boutons_export_rawSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boutons_export_raw
     */
    omit?: boutons_export_rawOmit<ExtArgs> | null
    /**
     * Filter, which boutons_export_raw to fetch.
     */
    where: boutons_export_rawWhereUniqueInput
  }

  /**
   * boutons_export_raw findFirst
   */
  export type boutons_export_rawFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boutons_export_raw
     */
    select?: boutons_export_rawSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boutons_export_raw
     */
    omit?: boutons_export_rawOmit<ExtArgs> | null
    /**
     * Filter, which boutons_export_raw to fetch.
     */
    where?: boutons_export_rawWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of boutons_export_raws to fetch.
     */
    orderBy?: boutons_export_rawOrderByWithRelationInput | boutons_export_rawOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for boutons_export_raws.
     */
    cursor?: boutons_export_rawWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` boutons_export_raws from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` boutons_export_raws.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of boutons_export_raws.
     */
    distinct?: Boutons_export_rawScalarFieldEnum | Boutons_export_rawScalarFieldEnum[]
  }

  /**
   * boutons_export_raw findFirstOrThrow
   */
  export type boutons_export_rawFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boutons_export_raw
     */
    select?: boutons_export_rawSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boutons_export_raw
     */
    omit?: boutons_export_rawOmit<ExtArgs> | null
    /**
     * Filter, which boutons_export_raw to fetch.
     */
    where?: boutons_export_rawWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of boutons_export_raws to fetch.
     */
    orderBy?: boutons_export_rawOrderByWithRelationInput | boutons_export_rawOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for boutons_export_raws.
     */
    cursor?: boutons_export_rawWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` boutons_export_raws from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` boutons_export_raws.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of boutons_export_raws.
     */
    distinct?: Boutons_export_rawScalarFieldEnum | Boutons_export_rawScalarFieldEnum[]
  }

  /**
   * boutons_export_raw findMany
   */
  export type boutons_export_rawFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boutons_export_raw
     */
    select?: boutons_export_rawSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boutons_export_raw
     */
    omit?: boutons_export_rawOmit<ExtArgs> | null
    /**
     * Filter, which boutons_export_raws to fetch.
     */
    where?: boutons_export_rawWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of boutons_export_raws to fetch.
     */
    orderBy?: boutons_export_rawOrderByWithRelationInput | boutons_export_rawOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing boutons_export_raws.
     */
    cursor?: boutons_export_rawWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` boutons_export_raws from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` boutons_export_raws.
     */
    skip?: number
    distinct?: Boutons_export_rawScalarFieldEnum | Boutons_export_rawScalarFieldEnum[]
  }

  /**
   * boutons_export_raw create
   */
  export type boutons_export_rawCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boutons_export_raw
     */
    select?: boutons_export_rawSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boutons_export_raw
     */
    omit?: boutons_export_rawOmit<ExtArgs> | null
    /**
     * The data needed to create a boutons_export_raw.
     */
    data: XOR<boutons_export_rawCreateInput, boutons_export_rawUncheckedCreateInput>
  }

  /**
   * boutons_export_raw createMany
   */
  export type boutons_export_rawCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many boutons_export_raws.
     */
    data: boutons_export_rawCreateManyInput | boutons_export_rawCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * boutons_export_raw createManyAndReturn
   */
  export type boutons_export_rawCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boutons_export_raw
     */
    select?: boutons_export_rawSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the boutons_export_raw
     */
    omit?: boutons_export_rawOmit<ExtArgs> | null
    /**
     * The data used to create many boutons_export_raws.
     */
    data: boutons_export_rawCreateManyInput | boutons_export_rawCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * boutons_export_raw update
   */
  export type boutons_export_rawUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boutons_export_raw
     */
    select?: boutons_export_rawSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boutons_export_raw
     */
    omit?: boutons_export_rawOmit<ExtArgs> | null
    /**
     * The data needed to update a boutons_export_raw.
     */
    data: XOR<boutons_export_rawUpdateInput, boutons_export_rawUncheckedUpdateInput>
    /**
     * Choose, which boutons_export_raw to update.
     */
    where: boutons_export_rawWhereUniqueInput
  }

  /**
   * boutons_export_raw updateMany
   */
  export type boutons_export_rawUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update boutons_export_raws.
     */
    data: XOR<boutons_export_rawUpdateManyMutationInput, boutons_export_rawUncheckedUpdateManyInput>
    /**
     * Filter which boutons_export_raws to update
     */
    where?: boutons_export_rawWhereInput
    /**
     * Limit how many boutons_export_raws to update.
     */
    limit?: number
  }

  /**
   * boutons_export_raw updateManyAndReturn
   */
  export type boutons_export_rawUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boutons_export_raw
     */
    select?: boutons_export_rawSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the boutons_export_raw
     */
    omit?: boutons_export_rawOmit<ExtArgs> | null
    /**
     * The data used to update boutons_export_raws.
     */
    data: XOR<boutons_export_rawUpdateManyMutationInput, boutons_export_rawUncheckedUpdateManyInput>
    /**
     * Filter which boutons_export_raws to update
     */
    where?: boutons_export_rawWhereInput
    /**
     * Limit how many boutons_export_raws to update.
     */
    limit?: number
  }

  /**
   * boutons_export_raw upsert
   */
  export type boutons_export_rawUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boutons_export_raw
     */
    select?: boutons_export_rawSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boutons_export_raw
     */
    omit?: boutons_export_rawOmit<ExtArgs> | null
    /**
     * The filter to search for the boutons_export_raw to update in case it exists.
     */
    where: boutons_export_rawWhereUniqueInput
    /**
     * In case the boutons_export_raw found by the `where` argument doesn't exist, create a new boutons_export_raw with this data.
     */
    create: XOR<boutons_export_rawCreateInput, boutons_export_rawUncheckedCreateInput>
    /**
     * In case the boutons_export_raw was found with the provided `where` argument, update it with this data.
     */
    update: XOR<boutons_export_rawUpdateInput, boutons_export_rawUncheckedUpdateInput>
  }

  /**
   * boutons_export_raw delete
   */
  export type boutons_export_rawDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boutons_export_raw
     */
    select?: boutons_export_rawSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boutons_export_raw
     */
    omit?: boutons_export_rawOmit<ExtArgs> | null
    /**
     * Filter which boutons_export_raw to delete.
     */
    where: boutons_export_rawWhereUniqueInput
  }

  /**
   * boutons_export_raw deleteMany
   */
  export type boutons_export_rawDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which boutons_export_raws to delete
     */
    where?: boutons_export_rawWhereInput
    /**
     * Limit how many boutons_export_raws to delete.
     */
    limit?: number
  }

  /**
   * boutons_export_raw without action
   */
  export type boutons_export_rawDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boutons_export_raw
     */
    select?: boutons_export_rawSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boutons_export_raw
     */
    omit?: boutons_export_rawOmit<ExtArgs> | null
  }


  /**
   * Model boutons_homepage
   */

  export type AggregateBoutons_homepage = {
    _count: Boutons_homepageCountAggregateOutputType | null
    _avg: Boutons_homepageAvgAggregateOutputType | null
    _sum: Boutons_homepageSumAggregateOutputType | null
    _min: Boutons_homepageMinAggregateOutputType | null
    _max: Boutons_homepageMaxAggregateOutputType | null
  }

  export type Boutons_homepageAvgAggregateOutputType = {
    id: number | null
  }

  export type Boutons_homepageSumAggregateOutputType = {
    id: bigint | null
  }

  export type Boutons_homepageMinAggregateOutputType = {
    id: bigint | null
    event: string | null
    event_timestamp: Date | null
    distinct_id: string | null
    session_id: string | null
    person_id: string | null
    ingested_at: Date | null
  }

  export type Boutons_homepageMaxAggregateOutputType = {
    id: bigint | null
    event: string | null
    event_timestamp: Date | null
    distinct_id: string | null
    session_id: string | null
    person_id: string | null
    ingested_at: Date | null
  }

  export type Boutons_homepageCountAggregateOutputType = {
    id: number
    event: number
    event_timestamp: number
    properties: number
    distinct_id: number
    session_id: number
    person_id: number
    ingested_at: number
    _all: number
  }


  export type Boutons_homepageAvgAggregateInputType = {
    id?: true
  }

  export type Boutons_homepageSumAggregateInputType = {
    id?: true
  }

  export type Boutons_homepageMinAggregateInputType = {
    id?: true
    event?: true
    event_timestamp?: true
    distinct_id?: true
    session_id?: true
    person_id?: true
    ingested_at?: true
  }

  export type Boutons_homepageMaxAggregateInputType = {
    id?: true
    event?: true
    event_timestamp?: true
    distinct_id?: true
    session_id?: true
    person_id?: true
    ingested_at?: true
  }

  export type Boutons_homepageCountAggregateInputType = {
    id?: true
    event?: true
    event_timestamp?: true
    properties?: true
    distinct_id?: true
    session_id?: true
    person_id?: true
    ingested_at?: true
    _all?: true
  }

  export type Boutons_homepageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which boutons_homepage to aggregate.
     */
    where?: boutons_homepageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of boutons_homepages to fetch.
     */
    orderBy?: boutons_homepageOrderByWithRelationInput | boutons_homepageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: boutons_homepageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` boutons_homepages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` boutons_homepages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned boutons_homepages
    **/
    _count?: true | Boutons_homepageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Boutons_homepageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Boutons_homepageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Boutons_homepageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Boutons_homepageMaxAggregateInputType
  }

  export type GetBoutons_homepageAggregateType<T extends Boutons_homepageAggregateArgs> = {
        [P in keyof T & keyof AggregateBoutons_homepage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBoutons_homepage[P]>
      : GetScalarType<T[P], AggregateBoutons_homepage[P]>
  }




  export type boutons_homepageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: boutons_homepageWhereInput
    orderBy?: boutons_homepageOrderByWithAggregationInput | boutons_homepageOrderByWithAggregationInput[]
    by: Boutons_homepageScalarFieldEnum[] | Boutons_homepageScalarFieldEnum
    having?: boutons_homepageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Boutons_homepageCountAggregateInputType | true
    _avg?: Boutons_homepageAvgAggregateInputType
    _sum?: Boutons_homepageSumAggregateInputType
    _min?: Boutons_homepageMinAggregateInputType
    _max?: Boutons_homepageMaxAggregateInputType
  }

  export type Boutons_homepageGroupByOutputType = {
    id: bigint
    event: string | null
    event_timestamp: Date
    properties: JsonValue | null
    distinct_id: string | null
    session_id: string | null
    person_id: string | null
    ingested_at: Date
    _count: Boutons_homepageCountAggregateOutputType | null
    _avg: Boutons_homepageAvgAggregateOutputType | null
    _sum: Boutons_homepageSumAggregateOutputType | null
    _min: Boutons_homepageMinAggregateOutputType | null
    _max: Boutons_homepageMaxAggregateOutputType | null
  }

  type GetBoutons_homepageGroupByPayload<T extends boutons_homepageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Boutons_homepageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Boutons_homepageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Boutons_homepageGroupByOutputType[P]>
            : GetScalarType<T[P], Boutons_homepageGroupByOutputType[P]>
        }
      >
    >


  export type boutons_homepageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    event?: boolean
    event_timestamp?: boolean
    properties?: boolean
    distinct_id?: boolean
    session_id?: boolean
    person_id?: boolean
    ingested_at?: boolean
  }, ExtArgs["result"]["boutons_homepage"]>

  export type boutons_homepageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    event?: boolean
    event_timestamp?: boolean
    properties?: boolean
    distinct_id?: boolean
    session_id?: boolean
    person_id?: boolean
    ingested_at?: boolean
  }, ExtArgs["result"]["boutons_homepage"]>

  export type boutons_homepageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    event?: boolean
    event_timestamp?: boolean
    properties?: boolean
    distinct_id?: boolean
    session_id?: boolean
    person_id?: boolean
    ingested_at?: boolean
  }, ExtArgs["result"]["boutons_homepage"]>

  export type boutons_homepageSelectScalar = {
    id?: boolean
    event?: boolean
    event_timestamp?: boolean
    properties?: boolean
    distinct_id?: boolean
    session_id?: boolean
    person_id?: boolean
    ingested_at?: boolean
  }

  export type boutons_homepageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "event" | "event_timestamp" | "properties" | "distinct_id" | "session_id" | "person_id" | "ingested_at", ExtArgs["result"]["boutons_homepage"]>

  export type $boutons_homepagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "boutons_homepage"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      event: string | null
      event_timestamp: Date
      properties: Prisma.JsonValue | null
      distinct_id: string | null
      session_id: string | null
      person_id: string | null
      ingested_at: Date
    }, ExtArgs["result"]["boutons_homepage"]>
    composites: {}
  }

  type boutons_homepageGetPayload<S extends boolean | null | undefined | boutons_homepageDefaultArgs> = $Result.GetResult<Prisma.$boutons_homepagePayload, S>

  type boutons_homepageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<boutons_homepageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Boutons_homepageCountAggregateInputType | true
    }

  export interface boutons_homepageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['boutons_homepage'], meta: { name: 'boutons_homepage' } }
    /**
     * Find zero or one Boutons_homepage that matches the filter.
     * @param {boutons_homepageFindUniqueArgs} args - Arguments to find a Boutons_homepage
     * @example
     * // Get one Boutons_homepage
     * const boutons_homepage = await prisma.boutons_homepage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends boutons_homepageFindUniqueArgs>(args: SelectSubset<T, boutons_homepageFindUniqueArgs<ExtArgs>>): Prisma__boutons_homepageClient<$Result.GetResult<Prisma.$boutons_homepagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Boutons_homepage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {boutons_homepageFindUniqueOrThrowArgs} args - Arguments to find a Boutons_homepage
     * @example
     * // Get one Boutons_homepage
     * const boutons_homepage = await prisma.boutons_homepage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends boutons_homepageFindUniqueOrThrowArgs>(args: SelectSubset<T, boutons_homepageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__boutons_homepageClient<$Result.GetResult<Prisma.$boutons_homepagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Boutons_homepage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {boutons_homepageFindFirstArgs} args - Arguments to find a Boutons_homepage
     * @example
     * // Get one Boutons_homepage
     * const boutons_homepage = await prisma.boutons_homepage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends boutons_homepageFindFirstArgs>(args?: SelectSubset<T, boutons_homepageFindFirstArgs<ExtArgs>>): Prisma__boutons_homepageClient<$Result.GetResult<Prisma.$boutons_homepagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Boutons_homepage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {boutons_homepageFindFirstOrThrowArgs} args - Arguments to find a Boutons_homepage
     * @example
     * // Get one Boutons_homepage
     * const boutons_homepage = await prisma.boutons_homepage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends boutons_homepageFindFirstOrThrowArgs>(args?: SelectSubset<T, boutons_homepageFindFirstOrThrowArgs<ExtArgs>>): Prisma__boutons_homepageClient<$Result.GetResult<Prisma.$boutons_homepagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Boutons_homepages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {boutons_homepageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Boutons_homepages
     * const boutons_homepages = await prisma.boutons_homepage.findMany()
     * 
     * // Get first 10 Boutons_homepages
     * const boutons_homepages = await prisma.boutons_homepage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const boutons_homepageWithIdOnly = await prisma.boutons_homepage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends boutons_homepageFindManyArgs>(args?: SelectSubset<T, boutons_homepageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$boutons_homepagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Boutons_homepage.
     * @param {boutons_homepageCreateArgs} args - Arguments to create a Boutons_homepage.
     * @example
     * // Create one Boutons_homepage
     * const Boutons_homepage = await prisma.boutons_homepage.create({
     *   data: {
     *     // ... data to create a Boutons_homepage
     *   }
     * })
     * 
     */
    create<T extends boutons_homepageCreateArgs>(args: SelectSubset<T, boutons_homepageCreateArgs<ExtArgs>>): Prisma__boutons_homepageClient<$Result.GetResult<Prisma.$boutons_homepagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Boutons_homepages.
     * @param {boutons_homepageCreateManyArgs} args - Arguments to create many Boutons_homepages.
     * @example
     * // Create many Boutons_homepages
     * const boutons_homepage = await prisma.boutons_homepage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends boutons_homepageCreateManyArgs>(args?: SelectSubset<T, boutons_homepageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Boutons_homepages and returns the data saved in the database.
     * @param {boutons_homepageCreateManyAndReturnArgs} args - Arguments to create many Boutons_homepages.
     * @example
     * // Create many Boutons_homepages
     * const boutons_homepage = await prisma.boutons_homepage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Boutons_homepages and only return the `id`
     * const boutons_homepageWithIdOnly = await prisma.boutons_homepage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends boutons_homepageCreateManyAndReturnArgs>(args?: SelectSubset<T, boutons_homepageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$boutons_homepagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Boutons_homepage.
     * @param {boutons_homepageDeleteArgs} args - Arguments to delete one Boutons_homepage.
     * @example
     * // Delete one Boutons_homepage
     * const Boutons_homepage = await prisma.boutons_homepage.delete({
     *   where: {
     *     // ... filter to delete one Boutons_homepage
     *   }
     * })
     * 
     */
    delete<T extends boutons_homepageDeleteArgs>(args: SelectSubset<T, boutons_homepageDeleteArgs<ExtArgs>>): Prisma__boutons_homepageClient<$Result.GetResult<Prisma.$boutons_homepagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Boutons_homepage.
     * @param {boutons_homepageUpdateArgs} args - Arguments to update one Boutons_homepage.
     * @example
     * // Update one Boutons_homepage
     * const boutons_homepage = await prisma.boutons_homepage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends boutons_homepageUpdateArgs>(args: SelectSubset<T, boutons_homepageUpdateArgs<ExtArgs>>): Prisma__boutons_homepageClient<$Result.GetResult<Prisma.$boutons_homepagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Boutons_homepages.
     * @param {boutons_homepageDeleteManyArgs} args - Arguments to filter Boutons_homepages to delete.
     * @example
     * // Delete a few Boutons_homepages
     * const { count } = await prisma.boutons_homepage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends boutons_homepageDeleteManyArgs>(args?: SelectSubset<T, boutons_homepageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Boutons_homepages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {boutons_homepageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Boutons_homepages
     * const boutons_homepage = await prisma.boutons_homepage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends boutons_homepageUpdateManyArgs>(args: SelectSubset<T, boutons_homepageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Boutons_homepages and returns the data updated in the database.
     * @param {boutons_homepageUpdateManyAndReturnArgs} args - Arguments to update many Boutons_homepages.
     * @example
     * // Update many Boutons_homepages
     * const boutons_homepage = await prisma.boutons_homepage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Boutons_homepages and only return the `id`
     * const boutons_homepageWithIdOnly = await prisma.boutons_homepage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends boutons_homepageUpdateManyAndReturnArgs>(args: SelectSubset<T, boutons_homepageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$boutons_homepagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Boutons_homepage.
     * @param {boutons_homepageUpsertArgs} args - Arguments to update or create a Boutons_homepage.
     * @example
     * // Update or create a Boutons_homepage
     * const boutons_homepage = await prisma.boutons_homepage.upsert({
     *   create: {
     *     // ... data to create a Boutons_homepage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Boutons_homepage we want to update
     *   }
     * })
     */
    upsert<T extends boutons_homepageUpsertArgs>(args: SelectSubset<T, boutons_homepageUpsertArgs<ExtArgs>>): Prisma__boutons_homepageClient<$Result.GetResult<Prisma.$boutons_homepagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Boutons_homepages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {boutons_homepageCountArgs} args - Arguments to filter Boutons_homepages to count.
     * @example
     * // Count the number of Boutons_homepages
     * const count = await prisma.boutons_homepage.count({
     *   where: {
     *     // ... the filter for the Boutons_homepages we want to count
     *   }
     * })
    **/
    count<T extends boutons_homepageCountArgs>(
      args?: Subset<T, boutons_homepageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Boutons_homepageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Boutons_homepage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Boutons_homepageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Boutons_homepageAggregateArgs>(args: Subset<T, Boutons_homepageAggregateArgs>): Prisma.PrismaPromise<GetBoutons_homepageAggregateType<T>>

    /**
     * Group by Boutons_homepage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {boutons_homepageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends boutons_homepageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: boutons_homepageGroupByArgs['orderBy'] }
        : { orderBy?: boutons_homepageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, boutons_homepageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBoutons_homepageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the boutons_homepage model
   */
  readonly fields: boutons_homepageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for boutons_homepage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__boutons_homepageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the boutons_homepage model
   */
  interface boutons_homepageFieldRefs {
    readonly id: FieldRef<"boutons_homepage", 'BigInt'>
    readonly event: FieldRef<"boutons_homepage", 'String'>
    readonly event_timestamp: FieldRef<"boutons_homepage", 'DateTime'>
    readonly properties: FieldRef<"boutons_homepage", 'Json'>
    readonly distinct_id: FieldRef<"boutons_homepage", 'String'>
    readonly session_id: FieldRef<"boutons_homepage", 'String'>
    readonly person_id: FieldRef<"boutons_homepage", 'String'>
    readonly ingested_at: FieldRef<"boutons_homepage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * boutons_homepage findUnique
   */
  export type boutons_homepageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boutons_homepage
     */
    select?: boutons_homepageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boutons_homepage
     */
    omit?: boutons_homepageOmit<ExtArgs> | null
    /**
     * Filter, which boutons_homepage to fetch.
     */
    where: boutons_homepageWhereUniqueInput
  }

  /**
   * boutons_homepage findUniqueOrThrow
   */
  export type boutons_homepageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boutons_homepage
     */
    select?: boutons_homepageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boutons_homepage
     */
    omit?: boutons_homepageOmit<ExtArgs> | null
    /**
     * Filter, which boutons_homepage to fetch.
     */
    where: boutons_homepageWhereUniqueInput
  }

  /**
   * boutons_homepage findFirst
   */
  export type boutons_homepageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boutons_homepage
     */
    select?: boutons_homepageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boutons_homepage
     */
    omit?: boutons_homepageOmit<ExtArgs> | null
    /**
     * Filter, which boutons_homepage to fetch.
     */
    where?: boutons_homepageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of boutons_homepages to fetch.
     */
    orderBy?: boutons_homepageOrderByWithRelationInput | boutons_homepageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for boutons_homepages.
     */
    cursor?: boutons_homepageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` boutons_homepages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` boutons_homepages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of boutons_homepages.
     */
    distinct?: Boutons_homepageScalarFieldEnum | Boutons_homepageScalarFieldEnum[]
  }

  /**
   * boutons_homepage findFirstOrThrow
   */
  export type boutons_homepageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boutons_homepage
     */
    select?: boutons_homepageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boutons_homepage
     */
    omit?: boutons_homepageOmit<ExtArgs> | null
    /**
     * Filter, which boutons_homepage to fetch.
     */
    where?: boutons_homepageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of boutons_homepages to fetch.
     */
    orderBy?: boutons_homepageOrderByWithRelationInput | boutons_homepageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for boutons_homepages.
     */
    cursor?: boutons_homepageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` boutons_homepages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` boutons_homepages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of boutons_homepages.
     */
    distinct?: Boutons_homepageScalarFieldEnum | Boutons_homepageScalarFieldEnum[]
  }

  /**
   * boutons_homepage findMany
   */
  export type boutons_homepageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boutons_homepage
     */
    select?: boutons_homepageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boutons_homepage
     */
    omit?: boutons_homepageOmit<ExtArgs> | null
    /**
     * Filter, which boutons_homepages to fetch.
     */
    where?: boutons_homepageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of boutons_homepages to fetch.
     */
    orderBy?: boutons_homepageOrderByWithRelationInput | boutons_homepageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing boutons_homepages.
     */
    cursor?: boutons_homepageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` boutons_homepages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` boutons_homepages.
     */
    skip?: number
    distinct?: Boutons_homepageScalarFieldEnum | Boutons_homepageScalarFieldEnum[]
  }

  /**
   * boutons_homepage create
   */
  export type boutons_homepageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boutons_homepage
     */
    select?: boutons_homepageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boutons_homepage
     */
    omit?: boutons_homepageOmit<ExtArgs> | null
    /**
     * The data needed to create a boutons_homepage.
     */
    data: XOR<boutons_homepageCreateInput, boutons_homepageUncheckedCreateInput>
  }

  /**
   * boutons_homepage createMany
   */
  export type boutons_homepageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many boutons_homepages.
     */
    data: boutons_homepageCreateManyInput | boutons_homepageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * boutons_homepage createManyAndReturn
   */
  export type boutons_homepageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boutons_homepage
     */
    select?: boutons_homepageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the boutons_homepage
     */
    omit?: boutons_homepageOmit<ExtArgs> | null
    /**
     * The data used to create many boutons_homepages.
     */
    data: boutons_homepageCreateManyInput | boutons_homepageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * boutons_homepage update
   */
  export type boutons_homepageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boutons_homepage
     */
    select?: boutons_homepageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boutons_homepage
     */
    omit?: boutons_homepageOmit<ExtArgs> | null
    /**
     * The data needed to update a boutons_homepage.
     */
    data: XOR<boutons_homepageUpdateInput, boutons_homepageUncheckedUpdateInput>
    /**
     * Choose, which boutons_homepage to update.
     */
    where: boutons_homepageWhereUniqueInput
  }

  /**
   * boutons_homepage updateMany
   */
  export type boutons_homepageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update boutons_homepages.
     */
    data: XOR<boutons_homepageUpdateManyMutationInput, boutons_homepageUncheckedUpdateManyInput>
    /**
     * Filter which boutons_homepages to update
     */
    where?: boutons_homepageWhereInput
    /**
     * Limit how many boutons_homepages to update.
     */
    limit?: number
  }

  /**
   * boutons_homepage updateManyAndReturn
   */
  export type boutons_homepageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boutons_homepage
     */
    select?: boutons_homepageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the boutons_homepage
     */
    omit?: boutons_homepageOmit<ExtArgs> | null
    /**
     * The data used to update boutons_homepages.
     */
    data: XOR<boutons_homepageUpdateManyMutationInput, boutons_homepageUncheckedUpdateManyInput>
    /**
     * Filter which boutons_homepages to update
     */
    where?: boutons_homepageWhereInput
    /**
     * Limit how many boutons_homepages to update.
     */
    limit?: number
  }

  /**
   * boutons_homepage upsert
   */
  export type boutons_homepageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boutons_homepage
     */
    select?: boutons_homepageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boutons_homepage
     */
    omit?: boutons_homepageOmit<ExtArgs> | null
    /**
     * The filter to search for the boutons_homepage to update in case it exists.
     */
    where: boutons_homepageWhereUniqueInput
    /**
     * In case the boutons_homepage found by the `where` argument doesn't exist, create a new boutons_homepage with this data.
     */
    create: XOR<boutons_homepageCreateInput, boutons_homepageUncheckedCreateInput>
    /**
     * In case the boutons_homepage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<boutons_homepageUpdateInput, boutons_homepageUncheckedUpdateInput>
  }

  /**
   * boutons_homepage delete
   */
  export type boutons_homepageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boutons_homepage
     */
    select?: boutons_homepageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boutons_homepage
     */
    omit?: boutons_homepageOmit<ExtArgs> | null
    /**
     * Filter which boutons_homepage to delete.
     */
    where: boutons_homepageWhereUniqueInput
  }

  /**
   * boutons_homepage deleteMany
   */
  export type boutons_homepageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which boutons_homepages to delete
     */
    where?: boutons_homepageWhereInput
    /**
     * Limit how many boutons_homepages to delete.
     */
    limit?: number
  }

  /**
   * boutons_homepage without action
   */
  export type boutons_homepageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boutons_homepage
     */
    select?: boutons_homepageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boutons_homepage
     */
    omit?: boutons_homepageOmit<ExtArgs> | null
  }


  /**
   * Model couverture_population
   */

  export type AggregateCouverture_population = {
    _count: Couverture_populationCountAggregateOutputType | null
    _avg: Couverture_populationAvgAggregateOutputType | null
    _sum: Couverture_populationSumAggregateOutputType | null
    _min: Couverture_populationMinAggregateOutputType | null
    _max: Couverture_populationMaxAggregateOutputType | null
  }

  export type Couverture_populationAvgAggregateOutputType = {
    id: number | null
    population: number | null
  }

  export type Couverture_populationSumAggregateOutputType = {
    id: bigint | null
    population: number | null
  }

  export type Couverture_populationMinAggregateOutputType = {
    id: bigint | null
    date: Date | null
    population: number | null
  }

  export type Couverture_populationMaxAggregateOutputType = {
    id: bigint | null
    date: Date | null
    population: number | null
  }

  export type Couverture_populationCountAggregateOutputType = {
    id: number
    date: number
    population: number
    _all: number
  }


  export type Couverture_populationAvgAggregateInputType = {
    id?: true
    population?: true
  }

  export type Couverture_populationSumAggregateInputType = {
    id?: true
    population?: true
  }

  export type Couverture_populationMinAggregateInputType = {
    id?: true
    date?: true
    population?: true
  }

  export type Couverture_populationMaxAggregateInputType = {
    id?: true
    date?: true
    population?: true
  }

  export type Couverture_populationCountAggregateInputType = {
    id?: true
    date?: true
    population?: true
    _all?: true
  }

  export type Couverture_populationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which couverture_population to aggregate.
     */
    where?: couverture_populationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of couverture_populations to fetch.
     */
    orderBy?: couverture_populationOrderByWithRelationInput | couverture_populationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: couverture_populationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` couverture_populations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` couverture_populations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned couverture_populations
    **/
    _count?: true | Couverture_populationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Couverture_populationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Couverture_populationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Couverture_populationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Couverture_populationMaxAggregateInputType
  }

  export type GetCouverture_populationAggregateType<T extends Couverture_populationAggregateArgs> = {
        [P in keyof T & keyof AggregateCouverture_population]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCouverture_population[P]>
      : GetScalarType<T[P], AggregateCouverture_population[P]>
  }




  export type couverture_populationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: couverture_populationWhereInput
    orderBy?: couverture_populationOrderByWithAggregationInput | couverture_populationOrderByWithAggregationInput[]
    by: Couverture_populationScalarFieldEnum[] | Couverture_populationScalarFieldEnum
    having?: couverture_populationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Couverture_populationCountAggregateInputType | true
    _avg?: Couverture_populationAvgAggregateInputType
    _sum?: Couverture_populationSumAggregateInputType
    _min?: Couverture_populationMinAggregateInputType
    _max?: Couverture_populationMaxAggregateInputType
  }

  export type Couverture_populationGroupByOutputType = {
    id: bigint
    date: Date
    population: number
    _count: Couverture_populationCountAggregateOutputType | null
    _avg: Couverture_populationAvgAggregateOutputType | null
    _sum: Couverture_populationSumAggregateOutputType | null
    _min: Couverture_populationMinAggregateOutputType | null
    _max: Couverture_populationMaxAggregateOutputType | null
  }

  type GetCouverture_populationGroupByPayload<T extends couverture_populationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Couverture_populationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Couverture_populationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Couverture_populationGroupByOutputType[P]>
            : GetScalarType<T[P], Couverture_populationGroupByOutputType[P]>
        }
      >
    >


  export type couverture_populationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    population?: boolean
  }, ExtArgs["result"]["couverture_population"]>

  export type couverture_populationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    population?: boolean
  }, ExtArgs["result"]["couverture_population"]>

  export type couverture_populationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    population?: boolean
  }, ExtArgs["result"]["couverture_population"]>

  export type couverture_populationSelectScalar = {
    id?: boolean
    date?: boolean
    population?: boolean
  }

  export type couverture_populationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "population", ExtArgs["result"]["couverture_population"]>

  export type $couverture_populationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "couverture_population"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      date: Date
      population: number
    }, ExtArgs["result"]["couverture_population"]>
    composites: {}
  }

  type couverture_populationGetPayload<S extends boolean | null | undefined | couverture_populationDefaultArgs> = $Result.GetResult<Prisma.$couverture_populationPayload, S>

  type couverture_populationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<couverture_populationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Couverture_populationCountAggregateInputType | true
    }

  export interface couverture_populationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['couverture_population'], meta: { name: 'couverture_population' } }
    /**
     * Find zero or one Couverture_population that matches the filter.
     * @param {couverture_populationFindUniqueArgs} args - Arguments to find a Couverture_population
     * @example
     * // Get one Couverture_population
     * const couverture_population = await prisma.couverture_population.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends couverture_populationFindUniqueArgs>(args: SelectSubset<T, couverture_populationFindUniqueArgs<ExtArgs>>): Prisma__couverture_populationClient<$Result.GetResult<Prisma.$couverture_populationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Couverture_population that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {couverture_populationFindUniqueOrThrowArgs} args - Arguments to find a Couverture_population
     * @example
     * // Get one Couverture_population
     * const couverture_population = await prisma.couverture_population.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends couverture_populationFindUniqueOrThrowArgs>(args: SelectSubset<T, couverture_populationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__couverture_populationClient<$Result.GetResult<Prisma.$couverture_populationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Couverture_population that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couverture_populationFindFirstArgs} args - Arguments to find a Couverture_population
     * @example
     * // Get one Couverture_population
     * const couverture_population = await prisma.couverture_population.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends couverture_populationFindFirstArgs>(args?: SelectSubset<T, couverture_populationFindFirstArgs<ExtArgs>>): Prisma__couverture_populationClient<$Result.GetResult<Prisma.$couverture_populationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Couverture_population that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couverture_populationFindFirstOrThrowArgs} args - Arguments to find a Couverture_population
     * @example
     * // Get one Couverture_population
     * const couverture_population = await prisma.couverture_population.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends couverture_populationFindFirstOrThrowArgs>(args?: SelectSubset<T, couverture_populationFindFirstOrThrowArgs<ExtArgs>>): Prisma__couverture_populationClient<$Result.GetResult<Prisma.$couverture_populationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Couverture_populations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couverture_populationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Couverture_populations
     * const couverture_populations = await prisma.couverture_population.findMany()
     * 
     * // Get first 10 Couverture_populations
     * const couverture_populations = await prisma.couverture_population.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const couverture_populationWithIdOnly = await prisma.couverture_population.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends couverture_populationFindManyArgs>(args?: SelectSubset<T, couverture_populationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$couverture_populationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Couverture_population.
     * @param {couverture_populationCreateArgs} args - Arguments to create a Couverture_population.
     * @example
     * // Create one Couverture_population
     * const Couverture_population = await prisma.couverture_population.create({
     *   data: {
     *     // ... data to create a Couverture_population
     *   }
     * })
     * 
     */
    create<T extends couverture_populationCreateArgs>(args: SelectSubset<T, couverture_populationCreateArgs<ExtArgs>>): Prisma__couverture_populationClient<$Result.GetResult<Prisma.$couverture_populationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Couverture_populations.
     * @param {couverture_populationCreateManyArgs} args - Arguments to create many Couverture_populations.
     * @example
     * // Create many Couverture_populations
     * const couverture_population = await prisma.couverture_population.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends couverture_populationCreateManyArgs>(args?: SelectSubset<T, couverture_populationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Couverture_populations and returns the data saved in the database.
     * @param {couverture_populationCreateManyAndReturnArgs} args - Arguments to create many Couverture_populations.
     * @example
     * // Create many Couverture_populations
     * const couverture_population = await prisma.couverture_population.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Couverture_populations and only return the `id`
     * const couverture_populationWithIdOnly = await prisma.couverture_population.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends couverture_populationCreateManyAndReturnArgs>(args?: SelectSubset<T, couverture_populationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$couverture_populationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Couverture_population.
     * @param {couverture_populationDeleteArgs} args - Arguments to delete one Couverture_population.
     * @example
     * // Delete one Couverture_population
     * const Couverture_population = await prisma.couverture_population.delete({
     *   where: {
     *     // ... filter to delete one Couverture_population
     *   }
     * })
     * 
     */
    delete<T extends couverture_populationDeleteArgs>(args: SelectSubset<T, couverture_populationDeleteArgs<ExtArgs>>): Prisma__couverture_populationClient<$Result.GetResult<Prisma.$couverture_populationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Couverture_population.
     * @param {couverture_populationUpdateArgs} args - Arguments to update one Couverture_population.
     * @example
     * // Update one Couverture_population
     * const couverture_population = await prisma.couverture_population.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends couverture_populationUpdateArgs>(args: SelectSubset<T, couverture_populationUpdateArgs<ExtArgs>>): Prisma__couverture_populationClient<$Result.GetResult<Prisma.$couverture_populationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Couverture_populations.
     * @param {couverture_populationDeleteManyArgs} args - Arguments to filter Couverture_populations to delete.
     * @example
     * // Delete a few Couverture_populations
     * const { count } = await prisma.couverture_population.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends couverture_populationDeleteManyArgs>(args?: SelectSubset<T, couverture_populationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Couverture_populations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couverture_populationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Couverture_populations
     * const couverture_population = await prisma.couverture_population.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends couverture_populationUpdateManyArgs>(args: SelectSubset<T, couverture_populationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Couverture_populations and returns the data updated in the database.
     * @param {couverture_populationUpdateManyAndReturnArgs} args - Arguments to update many Couverture_populations.
     * @example
     * // Update many Couverture_populations
     * const couverture_population = await prisma.couverture_population.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Couverture_populations and only return the `id`
     * const couverture_populationWithIdOnly = await prisma.couverture_population.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends couverture_populationUpdateManyAndReturnArgs>(args: SelectSubset<T, couverture_populationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$couverture_populationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Couverture_population.
     * @param {couverture_populationUpsertArgs} args - Arguments to update or create a Couverture_population.
     * @example
     * // Update or create a Couverture_population
     * const couverture_population = await prisma.couverture_population.upsert({
     *   create: {
     *     // ... data to create a Couverture_population
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Couverture_population we want to update
     *   }
     * })
     */
    upsert<T extends couverture_populationUpsertArgs>(args: SelectSubset<T, couverture_populationUpsertArgs<ExtArgs>>): Prisma__couverture_populationClient<$Result.GetResult<Prisma.$couverture_populationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Couverture_populations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couverture_populationCountArgs} args - Arguments to filter Couverture_populations to count.
     * @example
     * // Count the number of Couverture_populations
     * const count = await prisma.couverture_population.count({
     *   where: {
     *     // ... the filter for the Couverture_populations we want to count
     *   }
     * })
    **/
    count<T extends couverture_populationCountArgs>(
      args?: Subset<T, couverture_populationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Couverture_populationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Couverture_population.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Couverture_populationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Couverture_populationAggregateArgs>(args: Subset<T, Couverture_populationAggregateArgs>): Prisma.PrismaPromise<GetCouverture_populationAggregateType<T>>

    /**
     * Group by Couverture_population.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {couverture_populationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends couverture_populationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: couverture_populationGroupByArgs['orderBy'] }
        : { orderBy?: couverture_populationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, couverture_populationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCouverture_populationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the couverture_population model
   */
  readonly fields: couverture_populationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for couverture_population.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__couverture_populationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the couverture_population model
   */
  interface couverture_populationFieldRefs {
    readonly id: FieldRef<"couverture_population", 'BigInt'>
    readonly date: FieldRef<"couverture_population", 'DateTime'>
    readonly population: FieldRef<"couverture_population", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * couverture_population findUnique
   */
  export type couverture_populationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the couverture_population
     */
    select?: couverture_populationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the couverture_population
     */
    omit?: couverture_populationOmit<ExtArgs> | null
    /**
     * Filter, which couverture_population to fetch.
     */
    where: couverture_populationWhereUniqueInput
  }

  /**
   * couverture_population findUniqueOrThrow
   */
  export type couverture_populationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the couverture_population
     */
    select?: couverture_populationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the couverture_population
     */
    omit?: couverture_populationOmit<ExtArgs> | null
    /**
     * Filter, which couverture_population to fetch.
     */
    where: couverture_populationWhereUniqueInput
  }

  /**
   * couverture_population findFirst
   */
  export type couverture_populationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the couverture_population
     */
    select?: couverture_populationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the couverture_population
     */
    omit?: couverture_populationOmit<ExtArgs> | null
    /**
     * Filter, which couverture_population to fetch.
     */
    where?: couverture_populationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of couverture_populations to fetch.
     */
    orderBy?: couverture_populationOrderByWithRelationInput | couverture_populationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for couverture_populations.
     */
    cursor?: couverture_populationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` couverture_populations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` couverture_populations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of couverture_populations.
     */
    distinct?: Couverture_populationScalarFieldEnum | Couverture_populationScalarFieldEnum[]
  }

  /**
   * couverture_population findFirstOrThrow
   */
  export type couverture_populationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the couverture_population
     */
    select?: couverture_populationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the couverture_population
     */
    omit?: couverture_populationOmit<ExtArgs> | null
    /**
     * Filter, which couverture_population to fetch.
     */
    where?: couverture_populationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of couverture_populations to fetch.
     */
    orderBy?: couverture_populationOrderByWithRelationInput | couverture_populationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for couverture_populations.
     */
    cursor?: couverture_populationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` couverture_populations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` couverture_populations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of couverture_populations.
     */
    distinct?: Couverture_populationScalarFieldEnum | Couverture_populationScalarFieldEnum[]
  }

  /**
   * couverture_population findMany
   */
  export type couverture_populationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the couverture_population
     */
    select?: couverture_populationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the couverture_population
     */
    omit?: couverture_populationOmit<ExtArgs> | null
    /**
     * Filter, which couverture_populations to fetch.
     */
    where?: couverture_populationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of couverture_populations to fetch.
     */
    orderBy?: couverture_populationOrderByWithRelationInput | couverture_populationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing couverture_populations.
     */
    cursor?: couverture_populationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` couverture_populations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` couverture_populations.
     */
    skip?: number
    distinct?: Couverture_populationScalarFieldEnum | Couverture_populationScalarFieldEnum[]
  }

  /**
   * couverture_population create
   */
  export type couverture_populationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the couverture_population
     */
    select?: couverture_populationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the couverture_population
     */
    omit?: couverture_populationOmit<ExtArgs> | null
    /**
     * The data needed to create a couverture_population.
     */
    data: XOR<couverture_populationCreateInput, couverture_populationUncheckedCreateInput>
  }

  /**
   * couverture_population createMany
   */
  export type couverture_populationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many couverture_populations.
     */
    data: couverture_populationCreateManyInput | couverture_populationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * couverture_population createManyAndReturn
   */
  export type couverture_populationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the couverture_population
     */
    select?: couverture_populationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the couverture_population
     */
    omit?: couverture_populationOmit<ExtArgs> | null
    /**
     * The data used to create many couverture_populations.
     */
    data: couverture_populationCreateManyInput | couverture_populationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * couverture_population update
   */
  export type couverture_populationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the couverture_population
     */
    select?: couverture_populationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the couverture_population
     */
    omit?: couverture_populationOmit<ExtArgs> | null
    /**
     * The data needed to update a couverture_population.
     */
    data: XOR<couverture_populationUpdateInput, couverture_populationUncheckedUpdateInput>
    /**
     * Choose, which couverture_population to update.
     */
    where: couverture_populationWhereUniqueInput
  }

  /**
   * couverture_population updateMany
   */
  export type couverture_populationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update couverture_populations.
     */
    data: XOR<couverture_populationUpdateManyMutationInput, couverture_populationUncheckedUpdateManyInput>
    /**
     * Filter which couverture_populations to update
     */
    where?: couverture_populationWhereInput
    /**
     * Limit how many couverture_populations to update.
     */
    limit?: number
  }

  /**
   * couverture_population updateManyAndReturn
   */
  export type couverture_populationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the couverture_population
     */
    select?: couverture_populationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the couverture_population
     */
    omit?: couverture_populationOmit<ExtArgs> | null
    /**
     * The data used to update couverture_populations.
     */
    data: XOR<couverture_populationUpdateManyMutationInput, couverture_populationUncheckedUpdateManyInput>
    /**
     * Filter which couverture_populations to update
     */
    where?: couverture_populationWhereInput
    /**
     * Limit how many couverture_populations to update.
     */
    limit?: number
  }

  /**
   * couverture_population upsert
   */
  export type couverture_populationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the couverture_population
     */
    select?: couverture_populationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the couverture_population
     */
    omit?: couverture_populationOmit<ExtArgs> | null
    /**
     * The filter to search for the couverture_population to update in case it exists.
     */
    where: couverture_populationWhereUniqueInput
    /**
     * In case the couverture_population found by the `where` argument doesn't exist, create a new couverture_population with this data.
     */
    create: XOR<couverture_populationCreateInput, couverture_populationUncheckedCreateInput>
    /**
     * In case the couverture_population was found with the provided `where` argument, update it with this data.
     */
    update: XOR<couverture_populationUpdateInput, couverture_populationUncheckedUpdateInput>
  }

  /**
   * couverture_population delete
   */
  export type couverture_populationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the couverture_population
     */
    select?: couverture_populationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the couverture_population
     */
    omit?: couverture_populationOmit<ExtArgs> | null
    /**
     * Filter which couverture_population to delete.
     */
    where: couverture_populationWhereUniqueInput
  }

  /**
   * couverture_population deleteMany
   */
  export type couverture_populationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which couverture_populations to delete
     */
    where?: couverture_populationWhereInput
    /**
     * Limit how many couverture_populations to delete.
     */
    limit?: number
  }

  /**
   * couverture_population without action
   */
  export type couverture_populationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the couverture_population
     */
    select?: couverture_populationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the couverture_population
     */
    omit?: couverture_populationOmit<ExtArgs> | null
  }


  /**
   * Model ressources_consultees
   */

  export type AggregateRessources_consultees = {
    _count: Ressources_consulteesCountAggregateOutputType | null
    _avg: Ressources_consulteesAvgAggregateOutputType | null
    _sum: Ressources_consulteesSumAggregateOutputType | null
    _min: Ressources_consulteesMinAggregateOutputType | null
    _max: Ressources_consulteesMaxAggregateOutputType | null
  }

  export type Ressources_consulteesAvgAggregateOutputType = {
    id: number | null
  }

  export type Ressources_consulteesSumAggregateOutputType = {
    id: bigint | null
  }

  export type Ressources_consulteesMinAggregateOutputType = {
    id: bigint | null
    event_timestamp: Date | null
    distinct_id: string | null
    session_id: string | null
    person_id: string | null
    ressource: string | null
    ingested_at: Date | null
  }

  export type Ressources_consulteesMaxAggregateOutputType = {
    id: bigint | null
    event_timestamp: Date | null
    distinct_id: string | null
    session_id: string | null
    person_id: string | null
    ressource: string | null
    ingested_at: Date | null
  }

  export type Ressources_consulteesCountAggregateOutputType = {
    id: number
    event_timestamp: number
    distinct_id: number
    session_id: number
    person_id: number
    ressource: number
    ingested_at: number
    _all: number
  }


  export type Ressources_consulteesAvgAggregateInputType = {
    id?: true
  }

  export type Ressources_consulteesSumAggregateInputType = {
    id?: true
  }

  export type Ressources_consulteesMinAggregateInputType = {
    id?: true
    event_timestamp?: true
    distinct_id?: true
    session_id?: true
    person_id?: true
    ressource?: true
    ingested_at?: true
  }

  export type Ressources_consulteesMaxAggregateInputType = {
    id?: true
    event_timestamp?: true
    distinct_id?: true
    session_id?: true
    person_id?: true
    ressource?: true
    ingested_at?: true
  }

  export type Ressources_consulteesCountAggregateInputType = {
    id?: true
    event_timestamp?: true
    distinct_id?: true
    session_id?: true
    person_id?: true
    ressource?: true
    ingested_at?: true
    _all?: true
  }

  export type Ressources_consulteesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ressources_consultees to aggregate.
     */
    where?: ressources_consulteesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ressources_consultees to fetch.
     */
    orderBy?: ressources_consulteesOrderByWithRelationInput | ressources_consulteesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ressources_consulteesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ressources_consultees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ressources_consultees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ressources_consultees
    **/
    _count?: true | Ressources_consulteesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ressources_consulteesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ressources_consulteesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ressources_consulteesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ressources_consulteesMaxAggregateInputType
  }

  export type GetRessources_consulteesAggregateType<T extends Ressources_consulteesAggregateArgs> = {
        [P in keyof T & keyof AggregateRessources_consultees]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRessources_consultees[P]>
      : GetScalarType<T[P], AggregateRessources_consultees[P]>
  }




  export type ressources_consulteesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ressources_consulteesWhereInput
    orderBy?: ressources_consulteesOrderByWithAggregationInput | ressources_consulteesOrderByWithAggregationInput[]
    by: Ressources_consulteesScalarFieldEnum[] | Ressources_consulteesScalarFieldEnum
    having?: ressources_consulteesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ressources_consulteesCountAggregateInputType | true
    _avg?: Ressources_consulteesAvgAggregateInputType
    _sum?: Ressources_consulteesSumAggregateInputType
    _min?: Ressources_consulteesMinAggregateInputType
    _max?: Ressources_consulteesMaxAggregateInputType
  }

  export type Ressources_consulteesGroupByOutputType = {
    id: bigint
    event_timestamp: Date
    distinct_id: string | null
    session_id: string | null
    person_id: string | null
    ressource: string | null
    ingested_at: Date
    _count: Ressources_consulteesCountAggregateOutputType | null
    _avg: Ressources_consulteesAvgAggregateOutputType | null
    _sum: Ressources_consulteesSumAggregateOutputType | null
    _min: Ressources_consulteesMinAggregateOutputType | null
    _max: Ressources_consulteesMaxAggregateOutputType | null
  }

  type GetRessources_consulteesGroupByPayload<T extends ressources_consulteesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ressources_consulteesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ressources_consulteesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ressources_consulteesGroupByOutputType[P]>
            : GetScalarType<T[P], Ressources_consulteesGroupByOutputType[P]>
        }
      >
    >


  export type ressources_consulteesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    event_timestamp?: boolean
    distinct_id?: boolean
    session_id?: boolean
    person_id?: boolean
    ressource?: boolean
    ingested_at?: boolean
  }, ExtArgs["result"]["ressources_consultees"]>

  export type ressources_consulteesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    event_timestamp?: boolean
    distinct_id?: boolean
    session_id?: boolean
    person_id?: boolean
    ressource?: boolean
    ingested_at?: boolean
  }, ExtArgs["result"]["ressources_consultees"]>

  export type ressources_consulteesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    event_timestamp?: boolean
    distinct_id?: boolean
    session_id?: boolean
    person_id?: boolean
    ressource?: boolean
    ingested_at?: boolean
  }, ExtArgs["result"]["ressources_consultees"]>

  export type ressources_consulteesSelectScalar = {
    id?: boolean
    event_timestamp?: boolean
    distinct_id?: boolean
    session_id?: boolean
    person_id?: boolean
    ressource?: boolean
    ingested_at?: boolean
  }

  export type ressources_consulteesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "event_timestamp" | "distinct_id" | "session_id" | "person_id" | "ressource" | "ingested_at", ExtArgs["result"]["ressources_consultees"]>

  export type $ressources_consulteesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ressources_consultees"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      event_timestamp: Date
      distinct_id: string | null
      session_id: string | null
      person_id: string | null
      ressource: string | null
      ingested_at: Date
    }, ExtArgs["result"]["ressources_consultees"]>
    composites: {}
  }

  type ressources_consulteesGetPayload<S extends boolean | null | undefined | ressources_consulteesDefaultArgs> = $Result.GetResult<Prisma.$ressources_consulteesPayload, S>

  type ressources_consulteesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ressources_consulteesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ressources_consulteesCountAggregateInputType | true
    }

  export interface ressources_consulteesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ressources_consultees'], meta: { name: 'ressources_consultees' } }
    /**
     * Find zero or one Ressources_consultees that matches the filter.
     * @param {ressources_consulteesFindUniqueArgs} args - Arguments to find a Ressources_consultees
     * @example
     * // Get one Ressources_consultees
     * const ressources_consultees = await prisma.ressources_consultees.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ressources_consulteesFindUniqueArgs>(args: SelectSubset<T, ressources_consulteesFindUniqueArgs<ExtArgs>>): Prisma__ressources_consulteesClient<$Result.GetResult<Prisma.$ressources_consulteesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ressources_consultees that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ressources_consulteesFindUniqueOrThrowArgs} args - Arguments to find a Ressources_consultees
     * @example
     * // Get one Ressources_consultees
     * const ressources_consultees = await prisma.ressources_consultees.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ressources_consulteesFindUniqueOrThrowArgs>(args: SelectSubset<T, ressources_consulteesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ressources_consulteesClient<$Result.GetResult<Prisma.$ressources_consulteesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ressources_consultees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ressources_consulteesFindFirstArgs} args - Arguments to find a Ressources_consultees
     * @example
     * // Get one Ressources_consultees
     * const ressources_consultees = await prisma.ressources_consultees.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ressources_consulteesFindFirstArgs>(args?: SelectSubset<T, ressources_consulteesFindFirstArgs<ExtArgs>>): Prisma__ressources_consulteesClient<$Result.GetResult<Prisma.$ressources_consulteesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ressources_consultees that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ressources_consulteesFindFirstOrThrowArgs} args - Arguments to find a Ressources_consultees
     * @example
     * // Get one Ressources_consultees
     * const ressources_consultees = await prisma.ressources_consultees.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ressources_consulteesFindFirstOrThrowArgs>(args?: SelectSubset<T, ressources_consulteesFindFirstOrThrowArgs<ExtArgs>>): Prisma__ressources_consulteesClient<$Result.GetResult<Prisma.$ressources_consulteesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ressources_consultees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ressources_consulteesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ressources_consultees
     * const ressources_consultees = await prisma.ressources_consultees.findMany()
     * 
     * // Get first 10 Ressources_consultees
     * const ressources_consultees = await prisma.ressources_consultees.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ressources_consulteesWithIdOnly = await prisma.ressources_consultees.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ressources_consulteesFindManyArgs>(args?: SelectSubset<T, ressources_consulteesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ressources_consulteesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ressources_consultees.
     * @param {ressources_consulteesCreateArgs} args - Arguments to create a Ressources_consultees.
     * @example
     * // Create one Ressources_consultees
     * const Ressources_consultees = await prisma.ressources_consultees.create({
     *   data: {
     *     // ... data to create a Ressources_consultees
     *   }
     * })
     * 
     */
    create<T extends ressources_consulteesCreateArgs>(args: SelectSubset<T, ressources_consulteesCreateArgs<ExtArgs>>): Prisma__ressources_consulteesClient<$Result.GetResult<Prisma.$ressources_consulteesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ressources_consultees.
     * @param {ressources_consulteesCreateManyArgs} args - Arguments to create many Ressources_consultees.
     * @example
     * // Create many Ressources_consultees
     * const ressources_consultees = await prisma.ressources_consultees.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ressources_consulteesCreateManyArgs>(args?: SelectSubset<T, ressources_consulteesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ressources_consultees and returns the data saved in the database.
     * @param {ressources_consulteesCreateManyAndReturnArgs} args - Arguments to create many Ressources_consultees.
     * @example
     * // Create many Ressources_consultees
     * const ressources_consultees = await prisma.ressources_consultees.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ressources_consultees and only return the `id`
     * const ressources_consulteesWithIdOnly = await prisma.ressources_consultees.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ressources_consulteesCreateManyAndReturnArgs>(args?: SelectSubset<T, ressources_consulteesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ressources_consulteesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ressources_consultees.
     * @param {ressources_consulteesDeleteArgs} args - Arguments to delete one Ressources_consultees.
     * @example
     * // Delete one Ressources_consultees
     * const Ressources_consultees = await prisma.ressources_consultees.delete({
     *   where: {
     *     // ... filter to delete one Ressources_consultees
     *   }
     * })
     * 
     */
    delete<T extends ressources_consulteesDeleteArgs>(args: SelectSubset<T, ressources_consulteesDeleteArgs<ExtArgs>>): Prisma__ressources_consulteesClient<$Result.GetResult<Prisma.$ressources_consulteesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ressources_consultees.
     * @param {ressources_consulteesUpdateArgs} args - Arguments to update one Ressources_consultees.
     * @example
     * // Update one Ressources_consultees
     * const ressources_consultees = await prisma.ressources_consultees.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ressources_consulteesUpdateArgs>(args: SelectSubset<T, ressources_consulteesUpdateArgs<ExtArgs>>): Prisma__ressources_consulteesClient<$Result.GetResult<Prisma.$ressources_consulteesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ressources_consultees.
     * @param {ressources_consulteesDeleteManyArgs} args - Arguments to filter Ressources_consultees to delete.
     * @example
     * // Delete a few Ressources_consultees
     * const { count } = await prisma.ressources_consultees.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ressources_consulteesDeleteManyArgs>(args?: SelectSubset<T, ressources_consulteesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ressources_consultees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ressources_consulteesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ressources_consultees
     * const ressources_consultees = await prisma.ressources_consultees.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ressources_consulteesUpdateManyArgs>(args: SelectSubset<T, ressources_consulteesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ressources_consultees and returns the data updated in the database.
     * @param {ressources_consulteesUpdateManyAndReturnArgs} args - Arguments to update many Ressources_consultees.
     * @example
     * // Update many Ressources_consultees
     * const ressources_consultees = await prisma.ressources_consultees.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ressources_consultees and only return the `id`
     * const ressources_consulteesWithIdOnly = await prisma.ressources_consultees.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ressources_consulteesUpdateManyAndReturnArgs>(args: SelectSubset<T, ressources_consulteesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ressources_consulteesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ressources_consultees.
     * @param {ressources_consulteesUpsertArgs} args - Arguments to update or create a Ressources_consultees.
     * @example
     * // Update or create a Ressources_consultees
     * const ressources_consultees = await prisma.ressources_consultees.upsert({
     *   create: {
     *     // ... data to create a Ressources_consultees
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ressources_consultees we want to update
     *   }
     * })
     */
    upsert<T extends ressources_consulteesUpsertArgs>(args: SelectSubset<T, ressources_consulteesUpsertArgs<ExtArgs>>): Prisma__ressources_consulteesClient<$Result.GetResult<Prisma.$ressources_consulteesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ressources_consultees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ressources_consulteesCountArgs} args - Arguments to filter Ressources_consultees to count.
     * @example
     * // Count the number of Ressources_consultees
     * const count = await prisma.ressources_consultees.count({
     *   where: {
     *     // ... the filter for the Ressources_consultees we want to count
     *   }
     * })
    **/
    count<T extends ressources_consulteesCountArgs>(
      args?: Subset<T, ressources_consulteesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ressources_consulteesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ressources_consultees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ressources_consulteesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ressources_consulteesAggregateArgs>(args: Subset<T, Ressources_consulteesAggregateArgs>): Prisma.PrismaPromise<GetRessources_consulteesAggregateType<T>>

    /**
     * Group by Ressources_consultees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ressources_consulteesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ressources_consulteesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ressources_consulteesGroupByArgs['orderBy'] }
        : { orderBy?: ressources_consulteesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ressources_consulteesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRessources_consulteesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ressources_consultees model
   */
  readonly fields: ressources_consulteesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ressources_consultees.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ressources_consulteesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ressources_consultees model
   */
  interface ressources_consulteesFieldRefs {
    readonly id: FieldRef<"ressources_consultees", 'BigInt'>
    readonly event_timestamp: FieldRef<"ressources_consultees", 'DateTime'>
    readonly distinct_id: FieldRef<"ressources_consultees", 'String'>
    readonly session_id: FieldRef<"ressources_consultees", 'String'>
    readonly person_id: FieldRef<"ressources_consultees", 'String'>
    readonly ressource: FieldRef<"ressources_consultees", 'String'>
    readonly ingested_at: FieldRef<"ressources_consultees", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ressources_consultees findUnique
   */
  export type ressources_consulteesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ressources_consultees
     */
    select?: ressources_consulteesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ressources_consultees
     */
    omit?: ressources_consulteesOmit<ExtArgs> | null
    /**
     * Filter, which ressources_consultees to fetch.
     */
    where: ressources_consulteesWhereUniqueInput
  }

  /**
   * ressources_consultees findUniqueOrThrow
   */
  export type ressources_consulteesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ressources_consultees
     */
    select?: ressources_consulteesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ressources_consultees
     */
    omit?: ressources_consulteesOmit<ExtArgs> | null
    /**
     * Filter, which ressources_consultees to fetch.
     */
    where: ressources_consulteesWhereUniqueInput
  }

  /**
   * ressources_consultees findFirst
   */
  export type ressources_consulteesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ressources_consultees
     */
    select?: ressources_consulteesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ressources_consultees
     */
    omit?: ressources_consulteesOmit<ExtArgs> | null
    /**
     * Filter, which ressources_consultees to fetch.
     */
    where?: ressources_consulteesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ressources_consultees to fetch.
     */
    orderBy?: ressources_consulteesOrderByWithRelationInput | ressources_consulteesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ressources_consultees.
     */
    cursor?: ressources_consulteesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ressources_consultees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ressources_consultees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ressources_consultees.
     */
    distinct?: Ressources_consulteesScalarFieldEnum | Ressources_consulteesScalarFieldEnum[]
  }

  /**
   * ressources_consultees findFirstOrThrow
   */
  export type ressources_consulteesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ressources_consultees
     */
    select?: ressources_consulteesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ressources_consultees
     */
    omit?: ressources_consulteesOmit<ExtArgs> | null
    /**
     * Filter, which ressources_consultees to fetch.
     */
    where?: ressources_consulteesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ressources_consultees to fetch.
     */
    orderBy?: ressources_consulteesOrderByWithRelationInput | ressources_consulteesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ressources_consultees.
     */
    cursor?: ressources_consulteesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ressources_consultees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ressources_consultees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ressources_consultees.
     */
    distinct?: Ressources_consulteesScalarFieldEnum | Ressources_consulteesScalarFieldEnum[]
  }

  /**
   * ressources_consultees findMany
   */
  export type ressources_consulteesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ressources_consultees
     */
    select?: ressources_consulteesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ressources_consultees
     */
    omit?: ressources_consulteesOmit<ExtArgs> | null
    /**
     * Filter, which ressources_consultees to fetch.
     */
    where?: ressources_consulteesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ressources_consultees to fetch.
     */
    orderBy?: ressources_consulteesOrderByWithRelationInput | ressources_consulteesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ressources_consultees.
     */
    cursor?: ressources_consulteesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ressources_consultees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ressources_consultees.
     */
    skip?: number
    distinct?: Ressources_consulteesScalarFieldEnum | Ressources_consulteesScalarFieldEnum[]
  }

  /**
   * ressources_consultees create
   */
  export type ressources_consulteesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ressources_consultees
     */
    select?: ressources_consulteesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ressources_consultees
     */
    omit?: ressources_consulteesOmit<ExtArgs> | null
    /**
     * The data needed to create a ressources_consultees.
     */
    data: XOR<ressources_consulteesCreateInput, ressources_consulteesUncheckedCreateInput>
  }

  /**
   * ressources_consultees createMany
   */
  export type ressources_consulteesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ressources_consultees.
     */
    data: ressources_consulteesCreateManyInput | ressources_consulteesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ressources_consultees createManyAndReturn
   */
  export type ressources_consulteesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ressources_consultees
     */
    select?: ressources_consulteesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ressources_consultees
     */
    omit?: ressources_consulteesOmit<ExtArgs> | null
    /**
     * The data used to create many ressources_consultees.
     */
    data: ressources_consulteesCreateManyInput | ressources_consulteesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ressources_consultees update
   */
  export type ressources_consulteesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ressources_consultees
     */
    select?: ressources_consulteesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ressources_consultees
     */
    omit?: ressources_consulteesOmit<ExtArgs> | null
    /**
     * The data needed to update a ressources_consultees.
     */
    data: XOR<ressources_consulteesUpdateInput, ressources_consulteesUncheckedUpdateInput>
    /**
     * Choose, which ressources_consultees to update.
     */
    where: ressources_consulteesWhereUniqueInput
  }

  /**
   * ressources_consultees updateMany
   */
  export type ressources_consulteesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ressources_consultees.
     */
    data: XOR<ressources_consulteesUpdateManyMutationInput, ressources_consulteesUncheckedUpdateManyInput>
    /**
     * Filter which ressources_consultees to update
     */
    where?: ressources_consulteesWhereInput
    /**
     * Limit how many ressources_consultees to update.
     */
    limit?: number
  }

  /**
   * ressources_consultees updateManyAndReturn
   */
  export type ressources_consulteesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ressources_consultees
     */
    select?: ressources_consulteesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ressources_consultees
     */
    omit?: ressources_consulteesOmit<ExtArgs> | null
    /**
     * The data used to update ressources_consultees.
     */
    data: XOR<ressources_consulteesUpdateManyMutationInput, ressources_consulteesUncheckedUpdateManyInput>
    /**
     * Filter which ressources_consultees to update
     */
    where?: ressources_consulteesWhereInput
    /**
     * Limit how many ressources_consultees to update.
     */
    limit?: number
  }

  /**
   * ressources_consultees upsert
   */
  export type ressources_consulteesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ressources_consultees
     */
    select?: ressources_consulteesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ressources_consultees
     */
    omit?: ressources_consulteesOmit<ExtArgs> | null
    /**
     * The filter to search for the ressources_consultees to update in case it exists.
     */
    where: ressources_consulteesWhereUniqueInput
    /**
     * In case the ressources_consultees found by the `where` argument doesn't exist, create a new ressources_consultees with this data.
     */
    create: XOR<ressources_consulteesCreateInput, ressources_consulteesUncheckedCreateInput>
    /**
     * In case the ressources_consultees was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ressources_consulteesUpdateInput, ressources_consulteesUncheckedUpdateInput>
  }

  /**
   * ressources_consultees delete
   */
  export type ressources_consulteesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ressources_consultees
     */
    select?: ressources_consulteesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ressources_consultees
     */
    omit?: ressources_consulteesOmit<ExtArgs> | null
    /**
     * Filter which ressources_consultees to delete.
     */
    where: ressources_consulteesWhereUniqueInput
  }

  /**
   * ressources_consultees deleteMany
   */
  export type ressources_consulteesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ressources_consultees to delete
     */
    where?: ressources_consulteesWhereInput
    /**
     * Limit how many ressources_consultees to delete.
     */
    limit?: number
  }

  /**
   * ressources_consultees without action
   */
  export type ressources_consulteesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ressources_consultees
     */
    select?: ressources_consulteesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ressources_consultees
     */
    omit?: ressources_consulteesOmit<ExtArgs> | null
  }


  /**
   * Model thematique
   */

  export type AggregateThematique = {
    _count: ThematiqueCountAggregateOutputType | null
    _avg: ThematiqueAvgAggregateOutputType | null
    _sum: ThematiqueSumAggregateOutputType | null
    _min: ThematiqueMinAggregateOutputType | null
    _max: ThematiqueMaxAggregateOutputType | null
  }

  export type ThematiqueAvgAggregateOutputType = {
    id: number | null
  }

  export type ThematiqueSumAggregateOutputType = {
    id: bigint | null
  }

  export type ThematiqueMinAggregateOutputType = {
    id: bigint | null
    event_timestamp: Date | null
    distinct_id: string | null
    session_id: string | null
    person_id: string | null
    thematique: string | null
    ingested_at: Date | null
  }

  export type ThematiqueMaxAggregateOutputType = {
    id: bigint | null
    event_timestamp: Date | null
    distinct_id: string | null
    session_id: string | null
    person_id: string | null
    thematique: string | null
    ingested_at: Date | null
  }

  export type ThematiqueCountAggregateOutputType = {
    id: number
    event_timestamp: number
    properties: number
    distinct_id: number
    session_id: number
    person_id: number
    thematique: number
    ingested_at: number
    _all: number
  }


  export type ThematiqueAvgAggregateInputType = {
    id?: true
  }

  export type ThematiqueSumAggregateInputType = {
    id?: true
  }

  export type ThematiqueMinAggregateInputType = {
    id?: true
    event_timestamp?: true
    distinct_id?: true
    session_id?: true
    person_id?: true
    thematique?: true
    ingested_at?: true
  }

  export type ThematiqueMaxAggregateInputType = {
    id?: true
    event_timestamp?: true
    distinct_id?: true
    session_id?: true
    person_id?: true
    thematique?: true
    ingested_at?: true
  }

  export type ThematiqueCountAggregateInputType = {
    id?: true
    event_timestamp?: true
    properties?: true
    distinct_id?: true
    session_id?: true
    person_id?: true
    thematique?: true
    ingested_at?: true
    _all?: true
  }

  export type ThematiqueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which thematique to aggregate.
     */
    where?: thematiqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of thematiques to fetch.
     */
    orderBy?: thematiqueOrderByWithRelationInput | thematiqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: thematiqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` thematiques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` thematiques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned thematiques
    **/
    _count?: true | ThematiqueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ThematiqueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ThematiqueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ThematiqueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ThematiqueMaxAggregateInputType
  }

  export type GetThematiqueAggregateType<T extends ThematiqueAggregateArgs> = {
        [P in keyof T & keyof AggregateThematique]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateThematique[P]>
      : GetScalarType<T[P], AggregateThematique[P]>
  }




  export type thematiqueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: thematiqueWhereInput
    orderBy?: thematiqueOrderByWithAggregationInput | thematiqueOrderByWithAggregationInput[]
    by: ThematiqueScalarFieldEnum[] | ThematiqueScalarFieldEnum
    having?: thematiqueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ThematiqueCountAggregateInputType | true
    _avg?: ThematiqueAvgAggregateInputType
    _sum?: ThematiqueSumAggregateInputType
    _min?: ThematiqueMinAggregateInputType
    _max?: ThematiqueMaxAggregateInputType
  }

  export type ThematiqueGroupByOutputType = {
    id: bigint
    event_timestamp: Date
    properties: JsonValue | null
    distinct_id: string | null
    session_id: string | null
    person_id: string | null
    thematique: string | null
    ingested_at: Date
    _count: ThematiqueCountAggregateOutputType | null
    _avg: ThematiqueAvgAggregateOutputType | null
    _sum: ThematiqueSumAggregateOutputType | null
    _min: ThematiqueMinAggregateOutputType | null
    _max: ThematiqueMaxAggregateOutputType | null
  }

  type GetThematiqueGroupByPayload<T extends thematiqueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ThematiqueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ThematiqueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ThematiqueGroupByOutputType[P]>
            : GetScalarType<T[P], ThematiqueGroupByOutputType[P]>
        }
      >
    >


  export type thematiqueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    event_timestamp?: boolean
    properties?: boolean
    distinct_id?: boolean
    session_id?: boolean
    person_id?: boolean
    thematique?: boolean
    ingested_at?: boolean
  }, ExtArgs["result"]["thematique"]>

  export type thematiqueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    event_timestamp?: boolean
    properties?: boolean
    distinct_id?: boolean
    session_id?: boolean
    person_id?: boolean
    thematique?: boolean
    ingested_at?: boolean
  }, ExtArgs["result"]["thematique"]>

  export type thematiqueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    event_timestamp?: boolean
    properties?: boolean
    distinct_id?: boolean
    session_id?: boolean
    person_id?: boolean
    thematique?: boolean
    ingested_at?: boolean
  }, ExtArgs["result"]["thematique"]>

  export type thematiqueSelectScalar = {
    id?: boolean
    event_timestamp?: boolean
    properties?: boolean
    distinct_id?: boolean
    session_id?: boolean
    person_id?: boolean
    thematique?: boolean
    ingested_at?: boolean
  }

  export type thematiqueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "event_timestamp" | "properties" | "distinct_id" | "session_id" | "person_id" | "thematique" | "ingested_at", ExtArgs["result"]["thematique"]>

  export type $thematiquePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "thematique"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      event_timestamp: Date
      properties: Prisma.JsonValue | null
      distinct_id: string | null
      session_id: string | null
      person_id: string | null
      thematique: string | null
      ingested_at: Date
    }, ExtArgs["result"]["thematique"]>
    composites: {}
  }

  type thematiqueGetPayload<S extends boolean | null | undefined | thematiqueDefaultArgs> = $Result.GetResult<Prisma.$thematiquePayload, S>

  type thematiqueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<thematiqueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ThematiqueCountAggregateInputType | true
    }

  export interface thematiqueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['thematique'], meta: { name: 'thematique' } }
    /**
     * Find zero or one Thematique that matches the filter.
     * @param {thematiqueFindUniqueArgs} args - Arguments to find a Thematique
     * @example
     * // Get one Thematique
     * const thematique = await prisma.thematique.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends thematiqueFindUniqueArgs>(args: SelectSubset<T, thematiqueFindUniqueArgs<ExtArgs>>): Prisma__thematiqueClient<$Result.GetResult<Prisma.$thematiquePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Thematique that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {thematiqueFindUniqueOrThrowArgs} args - Arguments to find a Thematique
     * @example
     * // Get one Thematique
     * const thematique = await prisma.thematique.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends thematiqueFindUniqueOrThrowArgs>(args: SelectSubset<T, thematiqueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__thematiqueClient<$Result.GetResult<Prisma.$thematiquePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Thematique that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {thematiqueFindFirstArgs} args - Arguments to find a Thematique
     * @example
     * // Get one Thematique
     * const thematique = await prisma.thematique.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends thematiqueFindFirstArgs>(args?: SelectSubset<T, thematiqueFindFirstArgs<ExtArgs>>): Prisma__thematiqueClient<$Result.GetResult<Prisma.$thematiquePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Thematique that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {thematiqueFindFirstOrThrowArgs} args - Arguments to find a Thematique
     * @example
     * // Get one Thematique
     * const thematique = await prisma.thematique.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends thematiqueFindFirstOrThrowArgs>(args?: SelectSubset<T, thematiqueFindFirstOrThrowArgs<ExtArgs>>): Prisma__thematiqueClient<$Result.GetResult<Prisma.$thematiquePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Thematiques that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {thematiqueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Thematiques
     * const thematiques = await prisma.thematique.findMany()
     * 
     * // Get first 10 Thematiques
     * const thematiques = await prisma.thematique.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const thematiqueWithIdOnly = await prisma.thematique.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends thematiqueFindManyArgs>(args?: SelectSubset<T, thematiqueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$thematiquePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Thematique.
     * @param {thematiqueCreateArgs} args - Arguments to create a Thematique.
     * @example
     * // Create one Thematique
     * const Thematique = await prisma.thematique.create({
     *   data: {
     *     // ... data to create a Thematique
     *   }
     * })
     * 
     */
    create<T extends thematiqueCreateArgs>(args: SelectSubset<T, thematiqueCreateArgs<ExtArgs>>): Prisma__thematiqueClient<$Result.GetResult<Prisma.$thematiquePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Thematiques.
     * @param {thematiqueCreateManyArgs} args - Arguments to create many Thematiques.
     * @example
     * // Create many Thematiques
     * const thematique = await prisma.thematique.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends thematiqueCreateManyArgs>(args?: SelectSubset<T, thematiqueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Thematiques and returns the data saved in the database.
     * @param {thematiqueCreateManyAndReturnArgs} args - Arguments to create many Thematiques.
     * @example
     * // Create many Thematiques
     * const thematique = await prisma.thematique.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Thematiques and only return the `id`
     * const thematiqueWithIdOnly = await prisma.thematique.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends thematiqueCreateManyAndReturnArgs>(args?: SelectSubset<T, thematiqueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$thematiquePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Thematique.
     * @param {thematiqueDeleteArgs} args - Arguments to delete one Thematique.
     * @example
     * // Delete one Thematique
     * const Thematique = await prisma.thematique.delete({
     *   where: {
     *     // ... filter to delete one Thematique
     *   }
     * })
     * 
     */
    delete<T extends thematiqueDeleteArgs>(args: SelectSubset<T, thematiqueDeleteArgs<ExtArgs>>): Prisma__thematiqueClient<$Result.GetResult<Prisma.$thematiquePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Thematique.
     * @param {thematiqueUpdateArgs} args - Arguments to update one Thematique.
     * @example
     * // Update one Thematique
     * const thematique = await prisma.thematique.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends thematiqueUpdateArgs>(args: SelectSubset<T, thematiqueUpdateArgs<ExtArgs>>): Prisma__thematiqueClient<$Result.GetResult<Prisma.$thematiquePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Thematiques.
     * @param {thematiqueDeleteManyArgs} args - Arguments to filter Thematiques to delete.
     * @example
     * // Delete a few Thematiques
     * const { count } = await prisma.thematique.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends thematiqueDeleteManyArgs>(args?: SelectSubset<T, thematiqueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Thematiques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {thematiqueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Thematiques
     * const thematique = await prisma.thematique.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends thematiqueUpdateManyArgs>(args: SelectSubset<T, thematiqueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Thematiques and returns the data updated in the database.
     * @param {thematiqueUpdateManyAndReturnArgs} args - Arguments to update many Thematiques.
     * @example
     * // Update many Thematiques
     * const thematique = await prisma.thematique.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Thematiques and only return the `id`
     * const thematiqueWithIdOnly = await prisma.thematique.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends thematiqueUpdateManyAndReturnArgs>(args: SelectSubset<T, thematiqueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$thematiquePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Thematique.
     * @param {thematiqueUpsertArgs} args - Arguments to update or create a Thematique.
     * @example
     * // Update or create a Thematique
     * const thematique = await prisma.thematique.upsert({
     *   create: {
     *     // ... data to create a Thematique
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Thematique we want to update
     *   }
     * })
     */
    upsert<T extends thematiqueUpsertArgs>(args: SelectSubset<T, thematiqueUpsertArgs<ExtArgs>>): Prisma__thematiqueClient<$Result.GetResult<Prisma.$thematiquePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Thematiques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {thematiqueCountArgs} args - Arguments to filter Thematiques to count.
     * @example
     * // Count the number of Thematiques
     * const count = await prisma.thematique.count({
     *   where: {
     *     // ... the filter for the Thematiques we want to count
     *   }
     * })
    **/
    count<T extends thematiqueCountArgs>(
      args?: Subset<T, thematiqueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ThematiqueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Thematique.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThematiqueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ThematiqueAggregateArgs>(args: Subset<T, ThematiqueAggregateArgs>): Prisma.PrismaPromise<GetThematiqueAggregateType<T>>

    /**
     * Group by Thematique.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {thematiqueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends thematiqueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: thematiqueGroupByArgs['orderBy'] }
        : { orderBy?: thematiqueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, thematiqueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetThematiqueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the thematique model
   */
  readonly fields: thematiqueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for thematique.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__thematiqueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the thematique model
   */
  interface thematiqueFieldRefs {
    readonly id: FieldRef<"thematique", 'BigInt'>
    readonly event_timestamp: FieldRef<"thematique", 'DateTime'>
    readonly properties: FieldRef<"thematique", 'Json'>
    readonly distinct_id: FieldRef<"thematique", 'String'>
    readonly session_id: FieldRef<"thematique", 'String'>
    readonly person_id: FieldRef<"thematique", 'String'>
    readonly thematique: FieldRef<"thematique", 'String'>
    readonly ingested_at: FieldRef<"thematique", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * thematique findUnique
   */
  export type thematiqueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the thematique
     */
    select?: thematiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the thematique
     */
    omit?: thematiqueOmit<ExtArgs> | null
    /**
     * Filter, which thematique to fetch.
     */
    where: thematiqueWhereUniqueInput
  }

  /**
   * thematique findUniqueOrThrow
   */
  export type thematiqueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the thematique
     */
    select?: thematiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the thematique
     */
    omit?: thematiqueOmit<ExtArgs> | null
    /**
     * Filter, which thematique to fetch.
     */
    where: thematiqueWhereUniqueInput
  }

  /**
   * thematique findFirst
   */
  export type thematiqueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the thematique
     */
    select?: thematiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the thematique
     */
    omit?: thematiqueOmit<ExtArgs> | null
    /**
     * Filter, which thematique to fetch.
     */
    where?: thematiqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of thematiques to fetch.
     */
    orderBy?: thematiqueOrderByWithRelationInput | thematiqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for thematiques.
     */
    cursor?: thematiqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` thematiques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` thematiques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of thematiques.
     */
    distinct?: ThematiqueScalarFieldEnum | ThematiqueScalarFieldEnum[]
  }

  /**
   * thematique findFirstOrThrow
   */
  export type thematiqueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the thematique
     */
    select?: thematiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the thematique
     */
    omit?: thematiqueOmit<ExtArgs> | null
    /**
     * Filter, which thematique to fetch.
     */
    where?: thematiqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of thematiques to fetch.
     */
    orderBy?: thematiqueOrderByWithRelationInput | thematiqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for thematiques.
     */
    cursor?: thematiqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` thematiques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` thematiques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of thematiques.
     */
    distinct?: ThematiqueScalarFieldEnum | ThematiqueScalarFieldEnum[]
  }

  /**
   * thematique findMany
   */
  export type thematiqueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the thematique
     */
    select?: thematiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the thematique
     */
    omit?: thematiqueOmit<ExtArgs> | null
    /**
     * Filter, which thematiques to fetch.
     */
    where?: thematiqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of thematiques to fetch.
     */
    orderBy?: thematiqueOrderByWithRelationInput | thematiqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing thematiques.
     */
    cursor?: thematiqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` thematiques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` thematiques.
     */
    skip?: number
    distinct?: ThematiqueScalarFieldEnum | ThematiqueScalarFieldEnum[]
  }

  /**
   * thematique create
   */
  export type thematiqueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the thematique
     */
    select?: thematiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the thematique
     */
    omit?: thematiqueOmit<ExtArgs> | null
    /**
     * The data needed to create a thematique.
     */
    data: XOR<thematiqueCreateInput, thematiqueUncheckedCreateInput>
  }

  /**
   * thematique createMany
   */
  export type thematiqueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many thematiques.
     */
    data: thematiqueCreateManyInput | thematiqueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * thematique createManyAndReturn
   */
  export type thematiqueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the thematique
     */
    select?: thematiqueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the thematique
     */
    omit?: thematiqueOmit<ExtArgs> | null
    /**
     * The data used to create many thematiques.
     */
    data: thematiqueCreateManyInput | thematiqueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * thematique update
   */
  export type thematiqueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the thematique
     */
    select?: thematiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the thematique
     */
    omit?: thematiqueOmit<ExtArgs> | null
    /**
     * The data needed to update a thematique.
     */
    data: XOR<thematiqueUpdateInput, thematiqueUncheckedUpdateInput>
    /**
     * Choose, which thematique to update.
     */
    where: thematiqueWhereUniqueInput
  }

  /**
   * thematique updateMany
   */
  export type thematiqueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update thematiques.
     */
    data: XOR<thematiqueUpdateManyMutationInput, thematiqueUncheckedUpdateManyInput>
    /**
     * Filter which thematiques to update
     */
    where?: thematiqueWhereInput
    /**
     * Limit how many thematiques to update.
     */
    limit?: number
  }

  /**
   * thematique updateManyAndReturn
   */
  export type thematiqueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the thematique
     */
    select?: thematiqueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the thematique
     */
    omit?: thematiqueOmit<ExtArgs> | null
    /**
     * The data used to update thematiques.
     */
    data: XOR<thematiqueUpdateManyMutationInput, thematiqueUncheckedUpdateManyInput>
    /**
     * Filter which thematiques to update
     */
    where?: thematiqueWhereInput
    /**
     * Limit how many thematiques to update.
     */
    limit?: number
  }

  /**
   * thematique upsert
   */
  export type thematiqueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the thematique
     */
    select?: thematiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the thematique
     */
    omit?: thematiqueOmit<ExtArgs> | null
    /**
     * The filter to search for the thematique to update in case it exists.
     */
    where: thematiqueWhereUniqueInput
    /**
     * In case the thematique found by the `where` argument doesn't exist, create a new thematique with this data.
     */
    create: XOR<thematiqueCreateInput, thematiqueUncheckedCreateInput>
    /**
     * In case the thematique was found with the provided `where` argument, update it with this data.
     */
    update: XOR<thematiqueUpdateInput, thematiqueUncheckedUpdateInput>
  }

  /**
   * thematique delete
   */
  export type thematiqueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the thematique
     */
    select?: thematiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the thematique
     */
    omit?: thematiqueOmit<ExtArgs> | null
    /**
     * Filter which thematique to delete.
     */
    where: thematiqueWhereUniqueInput
  }

  /**
   * thematique deleteMany
   */
  export type thematiqueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which thematiques to delete
     */
    where?: thematiqueWhereInput
    /**
     * Limit how many thematiques to delete.
     */
    limit?: number
  }

  /**
   * thematique without action
   */
  export type thematiqueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the thematique
     */
    select?: thematiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the thematique
     */
    omit?: thematiqueOmit<ExtArgs> | null
  }


  /**
   * Model agriculture
   */

  export type AggregateAgriculture = {
    _count: AgricultureCountAggregateOutputType | null
    _avg: AgricultureAvgAggregateOutputType | null
    _sum: AgricultureSumAggregateOutputType | null
    _min: AgricultureMinAggregateOutputType | null
    _max: AgricultureMaxAggregateOutputType | null
  }

  export type AgricultureAvgAggregateOutputType = {
    index: number | null
    region: number | null
    part_irr_SAU_2020: number | null
  }

  export type AgricultureSumAggregateOutputType = {
    index: number | null
    region: number | null
    part_irr_SAU_2020: number | null
  }

  export type AgricultureMinAggregateOutputType = {
    index: number | null
    code_geographique: string | null
    libelle_geographique: string | null
    epci: string | null
    libelle_epci: string | null
    departement: string | null
    libelle_departement: string | null
    region: number | null
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
    part_irr_SAU_2020: number | null
    otex_12_postes: string | null
  }

  export type AgricultureMaxAggregateOutputType = {
    index: number | null
    code_geographique: string | null
    libelle_geographique: string | null
    epci: string | null
    libelle_epci: string | null
    departement: string | null
    libelle_departement: string | null
    region: number | null
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
    part_irr_SAU_2020: number | null
    otex_12_postes: string | null
  }

  export type AgricultureCountAggregateOutputType = {
    index: number
    code_geographique: number
    libelle_geographique: number
    epci: number
    libelle_epci: number
    departement: number
    libelle_departement: number
    region: number
    ept: number
    libelle_petr: number
    code_pnr: number
    libelle_pnr: number
    part_irr_SAU_2020: number
    otex_12_postes: number
    _all: number
  }


  export type AgricultureAvgAggregateInputType = {
    index?: true
    region?: true
    part_irr_SAU_2020?: true
  }

  export type AgricultureSumAggregateInputType = {
    index?: true
    region?: true
    part_irr_SAU_2020?: true
  }

  export type AgricultureMinAggregateInputType = {
    index?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
    part_irr_SAU_2020?: true
    otex_12_postes?: true
  }

  export type AgricultureMaxAggregateInputType = {
    index?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
    part_irr_SAU_2020?: true
    otex_12_postes?: true
  }

  export type AgricultureCountAggregateInputType = {
    index?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
    part_irr_SAU_2020?: true
    otex_12_postes?: true
    _all?: true
  }

  export type AgricultureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which agriculture to aggregate.
     */
    where?: agricultureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agricultures to fetch.
     */
    orderBy?: agricultureOrderByWithRelationInput | agricultureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: agricultureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agricultures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agricultures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned agricultures
    **/
    _count?: true | AgricultureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgricultureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgricultureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgricultureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgricultureMaxAggregateInputType
  }

  export type GetAgricultureAggregateType<T extends AgricultureAggregateArgs> = {
        [P in keyof T & keyof AggregateAgriculture]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgriculture[P]>
      : GetScalarType<T[P], AggregateAgriculture[P]>
  }




  export type agricultureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: agricultureWhereInput
    orderBy?: agricultureOrderByWithAggregationInput | agricultureOrderByWithAggregationInput[]
    by: AgricultureScalarFieldEnum[] | AgricultureScalarFieldEnum
    having?: agricultureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgricultureCountAggregateInputType | true
    _avg?: AgricultureAvgAggregateInputType
    _sum?: AgricultureSumAggregateInputType
    _min?: AgricultureMinAggregateInputType
    _max?: AgricultureMaxAggregateInputType
  }

  export type AgricultureGroupByOutputType = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
    part_irr_SAU_2020: number | null
    otex_12_postes: string
    _count: AgricultureCountAggregateOutputType | null
    _avg: AgricultureAvgAggregateOutputType | null
    _sum: AgricultureSumAggregateOutputType | null
    _min: AgricultureMinAggregateOutputType | null
    _max: AgricultureMaxAggregateOutputType | null
  }

  type GetAgricultureGroupByPayload<T extends agricultureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgricultureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgricultureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgricultureGroupByOutputType[P]>
            : GetScalarType<T[P], AgricultureGroupByOutputType[P]>
        }
      >
    >


  export type agricultureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    part_irr_SAU_2020?: boolean
    otex_12_postes?: boolean
  }, ExtArgs["result"]["agriculture"]>

  export type agricultureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    part_irr_SAU_2020?: boolean
    otex_12_postes?: boolean
  }, ExtArgs["result"]["agriculture"]>

  export type agricultureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    part_irr_SAU_2020?: boolean
    otex_12_postes?: boolean
  }, ExtArgs["result"]["agriculture"]>

  export type agricultureSelectScalar = {
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    part_irr_SAU_2020?: boolean
    otex_12_postes?: boolean
  }

  export type agricultureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"index" | "code_geographique" | "libelle_geographique" | "epci" | "libelle_epci" | "departement" | "libelle_departement" | "region" | "ept" | "libelle_petr" | "code_pnr" | "libelle_pnr" | "part_irr_SAU_2020" | "otex_12_postes", ExtArgs["result"]["agriculture"]>

  export type $agriculturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "agriculture"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      index: number
      code_geographique: string
      libelle_geographique: string
      epci: string
      libelle_epci: string
      departement: string
      libelle_departement: string
      region: number
      ept: string | null
      libelle_petr: string | null
      code_pnr: string | null
      libelle_pnr: string | null
      part_irr_SAU_2020: number | null
      otex_12_postes: string
    }, ExtArgs["result"]["agriculture"]>
    composites: {}
  }

  type agricultureGetPayload<S extends boolean | null | undefined | agricultureDefaultArgs> = $Result.GetResult<Prisma.$agriculturePayload, S>

  type agricultureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<agricultureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgricultureCountAggregateInputType | true
    }

  export interface agricultureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['agriculture'], meta: { name: 'agriculture' } }
    /**
     * Find zero or one Agriculture that matches the filter.
     * @param {agricultureFindUniqueArgs} args - Arguments to find a Agriculture
     * @example
     * // Get one Agriculture
     * const agriculture = await prisma.agriculture.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends agricultureFindUniqueArgs>(args: SelectSubset<T, agricultureFindUniqueArgs<ExtArgs>>): Prisma__agricultureClient<$Result.GetResult<Prisma.$agriculturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Agriculture that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {agricultureFindUniqueOrThrowArgs} args - Arguments to find a Agriculture
     * @example
     * // Get one Agriculture
     * const agriculture = await prisma.agriculture.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends agricultureFindUniqueOrThrowArgs>(args: SelectSubset<T, agricultureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__agricultureClient<$Result.GetResult<Prisma.$agriculturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agriculture that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agricultureFindFirstArgs} args - Arguments to find a Agriculture
     * @example
     * // Get one Agriculture
     * const agriculture = await prisma.agriculture.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends agricultureFindFirstArgs>(args?: SelectSubset<T, agricultureFindFirstArgs<ExtArgs>>): Prisma__agricultureClient<$Result.GetResult<Prisma.$agriculturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agriculture that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agricultureFindFirstOrThrowArgs} args - Arguments to find a Agriculture
     * @example
     * // Get one Agriculture
     * const agriculture = await prisma.agriculture.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends agricultureFindFirstOrThrowArgs>(args?: SelectSubset<T, agricultureFindFirstOrThrowArgs<ExtArgs>>): Prisma__agricultureClient<$Result.GetResult<Prisma.$agriculturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agricultures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agricultureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agricultures
     * const agricultures = await prisma.agriculture.findMany()
     * 
     * // Get first 10 Agricultures
     * const agricultures = await prisma.agriculture.findMany({ take: 10 })
     * 
     * // Only select the `index`
     * const agricultureWithIndexOnly = await prisma.agriculture.findMany({ select: { index: true } })
     * 
     */
    findMany<T extends agricultureFindManyArgs>(args?: SelectSubset<T, agricultureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$agriculturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Agriculture.
     * @param {agricultureCreateArgs} args - Arguments to create a Agriculture.
     * @example
     * // Create one Agriculture
     * const Agriculture = await prisma.agriculture.create({
     *   data: {
     *     // ... data to create a Agriculture
     *   }
     * })
     * 
     */
    create<T extends agricultureCreateArgs>(args: SelectSubset<T, agricultureCreateArgs<ExtArgs>>): Prisma__agricultureClient<$Result.GetResult<Prisma.$agriculturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Agricultures.
     * @param {agricultureCreateManyArgs} args - Arguments to create many Agricultures.
     * @example
     * // Create many Agricultures
     * const agriculture = await prisma.agriculture.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends agricultureCreateManyArgs>(args?: SelectSubset<T, agricultureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Agricultures and returns the data saved in the database.
     * @param {agricultureCreateManyAndReturnArgs} args - Arguments to create many Agricultures.
     * @example
     * // Create many Agricultures
     * const agriculture = await prisma.agriculture.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Agricultures and only return the `index`
     * const agricultureWithIndexOnly = await prisma.agriculture.createManyAndReturn({
     *   select: { index: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends agricultureCreateManyAndReturnArgs>(args?: SelectSubset<T, agricultureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$agriculturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Agriculture.
     * @param {agricultureDeleteArgs} args - Arguments to delete one Agriculture.
     * @example
     * // Delete one Agriculture
     * const Agriculture = await prisma.agriculture.delete({
     *   where: {
     *     // ... filter to delete one Agriculture
     *   }
     * })
     * 
     */
    delete<T extends agricultureDeleteArgs>(args: SelectSubset<T, agricultureDeleteArgs<ExtArgs>>): Prisma__agricultureClient<$Result.GetResult<Prisma.$agriculturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Agriculture.
     * @param {agricultureUpdateArgs} args - Arguments to update one Agriculture.
     * @example
     * // Update one Agriculture
     * const agriculture = await prisma.agriculture.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends agricultureUpdateArgs>(args: SelectSubset<T, agricultureUpdateArgs<ExtArgs>>): Prisma__agricultureClient<$Result.GetResult<Prisma.$agriculturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Agricultures.
     * @param {agricultureDeleteManyArgs} args - Arguments to filter Agricultures to delete.
     * @example
     * // Delete a few Agricultures
     * const { count } = await prisma.agriculture.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends agricultureDeleteManyArgs>(args?: SelectSubset<T, agricultureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agricultures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agricultureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agricultures
     * const agriculture = await prisma.agriculture.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends agricultureUpdateManyArgs>(args: SelectSubset<T, agricultureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agricultures and returns the data updated in the database.
     * @param {agricultureUpdateManyAndReturnArgs} args - Arguments to update many Agricultures.
     * @example
     * // Update many Agricultures
     * const agriculture = await prisma.agriculture.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Agricultures and only return the `index`
     * const agricultureWithIndexOnly = await prisma.agriculture.updateManyAndReturn({
     *   select: { index: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends agricultureUpdateManyAndReturnArgs>(args: SelectSubset<T, agricultureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$agriculturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Agriculture.
     * @param {agricultureUpsertArgs} args - Arguments to update or create a Agriculture.
     * @example
     * // Update or create a Agriculture
     * const agriculture = await prisma.agriculture.upsert({
     *   create: {
     *     // ... data to create a Agriculture
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agriculture we want to update
     *   }
     * })
     */
    upsert<T extends agricultureUpsertArgs>(args: SelectSubset<T, agricultureUpsertArgs<ExtArgs>>): Prisma__agricultureClient<$Result.GetResult<Prisma.$agriculturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Agricultures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agricultureCountArgs} args - Arguments to filter Agricultures to count.
     * @example
     * // Count the number of Agricultures
     * const count = await prisma.agriculture.count({
     *   where: {
     *     // ... the filter for the Agricultures we want to count
     *   }
     * })
    **/
    count<T extends agricultureCountArgs>(
      args?: Subset<T, agricultureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgricultureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agriculture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgricultureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgricultureAggregateArgs>(args: Subset<T, AgricultureAggregateArgs>): Prisma.PrismaPromise<GetAgricultureAggregateType<T>>

    /**
     * Group by Agriculture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agricultureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends agricultureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: agricultureGroupByArgs['orderBy'] }
        : { orderBy?: agricultureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, agricultureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgricultureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the agriculture model
   */
  readonly fields: agricultureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for agriculture.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__agricultureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the agriculture model
   */
  interface agricultureFieldRefs {
    readonly index: FieldRef<"agriculture", 'Int'>
    readonly code_geographique: FieldRef<"agriculture", 'String'>
    readonly libelle_geographique: FieldRef<"agriculture", 'String'>
    readonly epci: FieldRef<"agriculture", 'String'>
    readonly libelle_epci: FieldRef<"agriculture", 'String'>
    readonly departement: FieldRef<"agriculture", 'String'>
    readonly libelle_departement: FieldRef<"agriculture", 'String'>
    readonly region: FieldRef<"agriculture", 'Float'>
    readonly ept: FieldRef<"agriculture", 'String'>
    readonly libelle_petr: FieldRef<"agriculture", 'String'>
    readonly code_pnr: FieldRef<"agriculture", 'String'>
    readonly libelle_pnr: FieldRef<"agriculture", 'String'>
    readonly part_irr_SAU_2020: FieldRef<"agriculture", 'Float'>
    readonly otex_12_postes: FieldRef<"agriculture", 'String'>
  }
    

  // Custom InputTypes
  /**
   * agriculture findUnique
   */
  export type agricultureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agriculture
     */
    select?: agricultureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agriculture
     */
    omit?: agricultureOmit<ExtArgs> | null
    /**
     * Filter, which agriculture to fetch.
     */
    where: agricultureWhereUniqueInput
  }

  /**
   * agriculture findUniqueOrThrow
   */
  export type agricultureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agriculture
     */
    select?: agricultureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agriculture
     */
    omit?: agricultureOmit<ExtArgs> | null
    /**
     * Filter, which agriculture to fetch.
     */
    where: agricultureWhereUniqueInput
  }

  /**
   * agriculture findFirst
   */
  export type agricultureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agriculture
     */
    select?: agricultureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agriculture
     */
    omit?: agricultureOmit<ExtArgs> | null
    /**
     * Filter, which agriculture to fetch.
     */
    where?: agricultureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agricultures to fetch.
     */
    orderBy?: agricultureOrderByWithRelationInput | agricultureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for agricultures.
     */
    cursor?: agricultureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agricultures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agricultures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of agricultures.
     */
    distinct?: AgricultureScalarFieldEnum | AgricultureScalarFieldEnum[]
  }

  /**
   * agriculture findFirstOrThrow
   */
  export type agricultureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agriculture
     */
    select?: agricultureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agriculture
     */
    omit?: agricultureOmit<ExtArgs> | null
    /**
     * Filter, which agriculture to fetch.
     */
    where?: agricultureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agricultures to fetch.
     */
    orderBy?: agricultureOrderByWithRelationInput | agricultureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for agricultures.
     */
    cursor?: agricultureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agricultures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agricultures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of agricultures.
     */
    distinct?: AgricultureScalarFieldEnum | AgricultureScalarFieldEnum[]
  }

  /**
   * agriculture findMany
   */
  export type agricultureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agriculture
     */
    select?: agricultureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agriculture
     */
    omit?: agricultureOmit<ExtArgs> | null
    /**
     * Filter, which agricultures to fetch.
     */
    where?: agricultureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agricultures to fetch.
     */
    orderBy?: agricultureOrderByWithRelationInput | agricultureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing agricultures.
     */
    cursor?: agricultureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agricultures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agricultures.
     */
    skip?: number
    distinct?: AgricultureScalarFieldEnum | AgricultureScalarFieldEnum[]
  }

  /**
   * agriculture create
   */
  export type agricultureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agriculture
     */
    select?: agricultureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agriculture
     */
    omit?: agricultureOmit<ExtArgs> | null
    /**
     * The data needed to create a agriculture.
     */
    data: XOR<agricultureCreateInput, agricultureUncheckedCreateInput>
  }

  /**
   * agriculture createMany
   */
  export type agricultureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many agricultures.
     */
    data: agricultureCreateManyInput | agricultureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * agriculture createManyAndReturn
   */
  export type agricultureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agriculture
     */
    select?: agricultureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the agriculture
     */
    omit?: agricultureOmit<ExtArgs> | null
    /**
     * The data used to create many agricultures.
     */
    data: agricultureCreateManyInput | agricultureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * agriculture update
   */
  export type agricultureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agriculture
     */
    select?: agricultureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agriculture
     */
    omit?: agricultureOmit<ExtArgs> | null
    /**
     * The data needed to update a agriculture.
     */
    data: XOR<agricultureUpdateInput, agricultureUncheckedUpdateInput>
    /**
     * Choose, which agriculture to update.
     */
    where: agricultureWhereUniqueInput
  }

  /**
   * agriculture updateMany
   */
  export type agricultureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update agricultures.
     */
    data: XOR<agricultureUpdateManyMutationInput, agricultureUncheckedUpdateManyInput>
    /**
     * Filter which agricultures to update
     */
    where?: agricultureWhereInput
    /**
     * Limit how many agricultures to update.
     */
    limit?: number
  }

  /**
   * agriculture updateManyAndReturn
   */
  export type agricultureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agriculture
     */
    select?: agricultureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the agriculture
     */
    omit?: agricultureOmit<ExtArgs> | null
    /**
     * The data used to update agricultures.
     */
    data: XOR<agricultureUpdateManyMutationInput, agricultureUncheckedUpdateManyInput>
    /**
     * Filter which agricultures to update
     */
    where?: agricultureWhereInput
    /**
     * Limit how many agricultures to update.
     */
    limit?: number
  }

  /**
   * agriculture upsert
   */
  export type agricultureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agriculture
     */
    select?: agricultureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agriculture
     */
    omit?: agricultureOmit<ExtArgs> | null
    /**
     * The filter to search for the agriculture to update in case it exists.
     */
    where: agricultureWhereUniqueInput
    /**
     * In case the agriculture found by the `where` argument doesn't exist, create a new agriculture with this data.
     */
    create: XOR<agricultureCreateInput, agricultureUncheckedCreateInput>
    /**
     * In case the agriculture was found with the provided `where` argument, update it with this data.
     */
    update: XOR<agricultureUpdateInput, agricultureUncheckedUpdateInput>
  }

  /**
   * agriculture delete
   */
  export type agricultureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agriculture
     */
    select?: agricultureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agriculture
     */
    omit?: agricultureOmit<ExtArgs> | null
    /**
     * Filter which agriculture to delete.
     */
    where: agricultureWhereUniqueInput
  }

  /**
   * agriculture deleteMany
   */
  export type agricultureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which agricultures to delete
     */
    where?: agricultureWhereInput
    /**
     * Limit how many agricultures to delete.
     */
    limit?: number
  }

  /**
   * agriculture without action
   */
  export type agricultureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agriculture
     */
    select?: agricultureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agriculture
     */
    omit?: agricultureOmit<ExtArgs> | null
  }


  /**
   * Model agriculture_bio
   */

  export type AggregateAgriculture_bio = {
    _count: Agriculture_bioCountAggregateOutputType | null
    _avg: Agriculture_bioAvgAggregateOutputType | null
    _sum: Agriculture_bioSumAggregateOutputType | null
    _min: Agriculture_bioMinAggregateOutputType | null
    _max: Agriculture_bioMaxAggregateOutputType | null
  }

  export type Agriculture_bioAvgAggregateOutputType = {
    index: number | null
    surface_2023: number | null
    surface_2022: number | null
    surface_2021: number | null
    surface_2020: number | null
    surface_2019: number | null
    surface_2018: number | null
    surface_2017: number | null
    surface_2016: number | null
    surface_2015: number | null
    surface_2014: number | null
    surface_2013: number | null
    surface_2012: number | null
    surface_2011: number | null
    surface_2010: number | null
    surface_2009: number | null
    surface_2008: number | null
    nombre_2023: number | null
    nombre_2022: number | null
    nombre_2021: number | null
    nombre_2020: number | null
    nombre_2019: number | null
    nombre_2018: number | null
    nombre_2017: number | null
    nombre_2016: number | null
    nombre_2015: number | null
    nombre_2014: number | null
    nombre_2013: number | null
    nombre_2012: number | null
    nombre_2011: number | null
    nombre_2010: number | null
    nombre_2009: number | null
    nombre_2008: number | null
  }

  export type Agriculture_bioSumAggregateOutputType = {
    index: number | null
    surface_2023: number | null
    surface_2022: number | null
    surface_2021: number | null
    surface_2020: number | null
    surface_2019: number | null
    surface_2018: number | null
    surface_2017: number | null
    surface_2016: number | null
    surface_2015: number | null
    surface_2014: number | null
    surface_2013: number | null
    surface_2012: number | null
    surface_2011: number | null
    surface_2010: number | null
    surface_2009: number | null
    surface_2008: number | null
    nombre_2023: number | null
    nombre_2022: number | null
    nombre_2021: number | null
    nombre_2020: number | null
    nombre_2019: number | null
    nombre_2018: number | null
    nombre_2017: number | null
    nombre_2016: number | null
    nombre_2015: number | null
    nombre_2014: number | null
    nombre_2013: number | null
    nombre_2012: number | null
    nombre_2011: number | null
    nombre_2010: number | null
    nombre_2009: number | null
    nombre_2008: number | null
  }

  export type Agriculture_bioMinAggregateOutputType = {
    index: number | null
    epci: string | null
    libelle_epci: string | null
    VARIABLE: string | null
    LIBELLE_SOUS_CHAMP: string | null
    surface_2023: number | null
    surface_2022: number | null
    surface_2021: number | null
    surface_2020: number | null
    surface_2019: number | null
    surface_2018: number | null
    surface_2017: number | null
    surface_2016: number | null
    surface_2015: number | null
    surface_2014: number | null
    surface_2013: number | null
    surface_2012: number | null
    surface_2011: number | null
    surface_2010: number | null
    surface_2009: number | null
    surface_2008: number | null
    nombre_2023: number | null
    nombre_2022: number | null
    nombre_2021: number | null
    nombre_2020: number | null
    nombre_2019: number | null
    nombre_2018: number | null
    nombre_2017: number | null
    nombre_2016: number | null
    nombre_2015: number | null
    nombre_2014: number | null
    nombre_2013: number | null
    nombre_2012: number | null
    nombre_2011: number | null
    nombre_2010: number | null
    nombre_2009: number | null
    nombre_2008: number | null
  }

  export type Agriculture_bioMaxAggregateOutputType = {
    index: number | null
    epci: string | null
    libelle_epci: string | null
    VARIABLE: string | null
    LIBELLE_SOUS_CHAMP: string | null
    surface_2023: number | null
    surface_2022: number | null
    surface_2021: number | null
    surface_2020: number | null
    surface_2019: number | null
    surface_2018: number | null
    surface_2017: number | null
    surface_2016: number | null
    surface_2015: number | null
    surface_2014: number | null
    surface_2013: number | null
    surface_2012: number | null
    surface_2011: number | null
    surface_2010: number | null
    surface_2009: number | null
    surface_2008: number | null
    nombre_2023: number | null
    nombre_2022: number | null
    nombre_2021: number | null
    nombre_2020: number | null
    nombre_2019: number | null
    nombre_2018: number | null
    nombre_2017: number | null
    nombre_2016: number | null
    nombre_2015: number | null
    nombre_2014: number | null
    nombre_2013: number | null
    nombre_2012: number | null
    nombre_2011: number | null
    nombre_2010: number | null
    nombre_2009: number | null
    nombre_2008: number | null
  }

  export type Agriculture_bioCountAggregateOutputType = {
    index: number
    epci: number
    libelle_epci: number
    VARIABLE: number
    LIBELLE_SOUS_CHAMP: number
    surface_2023: number
    surface_2022: number
    surface_2021: number
    surface_2020: number
    surface_2019: number
    surface_2018: number
    surface_2017: number
    surface_2016: number
    surface_2015: number
    surface_2014: number
    surface_2013: number
    surface_2012: number
    surface_2011: number
    surface_2010: number
    surface_2009: number
    surface_2008: number
    nombre_2023: number
    nombre_2022: number
    nombre_2021: number
    nombre_2020: number
    nombre_2019: number
    nombre_2018: number
    nombre_2017: number
    nombre_2016: number
    nombre_2015: number
    nombre_2014: number
    nombre_2013: number
    nombre_2012: number
    nombre_2011: number
    nombre_2010: number
    nombre_2009: number
    nombre_2008: number
    _all: number
  }


  export type Agriculture_bioAvgAggregateInputType = {
    index?: true
    surface_2023?: true
    surface_2022?: true
    surface_2021?: true
    surface_2020?: true
    surface_2019?: true
    surface_2018?: true
    surface_2017?: true
    surface_2016?: true
    surface_2015?: true
    surface_2014?: true
    surface_2013?: true
    surface_2012?: true
    surface_2011?: true
    surface_2010?: true
    surface_2009?: true
    surface_2008?: true
    nombre_2023?: true
    nombre_2022?: true
    nombre_2021?: true
    nombre_2020?: true
    nombre_2019?: true
    nombre_2018?: true
    nombre_2017?: true
    nombre_2016?: true
    nombre_2015?: true
    nombre_2014?: true
    nombre_2013?: true
    nombre_2012?: true
    nombre_2011?: true
    nombre_2010?: true
    nombre_2009?: true
    nombre_2008?: true
  }

  export type Agriculture_bioSumAggregateInputType = {
    index?: true
    surface_2023?: true
    surface_2022?: true
    surface_2021?: true
    surface_2020?: true
    surface_2019?: true
    surface_2018?: true
    surface_2017?: true
    surface_2016?: true
    surface_2015?: true
    surface_2014?: true
    surface_2013?: true
    surface_2012?: true
    surface_2011?: true
    surface_2010?: true
    surface_2009?: true
    surface_2008?: true
    nombre_2023?: true
    nombre_2022?: true
    nombre_2021?: true
    nombre_2020?: true
    nombre_2019?: true
    nombre_2018?: true
    nombre_2017?: true
    nombre_2016?: true
    nombre_2015?: true
    nombre_2014?: true
    nombre_2013?: true
    nombre_2012?: true
    nombre_2011?: true
    nombre_2010?: true
    nombre_2009?: true
    nombre_2008?: true
  }

  export type Agriculture_bioMinAggregateInputType = {
    index?: true
    epci?: true
    libelle_epci?: true
    VARIABLE?: true
    LIBELLE_SOUS_CHAMP?: true
    surface_2023?: true
    surface_2022?: true
    surface_2021?: true
    surface_2020?: true
    surface_2019?: true
    surface_2018?: true
    surface_2017?: true
    surface_2016?: true
    surface_2015?: true
    surface_2014?: true
    surface_2013?: true
    surface_2012?: true
    surface_2011?: true
    surface_2010?: true
    surface_2009?: true
    surface_2008?: true
    nombre_2023?: true
    nombre_2022?: true
    nombre_2021?: true
    nombre_2020?: true
    nombre_2019?: true
    nombre_2018?: true
    nombre_2017?: true
    nombre_2016?: true
    nombre_2015?: true
    nombre_2014?: true
    nombre_2013?: true
    nombre_2012?: true
    nombre_2011?: true
    nombre_2010?: true
    nombre_2009?: true
    nombre_2008?: true
  }

  export type Agriculture_bioMaxAggregateInputType = {
    index?: true
    epci?: true
    libelle_epci?: true
    VARIABLE?: true
    LIBELLE_SOUS_CHAMP?: true
    surface_2023?: true
    surface_2022?: true
    surface_2021?: true
    surface_2020?: true
    surface_2019?: true
    surface_2018?: true
    surface_2017?: true
    surface_2016?: true
    surface_2015?: true
    surface_2014?: true
    surface_2013?: true
    surface_2012?: true
    surface_2011?: true
    surface_2010?: true
    surface_2009?: true
    surface_2008?: true
    nombre_2023?: true
    nombre_2022?: true
    nombre_2021?: true
    nombre_2020?: true
    nombre_2019?: true
    nombre_2018?: true
    nombre_2017?: true
    nombre_2016?: true
    nombre_2015?: true
    nombre_2014?: true
    nombre_2013?: true
    nombre_2012?: true
    nombre_2011?: true
    nombre_2010?: true
    nombre_2009?: true
    nombre_2008?: true
  }

  export type Agriculture_bioCountAggregateInputType = {
    index?: true
    epci?: true
    libelle_epci?: true
    VARIABLE?: true
    LIBELLE_SOUS_CHAMP?: true
    surface_2023?: true
    surface_2022?: true
    surface_2021?: true
    surface_2020?: true
    surface_2019?: true
    surface_2018?: true
    surface_2017?: true
    surface_2016?: true
    surface_2015?: true
    surface_2014?: true
    surface_2013?: true
    surface_2012?: true
    surface_2011?: true
    surface_2010?: true
    surface_2009?: true
    surface_2008?: true
    nombre_2023?: true
    nombre_2022?: true
    nombre_2021?: true
    nombre_2020?: true
    nombre_2019?: true
    nombre_2018?: true
    nombre_2017?: true
    nombre_2016?: true
    nombre_2015?: true
    nombre_2014?: true
    nombre_2013?: true
    nombre_2012?: true
    nombre_2011?: true
    nombre_2010?: true
    nombre_2009?: true
    nombre_2008?: true
    _all?: true
  }

  export type Agriculture_bioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which agriculture_bio to aggregate.
     */
    where?: agriculture_bioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agriculture_bios to fetch.
     */
    orderBy?: agriculture_bioOrderByWithRelationInput | agriculture_bioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: agriculture_bioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agriculture_bios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agriculture_bios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned agriculture_bios
    **/
    _count?: true | Agriculture_bioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Agriculture_bioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Agriculture_bioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Agriculture_bioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Agriculture_bioMaxAggregateInputType
  }

  export type GetAgriculture_bioAggregateType<T extends Agriculture_bioAggregateArgs> = {
        [P in keyof T & keyof AggregateAgriculture_bio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgriculture_bio[P]>
      : GetScalarType<T[P], AggregateAgriculture_bio[P]>
  }




  export type agriculture_bioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: agriculture_bioWhereInput
    orderBy?: agriculture_bioOrderByWithAggregationInput | agriculture_bioOrderByWithAggregationInput[]
    by: Agriculture_bioScalarFieldEnum[] | Agriculture_bioScalarFieldEnum
    having?: agriculture_bioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Agriculture_bioCountAggregateInputType | true
    _avg?: Agriculture_bioAvgAggregateInputType
    _sum?: Agriculture_bioSumAggregateInputType
    _min?: Agriculture_bioMinAggregateInputType
    _max?: Agriculture_bioMaxAggregateInputType
  }

  export type Agriculture_bioGroupByOutputType = {
    index: number
    epci: string
    libelle_epci: string
    VARIABLE: string
    LIBELLE_SOUS_CHAMP: string | null
    surface_2023: number | null
    surface_2022: number | null
    surface_2021: number | null
    surface_2020: number | null
    surface_2019: number | null
    surface_2018: number | null
    surface_2017: number | null
    surface_2016: number | null
    surface_2015: number | null
    surface_2014: number | null
    surface_2013: number | null
    surface_2012: number | null
    surface_2011: number | null
    surface_2010: number | null
    surface_2009: number | null
    surface_2008: number | null
    nombre_2023: number | null
    nombre_2022: number | null
    nombre_2021: number | null
    nombre_2020: number | null
    nombre_2019: number | null
    nombre_2018: number | null
    nombre_2017: number | null
    nombre_2016: number | null
    nombre_2015: number | null
    nombre_2014: number | null
    nombre_2013: number | null
    nombre_2012: number | null
    nombre_2011: number | null
    nombre_2010: number | null
    nombre_2009: number | null
    nombre_2008: number | null
    _count: Agriculture_bioCountAggregateOutputType | null
    _avg: Agriculture_bioAvgAggregateOutputType | null
    _sum: Agriculture_bioSumAggregateOutputType | null
    _min: Agriculture_bioMinAggregateOutputType | null
    _max: Agriculture_bioMaxAggregateOutputType | null
  }

  type GetAgriculture_bioGroupByPayload<T extends agriculture_bioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Agriculture_bioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Agriculture_bioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Agriculture_bioGroupByOutputType[P]>
            : GetScalarType<T[P], Agriculture_bioGroupByOutputType[P]>
        }
      >
    >


  export type agriculture_bioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    epci?: boolean
    libelle_epci?: boolean
    VARIABLE?: boolean
    LIBELLE_SOUS_CHAMP?: boolean
    surface_2023?: boolean
    surface_2022?: boolean
    surface_2021?: boolean
    surface_2020?: boolean
    surface_2019?: boolean
    surface_2018?: boolean
    surface_2017?: boolean
    surface_2016?: boolean
    surface_2015?: boolean
    surface_2014?: boolean
    surface_2013?: boolean
    surface_2012?: boolean
    surface_2011?: boolean
    surface_2010?: boolean
    surface_2009?: boolean
    surface_2008?: boolean
    nombre_2023?: boolean
    nombre_2022?: boolean
    nombre_2021?: boolean
    nombre_2020?: boolean
    nombre_2019?: boolean
    nombre_2018?: boolean
    nombre_2017?: boolean
    nombre_2016?: boolean
    nombre_2015?: boolean
    nombre_2014?: boolean
    nombre_2013?: boolean
    nombre_2012?: boolean
    nombre_2011?: boolean
    nombre_2010?: boolean
    nombre_2009?: boolean
    nombre_2008?: boolean
  }, ExtArgs["result"]["agriculture_bio"]>

  export type agriculture_bioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    epci?: boolean
    libelle_epci?: boolean
    VARIABLE?: boolean
    LIBELLE_SOUS_CHAMP?: boolean
    surface_2023?: boolean
    surface_2022?: boolean
    surface_2021?: boolean
    surface_2020?: boolean
    surface_2019?: boolean
    surface_2018?: boolean
    surface_2017?: boolean
    surface_2016?: boolean
    surface_2015?: boolean
    surface_2014?: boolean
    surface_2013?: boolean
    surface_2012?: boolean
    surface_2011?: boolean
    surface_2010?: boolean
    surface_2009?: boolean
    surface_2008?: boolean
    nombre_2023?: boolean
    nombre_2022?: boolean
    nombre_2021?: boolean
    nombre_2020?: boolean
    nombre_2019?: boolean
    nombre_2018?: boolean
    nombre_2017?: boolean
    nombre_2016?: boolean
    nombre_2015?: boolean
    nombre_2014?: boolean
    nombre_2013?: boolean
    nombre_2012?: boolean
    nombre_2011?: boolean
    nombre_2010?: boolean
    nombre_2009?: boolean
    nombre_2008?: boolean
  }, ExtArgs["result"]["agriculture_bio"]>

  export type agriculture_bioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    epci?: boolean
    libelle_epci?: boolean
    VARIABLE?: boolean
    LIBELLE_SOUS_CHAMP?: boolean
    surface_2023?: boolean
    surface_2022?: boolean
    surface_2021?: boolean
    surface_2020?: boolean
    surface_2019?: boolean
    surface_2018?: boolean
    surface_2017?: boolean
    surface_2016?: boolean
    surface_2015?: boolean
    surface_2014?: boolean
    surface_2013?: boolean
    surface_2012?: boolean
    surface_2011?: boolean
    surface_2010?: boolean
    surface_2009?: boolean
    surface_2008?: boolean
    nombre_2023?: boolean
    nombre_2022?: boolean
    nombre_2021?: boolean
    nombre_2020?: boolean
    nombre_2019?: boolean
    nombre_2018?: boolean
    nombre_2017?: boolean
    nombre_2016?: boolean
    nombre_2015?: boolean
    nombre_2014?: boolean
    nombre_2013?: boolean
    nombre_2012?: boolean
    nombre_2011?: boolean
    nombre_2010?: boolean
    nombre_2009?: boolean
    nombre_2008?: boolean
  }, ExtArgs["result"]["agriculture_bio"]>

  export type agriculture_bioSelectScalar = {
    index?: boolean
    epci?: boolean
    libelle_epci?: boolean
    VARIABLE?: boolean
    LIBELLE_SOUS_CHAMP?: boolean
    surface_2023?: boolean
    surface_2022?: boolean
    surface_2021?: boolean
    surface_2020?: boolean
    surface_2019?: boolean
    surface_2018?: boolean
    surface_2017?: boolean
    surface_2016?: boolean
    surface_2015?: boolean
    surface_2014?: boolean
    surface_2013?: boolean
    surface_2012?: boolean
    surface_2011?: boolean
    surface_2010?: boolean
    surface_2009?: boolean
    surface_2008?: boolean
    nombre_2023?: boolean
    nombre_2022?: boolean
    nombre_2021?: boolean
    nombre_2020?: boolean
    nombre_2019?: boolean
    nombre_2018?: boolean
    nombre_2017?: boolean
    nombre_2016?: boolean
    nombre_2015?: boolean
    nombre_2014?: boolean
    nombre_2013?: boolean
    nombre_2012?: boolean
    nombre_2011?: boolean
    nombre_2010?: boolean
    nombre_2009?: boolean
    nombre_2008?: boolean
  }

  export type agriculture_bioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"index" | "epci" | "libelle_epci" | "VARIABLE" | "LIBELLE_SOUS_CHAMP" | "surface_2023" | "surface_2022" | "surface_2021" | "surface_2020" | "surface_2019" | "surface_2018" | "surface_2017" | "surface_2016" | "surface_2015" | "surface_2014" | "surface_2013" | "surface_2012" | "surface_2011" | "surface_2010" | "surface_2009" | "surface_2008" | "nombre_2023" | "nombre_2022" | "nombre_2021" | "nombre_2020" | "nombre_2019" | "nombre_2018" | "nombre_2017" | "nombre_2016" | "nombre_2015" | "nombre_2014" | "nombre_2013" | "nombre_2012" | "nombre_2011" | "nombre_2010" | "nombre_2009" | "nombre_2008", ExtArgs["result"]["agriculture_bio"]>

  export type $agriculture_bioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "agriculture_bio"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      index: number
      epci: string
      libelle_epci: string
      VARIABLE: string
      LIBELLE_SOUS_CHAMP: string | null
      surface_2023: number | null
      surface_2022: number | null
      surface_2021: number | null
      surface_2020: number | null
      surface_2019: number | null
      surface_2018: number | null
      surface_2017: number | null
      surface_2016: number | null
      surface_2015: number | null
      surface_2014: number | null
      surface_2013: number | null
      surface_2012: number | null
      surface_2011: number | null
      surface_2010: number | null
      surface_2009: number | null
      surface_2008: number | null
      nombre_2023: number | null
      nombre_2022: number | null
      nombre_2021: number | null
      nombre_2020: number | null
      nombre_2019: number | null
      nombre_2018: number | null
      nombre_2017: number | null
      nombre_2016: number | null
      nombre_2015: number | null
      nombre_2014: number | null
      nombre_2013: number | null
      nombre_2012: number | null
      nombre_2011: number | null
      nombre_2010: number | null
      nombre_2009: number | null
      nombre_2008: number | null
    }, ExtArgs["result"]["agriculture_bio"]>
    composites: {}
  }

  type agriculture_bioGetPayload<S extends boolean | null | undefined | agriculture_bioDefaultArgs> = $Result.GetResult<Prisma.$agriculture_bioPayload, S>

  type agriculture_bioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<agriculture_bioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Agriculture_bioCountAggregateInputType | true
    }

  export interface agriculture_bioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['agriculture_bio'], meta: { name: 'agriculture_bio' } }
    /**
     * Find zero or one Agriculture_bio that matches the filter.
     * @param {agriculture_bioFindUniqueArgs} args - Arguments to find a Agriculture_bio
     * @example
     * // Get one Agriculture_bio
     * const agriculture_bio = await prisma.agriculture_bio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends agriculture_bioFindUniqueArgs>(args: SelectSubset<T, agriculture_bioFindUniqueArgs<ExtArgs>>): Prisma__agriculture_bioClient<$Result.GetResult<Prisma.$agriculture_bioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Agriculture_bio that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {agriculture_bioFindUniqueOrThrowArgs} args - Arguments to find a Agriculture_bio
     * @example
     * // Get one Agriculture_bio
     * const agriculture_bio = await prisma.agriculture_bio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends agriculture_bioFindUniqueOrThrowArgs>(args: SelectSubset<T, agriculture_bioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__agriculture_bioClient<$Result.GetResult<Prisma.$agriculture_bioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agriculture_bio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agriculture_bioFindFirstArgs} args - Arguments to find a Agriculture_bio
     * @example
     * // Get one Agriculture_bio
     * const agriculture_bio = await prisma.agriculture_bio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends agriculture_bioFindFirstArgs>(args?: SelectSubset<T, agriculture_bioFindFirstArgs<ExtArgs>>): Prisma__agriculture_bioClient<$Result.GetResult<Prisma.$agriculture_bioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agriculture_bio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agriculture_bioFindFirstOrThrowArgs} args - Arguments to find a Agriculture_bio
     * @example
     * // Get one Agriculture_bio
     * const agriculture_bio = await prisma.agriculture_bio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends agriculture_bioFindFirstOrThrowArgs>(args?: SelectSubset<T, agriculture_bioFindFirstOrThrowArgs<ExtArgs>>): Prisma__agriculture_bioClient<$Result.GetResult<Prisma.$agriculture_bioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agriculture_bios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agriculture_bioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agriculture_bios
     * const agriculture_bios = await prisma.agriculture_bio.findMany()
     * 
     * // Get first 10 Agriculture_bios
     * const agriculture_bios = await prisma.agriculture_bio.findMany({ take: 10 })
     * 
     * // Only select the `index`
     * const agriculture_bioWithIndexOnly = await prisma.agriculture_bio.findMany({ select: { index: true } })
     * 
     */
    findMany<T extends agriculture_bioFindManyArgs>(args?: SelectSubset<T, agriculture_bioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$agriculture_bioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Agriculture_bio.
     * @param {agriculture_bioCreateArgs} args - Arguments to create a Agriculture_bio.
     * @example
     * // Create one Agriculture_bio
     * const Agriculture_bio = await prisma.agriculture_bio.create({
     *   data: {
     *     // ... data to create a Agriculture_bio
     *   }
     * })
     * 
     */
    create<T extends agriculture_bioCreateArgs>(args: SelectSubset<T, agriculture_bioCreateArgs<ExtArgs>>): Prisma__agriculture_bioClient<$Result.GetResult<Prisma.$agriculture_bioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Agriculture_bios.
     * @param {agriculture_bioCreateManyArgs} args - Arguments to create many Agriculture_bios.
     * @example
     * // Create many Agriculture_bios
     * const agriculture_bio = await prisma.agriculture_bio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends agriculture_bioCreateManyArgs>(args?: SelectSubset<T, agriculture_bioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Agriculture_bios and returns the data saved in the database.
     * @param {agriculture_bioCreateManyAndReturnArgs} args - Arguments to create many Agriculture_bios.
     * @example
     * // Create many Agriculture_bios
     * const agriculture_bio = await prisma.agriculture_bio.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Agriculture_bios and only return the `index`
     * const agriculture_bioWithIndexOnly = await prisma.agriculture_bio.createManyAndReturn({
     *   select: { index: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends agriculture_bioCreateManyAndReturnArgs>(args?: SelectSubset<T, agriculture_bioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$agriculture_bioPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Agriculture_bio.
     * @param {agriculture_bioDeleteArgs} args - Arguments to delete one Agriculture_bio.
     * @example
     * // Delete one Agriculture_bio
     * const Agriculture_bio = await prisma.agriculture_bio.delete({
     *   where: {
     *     // ... filter to delete one Agriculture_bio
     *   }
     * })
     * 
     */
    delete<T extends agriculture_bioDeleteArgs>(args: SelectSubset<T, agriculture_bioDeleteArgs<ExtArgs>>): Prisma__agriculture_bioClient<$Result.GetResult<Prisma.$agriculture_bioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Agriculture_bio.
     * @param {agriculture_bioUpdateArgs} args - Arguments to update one Agriculture_bio.
     * @example
     * // Update one Agriculture_bio
     * const agriculture_bio = await prisma.agriculture_bio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends agriculture_bioUpdateArgs>(args: SelectSubset<T, agriculture_bioUpdateArgs<ExtArgs>>): Prisma__agriculture_bioClient<$Result.GetResult<Prisma.$agriculture_bioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Agriculture_bios.
     * @param {agriculture_bioDeleteManyArgs} args - Arguments to filter Agriculture_bios to delete.
     * @example
     * // Delete a few Agriculture_bios
     * const { count } = await prisma.agriculture_bio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends agriculture_bioDeleteManyArgs>(args?: SelectSubset<T, agriculture_bioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agriculture_bios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agriculture_bioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agriculture_bios
     * const agriculture_bio = await prisma.agriculture_bio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends agriculture_bioUpdateManyArgs>(args: SelectSubset<T, agriculture_bioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agriculture_bios and returns the data updated in the database.
     * @param {agriculture_bioUpdateManyAndReturnArgs} args - Arguments to update many Agriculture_bios.
     * @example
     * // Update many Agriculture_bios
     * const agriculture_bio = await prisma.agriculture_bio.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Agriculture_bios and only return the `index`
     * const agriculture_bioWithIndexOnly = await prisma.agriculture_bio.updateManyAndReturn({
     *   select: { index: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends agriculture_bioUpdateManyAndReturnArgs>(args: SelectSubset<T, agriculture_bioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$agriculture_bioPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Agriculture_bio.
     * @param {agriculture_bioUpsertArgs} args - Arguments to update or create a Agriculture_bio.
     * @example
     * // Update or create a Agriculture_bio
     * const agriculture_bio = await prisma.agriculture_bio.upsert({
     *   create: {
     *     // ... data to create a Agriculture_bio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agriculture_bio we want to update
     *   }
     * })
     */
    upsert<T extends agriculture_bioUpsertArgs>(args: SelectSubset<T, agriculture_bioUpsertArgs<ExtArgs>>): Prisma__agriculture_bioClient<$Result.GetResult<Prisma.$agriculture_bioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Agriculture_bios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agriculture_bioCountArgs} args - Arguments to filter Agriculture_bios to count.
     * @example
     * // Count the number of Agriculture_bios
     * const count = await prisma.agriculture_bio.count({
     *   where: {
     *     // ... the filter for the Agriculture_bios we want to count
     *   }
     * })
    **/
    count<T extends agriculture_bioCountArgs>(
      args?: Subset<T, agriculture_bioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Agriculture_bioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agriculture_bio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Agriculture_bioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Agriculture_bioAggregateArgs>(args: Subset<T, Agriculture_bioAggregateArgs>): Prisma.PrismaPromise<GetAgriculture_bioAggregateType<T>>

    /**
     * Group by Agriculture_bio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agriculture_bioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends agriculture_bioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: agriculture_bioGroupByArgs['orderBy'] }
        : { orderBy?: agriculture_bioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, agriculture_bioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgriculture_bioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the agriculture_bio model
   */
  readonly fields: agriculture_bioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for agriculture_bio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__agriculture_bioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the agriculture_bio model
   */
  interface agriculture_bioFieldRefs {
    readonly index: FieldRef<"agriculture_bio", 'Int'>
    readonly epci: FieldRef<"agriculture_bio", 'String'>
    readonly libelle_epci: FieldRef<"agriculture_bio", 'String'>
    readonly VARIABLE: FieldRef<"agriculture_bio", 'String'>
    readonly LIBELLE_SOUS_CHAMP: FieldRef<"agriculture_bio", 'String'>
    readonly surface_2023: FieldRef<"agriculture_bio", 'Float'>
    readonly surface_2022: FieldRef<"agriculture_bio", 'Float'>
    readonly surface_2021: FieldRef<"agriculture_bio", 'Float'>
    readonly surface_2020: FieldRef<"agriculture_bio", 'Float'>
    readonly surface_2019: FieldRef<"agriculture_bio", 'Float'>
    readonly surface_2018: FieldRef<"agriculture_bio", 'Float'>
    readonly surface_2017: FieldRef<"agriculture_bio", 'Float'>
    readonly surface_2016: FieldRef<"agriculture_bio", 'Float'>
    readonly surface_2015: FieldRef<"agriculture_bio", 'Float'>
    readonly surface_2014: FieldRef<"agriculture_bio", 'Float'>
    readonly surface_2013: FieldRef<"agriculture_bio", 'Float'>
    readonly surface_2012: FieldRef<"agriculture_bio", 'Float'>
    readonly surface_2011: FieldRef<"agriculture_bio", 'Float'>
    readonly surface_2010: FieldRef<"agriculture_bio", 'Float'>
    readonly surface_2009: FieldRef<"agriculture_bio", 'Float'>
    readonly surface_2008: FieldRef<"agriculture_bio", 'Float'>
    readonly nombre_2023: FieldRef<"agriculture_bio", 'Float'>
    readonly nombre_2022: FieldRef<"agriculture_bio", 'Float'>
    readonly nombre_2021: FieldRef<"agriculture_bio", 'Float'>
    readonly nombre_2020: FieldRef<"agriculture_bio", 'Float'>
    readonly nombre_2019: FieldRef<"agriculture_bio", 'Float'>
    readonly nombre_2018: FieldRef<"agriculture_bio", 'Float'>
    readonly nombre_2017: FieldRef<"agriculture_bio", 'Float'>
    readonly nombre_2016: FieldRef<"agriculture_bio", 'Float'>
    readonly nombre_2015: FieldRef<"agriculture_bio", 'Float'>
    readonly nombre_2014: FieldRef<"agriculture_bio", 'Float'>
    readonly nombre_2013: FieldRef<"agriculture_bio", 'Float'>
    readonly nombre_2012: FieldRef<"agriculture_bio", 'Float'>
    readonly nombre_2011: FieldRef<"agriculture_bio", 'Float'>
    readonly nombre_2010: FieldRef<"agriculture_bio", 'Float'>
    readonly nombre_2009: FieldRef<"agriculture_bio", 'Float'>
    readonly nombre_2008: FieldRef<"agriculture_bio", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * agriculture_bio findUnique
   */
  export type agriculture_bioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agriculture_bio
     */
    select?: agriculture_bioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agriculture_bio
     */
    omit?: agriculture_bioOmit<ExtArgs> | null
    /**
     * Filter, which agriculture_bio to fetch.
     */
    where: agriculture_bioWhereUniqueInput
  }

  /**
   * agriculture_bio findUniqueOrThrow
   */
  export type agriculture_bioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agriculture_bio
     */
    select?: agriculture_bioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agriculture_bio
     */
    omit?: agriculture_bioOmit<ExtArgs> | null
    /**
     * Filter, which agriculture_bio to fetch.
     */
    where: agriculture_bioWhereUniqueInput
  }

  /**
   * agriculture_bio findFirst
   */
  export type agriculture_bioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agriculture_bio
     */
    select?: agriculture_bioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agriculture_bio
     */
    omit?: agriculture_bioOmit<ExtArgs> | null
    /**
     * Filter, which agriculture_bio to fetch.
     */
    where?: agriculture_bioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agriculture_bios to fetch.
     */
    orderBy?: agriculture_bioOrderByWithRelationInput | agriculture_bioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for agriculture_bios.
     */
    cursor?: agriculture_bioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agriculture_bios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agriculture_bios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of agriculture_bios.
     */
    distinct?: Agriculture_bioScalarFieldEnum | Agriculture_bioScalarFieldEnum[]
  }

  /**
   * agriculture_bio findFirstOrThrow
   */
  export type agriculture_bioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agriculture_bio
     */
    select?: agriculture_bioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agriculture_bio
     */
    omit?: agriculture_bioOmit<ExtArgs> | null
    /**
     * Filter, which agriculture_bio to fetch.
     */
    where?: agriculture_bioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agriculture_bios to fetch.
     */
    orderBy?: agriculture_bioOrderByWithRelationInput | agriculture_bioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for agriculture_bios.
     */
    cursor?: agriculture_bioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agriculture_bios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agriculture_bios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of agriculture_bios.
     */
    distinct?: Agriculture_bioScalarFieldEnum | Agriculture_bioScalarFieldEnum[]
  }

  /**
   * agriculture_bio findMany
   */
  export type agriculture_bioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agriculture_bio
     */
    select?: agriculture_bioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agriculture_bio
     */
    omit?: agriculture_bioOmit<ExtArgs> | null
    /**
     * Filter, which agriculture_bios to fetch.
     */
    where?: agriculture_bioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agriculture_bios to fetch.
     */
    orderBy?: agriculture_bioOrderByWithRelationInput | agriculture_bioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing agriculture_bios.
     */
    cursor?: agriculture_bioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agriculture_bios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agriculture_bios.
     */
    skip?: number
    distinct?: Agriculture_bioScalarFieldEnum | Agriculture_bioScalarFieldEnum[]
  }

  /**
   * agriculture_bio create
   */
  export type agriculture_bioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agriculture_bio
     */
    select?: agriculture_bioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agriculture_bio
     */
    omit?: agriculture_bioOmit<ExtArgs> | null
    /**
     * The data needed to create a agriculture_bio.
     */
    data: XOR<agriculture_bioCreateInput, agriculture_bioUncheckedCreateInput>
  }

  /**
   * agriculture_bio createMany
   */
  export type agriculture_bioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many agriculture_bios.
     */
    data: agriculture_bioCreateManyInput | agriculture_bioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * agriculture_bio createManyAndReturn
   */
  export type agriculture_bioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agriculture_bio
     */
    select?: agriculture_bioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the agriculture_bio
     */
    omit?: agriculture_bioOmit<ExtArgs> | null
    /**
     * The data used to create many agriculture_bios.
     */
    data: agriculture_bioCreateManyInput | agriculture_bioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * agriculture_bio update
   */
  export type agriculture_bioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agriculture_bio
     */
    select?: agriculture_bioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agriculture_bio
     */
    omit?: agriculture_bioOmit<ExtArgs> | null
    /**
     * The data needed to update a agriculture_bio.
     */
    data: XOR<agriculture_bioUpdateInput, agriculture_bioUncheckedUpdateInput>
    /**
     * Choose, which agriculture_bio to update.
     */
    where: agriculture_bioWhereUniqueInput
  }

  /**
   * agriculture_bio updateMany
   */
  export type agriculture_bioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update agriculture_bios.
     */
    data: XOR<agriculture_bioUpdateManyMutationInput, agriculture_bioUncheckedUpdateManyInput>
    /**
     * Filter which agriculture_bios to update
     */
    where?: agriculture_bioWhereInput
    /**
     * Limit how many agriculture_bios to update.
     */
    limit?: number
  }

  /**
   * agriculture_bio updateManyAndReturn
   */
  export type agriculture_bioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agriculture_bio
     */
    select?: agriculture_bioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the agriculture_bio
     */
    omit?: agriculture_bioOmit<ExtArgs> | null
    /**
     * The data used to update agriculture_bios.
     */
    data: XOR<agriculture_bioUpdateManyMutationInput, agriculture_bioUncheckedUpdateManyInput>
    /**
     * Filter which agriculture_bios to update
     */
    where?: agriculture_bioWhereInput
    /**
     * Limit how many agriculture_bios to update.
     */
    limit?: number
  }

  /**
   * agriculture_bio upsert
   */
  export type agriculture_bioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agriculture_bio
     */
    select?: agriculture_bioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agriculture_bio
     */
    omit?: agriculture_bioOmit<ExtArgs> | null
    /**
     * The filter to search for the agriculture_bio to update in case it exists.
     */
    where: agriculture_bioWhereUniqueInput
    /**
     * In case the agriculture_bio found by the `where` argument doesn't exist, create a new agriculture_bio with this data.
     */
    create: XOR<agriculture_bioCreateInput, agriculture_bioUncheckedCreateInput>
    /**
     * In case the agriculture_bio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<agriculture_bioUpdateInput, agriculture_bioUncheckedUpdateInput>
  }

  /**
   * agriculture_bio delete
   */
  export type agriculture_bioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agriculture_bio
     */
    select?: agriculture_bioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agriculture_bio
     */
    omit?: agriculture_bioOmit<ExtArgs> | null
    /**
     * Filter which agriculture_bio to delete.
     */
    where: agriculture_bioWhereUniqueInput
  }

  /**
   * agriculture_bio deleteMany
   */
  export type agriculture_bioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which agriculture_bios to delete
     */
    where?: agriculture_bioWhereInput
    /**
     * Limit how many agriculture_bios to delete.
     */
    limit?: number
  }

  /**
   * agriculture_bio without action
   */
  export type agriculture_bioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agriculture_bio
     */
    select?: agriculture_bioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agriculture_bio
     */
    omit?: agriculture_bioOmit<ExtArgs> | null
  }


  /**
   * Model aot_40
   */

  export type AggregateAot_40 = {
    _count: Aot_40CountAggregateOutputType | null
    _avg: Aot_40AvgAggregateOutputType | null
    _sum: Aot_40SumAggregateOutputType | null
    _min: Aot_40MinAggregateOutputType | null
    _max: Aot_40MaxAggregateOutputType | null
  }

  export type Aot_40AvgAggregateOutputType = {
    index: number | null
    valeur_brute: number | null
    Latitude: number | null
    Longitude: number | null
  }

  export type Aot_40SumAggregateOutputType = {
    index: number | null
    valeur_brute: number | null
    Latitude: number | null
    Longitude: number | null
  }

  export type Aot_40MinAggregateOutputType = {
    index: number | null
    nom_site: string | null
    type_d_implantation: string | null
    valeur_brute: number | null
    Latitude: number | null
    Longitude: number | null
  }

  export type Aot_40MaxAggregateOutputType = {
    index: number | null
    nom_site: string | null
    type_d_implantation: string | null
    valeur_brute: number | null
    Latitude: number | null
    Longitude: number | null
  }

  export type Aot_40CountAggregateOutputType = {
    index: number
    nom_site: number
    type_d_implantation: number
    valeur_brute: number
    Latitude: number
    Longitude: number
    _all: number
  }


  export type Aot_40AvgAggregateInputType = {
    index?: true
    valeur_brute?: true
    Latitude?: true
    Longitude?: true
  }

  export type Aot_40SumAggregateInputType = {
    index?: true
    valeur_brute?: true
    Latitude?: true
    Longitude?: true
  }

  export type Aot_40MinAggregateInputType = {
    index?: true
    nom_site?: true
    type_d_implantation?: true
    valeur_brute?: true
    Latitude?: true
    Longitude?: true
  }

  export type Aot_40MaxAggregateInputType = {
    index?: true
    nom_site?: true
    type_d_implantation?: true
    valeur_brute?: true
    Latitude?: true
    Longitude?: true
  }

  export type Aot_40CountAggregateInputType = {
    index?: true
    nom_site?: true
    type_d_implantation?: true
    valeur_brute?: true
    Latitude?: true
    Longitude?: true
    _all?: true
  }

  export type Aot_40AggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which aot_40 to aggregate.
     */
    where?: aot_40WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aot_40s to fetch.
     */
    orderBy?: aot_40OrderByWithRelationInput | aot_40OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: aot_40WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aot_40s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aot_40s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned aot_40s
    **/
    _count?: true | Aot_40CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Aot_40AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Aot_40SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Aot_40MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Aot_40MaxAggregateInputType
  }

  export type GetAot_40AggregateType<T extends Aot_40AggregateArgs> = {
        [P in keyof T & keyof AggregateAot_40]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAot_40[P]>
      : GetScalarType<T[P], AggregateAot_40[P]>
  }




  export type aot_40GroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: aot_40WhereInput
    orderBy?: aot_40OrderByWithAggregationInput | aot_40OrderByWithAggregationInput[]
    by: Aot_40ScalarFieldEnum[] | Aot_40ScalarFieldEnum
    having?: aot_40ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Aot_40CountAggregateInputType | true
    _avg?: Aot_40AvgAggregateInputType
    _sum?: Aot_40SumAggregateInputType
    _min?: Aot_40MinAggregateInputType
    _max?: Aot_40MaxAggregateInputType
  }

  export type Aot_40GroupByOutputType = {
    index: number
    nom_site: string
    type_d_implantation: string
    valeur_brute: number
    Latitude: number
    Longitude: number
    _count: Aot_40CountAggregateOutputType | null
    _avg: Aot_40AvgAggregateOutputType | null
    _sum: Aot_40SumAggregateOutputType | null
    _min: Aot_40MinAggregateOutputType | null
    _max: Aot_40MaxAggregateOutputType | null
  }

  type GetAot_40GroupByPayload<T extends aot_40GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Aot_40GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Aot_40GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Aot_40GroupByOutputType[P]>
            : GetScalarType<T[P], Aot_40GroupByOutputType[P]>
        }
      >
    >


  export type aot_40Select<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    nom_site?: boolean
    type_d_implantation?: boolean
    valeur_brute?: boolean
    Latitude?: boolean
    Longitude?: boolean
  }, ExtArgs["result"]["aot_40"]>

  export type aot_40SelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    nom_site?: boolean
    type_d_implantation?: boolean
    valeur_brute?: boolean
    Latitude?: boolean
    Longitude?: boolean
  }, ExtArgs["result"]["aot_40"]>

  export type aot_40SelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    nom_site?: boolean
    type_d_implantation?: boolean
    valeur_brute?: boolean
    Latitude?: boolean
    Longitude?: boolean
  }, ExtArgs["result"]["aot_40"]>

  export type aot_40SelectScalar = {
    index?: boolean
    nom_site?: boolean
    type_d_implantation?: boolean
    valeur_brute?: boolean
    Latitude?: boolean
    Longitude?: boolean
  }

  export type aot_40Omit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"index" | "nom_site" | "type_d_implantation" | "valeur_brute" | "Latitude" | "Longitude", ExtArgs["result"]["aot_40"]>

  export type $aot_40Payload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "aot_40"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      index: number
      nom_site: string
      type_d_implantation: string
      valeur_brute: number
      Latitude: number
      Longitude: number
    }, ExtArgs["result"]["aot_40"]>
    composites: {}
  }

  type aot_40GetPayload<S extends boolean | null | undefined | aot_40DefaultArgs> = $Result.GetResult<Prisma.$aot_40Payload, S>

  type aot_40CountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<aot_40FindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Aot_40CountAggregateInputType | true
    }

  export interface aot_40Delegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['aot_40'], meta: { name: 'aot_40' } }
    /**
     * Find zero or one Aot_40 that matches the filter.
     * @param {aot_40FindUniqueArgs} args - Arguments to find a Aot_40
     * @example
     * // Get one Aot_40
     * const aot_40 = await prisma.aot_40.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends aot_40FindUniqueArgs>(args: SelectSubset<T, aot_40FindUniqueArgs<ExtArgs>>): Prisma__aot_40Client<$Result.GetResult<Prisma.$aot_40Payload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Aot_40 that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {aot_40FindUniqueOrThrowArgs} args - Arguments to find a Aot_40
     * @example
     * // Get one Aot_40
     * const aot_40 = await prisma.aot_40.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends aot_40FindUniqueOrThrowArgs>(args: SelectSubset<T, aot_40FindUniqueOrThrowArgs<ExtArgs>>): Prisma__aot_40Client<$Result.GetResult<Prisma.$aot_40Payload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Aot_40 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aot_40FindFirstArgs} args - Arguments to find a Aot_40
     * @example
     * // Get one Aot_40
     * const aot_40 = await prisma.aot_40.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends aot_40FindFirstArgs>(args?: SelectSubset<T, aot_40FindFirstArgs<ExtArgs>>): Prisma__aot_40Client<$Result.GetResult<Prisma.$aot_40Payload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Aot_40 that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aot_40FindFirstOrThrowArgs} args - Arguments to find a Aot_40
     * @example
     * // Get one Aot_40
     * const aot_40 = await prisma.aot_40.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends aot_40FindFirstOrThrowArgs>(args?: SelectSubset<T, aot_40FindFirstOrThrowArgs<ExtArgs>>): Prisma__aot_40Client<$Result.GetResult<Prisma.$aot_40Payload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Aot_40s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aot_40FindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Aot_40s
     * const aot_40s = await prisma.aot_40.findMany()
     * 
     * // Get first 10 Aot_40s
     * const aot_40s = await prisma.aot_40.findMany({ take: 10 })
     * 
     * // Only select the `index`
     * const aot_40WithIndexOnly = await prisma.aot_40.findMany({ select: { index: true } })
     * 
     */
    findMany<T extends aot_40FindManyArgs>(args?: SelectSubset<T, aot_40FindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$aot_40Payload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Aot_40.
     * @param {aot_40CreateArgs} args - Arguments to create a Aot_40.
     * @example
     * // Create one Aot_40
     * const Aot_40 = await prisma.aot_40.create({
     *   data: {
     *     // ... data to create a Aot_40
     *   }
     * })
     * 
     */
    create<T extends aot_40CreateArgs>(args: SelectSubset<T, aot_40CreateArgs<ExtArgs>>): Prisma__aot_40Client<$Result.GetResult<Prisma.$aot_40Payload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Aot_40s.
     * @param {aot_40CreateManyArgs} args - Arguments to create many Aot_40s.
     * @example
     * // Create many Aot_40s
     * const aot_40 = await prisma.aot_40.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends aot_40CreateManyArgs>(args?: SelectSubset<T, aot_40CreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Aot_40s and returns the data saved in the database.
     * @param {aot_40CreateManyAndReturnArgs} args - Arguments to create many Aot_40s.
     * @example
     * // Create many Aot_40s
     * const aot_40 = await prisma.aot_40.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Aot_40s and only return the `index`
     * const aot_40WithIndexOnly = await prisma.aot_40.createManyAndReturn({
     *   select: { index: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends aot_40CreateManyAndReturnArgs>(args?: SelectSubset<T, aot_40CreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$aot_40Payload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Aot_40.
     * @param {aot_40DeleteArgs} args - Arguments to delete one Aot_40.
     * @example
     * // Delete one Aot_40
     * const Aot_40 = await prisma.aot_40.delete({
     *   where: {
     *     // ... filter to delete one Aot_40
     *   }
     * })
     * 
     */
    delete<T extends aot_40DeleteArgs>(args: SelectSubset<T, aot_40DeleteArgs<ExtArgs>>): Prisma__aot_40Client<$Result.GetResult<Prisma.$aot_40Payload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Aot_40.
     * @param {aot_40UpdateArgs} args - Arguments to update one Aot_40.
     * @example
     * // Update one Aot_40
     * const aot_40 = await prisma.aot_40.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends aot_40UpdateArgs>(args: SelectSubset<T, aot_40UpdateArgs<ExtArgs>>): Prisma__aot_40Client<$Result.GetResult<Prisma.$aot_40Payload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Aot_40s.
     * @param {aot_40DeleteManyArgs} args - Arguments to filter Aot_40s to delete.
     * @example
     * // Delete a few Aot_40s
     * const { count } = await prisma.aot_40.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends aot_40DeleteManyArgs>(args?: SelectSubset<T, aot_40DeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Aot_40s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aot_40UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Aot_40s
     * const aot_40 = await prisma.aot_40.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends aot_40UpdateManyArgs>(args: SelectSubset<T, aot_40UpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Aot_40s and returns the data updated in the database.
     * @param {aot_40UpdateManyAndReturnArgs} args - Arguments to update many Aot_40s.
     * @example
     * // Update many Aot_40s
     * const aot_40 = await prisma.aot_40.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Aot_40s and only return the `index`
     * const aot_40WithIndexOnly = await prisma.aot_40.updateManyAndReturn({
     *   select: { index: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends aot_40UpdateManyAndReturnArgs>(args: SelectSubset<T, aot_40UpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$aot_40Payload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Aot_40.
     * @param {aot_40UpsertArgs} args - Arguments to update or create a Aot_40.
     * @example
     * // Update or create a Aot_40
     * const aot_40 = await prisma.aot_40.upsert({
     *   create: {
     *     // ... data to create a Aot_40
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Aot_40 we want to update
     *   }
     * })
     */
    upsert<T extends aot_40UpsertArgs>(args: SelectSubset<T, aot_40UpsertArgs<ExtArgs>>): Prisma__aot_40Client<$Result.GetResult<Prisma.$aot_40Payload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Aot_40s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aot_40CountArgs} args - Arguments to filter Aot_40s to count.
     * @example
     * // Count the number of Aot_40s
     * const count = await prisma.aot_40.count({
     *   where: {
     *     // ... the filter for the Aot_40s we want to count
     *   }
     * })
    **/
    count<T extends aot_40CountArgs>(
      args?: Subset<T, aot_40CountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Aot_40CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Aot_40.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Aot_40AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Aot_40AggregateArgs>(args: Subset<T, Aot_40AggregateArgs>): Prisma.PrismaPromise<GetAot_40AggregateType<T>>

    /**
     * Group by Aot_40.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aot_40GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends aot_40GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: aot_40GroupByArgs['orderBy'] }
        : { orderBy?: aot_40GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, aot_40GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAot_40GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the aot_40 model
   */
  readonly fields: aot_40FieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for aot_40.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__aot_40Client<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the aot_40 model
   */
  interface aot_40FieldRefs {
    readonly index: FieldRef<"aot_40", 'Int'>
    readonly nom_site: FieldRef<"aot_40", 'String'>
    readonly type_d_implantation: FieldRef<"aot_40", 'String'>
    readonly valeur_brute: FieldRef<"aot_40", 'Float'>
    readonly Latitude: FieldRef<"aot_40", 'Float'>
    readonly Longitude: FieldRef<"aot_40", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * aot_40 findUnique
   */
  export type aot_40FindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aot_40
     */
    select?: aot_40Select<ExtArgs> | null
    /**
     * Omit specific fields from the aot_40
     */
    omit?: aot_40Omit<ExtArgs> | null
    /**
     * Filter, which aot_40 to fetch.
     */
    where: aot_40WhereUniqueInput
  }

  /**
   * aot_40 findUniqueOrThrow
   */
  export type aot_40FindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aot_40
     */
    select?: aot_40Select<ExtArgs> | null
    /**
     * Omit specific fields from the aot_40
     */
    omit?: aot_40Omit<ExtArgs> | null
    /**
     * Filter, which aot_40 to fetch.
     */
    where: aot_40WhereUniqueInput
  }

  /**
   * aot_40 findFirst
   */
  export type aot_40FindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aot_40
     */
    select?: aot_40Select<ExtArgs> | null
    /**
     * Omit specific fields from the aot_40
     */
    omit?: aot_40Omit<ExtArgs> | null
    /**
     * Filter, which aot_40 to fetch.
     */
    where?: aot_40WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aot_40s to fetch.
     */
    orderBy?: aot_40OrderByWithRelationInput | aot_40OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for aot_40s.
     */
    cursor?: aot_40WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aot_40s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aot_40s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of aot_40s.
     */
    distinct?: Aot_40ScalarFieldEnum | Aot_40ScalarFieldEnum[]
  }

  /**
   * aot_40 findFirstOrThrow
   */
  export type aot_40FindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aot_40
     */
    select?: aot_40Select<ExtArgs> | null
    /**
     * Omit specific fields from the aot_40
     */
    omit?: aot_40Omit<ExtArgs> | null
    /**
     * Filter, which aot_40 to fetch.
     */
    where?: aot_40WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aot_40s to fetch.
     */
    orderBy?: aot_40OrderByWithRelationInput | aot_40OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for aot_40s.
     */
    cursor?: aot_40WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aot_40s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aot_40s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of aot_40s.
     */
    distinct?: Aot_40ScalarFieldEnum | Aot_40ScalarFieldEnum[]
  }

  /**
   * aot_40 findMany
   */
  export type aot_40FindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aot_40
     */
    select?: aot_40Select<ExtArgs> | null
    /**
     * Omit specific fields from the aot_40
     */
    omit?: aot_40Omit<ExtArgs> | null
    /**
     * Filter, which aot_40s to fetch.
     */
    where?: aot_40WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aot_40s to fetch.
     */
    orderBy?: aot_40OrderByWithRelationInput | aot_40OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing aot_40s.
     */
    cursor?: aot_40WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aot_40s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aot_40s.
     */
    skip?: number
    distinct?: Aot_40ScalarFieldEnum | Aot_40ScalarFieldEnum[]
  }

  /**
   * aot_40 create
   */
  export type aot_40CreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aot_40
     */
    select?: aot_40Select<ExtArgs> | null
    /**
     * Omit specific fields from the aot_40
     */
    omit?: aot_40Omit<ExtArgs> | null
    /**
     * The data needed to create a aot_40.
     */
    data: XOR<aot_40CreateInput, aot_40UncheckedCreateInput>
  }

  /**
   * aot_40 createMany
   */
  export type aot_40CreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many aot_40s.
     */
    data: aot_40CreateManyInput | aot_40CreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * aot_40 createManyAndReturn
   */
  export type aot_40CreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aot_40
     */
    select?: aot_40SelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the aot_40
     */
    omit?: aot_40Omit<ExtArgs> | null
    /**
     * The data used to create many aot_40s.
     */
    data: aot_40CreateManyInput | aot_40CreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * aot_40 update
   */
  export type aot_40UpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aot_40
     */
    select?: aot_40Select<ExtArgs> | null
    /**
     * Omit specific fields from the aot_40
     */
    omit?: aot_40Omit<ExtArgs> | null
    /**
     * The data needed to update a aot_40.
     */
    data: XOR<aot_40UpdateInput, aot_40UncheckedUpdateInput>
    /**
     * Choose, which aot_40 to update.
     */
    where: aot_40WhereUniqueInput
  }

  /**
   * aot_40 updateMany
   */
  export type aot_40UpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update aot_40s.
     */
    data: XOR<aot_40UpdateManyMutationInput, aot_40UncheckedUpdateManyInput>
    /**
     * Filter which aot_40s to update
     */
    where?: aot_40WhereInput
    /**
     * Limit how many aot_40s to update.
     */
    limit?: number
  }

  /**
   * aot_40 updateManyAndReturn
   */
  export type aot_40UpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aot_40
     */
    select?: aot_40SelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the aot_40
     */
    omit?: aot_40Omit<ExtArgs> | null
    /**
     * The data used to update aot_40s.
     */
    data: XOR<aot_40UpdateManyMutationInput, aot_40UncheckedUpdateManyInput>
    /**
     * Filter which aot_40s to update
     */
    where?: aot_40WhereInput
    /**
     * Limit how many aot_40s to update.
     */
    limit?: number
  }

  /**
   * aot_40 upsert
   */
  export type aot_40UpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aot_40
     */
    select?: aot_40Select<ExtArgs> | null
    /**
     * Omit specific fields from the aot_40
     */
    omit?: aot_40Omit<ExtArgs> | null
    /**
     * The filter to search for the aot_40 to update in case it exists.
     */
    where: aot_40WhereUniqueInput
    /**
     * In case the aot_40 found by the `where` argument doesn't exist, create a new aot_40 with this data.
     */
    create: XOR<aot_40CreateInput, aot_40UncheckedCreateInput>
    /**
     * In case the aot_40 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<aot_40UpdateInput, aot_40UncheckedUpdateInput>
  }

  /**
   * aot_40 delete
   */
  export type aot_40DeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aot_40
     */
    select?: aot_40Select<ExtArgs> | null
    /**
     * Omit specific fields from the aot_40
     */
    omit?: aot_40Omit<ExtArgs> | null
    /**
     * Filter which aot_40 to delete.
     */
    where: aot_40WhereUniqueInput
  }

  /**
   * aot_40 deleteMany
   */
  export type aot_40DeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which aot_40s to delete
     */
    where?: aot_40WhereInput
    /**
     * Limit how many aot_40s to delete.
     */
    limit?: number
  }

  /**
   * aot_40 without action
   */
  export type aot_40DefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aot_40
     */
    select?: aot_40Select<ExtArgs> | null
    /**
     * Omit specific fields from the aot_40
     */
    omit?: aot_40Omit<ExtArgs> | null
  }


  /**
   * Model arretes_catnat
   */

  export type AggregateArretes_catnat = {
    _count: Arretes_catnatCountAggregateOutputType | null
    _avg: Arretes_catnatAvgAggregateOutputType | null
    _sum: Arretes_catnatSumAggregateOutputType | null
    _min: Arretes_catnatMinAggregateOutputType | null
    _max: Arretes_catnatMaxAggregateOutputType | null
  }

  export type Arretes_catnatAvgAggregateOutputType = {
    index: number | null
    region: number | null
  }

  export type Arretes_catnatSumAggregateOutputType = {
    index: number | null
    region: number | null
  }

  export type Arretes_catnatMinAggregateOutputType = {
    index: number | null
    code_geographique: string | null
    libelle_geographique: string | null
    epci: string | null
    libelle_epci: string | null
    departement: string | null
    libelle_departement: string | null
    region: number | null
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
    lib_risque_jo: string | null
    dat_deb: string | null
    dat_fin: string | null
    dat_pub_arrete: string | null
  }

  export type Arretes_catnatMaxAggregateOutputType = {
    index: number | null
    code_geographique: string | null
    libelle_geographique: string | null
    epci: string | null
    libelle_epci: string | null
    departement: string | null
    libelle_departement: string | null
    region: number | null
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
    lib_risque_jo: string | null
    dat_deb: string | null
    dat_fin: string | null
    dat_pub_arrete: string | null
  }

  export type Arretes_catnatCountAggregateOutputType = {
    index: number
    code_geographique: number
    libelle_geographique: number
    epci: number
    libelle_epci: number
    departement: number
    libelle_departement: number
    region: number
    ept: number
    libelle_petr: number
    code_pnr: number
    libelle_pnr: number
    lib_risque_jo: number
    dat_deb: number
    dat_fin: number
    dat_pub_arrete: number
    _all: number
  }


  export type Arretes_catnatAvgAggregateInputType = {
    index?: true
    region?: true
  }

  export type Arretes_catnatSumAggregateInputType = {
    index?: true
    region?: true
  }

  export type Arretes_catnatMinAggregateInputType = {
    index?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
    lib_risque_jo?: true
    dat_deb?: true
    dat_fin?: true
    dat_pub_arrete?: true
  }

  export type Arretes_catnatMaxAggregateInputType = {
    index?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
    lib_risque_jo?: true
    dat_deb?: true
    dat_fin?: true
    dat_pub_arrete?: true
  }

  export type Arretes_catnatCountAggregateInputType = {
    index?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
    lib_risque_jo?: true
    dat_deb?: true
    dat_fin?: true
    dat_pub_arrete?: true
    _all?: true
  }

  export type Arretes_catnatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which arretes_catnat to aggregate.
     */
    where?: arretes_catnatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of arretes_catnats to fetch.
     */
    orderBy?: arretes_catnatOrderByWithRelationInput | arretes_catnatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: arretes_catnatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` arretes_catnats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` arretes_catnats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned arretes_catnats
    **/
    _count?: true | Arretes_catnatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Arretes_catnatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Arretes_catnatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Arretes_catnatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Arretes_catnatMaxAggregateInputType
  }

  export type GetArretes_catnatAggregateType<T extends Arretes_catnatAggregateArgs> = {
        [P in keyof T & keyof AggregateArretes_catnat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArretes_catnat[P]>
      : GetScalarType<T[P], AggregateArretes_catnat[P]>
  }




  export type arretes_catnatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: arretes_catnatWhereInput
    orderBy?: arretes_catnatOrderByWithAggregationInput | arretes_catnatOrderByWithAggregationInput[]
    by: Arretes_catnatScalarFieldEnum[] | Arretes_catnatScalarFieldEnum
    having?: arretes_catnatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Arretes_catnatCountAggregateInputType | true
    _avg?: Arretes_catnatAvgAggregateInputType
    _sum?: Arretes_catnatSumAggregateInputType
    _min?: Arretes_catnatMinAggregateInputType
    _max?: Arretes_catnatMaxAggregateInputType
  }

  export type Arretes_catnatGroupByOutputType = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
    lib_risque_jo: string
    dat_deb: string
    dat_fin: string
    dat_pub_arrete: string
    _count: Arretes_catnatCountAggregateOutputType | null
    _avg: Arretes_catnatAvgAggregateOutputType | null
    _sum: Arretes_catnatSumAggregateOutputType | null
    _min: Arretes_catnatMinAggregateOutputType | null
    _max: Arretes_catnatMaxAggregateOutputType | null
  }

  type GetArretes_catnatGroupByPayload<T extends arretes_catnatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Arretes_catnatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Arretes_catnatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Arretes_catnatGroupByOutputType[P]>
            : GetScalarType<T[P], Arretes_catnatGroupByOutputType[P]>
        }
      >
    >


  export type arretes_catnatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    lib_risque_jo?: boolean
    dat_deb?: boolean
    dat_fin?: boolean
    dat_pub_arrete?: boolean
  }, ExtArgs["result"]["arretes_catnat"]>

  export type arretes_catnatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    lib_risque_jo?: boolean
    dat_deb?: boolean
    dat_fin?: boolean
    dat_pub_arrete?: boolean
  }, ExtArgs["result"]["arretes_catnat"]>

  export type arretes_catnatSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    lib_risque_jo?: boolean
    dat_deb?: boolean
    dat_fin?: boolean
    dat_pub_arrete?: boolean
  }, ExtArgs["result"]["arretes_catnat"]>

  export type arretes_catnatSelectScalar = {
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    lib_risque_jo?: boolean
    dat_deb?: boolean
    dat_fin?: boolean
    dat_pub_arrete?: boolean
  }

  export type arretes_catnatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"index" | "code_geographique" | "libelle_geographique" | "epci" | "libelle_epci" | "departement" | "libelle_departement" | "region" | "ept" | "libelle_petr" | "code_pnr" | "libelle_pnr" | "lib_risque_jo" | "dat_deb" | "dat_fin" | "dat_pub_arrete", ExtArgs["result"]["arretes_catnat"]>

  export type $arretes_catnatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "arretes_catnat"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      index: number
      code_geographique: string
      libelle_geographique: string
      epci: string
      libelle_epci: string
      departement: string
      libelle_departement: string
      region: number
      ept: string | null
      libelle_petr: string | null
      code_pnr: string | null
      libelle_pnr: string | null
      lib_risque_jo: string
      dat_deb: string
      dat_fin: string
      dat_pub_arrete: string
    }, ExtArgs["result"]["arretes_catnat"]>
    composites: {}
  }

  type arretes_catnatGetPayload<S extends boolean | null | undefined | arretes_catnatDefaultArgs> = $Result.GetResult<Prisma.$arretes_catnatPayload, S>

  type arretes_catnatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<arretes_catnatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Arretes_catnatCountAggregateInputType | true
    }

  export interface arretes_catnatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['arretes_catnat'], meta: { name: 'arretes_catnat' } }
    /**
     * Find zero or one Arretes_catnat that matches the filter.
     * @param {arretes_catnatFindUniqueArgs} args - Arguments to find a Arretes_catnat
     * @example
     * // Get one Arretes_catnat
     * const arretes_catnat = await prisma.arretes_catnat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends arretes_catnatFindUniqueArgs>(args: SelectSubset<T, arretes_catnatFindUniqueArgs<ExtArgs>>): Prisma__arretes_catnatClient<$Result.GetResult<Prisma.$arretes_catnatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Arretes_catnat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {arretes_catnatFindUniqueOrThrowArgs} args - Arguments to find a Arretes_catnat
     * @example
     * // Get one Arretes_catnat
     * const arretes_catnat = await prisma.arretes_catnat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends arretes_catnatFindUniqueOrThrowArgs>(args: SelectSubset<T, arretes_catnatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__arretes_catnatClient<$Result.GetResult<Prisma.$arretes_catnatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Arretes_catnat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {arretes_catnatFindFirstArgs} args - Arguments to find a Arretes_catnat
     * @example
     * // Get one Arretes_catnat
     * const arretes_catnat = await prisma.arretes_catnat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends arretes_catnatFindFirstArgs>(args?: SelectSubset<T, arretes_catnatFindFirstArgs<ExtArgs>>): Prisma__arretes_catnatClient<$Result.GetResult<Prisma.$arretes_catnatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Arretes_catnat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {arretes_catnatFindFirstOrThrowArgs} args - Arguments to find a Arretes_catnat
     * @example
     * // Get one Arretes_catnat
     * const arretes_catnat = await prisma.arretes_catnat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends arretes_catnatFindFirstOrThrowArgs>(args?: SelectSubset<T, arretes_catnatFindFirstOrThrowArgs<ExtArgs>>): Prisma__arretes_catnatClient<$Result.GetResult<Prisma.$arretes_catnatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Arretes_catnats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {arretes_catnatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Arretes_catnats
     * const arretes_catnats = await prisma.arretes_catnat.findMany()
     * 
     * // Get first 10 Arretes_catnats
     * const arretes_catnats = await prisma.arretes_catnat.findMany({ take: 10 })
     * 
     * // Only select the `index`
     * const arretes_catnatWithIndexOnly = await prisma.arretes_catnat.findMany({ select: { index: true } })
     * 
     */
    findMany<T extends arretes_catnatFindManyArgs>(args?: SelectSubset<T, arretes_catnatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$arretes_catnatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Arretes_catnat.
     * @param {arretes_catnatCreateArgs} args - Arguments to create a Arretes_catnat.
     * @example
     * // Create one Arretes_catnat
     * const Arretes_catnat = await prisma.arretes_catnat.create({
     *   data: {
     *     // ... data to create a Arretes_catnat
     *   }
     * })
     * 
     */
    create<T extends arretes_catnatCreateArgs>(args: SelectSubset<T, arretes_catnatCreateArgs<ExtArgs>>): Prisma__arretes_catnatClient<$Result.GetResult<Prisma.$arretes_catnatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Arretes_catnats.
     * @param {arretes_catnatCreateManyArgs} args - Arguments to create many Arretes_catnats.
     * @example
     * // Create many Arretes_catnats
     * const arretes_catnat = await prisma.arretes_catnat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends arretes_catnatCreateManyArgs>(args?: SelectSubset<T, arretes_catnatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Arretes_catnats and returns the data saved in the database.
     * @param {arretes_catnatCreateManyAndReturnArgs} args - Arguments to create many Arretes_catnats.
     * @example
     * // Create many Arretes_catnats
     * const arretes_catnat = await prisma.arretes_catnat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Arretes_catnats and only return the `index`
     * const arretes_catnatWithIndexOnly = await prisma.arretes_catnat.createManyAndReturn({
     *   select: { index: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends arretes_catnatCreateManyAndReturnArgs>(args?: SelectSubset<T, arretes_catnatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$arretes_catnatPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Arretes_catnat.
     * @param {arretes_catnatDeleteArgs} args - Arguments to delete one Arretes_catnat.
     * @example
     * // Delete one Arretes_catnat
     * const Arretes_catnat = await prisma.arretes_catnat.delete({
     *   where: {
     *     // ... filter to delete one Arretes_catnat
     *   }
     * })
     * 
     */
    delete<T extends arretes_catnatDeleteArgs>(args: SelectSubset<T, arretes_catnatDeleteArgs<ExtArgs>>): Prisma__arretes_catnatClient<$Result.GetResult<Prisma.$arretes_catnatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Arretes_catnat.
     * @param {arretes_catnatUpdateArgs} args - Arguments to update one Arretes_catnat.
     * @example
     * // Update one Arretes_catnat
     * const arretes_catnat = await prisma.arretes_catnat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends arretes_catnatUpdateArgs>(args: SelectSubset<T, arretes_catnatUpdateArgs<ExtArgs>>): Prisma__arretes_catnatClient<$Result.GetResult<Prisma.$arretes_catnatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Arretes_catnats.
     * @param {arretes_catnatDeleteManyArgs} args - Arguments to filter Arretes_catnats to delete.
     * @example
     * // Delete a few Arretes_catnats
     * const { count } = await prisma.arretes_catnat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends arretes_catnatDeleteManyArgs>(args?: SelectSubset<T, arretes_catnatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Arretes_catnats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {arretes_catnatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Arretes_catnats
     * const arretes_catnat = await prisma.arretes_catnat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends arretes_catnatUpdateManyArgs>(args: SelectSubset<T, arretes_catnatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Arretes_catnats and returns the data updated in the database.
     * @param {arretes_catnatUpdateManyAndReturnArgs} args - Arguments to update many Arretes_catnats.
     * @example
     * // Update many Arretes_catnats
     * const arretes_catnat = await prisma.arretes_catnat.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Arretes_catnats and only return the `index`
     * const arretes_catnatWithIndexOnly = await prisma.arretes_catnat.updateManyAndReturn({
     *   select: { index: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends arretes_catnatUpdateManyAndReturnArgs>(args: SelectSubset<T, arretes_catnatUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$arretes_catnatPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Arretes_catnat.
     * @param {arretes_catnatUpsertArgs} args - Arguments to update or create a Arretes_catnat.
     * @example
     * // Update or create a Arretes_catnat
     * const arretes_catnat = await prisma.arretes_catnat.upsert({
     *   create: {
     *     // ... data to create a Arretes_catnat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Arretes_catnat we want to update
     *   }
     * })
     */
    upsert<T extends arretes_catnatUpsertArgs>(args: SelectSubset<T, arretes_catnatUpsertArgs<ExtArgs>>): Prisma__arretes_catnatClient<$Result.GetResult<Prisma.$arretes_catnatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Arretes_catnats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {arretes_catnatCountArgs} args - Arguments to filter Arretes_catnats to count.
     * @example
     * // Count the number of Arretes_catnats
     * const count = await prisma.arretes_catnat.count({
     *   where: {
     *     // ... the filter for the Arretes_catnats we want to count
     *   }
     * })
    **/
    count<T extends arretes_catnatCountArgs>(
      args?: Subset<T, arretes_catnatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Arretes_catnatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Arretes_catnat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Arretes_catnatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Arretes_catnatAggregateArgs>(args: Subset<T, Arretes_catnatAggregateArgs>): Prisma.PrismaPromise<GetArretes_catnatAggregateType<T>>

    /**
     * Group by Arretes_catnat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {arretes_catnatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends arretes_catnatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: arretes_catnatGroupByArgs['orderBy'] }
        : { orderBy?: arretes_catnatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, arretes_catnatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArretes_catnatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the arretes_catnat model
   */
  readonly fields: arretes_catnatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for arretes_catnat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__arretes_catnatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the arretes_catnat model
   */
  interface arretes_catnatFieldRefs {
    readonly index: FieldRef<"arretes_catnat", 'Int'>
    readonly code_geographique: FieldRef<"arretes_catnat", 'String'>
    readonly libelle_geographique: FieldRef<"arretes_catnat", 'String'>
    readonly epci: FieldRef<"arretes_catnat", 'String'>
    readonly libelle_epci: FieldRef<"arretes_catnat", 'String'>
    readonly departement: FieldRef<"arretes_catnat", 'String'>
    readonly libelle_departement: FieldRef<"arretes_catnat", 'String'>
    readonly region: FieldRef<"arretes_catnat", 'Float'>
    readonly ept: FieldRef<"arretes_catnat", 'String'>
    readonly libelle_petr: FieldRef<"arretes_catnat", 'String'>
    readonly code_pnr: FieldRef<"arretes_catnat", 'String'>
    readonly libelle_pnr: FieldRef<"arretes_catnat", 'String'>
    readonly lib_risque_jo: FieldRef<"arretes_catnat", 'String'>
    readonly dat_deb: FieldRef<"arretes_catnat", 'String'>
    readonly dat_fin: FieldRef<"arretes_catnat", 'String'>
    readonly dat_pub_arrete: FieldRef<"arretes_catnat", 'String'>
  }
    

  // Custom InputTypes
  /**
   * arretes_catnat findUnique
   */
  export type arretes_catnatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the arretes_catnat
     */
    select?: arretes_catnatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the arretes_catnat
     */
    omit?: arretes_catnatOmit<ExtArgs> | null
    /**
     * Filter, which arretes_catnat to fetch.
     */
    where: arretes_catnatWhereUniqueInput
  }

  /**
   * arretes_catnat findUniqueOrThrow
   */
  export type arretes_catnatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the arretes_catnat
     */
    select?: arretes_catnatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the arretes_catnat
     */
    omit?: arretes_catnatOmit<ExtArgs> | null
    /**
     * Filter, which arretes_catnat to fetch.
     */
    where: arretes_catnatWhereUniqueInput
  }

  /**
   * arretes_catnat findFirst
   */
  export type arretes_catnatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the arretes_catnat
     */
    select?: arretes_catnatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the arretes_catnat
     */
    omit?: arretes_catnatOmit<ExtArgs> | null
    /**
     * Filter, which arretes_catnat to fetch.
     */
    where?: arretes_catnatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of arretes_catnats to fetch.
     */
    orderBy?: arretes_catnatOrderByWithRelationInput | arretes_catnatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for arretes_catnats.
     */
    cursor?: arretes_catnatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` arretes_catnats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` arretes_catnats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of arretes_catnats.
     */
    distinct?: Arretes_catnatScalarFieldEnum | Arretes_catnatScalarFieldEnum[]
  }

  /**
   * arretes_catnat findFirstOrThrow
   */
  export type arretes_catnatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the arretes_catnat
     */
    select?: arretes_catnatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the arretes_catnat
     */
    omit?: arretes_catnatOmit<ExtArgs> | null
    /**
     * Filter, which arretes_catnat to fetch.
     */
    where?: arretes_catnatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of arretes_catnats to fetch.
     */
    orderBy?: arretes_catnatOrderByWithRelationInput | arretes_catnatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for arretes_catnats.
     */
    cursor?: arretes_catnatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` arretes_catnats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` arretes_catnats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of arretes_catnats.
     */
    distinct?: Arretes_catnatScalarFieldEnum | Arretes_catnatScalarFieldEnum[]
  }

  /**
   * arretes_catnat findMany
   */
  export type arretes_catnatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the arretes_catnat
     */
    select?: arretes_catnatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the arretes_catnat
     */
    omit?: arretes_catnatOmit<ExtArgs> | null
    /**
     * Filter, which arretes_catnats to fetch.
     */
    where?: arretes_catnatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of arretes_catnats to fetch.
     */
    orderBy?: arretes_catnatOrderByWithRelationInput | arretes_catnatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing arretes_catnats.
     */
    cursor?: arretes_catnatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` arretes_catnats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` arretes_catnats.
     */
    skip?: number
    distinct?: Arretes_catnatScalarFieldEnum | Arretes_catnatScalarFieldEnum[]
  }

  /**
   * arretes_catnat create
   */
  export type arretes_catnatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the arretes_catnat
     */
    select?: arretes_catnatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the arretes_catnat
     */
    omit?: arretes_catnatOmit<ExtArgs> | null
    /**
     * The data needed to create a arretes_catnat.
     */
    data: XOR<arretes_catnatCreateInput, arretes_catnatUncheckedCreateInput>
  }

  /**
   * arretes_catnat createMany
   */
  export type arretes_catnatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many arretes_catnats.
     */
    data: arretes_catnatCreateManyInput | arretes_catnatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * arretes_catnat createManyAndReturn
   */
  export type arretes_catnatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the arretes_catnat
     */
    select?: arretes_catnatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the arretes_catnat
     */
    omit?: arretes_catnatOmit<ExtArgs> | null
    /**
     * The data used to create many arretes_catnats.
     */
    data: arretes_catnatCreateManyInput | arretes_catnatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * arretes_catnat update
   */
  export type arretes_catnatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the arretes_catnat
     */
    select?: arretes_catnatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the arretes_catnat
     */
    omit?: arretes_catnatOmit<ExtArgs> | null
    /**
     * The data needed to update a arretes_catnat.
     */
    data: XOR<arretes_catnatUpdateInput, arretes_catnatUncheckedUpdateInput>
    /**
     * Choose, which arretes_catnat to update.
     */
    where: arretes_catnatWhereUniqueInput
  }

  /**
   * arretes_catnat updateMany
   */
  export type arretes_catnatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update arretes_catnats.
     */
    data: XOR<arretes_catnatUpdateManyMutationInput, arretes_catnatUncheckedUpdateManyInput>
    /**
     * Filter which arretes_catnats to update
     */
    where?: arretes_catnatWhereInput
    /**
     * Limit how many arretes_catnats to update.
     */
    limit?: number
  }

  /**
   * arretes_catnat updateManyAndReturn
   */
  export type arretes_catnatUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the arretes_catnat
     */
    select?: arretes_catnatSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the arretes_catnat
     */
    omit?: arretes_catnatOmit<ExtArgs> | null
    /**
     * The data used to update arretes_catnats.
     */
    data: XOR<arretes_catnatUpdateManyMutationInput, arretes_catnatUncheckedUpdateManyInput>
    /**
     * Filter which arretes_catnats to update
     */
    where?: arretes_catnatWhereInput
    /**
     * Limit how many arretes_catnats to update.
     */
    limit?: number
  }

  /**
   * arretes_catnat upsert
   */
  export type arretes_catnatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the arretes_catnat
     */
    select?: arretes_catnatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the arretes_catnat
     */
    omit?: arretes_catnatOmit<ExtArgs> | null
    /**
     * The filter to search for the arretes_catnat to update in case it exists.
     */
    where: arretes_catnatWhereUniqueInput
    /**
     * In case the arretes_catnat found by the `where` argument doesn't exist, create a new arretes_catnat with this data.
     */
    create: XOR<arretes_catnatCreateInput, arretes_catnatUncheckedCreateInput>
    /**
     * In case the arretes_catnat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<arretes_catnatUpdateInput, arretes_catnatUncheckedUpdateInput>
  }

  /**
   * arretes_catnat delete
   */
  export type arretes_catnatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the arretes_catnat
     */
    select?: arretes_catnatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the arretes_catnat
     */
    omit?: arretes_catnatOmit<ExtArgs> | null
    /**
     * Filter which arretes_catnat to delete.
     */
    where: arretes_catnatWhereUniqueInput
  }

  /**
   * arretes_catnat deleteMany
   */
  export type arretes_catnatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which arretes_catnats to delete
     */
    where?: arretes_catnatWhereInput
    /**
     * Limit how many arretes_catnats to delete.
     */
    limit?: number
  }

  /**
   * arretes_catnat without action
   */
  export type arretes_catnatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the arretes_catnat
     */
    select?: arretes_catnatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the arretes_catnat
     */
    omit?: arretes_catnatOmit<ExtArgs> | null
  }


  /**
   * Model atlas_biodiversite
   */

  export type AggregateAtlas_biodiversite = {
    _count: Atlas_biodiversiteCountAggregateOutputType | null
    _avg: Atlas_biodiversiteAvgAggregateOutputType | null
    _sum: Atlas_biodiversiteSumAggregateOutputType | null
    _min: Atlas_biodiversiteMinAggregateOutputType | null
    _max: Atlas_biodiversiteMaxAggregateOutputType | null
  }

  export type Atlas_biodiversiteAvgAggregateOutputType = {
    index: number | null
    region: number | null
    annee_debut: number | null
  }

  export type Atlas_biodiversiteSumAggregateOutputType = {
    index: number | null
    region: number | null
    annee_debut: number | null
  }

  export type Atlas_biodiversiteMinAggregateOutputType = {
    index: number | null
    code_geographique: string | null
    libelle_geographique: string | null
    epci: string | null
    libelle_epci: string | null
    departement: string | null
    libelle_departement: string | null
    region: number | null
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
    nom: string | null
    structure_porteuse: string | null
    type_de_structure_porteuse: string | null
    annee_debut: number | null
    avancement: string | null
  }

  export type Atlas_biodiversiteMaxAggregateOutputType = {
    index: number | null
    code_geographique: string | null
    libelle_geographique: string | null
    epci: string | null
    libelle_epci: string | null
    departement: string | null
    libelle_departement: string | null
    region: number | null
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
    nom: string | null
    structure_porteuse: string | null
    type_de_structure_porteuse: string | null
    annee_debut: number | null
    avancement: string | null
  }

  export type Atlas_biodiversiteCountAggregateOutputType = {
    index: number
    code_geographique: number
    libelle_geographique: number
    epci: number
    libelle_epci: number
    departement: number
    libelle_departement: number
    region: number
    ept: number
    libelle_petr: number
    code_pnr: number
    libelle_pnr: number
    nom: number
    structure_porteuse: number
    type_de_structure_porteuse: number
    annee_debut: number
    avancement: number
    _all: number
  }


  export type Atlas_biodiversiteAvgAggregateInputType = {
    index?: true
    region?: true
    annee_debut?: true
  }

  export type Atlas_biodiversiteSumAggregateInputType = {
    index?: true
    region?: true
    annee_debut?: true
  }

  export type Atlas_biodiversiteMinAggregateInputType = {
    index?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
    nom?: true
    structure_porteuse?: true
    type_de_structure_porteuse?: true
    annee_debut?: true
    avancement?: true
  }

  export type Atlas_biodiversiteMaxAggregateInputType = {
    index?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
    nom?: true
    structure_porteuse?: true
    type_de_structure_porteuse?: true
    annee_debut?: true
    avancement?: true
  }

  export type Atlas_biodiversiteCountAggregateInputType = {
    index?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
    nom?: true
    structure_porteuse?: true
    type_de_structure_porteuse?: true
    annee_debut?: true
    avancement?: true
    _all?: true
  }

  export type Atlas_biodiversiteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which atlas_biodiversite to aggregate.
     */
    where?: atlas_biodiversiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of atlas_biodiversites to fetch.
     */
    orderBy?: atlas_biodiversiteOrderByWithRelationInput | atlas_biodiversiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: atlas_biodiversiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` atlas_biodiversites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` atlas_biodiversites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned atlas_biodiversites
    **/
    _count?: true | Atlas_biodiversiteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Atlas_biodiversiteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Atlas_biodiversiteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Atlas_biodiversiteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Atlas_biodiversiteMaxAggregateInputType
  }

  export type GetAtlas_biodiversiteAggregateType<T extends Atlas_biodiversiteAggregateArgs> = {
        [P in keyof T & keyof AggregateAtlas_biodiversite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAtlas_biodiversite[P]>
      : GetScalarType<T[P], AggregateAtlas_biodiversite[P]>
  }




  export type atlas_biodiversiteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: atlas_biodiversiteWhereInput
    orderBy?: atlas_biodiversiteOrderByWithAggregationInput | atlas_biodiversiteOrderByWithAggregationInput[]
    by: Atlas_biodiversiteScalarFieldEnum[] | Atlas_biodiversiteScalarFieldEnum
    having?: atlas_biodiversiteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Atlas_biodiversiteCountAggregateInputType | true
    _avg?: Atlas_biodiversiteAvgAggregateInputType
    _sum?: Atlas_biodiversiteSumAggregateInputType
    _min?: Atlas_biodiversiteMinAggregateInputType
    _max?: Atlas_biodiversiteMaxAggregateInputType
  }

  export type Atlas_biodiversiteGroupByOutputType = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
    nom: string | null
    structure_porteuse: string | null
    type_de_structure_porteuse: string | null
    annee_debut: number | null
    avancement: string | null
    _count: Atlas_biodiversiteCountAggregateOutputType | null
    _avg: Atlas_biodiversiteAvgAggregateOutputType | null
    _sum: Atlas_biodiversiteSumAggregateOutputType | null
    _min: Atlas_biodiversiteMinAggregateOutputType | null
    _max: Atlas_biodiversiteMaxAggregateOutputType | null
  }

  type GetAtlas_biodiversiteGroupByPayload<T extends atlas_biodiversiteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Atlas_biodiversiteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Atlas_biodiversiteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Atlas_biodiversiteGroupByOutputType[P]>
            : GetScalarType<T[P], Atlas_biodiversiteGroupByOutputType[P]>
        }
      >
    >


  export type atlas_biodiversiteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    nom?: boolean
    structure_porteuse?: boolean
    type_de_structure_porteuse?: boolean
    annee_debut?: boolean
    avancement?: boolean
  }, ExtArgs["result"]["atlas_biodiversite"]>

  export type atlas_biodiversiteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    nom?: boolean
    structure_porteuse?: boolean
    type_de_structure_porteuse?: boolean
    annee_debut?: boolean
    avancement?: boolean
  }, ExtArgs["result"]["atlas_biodiversite"]>

  export type atlas_biodiversiteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    nom?: boolean
    structure_porteuse?: boolean
    type_de_structure_porteuse?: boolean
    annee_debut?: boolean
    avancement?: boolean
  }, ExtArgs["result"]["atlas_biodiversite"]>

  export type atlas_biodiversiteSelectScalar = {
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    nom?: boolean
    structure_porteuse?: boolean
    type_de_structure_porteuse?: boolean
    annee_debut?: boolean
    avancement?: boolean
  }

  export type atlas_biodiversiteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"index" | "code_geographique" | "libelle_geographique" | "epci" | "libelle_epci" | "departement" | "libelle_departement" | "region" | "ept" | "libelle_petr" | "code_pnr" | "libelle_pnr" | "nom" | "structure_porteuse" | "type_de_structure_porteuse" | "annee_debut" | "avancement", ExtArgs["result"]["atlas_biodiversite"]>

  export type $atlas_biodiversitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "atlas_biodiversite"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      index: number
      code_geographique: string
      libelle_geographique: string
      epci: string
      libelle_epci: string
      departement: string
      libelle_departement: string
      region: number
      ept: string | null
      libelle_petr: string | null
      code_pnr: string | null
      libelle_pnr: string | null
      nom: string | null
      structure_porteuse: string | null
      type_de_structure_porteuse: string | null
      annee_debut: number | null
      avancement: string | null
    }, ExtArgs["result"]["atlas_biodiversite"]>
    composites: {}
  }

  type atlas_biodiversiteGetPayload<S extends boolean | null | undefined | atlas_biodiversiteDefaultArgs> = $Result.GetResult<Prisma.$atlas_biodiversitePayload, S>

  type atlas_biodiversiteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<atlas_biodiversiteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Atlas_biodiversiteCountAggregateInputType | true
    }

  export interface atlas_biodiversiteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['atlas_biodiversite'], meta: { name: 'atlas_biodiversite' } }
    /**
     * Find zero or one Atlas_biodiversite that matches the filter.
     * @param {atlas_biodiversiteFindUniqueArgs} args - Arguments to find a Atlas_biodiversite
     * @example
     * // Get one Atlas_biodiversite
     * const atlas_biodiversite = await prisma.atlas_biodiversite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends atlas_biodiversiteFindUniqueArgs>(args: SelectSubset<T, atlas_biodiversiteFindUniqueArgs<ExtArgs>>): Prisma__atlas_biodiversiteClient<$Result.GetResult<Prisma.$atlas_biodiversitePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Atlas_biodiversite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {atlas_biodiversiteFindUniqueOrThrowArgs} args - Arguments to find a Atlas_biodiversite
     * @example
     * // Get one Atlas_biodiversite
     * const atlas_biodiversite = await prisma.atlas_biodiversite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends atlas_biodiversiteFindUniqueOrThrowArgs>(args: SelectSubset<T, atlas_biodiversiteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__atlas_biodiversiteClient<$Result.GetResult<Prisma.$atlas_biodiversitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Atlas_biodiversite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {atlas_biodiversiteFindFirstArgs} args - Arguments to find a Atlas_biodiversite
     * @example
     * // Get one Atlas_biodiversite
     * const atlas_biodiversite = await prisma.atlas_biodiversite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends atlas_biodiversiteFindFirstArgs>(args?: SelectSubset<T, atlas_biodiversiteFindFirstArgs<ExtArgs>>): Prisma__atlas_biodiversiteClient<$Result.GetResult<Prisma.$atlas_biodiversitePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Atlas_biodiversite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {atlas_biodiversiteFindFirstOrThrowArgs} args - Arguments to find a Atlas_biodiversite
     * @example
     * // Get one Atlas_biodiversite
     * const atlas_biodiversite = await prisma.atlas_biodiversite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends atlas_biodiversiteFindFirstOrThrowArgs>(args?: SelectSubset<T, atlas_biodiversiteFindFirstOrThrowArgs<ExtArgs>>): Prisma__atlas_biodiversiteClient<$Result.GetResult<Prisma.$atlas_biodiversitePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Atlas_biodiversites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {atlas_biodiversiteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Atlas_biodiversites
     * const atlas_biodiversites = await prisma.atlas_biodiversite.findMany()
     * 
     * // Get first 10 Atlas_biodiversites
     * const atlas_biodiversites = await prisma.atlas_biodiversite.findMany({ take: 10 })
     * 
     * // Only select the `index`
     * const atlas_biodiversiteWithIndexOnly = await prisma.atlas_biodiversite.findMany({ select: { index: true } })
     * 
     */
    findMany<T extends atlas_biodiversiteFindManyArgs>(args?: SelectSubset<T, atlas_biodiversiteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$atlas_biodiversitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Atlas_biodiversite.
     * @param {atlas_biodiversiteCreateArgs} args - Arguments to create a Atlas_biodiversite.
     * @example
     * // Create one Atlas_biodiversite
     * const Atlas_biodiversite = await prisma.atlas_biodiversite.create({
     *   data: {
     *     // ... data to create a Atlas_biodiversite
     *   }
     * })
     * 
     */
    create<T extends atlas_biodiversiteCreateArgs>(args: SelectSubset<T, atlas_biodiversiteCreateArgs<ExtArgs>>): Prisma__atlas_biodiversiteClient<$Result.GetResult<Prisma.$atlas_biodiversitePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Atlas_biodiversites.
     * @param {atlas_biodiversiteCreateManyArgs} args - Arguments to create many Atlas_biodiversites.
     * @example
     * // Create many Atlas_biodiversites
     * const atlas_biodiversite = await prisma.atlas_biodiversite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends atlas_biodiversiteCreateManyArgs>(args?: SelectSubset<T, atlas_biodiversiteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Atlas_biodiversites and returns the data saved in the database.
     * @param {atlas_biodiversiteCreateManyAndReturnArgs} args - Arguments to create many Atlas_biodiversites.
     * @example
     * // Create many Atlas_biodiversites
     * const atlas_biodiversite = await prisma.atlas_biodiversite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Atlas_biodiversites and only return the `index`
     * const atlas_biodiversiteWithIndexOnly = await prisma.atlas_biodiversite.createManyAndReturn({
     *   select: { index: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends atlas_biodiversiteCreateManyAndReturnArgs>(args?: SelectSubset<T, atlas_biodiversiteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$atlas_biodiversitePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Atlas_biodiversite.
     * @param {atlas_biodiversiteDeleteArgs} args - Arguments to delete one Atlas_biodiversite.
     * @example
     * // Delete one Atlas_biodiversite
     * const Atlas_biodiversite = await prisma.atlas_biodiversite.delete({
     *   where: {
     *     // ... filter to delete one Atlas_biodiversite
     *   }
     * })
     * 
     */
    delete<T extends atlas_biodiversiteDeleteArgs>(args: SelectSubset<T, atlas_biodiversiteDeleteArgs<ExtArgs>>): Prisma__atlas_biodiversiteClient<$Result.GetResult<Prisma.$atlas_biodiversitePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Atlas_biodiversite.
     * @param {atlas_biodiversiteUpdateArgs} args - Arguments to update one Atlas_biodiversite.
     * @example
     * // Update one Atlas_biodiversite
     * const atlas_biodiversite = await prisma.atlas_biodiversite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends atlas_biodiversiteUpdateArgs>(args: SelectSubset<T, atlas_biodiversiteUpdateArgs<ExtArgs>>): Prisma__atlas_biodiversiteClient<$Result.GetResult<Prisma.$atlas_biodiversitePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Atlas_biodiversites.
     * @param {atlas_biodiversiteDeleteManyArgs} args - Arguments to filter Atlas_biodiversites to delete.
     * @example
     * // Delete a few Atlas_biodiversites
     * const { count } = await prisma.atlas_biodiversite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends atlas_biodiversiteDeleteManyArgs>(args?: SelectSubset<T, atlas_biodiversiteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Atlas_biodiversites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {atlas_biodiversiteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Atlas_biodiversites
     * const atlas_biodiversite = await prisma.atlas_biodiversite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends atlas_biodiversiteUpdateManyArgs>(args: SelectSubset<T, atlas_biodiversiteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Atlas_biodiversites and returns the data updated in the database.
     * @param {atlas_biodiversiteUpdateManyAndReturnArgs} args - Arguments to update many Atlas_biodiversites.
     * @example
     * // Update many Atlas_biodiversites
     * const atlas_biodiversite = await prisma.atlas_biodiversite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Atlas_biodiversites and only return the `index`
     * const atlas_biodiversiteWithIndexOnly = await prisma.atlas_biodiversite.updateManyAndReturn({
     *   select: { index: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends atlas_biodiversiteUpdateManyAndReturnArgs>(args: SelectSubset<T, atlas_biodiversiteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$atlas_biodiversitePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Atlas_biodiversite.
     * @param {atlas_biodiversiteUpsertArgs} args - Arguments to update or create a Atlas_biodiversite.
     * @example
     * // Update or create a Atlas_biodiversite
     * const atlas_biodiversite = await prisma.atlas_biodiversite.upsert({
     *   create: {
     *     // ... data to create a Atlas_biodiversite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Atlas_biodiversite we want to update
     *   }
     * })
     */
    upsert<T extends atlas_biodiversiteUpsertArgs>(args: SelectSubset<T, atlas_biodiversiteUpsertArgs<ExtArgs>>): Prisma__atlas_biodiversiteClient<$Result.GetResult<Prisma.$atlas_biodiversitePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Atlas_biodiversites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {atlas_biodiversiteCountArgs} args - Arguments to filter Atlas_biodiversites to count.
     * @example
     * // Count the number of Atlas_biodiversites
     * const count = await prisma.atlas_biodiversite.count({
     *   where: {
     *     // ... the filter for the Atlas_biodiversites we want to count
     *   }
     * })
    **/
    count<T extends atlas_biodiversiteCountArgs>(
      args?: Subset<T, atlas_biodiversiteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Atlas_biodiversiteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Atlas_biodiversite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Atlas_biodiversiteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Atlas_biodiversiteAggregateArgs>(args: Subset<T, Atlas_biodiversiteAggregateArgs>): Prisma.PrismaPromise<GetAtlas_biodiversiteAggregateType<T>>

    /**
     * Group by Atlas_biodiversite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {atlas_biodiversiteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends atlas_biodiversiteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: atlas_biodiversiteGroupByArgs['orderBy'] }
        : { orderBy?: atlas_biodiversiteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, atlas_biodiversiteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAtlas_biodiversiteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the atlas_biodiversite model
   */
  readonly fields: atlas_biodiversiteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for atlas_biodiversite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__atlas_biodiversiteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the atlas_biodiversite model
   */
  interface atlas_biodiversiteFieldRefs {
    readonly index: FieldRef<"atlas_biodiversite", 'Int'>
    readonly code_geographique: FieldRef<"atlas_biodiversite", 'String'>
    readonly libelle_geographique: FieldRef<"atlas_biodiversite", 'String'>
    readonly epci: FieldRef<"atlas_biodiversite", 'String'>
    readonly libelle_epci: FieldRef<"atlas_biodiversite", 'String'>
    readonly departement: FieldRef<"atlas_biodiversite", 'String'>
    readonly libelle_departement: FieldRef<"atlas_biodiversite", 'String'>
    readonly region: FieldRef<"atlas_biodiversite", 'Float'>
    readonly ept: FieldRef<"atlas_biodiversite", 'String'>
    readonly libelle_petr: FieldRef<"atlas_biodiversite", 'String'>
    readonly code_pnr: FieldRef<"atlas_biodiversite", 'String'>
    readonly libelle_pnr: FieldRef<"atlas_biodiversite", 'String'>
    readonly nom: FieldRef<"atlas_biodiversite", 'String'>
    readonly structure_porteuse: FieldRef<"atlas_biodiversite", 'String'>
    readonly type_de_structure_porteuse: FieldRef<"atlas_biodiversite", 'String'>
    readonly annee_debut: FieldRef<"atlas_biodiversite", 'Float'>
    readonly avancement: FieldRef<"atlas_biodiversite", 'String'>
  }
    

  // Custom InputTypes
  /**
   * atlas_biodiversite findUnique
   */
  export type atlas_biodiversiteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the atlas_biodiversite
     */
    select?: atlas_biodiversiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the atlas_biodiversite
     */
    omit?: atlas_biodiversiteOmit<ExtArgs> | null
    /**
     * Filter, which atlas_biodiversite to fetch.
     */
    where: atlas_biodiversiteWhereUniqueInput
  }

  /**
   * atlas_biodiversite findUniqueOrThrow
   */
  export type atlas_biodiversiteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the atlas_biodiversite
     */
    select?: atlas_biodiversiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the atlas_biodiversite
     */
    omit?: atlas_biodiversiteOmit<ExtArgs> | null
    /**
     * Filter, which atlas_biodiversite to fetch.
     */
    where: atlas_biodiversiteWhereUniqueInput
  }

  /**
   * atlas_biodiversite findFirst
   */
  export type atlas_biodiversiteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the atlas_biodiversite
     */
    select?: atlas_biodiversiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the atlas_biodiversite
     */
    omit?: atlas_biodiversiteOmit<ExtArgs> | null
    /**
     * Filter, which atlas_biodiversite to fetch.
     */
    where?: atlas_biodiversiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of atlas_biodiversites to fetch.
     */
    orderBy?: atlas_biodiversiteOrderByWithRelationInput | atlas_biodiversiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for atlas_biodiversites.
     */
    cursor?: atlas_biodiversiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` atlas_biodiversites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` atlas_biodiversites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of atlas_biodiversites.
     */
    distinct?: Atlas_biodiversiteScalarFieldEnum | Atlas_biodiversiteScalarFieldEnum[]
  }

  /**
   * atlas_biodiversite findFirstOrThrow
   */
  export type atlas_biodiversiteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the atlas_biodiversite
     */
    select?: atlas_biodiversiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the atlas_biodiversite
     */
    omit?: atlas_biodiversiteOmit<ExtArgs> | null
    /**
     * Filter, which atlas_biodiversite to fetch.
     */
    where?: atlas_biodiversiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of atlas_biodiversites to fetch.
     */
    orderBy?: atlas_biodiversiteOrderByWithRelationInput | atlas_biodiversiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for atlas_biodiversites.
     */
    cursor?: atlas_biodiversiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` atlas_biodiversites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` atlas_biodiversites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of atlas_biodiversites.
     */
    distinct?: Atlas_biodiversiteScalarFieldEnum | Atlas_biodiversiteScalarFieldEnum[]
  }

  /**
   * atlas_biodiversite findMany
   */
  export type atlas_biodiversiteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the atlas_biodiversite
     */
    select?: atlas_biodiversiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the atlas_biodiversite
     */
    omit?: atlas_biodiversiteOmit<ExtArgs> | null
    /**
     * Filter, which atlas_biodiversites to fetch.
     */
    where?: atlas_biodiversiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of atlas_biodiversites to fetch.
     */
    orderBy?: atlas_biodiversiteOrderByWithRelationInput | atlas_biodiversiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing atlas_biodiversites.
     */
    cursor?: atlas_biodiversiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` atlas_biodiversites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` atlas_biodiversites.
     */
    skip?: number
    distinct?: Atlas_biodiversiteScalarFieldEnum | Atlas_biodiversiteScalarFieldEnum[]
  }

  /**
   * atlas_biodiversite create
   */
  export type atlas_biodiversiteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the atlas_biodiversite
     */
    select?: atlas_biodiversiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the atlas_biodiversite
     */
    omit?: atlas_biodiversiteOmit<ExtArgs> | null
    /**
     * The data needed to create a atlas_biodiversite.
     */
    data: XOR<atlas_biodiversiteCreateInput, atlas_biodiversiteUncheckedCreateInput>
  }

  /**
   * atlas_biodiversite createMany
   */
  export type atlas_biodiversiteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many atlas_biodiversites.
     */
    data: atlas_biodiversiteCreateManyInput | atlas_biodiversiteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * atlas_biodiversite createManyAndReturn
   */
  export type atlas_biodiversiteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the atlas_biodiversite
     */
    select?: atlas_biodiversiteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the atlas_biodiversite
     */
    omit?: atlas_biodiversiteOmit<ExtArgs> | null
    /**
     * The data used to create many atlas_biodiversites.
     */
    data: atlas_biodiversiteCreateManyInput | atlas_biodiversiteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * atlas_biodiversite update
   */
  export type atlas_biodiversiteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the atlas_biodiversite
     */
    select?: atlas_biodiversiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the atlas_biodiversite
     */
    omit?: atlas_biodiversiteOmit<ExtArgs> | null
    /**
     * The data needed to update a atlas_biodiversite.
     */
    data: XOR<atlas_biodiversiteUpdateInput, atlas_biodiversiteUncheckedUpdateInput>
    /**
     * Choose, which atlas_biodiversite to update.
     */
    where: atlas_biodiversiteWhereUniqueInput
  }

  /**
   * atlas_biodiversite updateMany
   */
  export type atlas_biodiversiteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update atlas_biodiversites.
     */
    data: XOR<atlas_biodiversiteUpdateManyMutationInput, atlas_biodiversiteUncheckedUpdateManyInput>
    /**
     * Filter which atlas_biodiversites to update
     */
    where?: atlas_biodiversiteWhereInput
    /**
     * Limit how many atlas_biodiversites to update.
     */
    limit?: number
  }

  /**
   * atlas_biodiversite updateManyAndReturn
   */
  export type atlas_biodiversiteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the atlas_biodiversite
     */
    select?: atlas_biodiversiteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the atlas_biodiversite
     */
    omit?: atlas_biodiversiteOmit<ExtArgs> | null
    /**
     * The data used to update atlas_biodiversites.
     */
    data: XOR<atlas_biodiversiteUpdateManyMutationInput, atlas_biodiversiteUncheckedUpdateManyInput>
    /**
     * Filter which atlas_biodiversites to update
     */
    where?: atlas_biodiversiteWhereInput
    /**
     * Limit how many atlas_biodiversites to update.
     */
    limit?: number
  }

  /**
   * atlas_biodiversite upsert
   */
  export type atlas_biodiversiteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the atlas_biodiversite
     */
    select?: atlas_biodiversiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the atlas_biodiversite
     */
    omit?: atlas_biodiversiteOmit<ExtArgs> | null
    /**
     * The filter to search for the atlas_biodiversite to update in case it exists.
     */
    where: atlas_biodiversiteWhereUniqueInput
    /**
     * In case the atlas_biodiversite found by the `where` argument doesn't exist, create a new atlas_biodiversite with this data.
     */
    create: XOR<atlas_biodiversiteCreateInput, atlas_biodiversiteUncheckedCreateInput>
    /**
     * In case the atlas_biodiversite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<atlas_biodiversiteUpdateInput, atlas_biodiversiteUncheckedUpdateInput>
  }

  /**
   * atlas_biodiversite delete
   */
  export type atlas_biodiversiteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the atlas_biodiversite
     */
    select?: atlas_biodiversiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the atlas_biodiversite
     */
    omit?: atlas_biodiversiteOmit<ExtArgs> | null
    /**
     * Filter which atlas_biodiversite to delete.
     */
    where: atlas_biodiversiteWhereUniqueInput
  }

  /**
   * atlas_biodiversite deleteMany
   */
  export type atlas_biodiversiteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which atlas_biodiversites to delete
     */
    where?: atlas_biodiversiteWhereInput
    /**
     * Limit how many atlas_biodiversites to delete.
     */
    limit?: number
  }

  /**
   * atlas_biodiversite without action
   */
  export type atlas_biodiversiteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the atlas_biodiversite
     */
    select?: atlas_biodiversiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the atlas_biodiversite
     */
    omit?: atlas_biodiversiteOmit<ExtArgs> | null
  }


  /**
   * Model collectivites_searchbar
   */

  export type AggregateCollectivites_searchbar = {
    _count: Collectivites_searchbarCountAggregateOutputType | null
    _avg: Collectivites_searchbarAvgAggregateOutputType | null
    _sum: Collectivites_searchbarSumAggregateOutputType | null
    _min: Collectivites_searchbarMinAggregateOutputType | null
    _max: Collectivites_searchbarMaxAggregateOutputType | null
  }

  export type Collectivites_searchbarAvgAggregateOutputType = {
    index: number | null
  }

  export type Collectivites_searchbarSumAggregateOutputType = {
    index: number | null
  }

  export type Collectivites_searchbarMinAggregateOutputType = {
    index: number | null
    code_geographique: string | null
    libelle_geographique: string | null
    epci: string | null
    libelle_epci: string | null
    departement: string | null
    libelle_departement: string | null
    region: string | null
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
    search_code: string | null
    search_libelle: string | null
  }

  export type Collectivites_searchbarMaxAggregateOutputType = {
    index: number | null
    code_geographique: string | null
    libelle_geographique: string | null
    epci: string | null
    libelle_epci: string | null
    departement: string | null
    libelle_departement: string | null
    region: string | null
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
    search_code: string | null
    search_libelle: string | null
  }

  export type Collectivites_searchbarCountAggregateOutputType = {
    index: number
    code_geographique: number
    libelle_geographique: number
    epci: number
    libelle_epci: number
    departement: number
    libelle_departement: number
    region: number
    ept: number
    libelle_petr: number
    code_pnr: number
    libelle_pnr: number
    search_code: number
    search_libelle: number
    _all: number
  }


  export type Collectivites_searchbarAvgAggregateInputType = {
    index?: true
  }

  export type Collectivites_searchbarSumAggregateInputType = {
    index?: true
  }

  export type Collectivites_searchbarMinAggregateInputType = {
    index?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
    search_code?: true
    search_libelle?: true
  }

  export type Collectivites_searchbarMaxAggregateInputType = {
    index?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
    search_code?: true
    search_libelle?: true
  }

  export type Collectivites_searchbarCountAggregateInputType = {
    index?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
    search_code?: true
    search_libelle?: true
    _all?: true
  }

  export type Collectivites_searchbarAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which collectivites_searchbar to aggregate.
     */
    where?: collectivites_searchbarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collectivites_searchbars to fetch.
     */
    orderBy?: collectivites_searchbarOrderByWithRelationInput | collectivites_searchbarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: collectivites_searchbarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collectivites_searchbars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collectivites_searchbars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned collectivites_searchbars
    **/
    _count?: true | Collectivites_searchbarCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Collectivites_searchbarAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Collectivites_searchbarSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Collectivites_searchbarMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Collectivites_searchbarMaxAggregateInputType
  }

  export type GetCollectivites_searchbarAggregateType<T extends Collectivites_searchbarAggregateArgs> = {
        [P in keyof T & keyof AggregateCollectivites_searchbar]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollectivites_searchbar[P]>
      : GetScalarType<T[P], AggregateCollectivites_searchbar[P]>
  }




  export type collectivites_searchbarGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: collectivites_searchbarWhereInput
    orderBy?: collectivites_searchbarOrderByWithAggregationInput | collectivites_searchbarOrderByWithAggregationInput[]
    by: Collectivites_searchbarScalarFieldEnum[] | Collectivites_searchbarScalarFieldEnum
    having?: collectivites_searchbarScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Collectivites_searchbarCountAggregateInputType | true
    _avg?: Collectivites_searchbarAvgAggregateInputType
    _sum?: Collectivites_searchbarSumAggregateInputType
    _min?: Collectivites_searchbarMinAggregateInputType
    _max?: Collectivites_searchbarMaxAggregateInputType
  }

  export type Collectivites_searchbarGroupByOutputType = {
    index: number
    code_geographique: string | null
    libelle_geographique: string | null
    epci: string | null
    libelle_epci: string | null
    departement: string | null
    libelle_departement: string | null
    region: string | null
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
    search_code: string | null
    search_libelle: string
    _count: Collectivites_searchbarCountAggregateOutputType | null
    _avg: Collectivites_searchbarAvgAggregateOutputType | null
    _sum: Collectivites_searchbarSumAggregateOutputType | null
    _min: Collectivites_searchbarMinAggregateOutputType | null
    _max: Collectivites_searchbarMaxAggregateOutputType | null
  }

  type GetCollectivites_searchbarGroupByPayload<T extends collectivites_searchbarGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Collectivites_searchbarGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Collectivites_searchbarGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Collectivites_searchbarGroupByOutputType[P]>
            : GetScalarType<T[P], Collectivites_searchbarGroupByOutputType[P]>
        }
      >
    >


  export type collectivites_searchbarSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    search_code?: boolean
    search_libelle?: boolean
  }, ExtArgs["result"]["collectivites_searchbar"]>

  export type collectivites_searchbarSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    search_code?: boolean
    search_libelle?: boolean
  }, ExtArgs["result"]["collectivites_searchbar"]>

  export type collectivites_searchbarSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    search_code?: boolean
    search_libelle?: boolean
  }, ExtArgs["result"]["collectivites_searchbar"]>

  export type collectivites_searchbarSelectScalar = {
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    search_code?: boolean
    search_libelle?: boolean
  }

  export type collectivites_searchbarOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"index" | "code_geographique" | "libelle_geographique" | "epci" | "libelle_epci" | "departement" | "libelle_departement" | "region" | "ept" | "libelle_petr" | "code_pnr" | "libelle_pnr" | "search_code" | "search_libelle", ExtArgs["result"]["collectivites_searchbar"]>

  export type $collectivites_searchbarPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "collectivites_searchbar"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      index: number
      code_geographique: string | null
      libelle_geographique: string | null
      epci: string | null
      libelle_epci: string | null
      departement: string | null
      libelle_departement: string | null
      region: string | null
      ept: string | null
      libelle_petr: string | null
      code_pnr: string | null
      libelle_pnr: string | null
      search_code: string | null
      search_libelle: string
    }, ExtArgs["result"]["collectivites_searchbar"]>
    composites: {}
  }

  type collectivites_searchbarGetPayload<S extends boolean | null | undefined | collectivites_searchbarDefaultArgs> = $Result.GetResult<Prisma.$collectivites_searchbarPayload, S>

  type collectivites_searchbarCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<collectivites_searchbarFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Collectivites_searchbarCountAggregateInputType | true
    }

  export interface collectivites_searchbarDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['collectivites_searchbar'], meta: { name: 'collectivites_searchbar' } }
    /**
     * Find zero or one Collectivites_searchbar that matches the filter.
     * @param {collectivites_searchbarFindUniqueArgs} args - Arguments to find a Collectivites_searchbar
     * @example
     * // Get one Collectivites_searchbar
     * const collectivites_searchbar = await prisma.collectivites_searchbar.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends collectivites_searchbarFindUniqueArgs>(args: SelectSubset<T, collectivites_searchbarFindUniqueArgs<ExtArgs>>): Prisma__collectivites_searchbarClient<$Result.GetResult<Prisma.$collectivites_searchbarPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Collectivites_searchbar that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {collectivites_searchbarFindUniqueOrThrowArgs} args - Arguments to find a Collectivites_searchbar
     * @example
     * // Get one Collectivites_searchbar
     * const collectivites_searchbar = await prisma.collectivites_searchbar.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends collectivites_searchbarFindUniqueOrThrowArgs>(args: SelectSubset<T, collectivites_searchbarFindUniqueOrThrowArgs<ExtArgs>>): Prisma__collectivites_searchbarClient<$Result.GetResult<Prisma.$collectivites_searchbarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Collectivites_searchbar that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collectivites_searchbarFindFirstArgs} args - Arguments to find a Collectivites_searchbar
     * @example
     * // Get one Collectivites_searchbar
     * const collectivites_searchbar = await prisma.collectivites_searchbar.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends collectivites_searchbarFindFirstArgs>(args?: SelectSubset<T, collectivites_searchbarFindFirstArgs<ExtArgs>>): Prisma__collectivites_searchbarClient<$Result.GetResult<Prisma.$collectivites_searchbarPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Collectivites_searchbar that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collectivites_searchbarFindFirstOrThrowArgs} args - Arguments to find a Collectivites_searchbar
     * @example
     * // Get one Collectivites_searchbar
     * const collectivites_searchbar = await prisma.collectivites_searchbar.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends collectivites_searchbarFindFirstOrThrowArgs>(args?: SelectSubset<T, collectivites_searchbarFindFirstOrThrowArgs<ExtArgs>>): Prisma__collectivites_searchbarClient<$Result.GetResult<Prisma.$collectivites_searchbarPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Collectivites_searchbars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collectivites_searchbarFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Collectivites_searchbars
     * const collectivites_searchbars = await prisma.collectivites_searchbar.findMany()
     * 
     * // Get first 10 Collectivites_searchbars
     * const collectivites_searchbars = await prisma.collectivites_searchbar.findMany({ take: 10 })
     * 
     * // Only select the `index`
     * const collectivites_searchbarWithIndexOnly = await prisma.collectivites_searchbar.findMany({ select: { index: true } })
     * 
     */
    findMany<T extends collectivites_searchbarFindManyArgs>(args?: SelectSubset<T, collectivites_searchbarFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collectivites_searchbarPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Collectivites_searchbar.
     * @param {collectivites_searchbarCreateArgs} args - Arguments to create a Collectivites_searchbar.
     * @example
     * // Create one Collectivites_searchbar
     * const Collectivites_searchbar = await prisma.collectivites_searchbar.create({
     *   data: {
     *     // ... data to create a Collectivites_searchbar
     *   }
     * })
     * 
     */
    create<T extends collectivites_searchbarCreateArgs>(args: SelectSubset<T, collectivites_searchbarCreateArgs<ExtArgs>>): Prisma__collectivites_searchbarClient<$Result.GetResult<Prisma.$collectivites_searchbarPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Collectivites_searchbars.
     * @param {collectivites_searchbarCreateManyArgs} args - Arguments to create many Collectivites_searchbars.
     * @example
     * // Create many Collectivites_searchbars
     * const collectivites_searchbar = await prisma.collectivites_searchbar.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends collectivites_searchbarCreateManyArgs>(args?: SelectSubset<T, collectivites_searchbarCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Collectivites_searchbars and returns the data saved in the database.
     * @param {collectivites_searchbarCreateManyAndReturnArgs} args - Arguments to create many Collectivites_searchbars.
     * @example
     * // Create many Collectivites_searchbars
     * const collectivites_searchbar = await prisma.collectivites_searchbar.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Collectivites_searchbars and only return the `index`
     * const collectivites_searchbarWithIndexOnly = await prisma.collectivites_searchbar.createManyAndReturn({
     *   select: { index: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends collectivites_searchbarCreateManyAndReturnArgs>(args?: SelectSubset<T, collectivites_searchbarCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collectivites_searchbarPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Collectivites_searchbar.
     * @param {collectivites_searchbarDeleteArgs} args - Arguments to delete one Collectivites_searchbar.
     * @example
     * // Delete one Collectivites_searchbar
     * const Collectivites_searchbar = await prisma.collectivites_searchbar.delete({
     *   where: {
     *     // ... filter to delete one Collectivites_searchbar
     *   }
     * })
     * 
     */
    delete<T extends collectivites_searchbarDeleteArgs>(args: SelectSubset<T, collectivites_searchbarDeleteArgs<ExtArgs>>): Prisma__collectivites_searchbarClient<$Result.GetResult<Prisma.$collectivites_searchbarPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Collectivites_searchbar.
     * @param {collectivites_searchbarUpdateArgs} args - Arguments to update one Collectivites_searchbar.
     * @example
     * // Update one Collectivites_searchbar
     * const collectivites_searchbar = await prisma.collectivites_searchbar.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends collectivites_searchbarUpdateArgs>(args: SelectSubset<T, collectivites_searchbarUpdateArgs<ExtArgs>>): Prisma__collectivites_searchbarClient<$Result.GetResult<Prisma.$collectivites_searchbarPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Collectivites_searchbars.
     * @param {collectivites_searchbarDeleteManyArgs} args - Arguments to filter Collectivites_searchbars to delete.
     * @example
     * // Delete a few Collectivites_searchbars
     * const { count } = await prisma.collectivites_searchbar.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends collectivites_searchbarDeleteManyArgs>(args?: SelectSubset<T, collectivites_searchbarDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Collectivites_searchbars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collectivites_searchbarUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Collectivites_searchbars
     * const collectivites_searchbar = await prisma.collectivites_searchbar.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends collectivites_searchbarUpdateManyArgs>(args: SelectSubset<T, collectivites_searchbarUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Collectivites_searchbars and returns the data updated in the database.
     * @param {collectivites_searchbarUpdateManyAndReturnArgs} args - Arguments to update many Collectivites_searchbars.
     * @example
     * // Update many Collectivites_searchbars
     * const collectivites_searchbar = await prisma.collectivites_searchbar.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Collectivites_searchbars and only return the `index`
     * const collectivites_searchbarWithIndexOnly = await prisma.collectivites_searchbar.updateManyAndReturn({
     *   select: { index: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends collectivites_searchbarUpdateManyAndReturnArgs>(args: SelectSubset<T, collectivites_searchbarUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$collectivites_searchbarPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Collectivites_searchbar.
     * @param {collectivites_searchbarUpsertArgs} args - Arguments to update or create a Collectivites_searchbar.
     * @example
     * // Update or create a Collectivites_searchbar
     * const collectivites_searchbar = await prisma.collectivites_searchbar.upsert({
     *   create: {
     *     // ... data to create a Collectivites_searchbar
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Collectivites_searchbar we want to update
     *   }
     * })
     */
    upsert<T extends collectivites_searchbarUpsertArgs>(args: SelectSubset<T, collectivites_searchbarUpsertArgs<ExtArgs>>): Prisma__collectivites_searchbarClient<$Result.GetResult<Prisma.$collectivites_searchbarPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Collectivites_searchbars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collectivites_searchbarCountArgs} args - Arguments to filter Collectivites_searchbars to count.
     * @example
     * // Count the number of Collectivites_searchbars
     * const count = await prisma.collectivites_searchbar.count({
     *   where: {
     *     // ... the filter for the Collectivites_searchbars we want to count
     *   }
     * })
    **/
    count<T extends collectivites_searchbarCountArgs>(
      args?: Subset<T, collectivites_searchbarCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Collectivites_searchbarCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Collectivites_searchbar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Collectivites_searchbarAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Collectivites_searchbarAggregateArgs>(args: Subset<T, Collectivites_searchbarAggregateArgs>): Prisma.PrismaPromise<GetCollectivites_searchbarAggregateType<T>>

    /**
     * Group by Collectivites_searchbar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collectivites_searchbarGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends collectivites_searchbarGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: collectivites_searchbarGroupByArgs['orderBy'] }
        : { orderBy?: collectivites_searchbarGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, collectivites_searchbarGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollectivites_searchbarGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the collectivites_searchbar model
   */
  readonly fields: collectivites_searchbarFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for collectivites_searchbar.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__collectivites_searchbarClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the collectivites_searchbar model
   */
  interface collectivites_searchbarFieldRefs {
    readonly index: FieldRef<"collectivites_searchbar", 'Int'>
    readonly code_geographique: FieldRef<"collectivites_searchbar", 'String'>
    readonly libelle_geographique: FieldRef<"collectivites_searchbar", 'String'>
    readonly epci: FieldRef<"collectivites_searchbar", 'String'>
    readonly libelle_epci: FieldRef<"collectivites_searchbar", 'String'>
    readonly departement: FieldRef<"collectivites_searchbar", 'String'>
    readonly libelle_departement: FieldRef<"collectivites_searchbar", 'String'>
    readonly region: FieldRef<"collectivites_searchbar", 'String'>
    readonly ept: FieldRef<"collectivites_searchbar", 'String'>
    readonly libelle_petr: FieldRef<"collectivites_searchbar", 'String'>
    readonly code_pnr: FieldRef<"collectivites_searchbar", 'String'>
    readonly libelle_pnr: FieldRef<"collectivites_searchbar", 'String'>
    readonly search_code: FieldRef<"collectivites_searchbar", 'String'>
    readonly search_libelle: FieldRef<"collectivites_searchbar", 'String'>
  }
    

  // Custom InputTypes
  /**
   * collectivites_searchbar findUnique
   */
  export type collectivites_searchbarFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collectivites_searchbar
     */
    select?: collectivites_searchbarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collectivites_searchbar
     */
    omit?: collectivites_searchbarOmit<ExtArgs> | null
    /**
     * Filter, which collectivites_searchbar to fetch.
     */
    where: collectivites_searchbarWhereUniqueInput
  }

  /**
   * collectivites_searchbar findUniqueOrThrow
   */
  export type collectivites_searchbarFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collectivites_searchbar
     */
    select?: collectivites_searchbarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collectivites_searchbar
     */
    omit?: collectivites_searchbarOmit<ExtArgs> | null
    /**
     * Filter, which collectivites_searchbar to fetch.
     */
    where: collectivites_searchbarWhereUniqueInput
  }

  /**
   * collectivites_searchbar findFirst
   */
  export type collectivites_searchbarFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collectivites_searchbar
     */
    select?: collectivites_searchbarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collectivites_searchbar
     */
    omit?: collectivites_searchbarOmit<ExtArgs> | null
    /**
     * Filter, which collectivites_searchbar to fetch.
     */
    where?: collectivites_searchbarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collectivites_searchbars to fetch.
     */
    orderBy?: collectivites_searchbarOrderByWithRelationInput | collectivites_searchbarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collectivites_searchbars.
     */
    cursor?: collectivites_searchbarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collectivites_searchbars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collectivites_searchbars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collectivites_searchbars.
     */
    distinct?: Collectivites_searchbarScalarFieldEnum | Collectivites_searchbarScalarFieldEnum[]
  }

  /**
   * collectivites_searchbar findFirstOrThrow
   */
  export type collectivites_searchbarFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collectivites_searchbar
     */
    select?: collectivites_searchbarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collectivites_searchbar
     */
    omit?: collectivites_searchbarOmit<ExtArgs> | null
    /**
     * Filter, which collectivites_searchbar to fetch.
     */
    where?: collectivites_searchbarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collectivites_searchbars to fetch.
     */
    orderBy?: collectivites_searchbarOrderByWithRelationInput | collectivites_searchbarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collectivites_searchbars.
     */
    cursor?: collectivites_searchbarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collectivites_searchbars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collectivites_searchbars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collectivites_searchbars.
     */
    distinct?: Collectivites_searchbarScalarFieldEnum | Collectivites_searchbarScalarFieldEnum[]
  }

  /**
   * collectivites_searchbar findMany
   */
  export type collectivites_searchbarFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collectivites_searchbar
     */
    select?: collectivites_searchbarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collectivites_searchbar
     */
    omit?: collectivites_searchbarOmit<ExtArgs> | null
    /**
     * Filter, which collectivites_searchbars to fetch.
     */
    where?: collectivites_searchbarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collectivites_searchbars to fetch.
     */
    orderBy?: collectivites_searchbarOrderByWithRelationInput | collectivites_searchbarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing collectivites_searchbars.
     */
    cursor?: collectivites_searchbarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collectivites_searchbars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collectivites_searchbars.
     */
    skip?: number
    distinct?: Collectivites_searchbarScalarFieldEnum | Collectivites_searchbarScalarFieldEnum[]
  }

  /**
   * collectivites_searchbar create
   */
  export type collectivites_searchbarCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collectivites_searchbar
     */
    select?: collectivites_searchbarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collectivites_searchbar
     */
    omit?: collectivites_searchbarOmit<ExtArgs> | null
    /**
     * The data needed to create a collectivites_searchbar.
     */
    data: XOR<collectivites_searchbarCreateInput, collectivites_searchbarUncheckedCreateInput>
  }

  /**
   * collectivites_searchbar createMany
   */
  export type collectivites_searchbarCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many collectivites_searchbars.
     */
    data: collectivites_searchbarCreateManyInput | collectivites_searchbarCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * collectivites_searchbar createManyAndReturn
   */
  export type collectivites_searchbarCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collectivites_searchbar
     */
    select?: collectivites_searchbarSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the collectivites_searchbar
     */
    omit?: collectivites_searchbarOmit<ExtArgs> | null
    /**
     * The data used to create many collectivites_searchbars.
     */
    data: collectivites_searchbarCreateManyInput | collectivites_searchbarCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * collectivites_searchbar update
   */
  export type collectivites_searchbarUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collectivites_searchbar
     */
    select?: collectivites_searchbarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collectivites_searchbar
     */
    omit?: collectivites_searchbarOmit<ExtArgs> | null
    /**
     * The data needed to update a collectivites_searchbar.
     */
    data: XOR<collectivites_searchbarUpdateInput, collectivites_searchbarUncheckedUpdateInput>
    /**
     * Choose, which collectivites_searchbar to update.
     */
    where: collectivites_searchbarWhereUniqueInput
  }

  /**
   * collectivites_searchbar updateMany
   */
  export type collectivites_searchbarUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update collectivites_searchbars.
     */
    data: XOR<collectivites_searchbarUpdateManyMutationInput, collectivites_searchbarUncheckedUpdateManyInput>
    /**
     * Filter which collectivites_searchbars to update
     */
    where?: collectivites_searchbarWhereInput
    /**
     * Limit how many collectivites_searchbars to update.
     */
    limit?: number
  }

  /**
   * collectivites_searchbar updateManyAndReturn
   */
  export type collectivites_searchbarUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collectivites_searchbar
     */
    select?: collectivites_searchbarSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the collectivites_searchbar
     */
    omit?: collectivites_searchbarOmit<ExtArgs> | null
    /**
     * The data used to update collectivites_searchbars.
     */
    data: XOR<collectivites_searchbarUpdateManyMutationInput, collectivites_searchbarUncheckedUpdateManyInput>
    /**
     * Filter which collectivites_searchbars to update
     */
    where?: collectivites_searchbarWhereInput
    /**
     * Limit how many collectivites_searchbars to update.
     */
    limit?: number
  }

  /**
   * collectivites_searchbar upsert
   */
  export type collectivites_searchbarUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collectivites_searchbar
     */
    select?: collectivites_searchbarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collectivites_searchbar
     */
    omit?: collectivites_searchbarOmit<ExtArgs> | null
    /**
     * The filter to search for the collectivites_searchbar to update in case it exists.
     */
    where: collectivites_searchbarWhereUniqueInput
    /**
     * In case the collectivites_searchbar found by the `where` argument doesn't exist, create a new collectivites_searchbar with this data.
     */
    create: XOR<collectivites_searchbarCreateInput, collectivites_searchbarUncheckedCreateInput>
    /**
     * In case the collectivites_searchbar was found with the provided `where` argument, update it with this data.
     */
    update: XOR<collectivites_searchbarUpdateInput, collectivites_searchbarUncheckedUpdateInput>
  }

  /**
   * collectivites_searchbar delete
   */
  export type collectivites_searchbarDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collectivites_searchbar
     */
    select?: collectivites_searchbarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collectivites_searchbar
     */
    omit?: collectivites_searchbarOmit<ExtArgs> | null
    /**
     * Filter which collectivites_searchbar to delete.
     */
    where: collectivites_searchbarWhereUniqueInput
  }

  /**
   * collectivites_searchbar deleteMany
   */
  export type collectivites_searchbarDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which collectivites_searchbars to delete
     */
    where?: collectivites_searchbarWhereInput
    /**
     * Limit how many collectivites_searchbars to delete.
     */
    limit?: number
  }

  /**
   * collectivites_searchbar without action
   */
  export type collectivites_searchbarDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the collectivites_searchbar
     */
    select?: collectivites_searchbarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the collectivites_searchbar
     */
    omit?: collectivites_searchbarOmit<ExtArgs> | null
  }


  /**
   * Model confort_thermique
   */

  export type AggregateConfort_thermique = {
    _count: Confort_thermiqueCountAggregateOutputType | null
    _avg: Confort_thermiqueAvgAggregateOutputType | null
    _sum: Confort_thermiqueSumAggregateOutputType | null
    _min: Confort_thermiqueMinAggregateOutputType | null
    _max: Confort_thermiqueMaxAggregateOutputType | null
  }

  export type Confort_thermiqueAvgAggregateOutputType = {
    index: number | null
    region: number | null
    age_bati_post06: number | null
    age_bati_91_05: number | null
    age_bati_46_90: number | null
    age_bati_19_45: number | null
    age_bati_pre_19: number | null
    under_4_sum_1968: number | null
    to_75_sum_1968: number | null
    over_75_sum_1968: number | null
    under_4_sum_1975: number | null
    to_75_sum_1975: number | null
    over_75_sum_1975: number | null
    under_4_sum_1982: number | null
    to_75_sum_1982: number | null
    over_75_sum_1982: number | null
    under_4_sum_1990: number | null
    to_75_sum_1990: number | null
    over_75_sum_1990: number | null
    under_4_sum_1999: number | null
    to_75_sum_1999: number | null
    over_75_sum_1999: number | null
    under_4_sum_2009: number | null
    to_75_sum_2009: number | null
    over_75_sum_2009: number | null
    under_4_sum_2014: number | null
    to_75_sum_2014: number | null
    over_75_sum_2014: number | null
    under_4_sum_2020: number | null
    to_75_sum_2020: number | null
    over_75_sum_2020: number | null
    tee_log: number | null
    tee_mob: number | null
    precarite_logement: number | null
    NA5AZ_sum: number | null
    NA5BE_sum: number | null
    NA5FZ_sum: number | null
    NA5GU_sum: number | null
    NA5OQ_sum: number | null
    clc_1_artificialise: number | null
    clc_2_agricole: number | null
    clc_3_foret_semiNaturel: number | null
    clc_4_humide: number | null
    clc_5_eau: number | null
    superf_choro: number | null
  }

  export type Confort_thermiqueSumAggregateOutputType = {
    index: number | null
    region: number | null
    age_bati_post06: number | null
    age_bati_91_05: number | null
    age_bati_46_90: number | null
    age_bati_19_45: number | null
    age_bati_pre_19: number | null
    under_4_sum_1968: number | null
    to_75_sum_1968: number | null
    over_75_sum_1968: number | null
    under_4_sum_1975: number | null
    to_75_sum_1975: number | null
    over_75_sum_1975: number | null
    under_4_sum_1982: number | null
    to_75_sum_1982: number | null
    over_75_sum_1982: number | null
    under_4_sum_1990: number | null
    to_75_sum_1990: number | null
    over_75_sum_1990: number | null
    under_4_sum_1999: number | null
    to_75_sum_1999: number | null
    over_75_sum_1999: number | null
    under_4_sum_2009: number | null
    to_75_sum_2009: number | null
    over_75_sum_2009: number | null
    under_4_sum_2014: number | null
    to_75_sum_2014: number | null
    over_75_sum_2014: number | null
    under_4_sum_2020: number | null
    to_75_sum_2020: number | null
    over_75_sum_2020: number | null
    tee_log: number | null
    tee_mob: number | null
    precarite_logement: number | null
    NA5AZ_sum: number | null
    NA5BE_sum: number | null
    NA5FZ_sum: number | null
    NA5GU_sum: number | null
    NA5OQ_sum: number | null
    clc_1_artificialise: number | null
    clc_2_agricole: number | null
    clc_3_foret_semiNaturel: number | null
    clc_4_humide: number | null
    clc_5_eau: number | null
    superf_choro: number | null
  }

  export type Confort_thermiqueMinAggregateOutputType = {
    index: number | null
    code_geographique: string | null
    libelle_geographique: string | null
    epci: string | null
    libelle_epci: string | null
    departement: string | null
    libelle_departement: string | null
    region: number | null
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
    age_bati_post06: number | null
    age_bati_91_05: number | null
    age_bati_46_90: number | null
    age_bati_19_45: number | null
    age_bati_pre_19: number | null
    under_4_sum_1968: number | null
    to_75_sum_1968: number | null
    over_75_sum_1968: number | null
    under_4_sum_1975: number | null
    to_75_sum_1975: number | null
    over_75_sum_1975: number | null
    under_4_sum_1982: number | null
    to_75_sum_1982: number | null
    over_75_sum_1982: number | null
    under_4_sum_1990: number | null
    to_75_sum_1990: number | null
    over_75_sum_1990: number | null
    under_4_sum_1999: number | null
    to_75_sum_1999: number | null
    over_75_sum_1999: number | null
    under_4_sum_2009: number | null
    to_75_sum_2009: number | null
    over_75_sum_2009: number | null
    under_4_sum_2014: number | null
    to_75_sum_2014: number | null
    over_75_sum_2014: number | null
    under_4_sum_2020: number | null
    to_75_sum_2020: number | null
    over_75_sum_2020: number | null
    tee_log: number | null
    tee_mob: number | null
    precarite_logement: number | null
    NA5AZ_sum: number | null
    NA5BE_sum: number | null
    NA5FZ_sum: number | null
    NA5GU_sum: number | null
    NA5OQ_sum: number | null
    clc_1_artificialise: number | null
    clc_2_agricole: number | null
    clc_3_foret_semiNaturel: number | null
    clc_4_humide: number | null
    clc_5_eau: number | null
    superf_choro: number | null
  }

  export type Confort_thermiqueMaxAggregateOutputType = {
    index: number | null
    code_geographique: string | null
    libelle_geographique: string | null
    epci: string | null
    libelle_epci: string | null
    departement: string | null
    libelle_departement: string | null
    region: number | null
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
    age_bati_post06: number | null
    age_bati_91_05: number | null
    age_bati_46_90: number | null
    age_bati_19_45: number | null
    age_bati_pre_19: number | null
    under_4_sum_1968: number | null
    to_75_sum_1968: number | null
    over_75_sum_1968: number | null
    under_4_sum_1975: number | null
    to_75_sum_1975: number | null
    over_75_sum_1975: number | null
    under_4_sum_1982: number | null
    to_75_sum_1982: number | null
    over_75_sum_1982: number | null
    under_4_sum_1990: number | null
    to_75_sum_1990: number | null
    over_75_sum_1990: number | null
    under_4_sum_1999: number | null
    to_75_sum_1999: number | null
    over_75_sum_1999: number | null
    under_4_sum_2009: number | null
    to_75_sum_2009: number | null
    over_75_sum_2009: number | null
    under_4_sum_2014: number | null
    to_75_sum_2014: number | null
    over_75_sum_2014: number | null
    under_4_sum_2020: number | null
    to_75_sum_2020: number | null
    over_75_sum_2020: number | null
    tee_log: number | null
    tee_mob: number | null
    precarite_logement: number | null
    NA5AZ_sum: number | null
    NA5BE_sum: number | null
    NA5FZ_sum: number | null
    NA5GU_sum: number | null
    NA5OQ_sum: number | null
    clc_1_artificialise: number | null
    clc_2_agricole: number | null
    clc_3_foret_semiNaturel: number | null
    clc_4_humide: number | null
    clc_5_eau: number | null
    superf_choro: number | null
  }

  export type Confort_thermiqueCountAggregateOutputType = {
    index: number
    code_geographique: number
    libelle_geographique: number
    epci: number
    libelle_epci: number
    departement: number
    libelle_departement: number
    region: number
    ept: number
    libelle_petr: number
    code_pnr: number
    libelle_pnr: number
    age_bati_post06: number
    age_bati_91_05: number
    age_bati_46_90: number
    age_bati_19_45: number
    age_bati_pre_19: number
    under_4_sum_1968: number
    to_75_sum_1968: number
    over_75_sum_1968: number
    under_4_sum_1975: number
    to_75_sum_1975: number
    over_75_sum_1975: number
    under_4_sum_1982: number
    to_75_sum_1982: number
    over_75_sum_1982: number
    under_4_sum_1990: number
    to_75_sum_1990: number
    over_75_sum_1990: number
    under_4_sum_1999: number
    to_75_sum_1999: number
    over_75_sum_1999: number
    under_4_sum_2009: number
    to_75_sum_2009: number
    over_75_sum_2009: number
    under_4_sum_2014: number
    to_75_sum_2014: number
    over_75_sum_2014: number
    under_4_sum_2020: number
    to_75_sum_2020: number
    over_75_sum_2020: number
    tee_log: number
    tee_mob: number
    precarite_logement: number
    NA5AZ_sum: number
    NA5BE_sum: number
    NA5FZ_sum: number
    NA5GU_sum: number
    NA5OQ_sum: number
    clc_1_artificialise: number
    clc_2_agricole: number
    clc_3_foret_semiNaturel: number
    clc_4_humide: number
    clc_5_eau: number
    superf_choro: number
    _all: number
  }


  export type Confort_thermiqueAvgAggregateInputType = {
    index?: true
    region?: true
    age_bati_post06?: true
    age_bati_91_05?: true
    age_bati_46_90?: true
    age_bati_19_45?: true
    age_bati_pre_19?: true
    under_4_sum_1968?: true
    to_75_sum_1968?: true
    over_75_sum_1968?: true
    under_4_sum_1975?: true
    to_75_sum_1975?: true
    over_75_sum_1975?: true
    under_4_sum_1982?: true
    to_75_sum_1982?: true
    over_75_sum_1982?: true
    under_4_sum_1990?: true
    to_75_sum_1990?: true
    over_75_sum_1990?: true
    under_4_sum_1999?: true
    to_75_sum_1999?: true
    over_75_sum_1999?: true
    under_4_sum_2009?: true
    to_75_sum_2009?: true
    over_75_sum_2009?: true
    under_4_sum_2014?: true
    to_75_sum_2014?: true
    over_75_sum_2014?: true
    under_4_sum_2020?: true
    to_75_sum_2020?: true
    over_75_sum_2020?: true
    tee_log?: true
    tee_mob?: true
    precarite_logement?: true
    NA5AZ_sum?: true
    NA5BE_sum?: true
    NA5FZ_sum?: true
    NA5GU_sum?: true
    NA5OQ_sum?: true
    clc_1_artificialise?: true
    clc_2_agricole?: true
    clc_3_foret_semiNaturel?: true
    clc_4_humide?: true
    clc_5_eau?: true
    superf_choro?: true
  }

  export type Confort_thermiqueSumAggregateInputType = {
    index?: true
    region?: true
    age_bati_post06?: true
    age_bati_91_05?: true
    age_bati_46_90?: true
    age_bati_19_45?: true
    age_bati_pre_19?: true
    under_4_sum_1968?: true
    to_75_sum_1968?: true
    over_75_sum_1968?: true
    under_4_sum_1975?: true
    to_75_sum_1975?: true
    over_75_sum_1975?: true
    under_4_sum_1982?: true
    to_75_sum_1982?: true
    over_75_sum_1982?: true
    under_4_sum_1990?: true
    to_75_sum_1990?: true
    over_75_sum_1990?: true
    under_4_sum_1999?: true
    to_75_sum_1999?: true
    over_75_sum_1999?: true
    under_4_sum_2009?: true
    to_75_sum_2009?: true
    over_75_sum_2009?: true
    under_4_sum_2014?: true
    to_75_sum_2014?: true
    over_75_sum_2014?: true
    under_4_sum_2020?: true
    to_75_sum_2020?: true
    over_75_sum_2020?: true
    tee_log?: true
    tee_mob?: true
    precarite_logement?: true
    NA5AZ_sum?: true
    NA5BE_sum?: true
    NA5FZ_sum?: true
    NA5GU_sum?: true
    NA5OQ_sum?: true
    clc_1_artificialise?: true
    clc_2_agricole?: true
    clc_3_foret_semiNaturel?: true
    clc_4_humide?: true
    clc_5_eau?: true
    superf_choro?: true
  }

  export type Confort_thermiqueMinAggregateInputType = {
    index?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
    age_bati_post06?: true
    age_bati_91_05?: true
    age_bati_46_90?: true
    age_bati_19_45?: true
    age_bati_pre_19?: true
    under_4_sum_1968?: true
    to_75_sum_1968?: true
    over_75_sum_1968?: true
    under_4_sum_1975?: true
    to_75_sum_1975?: true
    over_75_sum_1975?: true
    under_4_sum_1982?: true
    to_75_sum_1982?: true
    over_75_sum_1982?: true
    under_4_sum_1990?: true
    to_75_sum_1990?: true
    over_75_sum_1990?: true
    under_4_sum_1999?: true
    to_75_sum_1999?: true
    over_75_sum_1999?: true
    under_4_sum_2009?: true
    to_75_sum_2009?: true
    over_75_sum_2009?: true
    under_4_sum_2014?: true
    to_75_sum_2014?: true
    over_75_sum_2014?: true
    under_4_sum_2020?: true
    to_75_sum_2020?: true
    over_75_sum_2020?: true
    tee_log?: true
    tee_mob?: true
    precarite_logement?: true
    NA5AZ_sum?: true
    NA5BE_sum?: true
    NA5FZ_sum?: true
    NA5GU_sum?: true
    NA5OQ_sum?: true
    clc_1_artificialise?: true
    clc_2_agricole?: true
    clc_3_foret_semiNaturel?: true
    clc_4_humide?: true
    clc_5_eau?: true
    superf_choro?: true
  }

  export type Confort_thermiqueMaxAggregateInputType = {
    index?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
    age_bati_post06?: true
    age_bati_91_05?: true
    age_bati_46_90?: true
    age_bati_19_45?: true
    age_bati_pre_19?: true
    under_4_sum_1968?: true
    to_75_sum_1968?: true
    over_75_sum_1968?: true
    under_4_sum_1975?: true
    to_75_sum_1975?: true
    over_75_sum_1975?: true
    under_4_sum_1982?: true
    to_75_sum_1982?: true
    over_75_sum_1982?: true
    under_4_sum_1990?: true
    to_75_sum_1990?: true
    over_75_sum_1990?: true
    under_4_sum_1999?: true
    to_75_sum_1999?: true
    over_75_sum_1999?: true
    under_4_sum_2009?: true
    to_75_sum_2009?: true
    over_75_sum_2009?: true
    under_4_sum_2014?: true
    to_75_sum_2014?: true
    over_75_sum_2014?: true
    under_4_sum_2020?: true
    to_75_sum_2020?: true
    over_75_sum_2020?: true
    tee_log?: true
    tee_mob?: true
    precarite_logement?: true
    NA5AZ_sum?: true
    NA5BE_sum?: true
    NA5FZ_sum?: true
    NA5GU_sum?: true
    NA5OQ_sum?: true
    clc_1_artificialise?: true
    clc_2_agricole?: true
    clc_3_foret_semiNaturel?: true
    clc_4_humide?: true
    clc_5_eau?: true
    superf_choro?: true
  }

  export type Confort_thermiqueCountAggregateInputType = {
    index?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
    age_bati_post06?: true
    age_bati_91_05?: true
    age_bati_46_90?: true
    age_bati_19_45?: true
    age_bati_pre_19?: true
    under_4_sum_1968?: true
    to_75_sum_1968?: true
    over_75_sum_1968?: true
    under_4_sum_1975?: true
    to_75_sum_1975?: true
    over_75_sum_1975?: true
    under_4_sum_1982?: true
    to_75_sum_1982?: true
    over_75_sum_1982?: true
    under_4_sum_1990?: true
    to_75_sum_1990?: true
    over_75_sum_1990?: true
    under_4_sum_1999?: true
    to_75_sum_1999?: true
    over_75_sum_1999?: true
    under_4_sum_2009?: true
    to_75_sum_2009?: true
    over_75_sum_2009?: true
    under_4_sum_2014?: true
    to_75_sum_2014?: true
    over_75_sum_2014?: true
    under_4_sum_2020?: true
    to_75_sum_2020?: true
    over_75_sum_2020?: true
    tee_log?: true
    tee_mob?: true
    precarite_logement?: true
    NA5AZ_sum?: true
    NA5BE_sum?: true
    NA5FZ_sum?: true
    NA5GU_sum?: true
    NA5OQ_sum?: true
    clc_1_artificialise?: true
    clc_2_agricole?: true
    clc_3_foret_semiNaturel?: true
    clc_4_humide?: true
    clc_5_eau?: true
    superf_choro?: true
    _all?: true
  }

  export type Confort_thermiqueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which confort_thermique to aggregate.
     */
    where?: confort_thermiqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of confort_thermiques to fetch.
     */
    orderBy?: confort_thermiqueOrderByWithRelationInput | confort_thermiqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: confort_thermiqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` confort_thermiques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` confort_thermiques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned confort_thermiques
    **/
    _count?: true | Confort_thermiqueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Confort_thermiqueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Confort_thermiqueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Confort_thermiqueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Confort_thermiqueMaxAggregateInputType
  }

  export type GetConfort_thermiqueAggregateType<T extends Confort_thermiqueAggregateArgs> = {
        [P in keyof T & keyof AggregateConfort_thermique]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfort_thermique[P]>
      : GetScalarType<T[P], AggregateConfort_thermique[P]>
  }




  export type confort_thermiqueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: confort_thermiqueWhereInput
    orderBy?: confort_thermiqueOrderByWithAggregationInput | confort_thermiqueOrderByWithAggregationInput[]
    by: Confort_thermiqueScalarFieldEnum[] | Confort_thermiqueScalarFieldEnum
    having?: confort_thermiqueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Confort_thermiqueCountAggregateInputType | true
    _avg?: Confort_thermiqueAvgAggregateInputType
    _sum?: Confort_thermiqueSumAggregateInputType
    _min?: Confort_thermiqueMinAggregateInputType
    _max?: Confort_thermiqueMaxAggregateInputType
  }

  export type Confort_thermiqueGroupByOutputType = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
    age_bati_post06: number | null
    age_bati_91_05: number | null
    age_bati_46_90: number | null
    age_bati_19_45: number | null
    age_bati_pre_19: number | null
    under_4_sum_1968: number | null
    to_75_sum_1968: number | null
    over_75_sum_1968: number | null
    under_4_sum_1975: number | null
    to_75_sum_1975: number | null
    over_75_sum_1975: number | null
    under_4_sum_1982: number | null
    to_75_sum_1982: number | null
    over_75_sum_1982: number | null
    under_4_sum_1990: number | null
    to_75_sum_1990: number | null
    over_75_sum_1990: number | null
    under_4_sum_1999: number | null
    to_75_sum_1999: number | null
    over_75_sum_1999: number | null
    under_4_sum_2009: number | null
    to_75_sum_2009: number | null
    over_75_sum_2009: number | null
    under_4_sum_2014: number | null
    to_75_sum_2014: number | null
    over_75_sum_2014: number | null
    under_4_sum_2020: number | null
    to_75_sum_2020: number | null
    over_75_sum_2020: number | null
    tee_log: number | null
    tee_mob: number | null
    precarite_logement: number | null
    NA5AZ_sum: number | null
    NA5BE_sum: number | null
    NA5FZ_sum: number | null
    NA5GU_sum: number | null
    NA5OQ_sum: number | null
    clc_1_artificialise: number | null
    clc_2_agricole: number | null
    clc_3_foret_semiNaturel: number | null
    clc_4_humide: number | null
    clc_5_eau: number | null
    superf_choro: number | null
    _count: Confort_thermiqueCountAggregateOutputType | null
    _avg: Confort_thermiqueAvgAggregateOutputType | null
    _sum: Confort_thermiqueSumAggregateOutputType | null
    _min: Confort_thermiqueMinAggregateOutputType | null
    _max: Confort_thermiqueMaxAggregateOutputType | null
  }

  type GetConfort_thermiqueGroupByPayload<T extends confort_thermiqueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Confort_thermiqueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Confort_thermiqueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Confort_thermiqueGroupByOutputType[P]>
            : GetScalarType<T[P], Confort_thermiqueGroupByOutputType[P]>
        }
      >
    >


  export type confort_thermiqueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    age_bati_post06?: boolean
    age_bati_91_05?: boolean
    age_bati_46_90?: boolean
    age_bati_19_45?: boolean
    age_bati_pre_19?: boolean
    under_4_sum_1968?: boolean
    to_75_sum_1968?: boolean
    over_75_sum_1968?: boolean
    under_4_sum_1975?: boolean
    to_75_sum_1975?: boolean
    over_75_sum_1975?: boolean
    under_4_sum_1982?: boolean
    to_75_sum_1982?: boolean
    over_75_sum_1982?: boolean
    under_4_sum_1990?: boolean
    to_75_sum_1990?: boolean
    over_75_sum_1990?: boolean
    under_4_sum_1999?: boolean
    to_75_sum_1999?: boolean
    over_75_sum_1999?: boolean
    under_4_sum_2009?: boolean
    to_75_sum_2009?: boolean
    over_75_sum_2009?: boolean
    under_4_sum_2014?: boolean
    to_75_sum_2014?: boolean
    over_75_sum_2014?: boolean
    under_4_sum_2020?: boolean
    to_75_sum_2020?: boolean
    over_75_sum_2020?: boolean
    tee_log?: boolean
    tee_mob?: boolean
    precarite_logement?: boolean
    NA5AZ_sum?: boolean
    NA5BE_sum?: boolean
    NA5FZ_sum?: boolean
    NA5GU_sum?: boolean
    NA5OQ_sum?: boolean
    clc_1_artificialise?: boolean
    clc_2_agricole?: boolean
    clc_3_foret_semiNaturel?: boolean
    clc_4_humide?: boolean
    clc_5_eau?: boolean
    superf_choro?: boolean
  }, ExtArgs["result"]["confort_thermique"]>

  export type confort_thermiqueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    age_bati_post06?: boolean
    age_bati_91_05?: boolean
    age_bati_46_90?: boolean
    age_bati_19_45?: boolean
    age_bati_pre_19?: boolean
    under_4_sum_1968?: boolean
    to_75_sum_1968?: boolean
    over_75_sum_1968?: boolean
    under_4_sum_1975?: boolean
    to_75_sum_1975?: boolean
    over_75_sum_1975?: boolean
    under_4_sum_1982?: boolean
    to_75_sum_1982?: boolean
    over_75_sum_1982?: boolean
    under_4_sum_1990?: boolean
    to_75_sum_1990?: boolean
    over_75_sum_1990?: boolean
    under_4_sum_1999?: boolean
    to_75_sum_1999?: boolean
    over_75_sum_1999?: boolean
    under_4_sum_2009?: boolean
    to_75_sum_2009?: boolean
    over_75_sum_2009?: boolean
    under_4_sum_2014?: boolean
    to_75_sum_2014?: boolean
    over_75_sum_2014?: boolean
    under_4_sum_2020?: boolean
    to_75_sum_2020?: boolean
    over_75_sum_2020?: boolean
    tee_log?: boolean
    tee_mob?: boolean
    precarite_logement?: boolean
    NA5AZ_sum?: boolean
    NA5BE_sum?: boolean
    NA5FZ_sum?: boolean
    NA5GU_sum?: boolean
    NA5OQ_sum?: boolean
    clc_1_artificialise?: boolean
    clc_2_agricole?: boolean
    clc_3_foret_semiNaturel?: boolean
    clc_4_humide?: boolean
    clc_5_eau?: boolean
    superf_choro?: boolean
  }, ExtArgs["result"]["confort_thermique"]>

  export type confort_thermiqueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    age_bati_post06?: boolean
    age_bati_91_05?: boolean
    age_bati_46_90?: boolean
    age_bati_19_45?: boolean
    age_bati_pre_19?: boolean
    under_4_sum_1968?: boolean
    to_75_sum_1968?: boolean
    over_75_sum_1968?: boolean
    under_4_sum_1975?: boolean
    to_75_sum_1975?: boolean
    over_75_sum_1975?: boolean
    under_4_sum_1982?: boolean
    to_75_sum_1982?: boolean
    over_75_sum_1982?: boolean
    under_4_sum_1990?: boolean
    to_75_sum_1990?: boolean
    over_75_sum_1990?: boolean
    under_4_sum_1999?: boolean
    to_75_sum_1999?: boolean
    over_75_sum_1999?: boolean
    under_4_sum_2009?: boolean
    to_75_sum_2009?: boolean
    over_75_sum_2009?: boolean
    under_4_sum_2014?: boolean
    to_75_sum_2014?: boolean
    over_75_sum_2014?: boolean
    under_4_sum_2020?: boolean
    to_75_sum_2020?: boolean
    over_75_sum_2020?: boolean
    tee_log?: boolean
    tee_mob?: boolean
    precarite_logement?: boolean
    NA5AZ_sum?: boolean
    NA5BE_sum?: boolean
    NA5FZ_sum?: boolean
    NA5GU_sum?: boolean
    NA5OQ_sum?: boolean
    clc_1_artificialise?: boolean
    clc_2_agricole?: boolean
    clc_3_foret_semiNaturel?: boolean
    clc_4_humide?: boolean
    clc_5_eau?: boolean
    superf_choro?: boolean
  }, ExtArgs["result"]["confort_thermique"]>

  export type confort_thermiqueSelectScalar = {
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    age_bati_post06?: boolean
    age_bati_91_05?: boolean
    age_bati_46_90?: boolean
    age_bati_19_45?: boolean
    age_bati_pre_19?: boolean
    under_4_sum_1968?: boolean
    to_75_sum_1968?: boolean
    over_75_sum_1968?: boolean
    under_4_sum_1975?: boolean
    to_75_sum_1975?: boolean
    over_75_sum_1975?: boolean
    under_4_sum_1982?: boolean
    to_75_sum_1982?: boolean
    over_75_sum_1982?: boolean
    under_4_sum_1990?: boolean
    to_75_sum_1990?: boolean
    over_75_sum_1990?: boolean
    under_4_sum_1999?: boolean
    to_75_sum_1999?: boolean
    over_75_sum_1999?: boolean
    under_4_sum_2009?: boolean
    to_75_sum_2009?: boolean
    over_75_sum_2009?: boolean
    under_4_sum_2014?: boolean
    to_75_sum_2014?: boolean
    over_75_sum_2014?: boolean
    under_4_sum_2020?: boolean
    to_75_sum_2020?: boolean
    over_75_sum_2020?: boolean
    tee_log?: boolean
    tee_mob?: boolean
    precarite_logement?: boolean
    NA5AZ_sum?: boolean
    NA5BE_sum?: boolean
    NA5FZ_sum?: boolean
    NA5GU_sum?: boolean
    NA5OQ_sum?: boolean
    clc_1_artificialise?: boolean
    clc_2_agricole?: boolean
    clc_3_foret_semiNaturel?: boolean
    clc_4_humide?: boolean
    clc_5_eau?: boolean
    superf_choro?: boolean
  }

  export type confort_thermiqueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"index" | "code_geographique" | "libelle_geographique" | "epci" | "libelle_epci" | "departement" | "libelle_departement" | "region" | "ept" | "libelle_petr" | "code_pnr" | "libelle_pnr" | "age_bati_post06" | "age_bati_91_05" | "age_bati_46_90" | "age_bati_19_45" | "age_bati_pre_19" | "under_4_sum_1968" | "to_75_sum_1968" | "over_75_sum_1968" | "under_4_sum_1975" | "to_75_sum_1975" | "over_75_sum_1975" | "under_4_sum_1982" | "to_75_sum_1982" | "over_75_sum_1982" | "under_4_sum_1990" | "to_75_sum_1990" | "over_75_sum_1990" | "under_4_sum_1999" | "to_75_sum_1999" | "over_75_sum_1999" | "under_4_sum_2009" | "to_75_sum_2009" | "over_75_sum_2009" | "under_4_sum_2014" | "to_75_sum_2014" | "over_75_sum_2014" | "under_4_sum_2020" | "to_75_sum_2020" | "over_75_sum_2020" | "tee_log" | "tee_mob" | "precarite_logement" | "NA5AZ_sum" | "NA5BE_sum" | "NA5FZ_sum" | "NA5GU_sum" | "NA5OQ_sum" | "clc_1_artificialise" | "clc_2_agricole" | "clc_3_foret_semiNaturel" | "clc_4_humide" | "clc_5_eau" | "superf_choro", ExtArgs["result"]["confort_thermique"]>

  export type $confort_thermiquePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "confort_thermique"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      index: number
      code_geographique: string
      libelle_geographique: string
      epci: string
      libelle_epci: string
      departement: string
      libelle_departement: string
      region: number
      ept: string | null
      libelle_petr: string | null
      code_pnr: string | null
      libelle_pnr: string | null
      age_bati_post06: number | null
      age_bati_91_05: number | null
      age_bati_46_90: number | null
      age_bati_19_45: number | null
      age_bati_pre_19: number | null
      under_4_sum_1968: number | null
      to_75_sum_1968: number | null
      over_75_sum_1968: number | null
      under_4_sum_1975: number | null
      to_75_sum_1975: number | null
      over_75_sum_1975: number | null
      under_4_sum_1982: number | null
      to_75_sum_1982: number | null
      over_75_sum_1982: number | null
      under_4_sum_1990: number | null
      to_75_sum_1990: number | null
      over_75_sum_1990: number | null
      under_4_sum_1999: number | null
      to_75_sum_1999: number | null
      over_75_sum_1999: number | null
      under_4_sum_2009: number | null
      to_75_sum_2009: number | null
      over_75_sum_2009: number | null
      under_4_sum_2014: number | null
      to_75_sum_2014: number | null
      over_75_sum_2014: number | null
      under_4_sum_2020: number | null
      to_75_sum_2020: number | null
      over_75_sum_2020: number | null
      tee_log: number | null
      tee_mob: number | null
      precarite_logement: number | null
      NA5AZ_sum: number | null
      NA5BE_sum: number | null
      NA5FZ_sum: number | null
      NA5GU_sum: number | null
      NA5OQ_sum: number | null
      clc_1_artificialise: number | null
      clc_2_agricole: number | null
      clc_3_foret_semiNaturel: number | null
      clc_4_humide: number | null
      clc_5_eau: number | null
      superf_choro: number | null
    }, ExtArgs["result"]["confort_thermique"]>
    composites: {}
  }

  type confort_thermiqueGetPayload<S extends boolean | null | undefined | confort_thermiqueDefaultArgs> = $Result.GetResult<Prisma.$confort_thermiquePayload, S>

  type confort_thermiqueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<confort_thermiqueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Confort_thermiqueCountAggregateInputType | true
    }

  export interface confort_thermiqueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['confort_thermique'], meta: { name: 'confort_thermique' } }
    /**
     * Find zero or one Confort_thermique that matches the filter.
     * @param {confort_thermiqueFindUniqueArgs} args - Arguments to find a Confort_thermique
     * @example
     * // Get one Confort_thermique
     * const confort_thermique = await prisma.confort_thermique.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends confort_thermiqueFindUniqueArgs>(args: SelectSubset<T, confort_thermiqueFindUniqueArgs<ExtArgs>>): Prisma__confort_thermiqueClient<$Result.GetResult<Prisma.$confort_thermiquePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Confort_thermique that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {confort_thermiqueFindUniqueOrThrowArgs} args - Arguments to find a Confort_thermique
     * @example
     * // Get one Confort_thermique
     * const confort_thermique = await prisma.confort_thermique.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends confort_thermiqueFindUniqueOrThrowArgs>(args: SelectSubset<T, confort_thermiqueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__confort_thermiqueClient<$Result.GetResult<Prisma.$confort_thermiquePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Confort_thermique that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {confort_thermiqueFindFirstArgs} args - Arguments to find a Confort_thermique
     * @example
     * // Get one Confort_thermique
     * const confort_thermique = await prisma.confort_thermique.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends confort_thermiqueFindFirstArgs>(args?: SelectSubset<T, confort_thermiqueFindFirstArgs<ExtArgs>>): Prisma__confort_thermiqueClient<$Result.GetResult<Prisma.$confort_thermiquePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Confort_thermique that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {confort_thermiqueFindFirstOrThrowArgs} args - Arguments to find a Confort_thermique
     * @example
     * // Get one Confort_thermique
     * const confort_thermique = await prisma.confort_thermique.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends confort_thermiqueFindFirstOrThrowArgs>(args?: SelectSubset<T, confort_thermiqueFindFirstOrThrowArgs<ExtArgs>>): Prisma__confort_thermiqueClient<$Result.GetResult<Prisma.$confort_thermiquePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Confort_thermiques that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {confort_thermiqueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Confort_thermiques
     * const confort_thermiques = await prisma.confort_thermique.findMany()
     * 
     * // Get first 10 Confort_thermiques
     * const confort_thermiques = await prisma.confort_thermique.findMany({ take: 10 })
     * 
     * // Only select the `index`
     * const confort_thermiqueWithIndexOnly = await prisma.confort_thermique.findMany({ select: { index: true } })
     * 
     */
    findMany<T extends confort_thermiqueFindManyArgs>(args?: SelectSubset<T, confort_thermiqueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$confort_thermiquePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Confort_thermique.
     * @param {confort_thermiqueCreateArgs} args - Arguments to create a Confort_thermique.
     * @example
     * // Create one Confort_thermique
     * const Confort_thermique = await prisma.confort_thermique.create({
     *   data: {
     *     // ... data to create a Confort_thermique
     *   }
     * })
     * 
     */
    create<T extends confort_thermiqueCreateArgs>(args: SelectSubset<T, confort_thermiqueCreateArgs<ExtArgs>>): Prisma__confort_thermiqueClient<$Result.GetResult<Prisma.$confort_thermiquePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Confort_thermiques.
     * @param {confort_thermiqueCreateManyArgs} args - Arguments to create many Confort_thermiques.
     * @example
     * // Create many Confort_thermiques
     * const confort_thermique = await prisma.confort_thermique.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends confort_thermiqueCreateManyArgs>(args?: SelectSubset<T, confort_thermiqueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Confort_thermiques and returns the data saved in the database.
     * @param {confort_thermiqueCreateManyAndReturnArgs} args - Arguments to create many Confort_thermiques.
     * @example
     * // Create many Confort_thermiques
     * const confort_thermique = await prisma.confort_thermique.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Confort_thermiques and only return the `index`
     * const confort_thermiqueWithIndexOnly = await prisma.confort_thermique.createManyAndReturn({
     *   select: { index: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends confort_thermiqueCreateManyAndReturnArgs>(args?: SelectSubset<T, confort_thermiqueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$confort_thermiquePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Confort_thermique.
     * @param {confort_thermiqueDeleteArgs} args - Arguments to delete one Confort_thermique.
     * @example
     * // Delete one Confort_thermique
     * const Confort_thermique = await prisma.confort_thermique.delete({
     *   where: {
     *     // ... filter to delete one Confort_thermique
     *   }
     * })
     * 
     */
    delete<T extends confort_thermiqueDeleteArgs>(args: SelectSubset<T, confort_thermiqueDeleteArgs<ExtArgs>>): Prisma__confort_thermiqueClient<$Result.GetResult<Prisma.$confort_thermiquePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Confort_thermique.
     * @param {confort_thermiqueUpdateArgs} args - Arguments to update one Confort_thermique.
     * @example
     * // Update one Confort_thermique
     * const confort_thermique = await prisma.confort_thermique.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends confort_thermiqueUpdateArgs>(args: SelectSubset<T, confort_thermiqueUpdateArgs<ExtArgs>>): Prisma__confort_thermiqueClient<$Result.GetResult<Prisma.$confort_thermiquePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Confort_thermiques.
     * @param {confort_thermiqueDeleteManyArgs} args - Arguments to filter Confort_thermiques to delete.
     * @example
     * // Delete a few Confort_thermiques
     * const { count } = await prisma.confort_thermique.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends confort_thermiqueDeleteManyArgs>(args?: SelectSubset<T, confort_thermiqueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Confort_thermiques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {confort_thermiqueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Confort_thermiques
     * const confort_thermique = await prisma.confort_thermique.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends confort_thermiqueUpdateManyArgs>(args: SelectSubset<T, confort_thermiqueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Confort_thermiques and returns the data updated in the database.
     * @param {confort_thermiqueUpdateManyAndReturnArgs} args - Arguments to update many Confort_thermiques.
     * @example
     * // Update many Confort_thermiques
     * const confort_thermique = await prisma.confort_thermique.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Confort_thermiques and only return the `index`
     * const confort_thermiqueWithIndexOnly = await prisma.confort_thermique.updateManyAndReturn({
     *   select: { index: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends confort_thermiqueUpdateManyAndReturnArgs>(args: SelectSubset<T, confort_thermiqueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$confort_thermiquePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Confort_thermique.
     * @param {confort_thermiqueUpsertArgs} args - Arguments to update or create a Confort_thermique.
     * @example
     * // Update or create a Confort_thermique
     * const confort_thermique = await prisma.confort_thermique.upsert({
     *   create: {
     *     // ... data to create a Confort_thermique
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Confort_thermique we want to update
     *   }
     * })
     */
    upsert<T extends confort_thermiqueUpsertArgs>(args: SelectSubset<T, confort_thermiqueUpsertArgs<ExtArgs>>): Prisma__confort_thermiqueClient<$Result.GetResult<Prisma.$confort_thermiquePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Confort_thermiques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {confort_thermiqueCountArgs} args - Arguments to filter Confort_thermiques to count.
     * @example
     * // Count the number of Confort_thermiques
     * const count = await prisma.confort_thermique.count({
     *   where: {
     *     // ... the filter for the Confort_thermiques we want to count
     *   }
     * })
    **/
    count<T extends confort_thermiqueCountArgs>(
      args?: Subset<T, confort_thermiqueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Confort_thermiqueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Confort_thermique.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Confort_thermiqueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Confort_thermiqueAggregateArgs>(args: Subset<T, Confort_thermiqueAggregateArgs>): Prisma.PrismaPromise<GetConfort_thermiqueAggregateType<T>>

    /**
     * Group by Confort_thermique.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {confort_thermiqueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends confort_thermiqueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: confort_thermiqueGroupByArgs['orderBy'] }
        : { orderBy?: confort_thermiqueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, confort_thermiqueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfort_thermiqueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the confort_thermique model
   */
  readonly fields: confort_thermiqueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for confort_thermique.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__confort_thermiqueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the confort_thermique model
   */
  interface confort_thermiqueFieldRefs {
    readonly index: FieldRef<"confort_thermique", 'Int'>
    readonly code_geographique: FieldRef<"confort_thermique", 'String'>
    readonly libelle_geographique: FieldRef<"confort_thermique", 'String'>
    readonly epci: FieldRef<"confort_thermique", 'String'>
    readonly libelle_epci: FieldRef<"confort_thermique", 'String'>
    readonly departement: FieldRef<"confort_thermique", 'String'>
    readonly libelle_departement: FieldRef<"confort_thermique", 'String'>
    readonly region: FieldRef<"confort_thermique", 'Int'>
    readonly ept: FieldRef<"confort_thermique", 'String'>
    readonly libelle_petr: FieldRef<"confort_thermique", 'String'>
    readonly code_pnr: FieldRef<"confort_thermique", 'String'>
    readonly libelle_pnr: FieldRef<"confort_thermique", 'String'>
    readonly age_bati_post06: FieldRef<"confort_thermique", 'Float'>
    readonly age_bati_91_05: FieldRef<"confort_thermique", 'Float'>
    readonly age_bati_46_90: FieldRef<"confort_thermique", 'Float'>
    readonly age_bati_19_45: FieldRef<"confort_thermique", 'Float'>
    readonly age_bati_pre_19: FieldRef<"confort_thermique", 'Float'>
    readonly under_4_sum_1968: FieldRef<"confort_thermique", 'Float'>
    readonly to_75_sum_1968: FieldRef<"confort_thermique", 'Float'>
    readonly over_75_sum_1968: FieldRef<"confort_thermique", 'Float'>
    readonly under_4_sum_1975: FieldRef<"confort_thermique", 'Float'>
    readonly to_75_sum_1975: FieldRef<"confort_thermique", 'Float'>
    readonly over_75_sum_1975: FieldRef<"confort_thermique", 'Float'>
    readonly under_4_sum_1982: FieldRef<"confort_thermique", 'Float'>
    readonly to_75_sum_1982: FieldRef<"confort_thermique", 'Float'>
    readonly over_75_sum_1982: FieldRef<"confort_thermique", 'Float'>
    readonly under_4_sum_1990: FieldRef<"confort_thermique", 'Float'>
    readonly to_75_sum_1990: FieldRef<"confort_thermique", 'Float'>
    readonly over_75_sum_1990: FieldRef<"confort_thermique", 'Float'>
    readonly under_4_sum_1999: FieldRef<"confort_thermique", 'Float'>
    readonly to_75_sum_1999: FieldRef<"confort_thermique", 'Float'>
    readonly over_75_sum_1999: FieldRef<"confort_thermique", 'Float'>
    readonly under_4_sum_2009: FieldRef<"confort_thermique", 'Float'>
    readonly to_75_sum_2009: FieldRef<"confort_thermique", 'Float'>
    readonly over_75_sum_2009: FieldRef<"confort_thermique", 'Float'>
    readonly under_4_sum_2014: FieldRef<"confort_thermique", 'Float'>
    readonly to_75_sum_2014: FieldRef<"confort_thermique", 'Float'>
    readonly over_75_sum_2014: FieldRef<"confort_thermique", 'Float'>
    readonly under_4_sum_2020: FieldRef<"confort_thermique", 'Float'>
    readonly to_75_sum_2020: FieldRef<"confort_thermique", 'Float'>
    readonly over_75_sum_2020: FieldRef<"confort_thermique", 'Float'>
    readonly tee_log: FieldRef<"confort_thermique", 'Float'>
    readonly tee_mob: FieldRef<"confort_thermique", 'Float'>
    readonly precarite_logement: FieldRef<"confort_thermique", 'Float'>
    readonly NA5AZ_sum: FieldRef<"confort_thermique", 'Float'>
    readonly NA5BE_sum: FieldRef<"confort_thermique", 'Float'>
    readonly NA5FZ_sum: FieldRef<"confort_thermique", 'Float'>
    readonly NA5GU_sum: FieldRef<"confort_thermique", 'Float'>
    readonly NA5OQ_sum: FieldRef<"confort_thermique", 'Float'>
    readonly clc_1_artificialise: FieldRef<"confort_thermique", 'Float'>
    readonly clc_2_agricole: FieldRef<"confort_thermique", 'Float'>
    readonly clc_3_foret_semiNaturel: FieldRef<"confort_thermique", 'Float'>
    readonly clc_4_humide: FieldRef<"confort_thermique", 'Float'>
    readonly clc_5_eau: FieldRef<"confort_thermique", 'Float'>
    readonly superf_choro: FieldRef<"confort_thermique", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * confort_thermique findUnique
   */
  export type confort_thermiqueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the confort_thermique
     */
    select?: confort_thermiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the confort_thermique
     */
    omit?: confort_thermiqueOmit<ExtArgs> | null
    /**
     * Filter, which confort_thermique to fetch.
     */
    where: confort_thermiqueWhereUniqueInput
  }

  /**
   * confort_thermique findUniqueOrThrow
   */
  export type confort_thermiqueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the confort_thermique
     */
    select?: confort_thermiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the confort_thermique
     */
    omit?: confort_thermiqueOmit<ExtArgs> | null
    /**
     * Filter, which confort_thermique to fetch.
     */
    where: confort_thermiqueWhereUniqueInput
  }

  /**
   * confort_thermique findFirst
   */
  export type confort_thermiqueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the confort_thermique
     */
    select?: confort_thermiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the confort_thermique
     */
    omit?: confort_thermiqueOmit<ExtArgs> | null
    /**
     * Filter, which confort_thermique to fetch.
     */
    where?: confort_thermiqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of confort_thermiques to fetch.
     */
    orderBy?: confort_thermiqueOrderByWithRelationInput | confort_thermiqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for confort_thermiques.
     */
    cursor?: confort_thermiqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` confort_thermiques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` confort_thermiques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of confort_thermiques.
     */
    distinct?: Confort_thermiqueScalarFieldEnum | Confort_thermiqueScalarFieldEnum[]
  }

  /**
   * confort_thermique findFirstOrThrow
   */
  export type confort_thermiqueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the confort_thermique
     */
    select?: confort_thermiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the confort_thermique
     */
    omit?: confort_thermiqueOmit<ExtArgs> | null
    /**
     * Filter, which confort_thermique to fetch.
     */
    where?: confort_thermiqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of confort_thermiques to fetch.
     */
    orderBy?: confort_thermiqueOrderByWithRelationInput | confort_thermiqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for confort_thermiques.
     */
    cursor?: confort_thermiqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` confort_thermiques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` confort_thermiques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of confort_thermiques.
     */
    distinct?: Confort_thermiqueScalarFieldEnum | Confort_thermiqueScalarFieldEnum[]
  }

  /**
   * confort_thermique findMany
   */
  export type confort_thermiqueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the confort_thermique
     */
    select?: confort_thermiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the confort_thermique
     */
    omit?: confort_thermiqueOmit<ExtArgs> | null
    /**
     * Filter, which confort_thermiques to fetch.
     */
    where?: confort_thermiqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of confort_thermiques to fetch.
     */
    orderBy?: confort_thermiqueOrderByWithRelationInput | confort_thermiqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing confort_thermiques.
     */
    cursor?: confort_thermiqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` confort_thermiques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` confort_thermiques.
     */
    skip?: number
    distinct?: Confort_thermiqueScalarFieldEnum | Confort_thermiqueScalarFieldEnum[]
  }

  /**
   * confort_thermique create
   */
  export type confort_thermiqueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the confort_thermique
     */
    select?: confort_thermiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the confort_thermique
     */
    omit?: confort_thermiqueOmit<ExtArgs> | null
    /**
     * The data needed to create a confort_thermique.
     */
    data: XOR<confort_thermiqueCreateInput, confort_thermiqueUncheckedCreateInput>
  }

  /**
   * confort_thermique createMany
   */
  export type confort_thermiqueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many confort_thermiques.
     */
    data: confort_thermiqueCreateManyInput | confort_thermiqueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * confort_thermique createManyAndReturn
   */
  export type confort_thermiqueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the confort_thermique
     */
    select?: confort_thermiqueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the confort_thermique
     */
    omit?: confort_thermiqueOmit<ExtArgs> | null
    /**
     * The data used to create many confort_thermiques.
     */
    data: confort_thermiqueCreateManyInput | confort_thermiqueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * confort_thermique update
   */
  export type confort_thermiqueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the confort_thermique
     */
    select?: confort_thermiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the confort_thermique
     */
    omit?: confort_thermiqueOmit<ExtArgs> | null
    /**
     * The data needed to update a confort_thermique.
     */
    data: XOR<confort_thermiqueUpdateInput, confort_thermiqueUncheckedUpdateInput>
    /**
     * Choose, which confort_thermique to update.
     */
    where: confort_thermiqueWhereUniqueInput
  }

  /**
   * confort_thermique updateMany
   */
  export type confort_thermiqueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update confort_thermiques.
     */
    data: XOR<confort_thermiqueUpdateManyMutationInput, confort_thermiqueUncheckedUpdateManyInput>
    /**
     * Filter which confort_thermiques to update
     */
    where?: confort_thermiqueWhereInput
    /**
     * Limit how many confort_thermiques to update.
     */
    limit?: number
  }

  /**
   * confort_thermique updateManyAndReturn
   */
  export type confort_thermiqueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the confort_thermique
     */
    select?: confort_thermiqueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the confort_thermique
     */
    omit?: confort_thermiqueOmit<ExtArgs> | null
    /**
     * The data used to update confort_thermiques.
     */
    data: XOR<confort_thermiqueUpdateManyMutationInput, confort_thermiqueUncheckedUpdateManyInput>
    /**
     * Filter which confort_thermiques to update
     */
    where?: confort_thermiqueWhereInput
    /**
     * Limit how many confort_thermiques to update.
     */
    limit?: number
  }

  /**
   * confort_thermique upsert
   */
  export type confort_thermiqueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the confort_thermique
     */
    select?: confort_thermiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the confort_thermique
     */
    omit?: confort_thermiqueOmit<ExtArgs> | null
    /**
     * The filter to search for the confort_thermique to update in case it exists.
     */
    where: confort_thermiqueWhereUniqueInput
    /**
     * In case the confort_thermique found by the `where` argument doesn't exist, create a new confort_thermique with this data.
     */
    create: XOR<confort_thermiqueCreateInput, confort_thermiqueUncheckedCreateInput>
    /**
     * In case the confort_thermique was found with the provided `where` argument, update it with this data.
     */
    update: XOR<confort_thermiqueUpdateInput, confort_thermiqueUncheckedUpdateInput>
  }

  /**
   * confort_thermique delete
   */
  export type confort_thermiqueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the confort_thermique
     */
    select?: confort_thermiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the confort_thermique
     */
    omit?: confort_thermiqueOmit<ExtArgs> | null
    /**
     * Filter which confort_thermique to delete.
     */
    where: confort_thermiqueWhereUniqueInput
  }

  /**
   * confort_thermique deleteMany
   */
  export type confort_thermiqueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which confort_thermiques to delete
     */
    where?: confort_thermiqueWhereInput
    /**
     * Limit how many confort_thermiques to delete.
     */
    limit?: number
  }

  /**
   * confort_thermique without action
   */
  export type confort_thermiqueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the confort_thermique
     */
    select?: confort_thermiqueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the confort_thermique
     */
    omit?: confort_thermiqueOmit<ExtArgs> | null
  }


  /**
   * Model consommation_espaces_naf
   */

  export type AggregateConsommation_espaces_naf = {
    _count: Consommation_espaces_nafCountAggregateOutputType | null
    _avg: Consommation_espaces_nafAvgAggregateOutputType | null
    _sum: Consommation_espaces_nafSumAggregateOutputType | null
    _min: Consommation_espaces_nafMinAggregateOutputType | null
    _max: Consommation_espaces_nafMaxAggregateOutputType | null
  }

  export type Consommation_espaces_nafAvgAggregateOutputType = {
    index: number | null
    region: number | null
    naf09art10: number | null
    art09act10: number | null
    art09hab10: number | null
    art09mix10: number | null
    art09rou10: number | null
    art09fer10: number | null
    art09inc10: number | null
    naf10art11: number | null
    art10act11: number | null
    art10hab11: number | null
    art10mix11: number | null
    art10rou11: number | null
    art10fer11: number | null
    art10inc11: number | null
    naf11art12: number | null
    art11act12: number | null
    art11hab12: number | null
    art11mix12: number | null
    art11rou12: number | null
    art11fer12: number | null
    art11inc12: number | null
    naf12art13: number | null
    art12act13: number | null
    art12hab13: number | null
    art12mix13: number | null
    art12rou13: number | null
    art12fer13: number | null
    art12inc13: number | null
    naf13art14: number | null
    art13act14: number | null
    art13hab14: number | null
    art13mix14: number | null
    art13rou14: number | null
    art13fer14: number | null
    art13inc14: number | null
    naf14art15: number | null
    art14act15: number | null
    art14hab15: number | null
    art14mix15: number | null
    art14rou15: number | null
    art14fer15: number | null
    art14inc15: number | null
    naf15art16: number | null
    art15act16: number | null
    art15hab16: number | null
    art15mix16: number | null
    art15rou16: number | null
    art15fer16: number | null
    art15inc16: number | null
    naf16art17: number | null
    art16act17: number | null
    art16hab17: number | null
    art16mix17: number | null
    art16rou17: number | null
    art16fer17: number | null
    art16inc17: number | null
    naf17art18: number | null
    art17act18: number | null
    art17hab18: number | null
    art17mix18: number | null
    art17rou18: number | null
    art17fer18: number | null
    art17inc18: number | null
    naf18art19: number | null
    art18act19: number | null
    art18hab19: number | null
    art18mix19: number | null
    art18rou19: number | null
    art18fer19: number | null
    art18inc19: number | null
    naf19art20: number | null
    art19act20: number | null
    art19hab20: number | null
    art19mix20: number | null
    art19rou20: number | null
    art19fer20: number | null
    art19inc20: number | null
    naf20art21: number | null
    art20act21: number | null
    art20hab21: number | null
    art20mix21: number | null
    art20rou21: number | null
    art20fer21: number | null
    art20inc21: number | null
    naf21art22: number | null
    art21act22: number | null
    art21hab22: number | null
    art21mix22: number | null
    art21rou22: number | null
    art21fer22: number | null
    art21inc22: number | null
    naf22art23: number | null
    art22act23: number | null
    art22hab23: number | null
    art22mix23: number | null
    art22rou23: number | null
    art22fer23: number | null
    art22inc23: number | null
    naf09art23: number | null
    art09act23: number | null
    art09hab23: number | null
    art09mix23: number | null
    art09inc23: number | null
    art09rou23: number | null
    art09fer23: number | null
    artcom0923: number | null
  }

  export type Consommation_espaces_nafSumAggregateOutputType = {
    index: number | null
    region: number | null
    naf09art10: number | null
    art09act10: number | null
    art09hab10: number | null
    art09mix10: number | null
    art09rou10: number | null
    art09fer10: number | null
    art09inc10: number | null
    naf10art11: number | null
    art10act11: number | null
    art10hab11: number | null
    art10mix11: number | null
    art10rou11: number | null
    art10fer11: number | null
    art10inc11: number | null
    naf11art12: number | null
    art11act12: number | null
    art11hab12: number | null
    art11mix12: number | null
    art11rou12: number | null
    art11fer12: number | null
    art11inc12: number | null
    naf12art13: number | null
    art12act13: number | null
    art12hab13: number | null
    art12mix13: number | null
    art12rou13: number | null
    art12fer13: number | null
    art12inc13: number | null
    naf13art14: number | null
    art13act14: number | null
    art13hab14: number | null
    art13mix14: number | null
    art13rou14: number | null
    art13fer14: number | null
    art13inc14: number | null
    naf14art15: number | null
    art14act15: number | null
    art14hab15: number | null
    art14mix15: number | null
    art14rou15: number | null
    art14fer15: number | null
    art14inc15: number | null
    naf15art16: number | null
    art15act16: number | null
    art15hab16: number | null
    art15mix16: number | null
    art15rou16: number | null
    art15fer16: number | null
    art15inc16: number | null
    naf16art17: number | null
    art16act17: number | null
    art16hab17: number | null
    art16mix17: number | null
    art16rou17: number | null
    art16fer17: number | null
    art16inc17: number | null
    naf17art18: number | null
    art17act18: number | null
    art17hab18: number | null
    art17mix18: number | null
    art17rou18: number | null
    art17fer18: number | null
    art17inc18: number | null
    naf18art19: number | null
    art18act19: number | null
    art18hab19: number | null
    art18mix19: number | null
    art18rou19: number | null
    art18fer19: number | null
    art18inc19: number | null
    naf19art20: number | null
    art19act20: number | null
    art19hab20: number | null
    art19mix20: number | null
    art19rou20: number | null
    art19fer20: number | null
    art19inc20: number | null
    naf20art21: number | null
    art20act21: number | null
    art20hab21: number | null
    art20mix21: number | null
    art20rou21: number | null
    art20fer21: number | null
    art20inc21: number | null
    naf21art22: number | null
    art21act22: number | null
    art21hab22: number | null
    art21mix22: number | null
    art21rou22: number | null
    art21fer22: number | null
    art21inc22: number | null
    naf22art23: number | null
    art22act23: number | null
    art22hab23: number | null
    art22mix23: number | null
    art22rou23: number | null
    art22fer23: number | null
    art22inc23: number | null
    naf09art23: number | null
    art09act23: number | null
    art09hab23: number | null
    art09mix23: number | null
    art09inc23: number | null
    art09rou23: number | null
    art09fer23: number | null
    artcom0923: number | null
  }

  export type Consommation_espaces_nafMinAggregateOutputType = {
    index: number | null
    code_geographique: string | null
    libelle_geographique: string | null
    epci: string | null
    libelle_epci: string | null
    departement: string | null
    libelle_departement: string | null
    region: number | null
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
    naf09art10: number | null
    art09act10: number | null
    art09hab10: number | null
    art09mix10: number | null
    art09rou10: number | null
    art09fer10: number | null
    art09inc10: number | null
    naf10art11: number | null
    art10act11: number | null
    art10hab11: number | null
    art10mix11: number | null
    art10rou11: number | null
    art10fer11: number | null
    art10inc11: number | null
    naf11art12: number | null
    art11act12: number | null
    art11hab12: number | null
    art11mix12: number | null
    art11rou12: number | null
    art11fer12: number | null
    art11inc12: number | null
    naf12art13: number | null
    art12act13: number | null
    art12hab13: number | null
    art12mix13: number | null
    art12rou13: number | null
    art12fer13: number | null
    art12inc13: number | null
    naf13art14: number | null
    art13act14: number | null
    art13hab14: number | null
    art13mix14: number | null
    art13rou14: number | null
    art13fer14: number | null
    art13inc14: number | null
    naf14art15: number | null
    art14act15: number | null
    art14hab15: number | null
    art14mix15: number | null
    art14rou15: number | null
    art14fer15: number | null
    art14inc15: number | null
    naf15art16: number | null
    art15act16: number | null
    art15hab16: number | null
    art15mix16: number | null
    art15rou16: number | null
    art15fer16: number | null
    art15inc16: number | null
    naf16art17: number | null
    art16act17: number | null
    art16hab17: number | null
    art16mix17: number | null
    art16rou17: number | null
    art16fer17: number | null
    art16inc17: number | null
    naf17art18: number | null
    art17act18: number | null
    art17hab18: number | null
    art17mix18: number | null
    art17rou18: number | null
    art17fer18: number | null
    art17inc18: number | null
    naf18art19: number | null
    art18act19: number | null
    art18hab19: number | null
    art18mix19: number | null
    art18rou19: number | null
    art18fer19: number | null
    art18inc19: number | null
    naf19art20: number | null
    art19act20: number | null
    art19hab20: number | null
    art19mix20: number | null
    art19rou20: number | null
    art19fer20: number | null
    art19inc20: number | null
    naf20art21: number | null
    art20act21: number | null
    art20hab21: number | null
    art20mix21: number | null
    art20rou21: number | null
    art20fer21: number | null
    art20inc21: number | null
    naf21art22: number | null
    art21act22: number | null
    art21hab22: number | null
    art21mix22: number | null
    art21rou22: number | null
    art21fer22: number | null
    art21inc22: number | null
    naf22art23: number | null
    art22act23: number | null
    art22hab23: number | null
    art22mix23: number | null
    art22rou23: number | null
    art22fer23: number | null
    art22inc23: number | null
    naf09art23: number | null
    art09act23: number | null
    art09hab23: number | null
    art09mix23: number | null
    art09inc23: number | null
    art09rou23: number | null
    art09fer23: number | null
    artcom0923: number | null
  }

  export type Consommation_espaces_nafMaxAggregateOutputType = {
    index: number | null
    code_geographique: string | null
    libelle_geographique: string | null
    epci: string | null
    libelle_epci: string | null
    departement: string | null
    libelle_departement: string | null
    region: number | null
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
    naf09art10: number | null
    art09act10: number | null
    art09hab10: number | null
    art09mix10: number | null
    art09rou10: number | null
    art09fer10: number | null
    art09inc10: number | null
    naf10art11: number | null
    art10act11: number | null
    art10hab11: number | null
    art10mix11: number | null
    art10rou11: number | null
    art10fer11: number | null
    art10inc11: number | null
    naf11art12: number | null
    art11act12: number | null
    art11hab12: number | null
    art11mix12: number | null
    art11rou12: number | null
    art11fer12: number | null
    art11inc12: number | null
    naf12art13: number | null
    art12act13: number | null
    art12hab13: number | null
    art12mix13: number | null
    art12rou13: number | null
    art12fer13: number | null
    art12inc13: number | null
    naf13art14: number | null
    art13act14: number | null
    art13hab14: number | null
    art13mix14: number | null
    art13rou14: number | null
    art13fer14: number | null
    art13inc14: number | null
    naf14art15: number | null
    art14act15: number | null
    art14hab15: number | null
    art14mix15: number | null
    art14rou15: number | null
    art14fer15: number | null
    art14inc15: number | null
    naf15art16: number | null
    art15act16: number | null
    art15hab16: number | null
    art15mix16: number | null
    art15rou16: number | null
    art15fer16: number | null
    art15inc16: number | null
    naf16art17: number | null
    art16act17: number | null
    art16hab17: number | null
    art16mix17: number | null
    art16rou17: number | null
    art16fer17: number | null
    art16inc17: number | null
    naf17art18: number | null
    art17act18: number | null
    art17hab18: number | null
    art17mix18: number | null
    art17rou18: number | null
    art17fer18: number | null
    art17inc18: number | null
    naf18art19: number | null
    art18act19: number | null
    art18hab19: number | null
    art18mix19: number | null
    art18rou19: number | null
    art18fer19: number | null
    art18inc19: number | null
    naf19art20: number | null
    art19act20: number | null
    art19hab20: number | null
    art19mix20: number | null
    art19rou20: number | null
    art19fer20: number | null
    art19inc20: number | null
    naf20art21: number | null
    art20act21: number | null
    art20hab21: number | null
    art20mix21: number | null
    art20rou21: number | null
    art20fer21: number | null
    art20inc21: number | null
    naf21art22: number | null
    art21act22: number | null
    art21hab22: number | null
    art21mix22: number | null
    art21rou22: number | null
    art21fer22: number | null
    art21inc22: number | null
    naf22art23: number | null
    art22act23: number | null
    art22hab23: number | null
    art22mix23: number | null
    art22rou23: number | null
    art22fer23: number | null
    art22inc23: number | null
    naf09art23: number | null
    art09act23: number | null
    art09hab23: number | null
    art09mix23: number | null
    art09inc23: number | null
    art09rou23: number | null
    art09fer23: number | null
    artcom0923: number | null
  }

  export type Consommation_espaces_nafCountAggregateOutputType = {
    index: number
    code_geographique: number
    libelle_geographique: number
    epci: number
    libelle_epci: number
    departement: number
    libelle_departement: number
    region: number
    ept: number
    libelle_petr: number
    code_pnr: number
    libelle_pnr: number
    naf09art10: number
    art09act10: number
    art09hab10: number
    art09mix10: number
    art09rou10: number
    art09fer10: number
    art09inc10: number
    naf10art11: number
    art10act11: number
    art10hab11: number
    art10mix11: number
    art10rou11: number
    art10fer11: number
    art10inc11: number
    naf11art12: number
    art11act12: number
    art11hab12: number
    art11mix12: number
    art11rou12: number
    art11fer12: number
    art11inc12: number
    naf12art13: number
    art12act13: number
    art12hab13: number
    art12mix13: number
    art12rou13: number
    art12fer13: number
    art12inc13: number
    naf13art14: number
    art13act14: number
    art13hab14: number
    art13mix14: number
    art13rou14: number
    art13fer14: number
    art13inc14: number
    naf14art15: number
    art14act15: number
    art14hab15: number
    art14mix15: number
    art14rou15: number
    art14fer15: number
    art14inc15: number
    naf15art16: number
    art15act16: number
    art15hab16: number
    art15mix16: number
    art15rou16: number
    art15fer16: number
    art15inc16: number
    naf16art17: number
    art16act17: number
    art16hab17: number
    art16mix17: number
    art16rou17: number
    art16fer17: number
    art16inc17: number
    naf17art18: number
    art17act18: number
    art17hab18: number
    art17mix18: number
    art17rou18: number
    art17fer18: number
    art17inc18: number
    naf18art19: number
    art18act19: number
    art18hab19: number
    art18mix19: number
    art18rou19: number
    art18fer19: number
    art18inc19: number
    naf19art20: number
    art19act20: number
    art19hab20: number
    art19mix20: number
    art19rou20: number
    art19fer20: number
    art19inc20: number
    naf20art21: number
    art20act21: number
    art20hab21: number
    art20mix21: number
    art20rou21: number
    art20fer21: number
    art20inc21: number
    naf21art22: number
    art21act22: number
    art21hab22: number
    art21mix22: number
    art21rou22: number
    art21fer22: number
    art21inc22: number
    naf22art23: number
    art22act23: number
    art22hab23: number
    art22mix23: number
    art22rou23: number
    art22fer23: number
    art22inc23: number
    naf09art23: number
    art09act23: number
    art09hab23: number
    art09mix23: number
    art09inc23: number
    art09rou23: number
    art09fer23: number
    artcom0923: number
    _all: number
  }


  export type Consommation_espaces_nafAvgAggregateInputType = {
    index?: true
    region?: true
    naf09art10?: true
    art09act10?: true
    art09hab10?: true
    art09mix10?: true
    art09rou10?: true
    art09fer10?: true
    art09inc10?: true
    naf10art11?: true
    art10act11?: true
    art10hab11?: true
    art10mix11?: true
    art10rou11?: true
    art10fer11?: true
    art10inc11?: true
    naf11art12?: true
    art11act12?: true
    art11hab12?: true
    art11mix12?: true
    art11rou12?: true
    art11fer12?: true
    art11inc12?: true
    naf12art13?: true
    art12act13?: true
    art12hab13?: true
    art12mix13?: true
    art12rou13?: true
    art12fer13?: true
    art12inc13?: true
    naf13art14?: true
    art13act14?: true
    art13hab14?: true
    art13mix14?: true
    art13rou14?: true
    art13fer14?: true
    art13inc14?: true
    naf14art15?: true
    art14act15?: true
    art14hab15?: true
    art14mix15?: true
    art14rou15?: true
    art14fer15?: true
    art14inc15?: true
    naf15art16?: true
    art15act16?: true
    art15hab16?: true
    art15mix16?: true
    art15rou16?: true
    art15fer16?: true
    art15inc16?: true
    naf16art17?: true
    art16act17?: true
    art16hab17?: true
    art16mix17?: true
    art16rou17?: true
    art16fer17?: true
    art16inc17?: true
    naf17art18?: true
    art17act18?: true
    art17hab18?: true
    art17mix18?: true
    art17rou18?: true
    art17fer18?: true
    art17inc18?: true
    naf18art19?: true
    art18act19?: true
    art18hab19?: true
    art18mix19?: true
    art18rou19?: true
    art18fer19?: true
    art18inc19?: true
    naf19art20?: true
    art19act20?: true
    art19hab20?: true
    art19mix20?: true
    art19rou20?: true
    art19fer20?: true
    art19inc20?: true
    naf20art21?: true
    art20act21?: true
    art20hab21?: true
    art20mix21?: true
    art20rou21?: true
    art20fer21?: true
    art20inc21?: true
    naf21art22?: true
    art21act22?: true
    art21hab22?: true
    art21mix22?: true
    art21rou22?: true
    art21fer22?: true
    art21inc22?: true
    naf22art23?: true
    art22act23?: true
    art22hab23?: true
    art22mix23?: true
    art22rou23?: true
    art22fer23?: true
    art22inc23?: true
    naf09art23?: true
    art09act23?: true
    art09hab23?: true
    art09mix23?: true
    art09inc23?: true
    art09rou23?: true
    art09fer23?: true
    artcom0923?: true
  }

  export type Consommation_espaces_nafSumAggregateInputType = {
    index?: true
    region?: true
    naf09art10?: true
    art09act10?: true
    art09hab10?: true
    art09mix10?: true
    art09rou10?: true
    art09fer10?: true
    art09inc10?: true
    naf10art11?: true
    art10act11?: true
    art10hab11?: true
    art10mix11?: true
    art10rou11?: true
    art10fer11?: true
    art10inc11?: true
    naf11art12?: true
    art11act12?: true
    art11hab12?: true
    art11mix12?: true
    art11rou12?: true
    art11fer12?: true
    art11inc12?: true
    naf12art13?: true
    art12act13?: true
    art12hab13?: true
    art12mix13?: true
    art12rou13?: true
    art12fer13?: true
    art12inc13?: true
    naf13art14?: true
    art13act14?: true
    art13hab14?: true
    art13mix14?: true
    art13rou14?: true
    art13fer14?: true
    art13inc14?: true
    naf14art15?: true
    art14act15?: true
    art14hab15?: true
    art14mix15?: true
    art14rou15?: true
    art14fer15?: true
    art14inc15?: true
    naf15art16?: true
    art15act16?: true
    art15hab16?: true
    art15mix16?: true
    art15rou16?: true
    art15fer16?: true
    art15inc16?: true
    naf16art17?: true
    art16act17?: true
    art16hab17?: true
    art16mix17?: true
    art16rou17?: true
    art16fer17?: true
    art16inc17?: true
    naf17art18?: true
    art17act18?: true
    art17hab18?: true
    art17mix18?: true
    art17rou18?: true
    art17fer18?: true
    art17inc18?: true
    naf18art19?: true
    art18act19?: true
    art18hab19?: true
    art18mix19?: true
    art18rou19?: true
    art18fer19?: true
    art18inc19?: true
    naf19art20?: true
    art19act20?: true
    art19hab20?: true
    art19mix20?: true
    art19rou20?: true
    art19fer20?: true
    art19inc20?: true
    naf20art21?: true
    art20act21?: true
    art20hab21?: true
    art20mix21?: true
    art20rou21?: true
    art20fer21?: true
    art20inc21?: true
    naf21art22?: true
    art21act22?: true
    art21hab22?: true
    art21mix22?: true
    art21rou22?: true
    art21fer22?: true
    art21inc22?: true
    naf22art23?: true
    art22act23?: true
    art22hab23?: true
    art22mix23?: true
    art22rou23?: true
    art22fer23?: true
    art22inc23?: true
    naf09art23?: true
    art09act23?: true
    art09hab23?: true
    art09mix23?: true
    art09inc23?: true
    art09rou23?: true
    art09fer23?: true
    artcom0923?: true
  }

  export type Consommation_espaces_nafMinAggregateInputType = {
    index?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
    naf09art10?: true
    art09act10?: true
    art09hab10?: true
    art09mix10?: true
    art09rou10?: true
    art09fer10?: true
    art09inc10?: true
    naf10art11?: true
    art10act11?: true
    art10hab11?: true
    art10mix11?: true
    art10rou11?: true
    art10fer11?: true
    art10inc11?: true
    naf11art12?: true
    art11act12?: true
    art11hab12?: true
    art11mix12?: true
    art11rou12?: true
    art11fer12?: true
    art11inc12?: true
    naf12art13?: true
    art12act13?: true
    art12hab13?: true
    art12mix13?: true
    art12rou13?: true
    art12fer13?: true
    art12inc13?: true
    naf13art14?: true
    art13act14?: true
    art13hab14?: true
    art13mix14?: true
    art13rou14?: true
    art13fer14?: true
    art13inc14?: true
    naf14art15?: true
    art14act15?: true
    art14hab15?: true
    art14mix15?: true
    art14rou15?: true
    art14fer15?: true
    art14inc15?: true
    naf15art16?: true
    art15act16?: true
    art15hab16?: true
    art15mix16?: true
    art15rou16?: true
    art15fer16?: true
    art15inc16?: true
    naf16art17?: true
    art16act17?: true
    art16hab17?: true
    art16mix17?: true
    art16rou17?: true
    art16fer17?: true
    art16inc17?: true
    naf17art18?: true
    art17act18?: true
    art17hab18?: true
    art17mix18?: true
    art17rou18?: true
    art17fer18?: true
    art17inc18?: true
    naf18art19?: true
    art18act19?: true
    art18hab19?: true
    art18mix19?: true
    art18rou19?: true
    art18fer19?: true
    art18inc19?: true
    naf19art20?: true
    art19act20?: true
    art19hab20?: true
    art19mix20?: true
    art19rou20?: true
    art19fer20?: true
    art19inc20?: true
    naf20art21?: true
    art20act21?: true
    art20hab21?: true
    art20mix21?: true
    art20rou21?: true
    art20fer21?: true
    art20inc21?: true
    naf21art22?: true
    art21act22?: true
    art21hab22?: true
    art21mix22?: true
    art21rou22?: true
    art21fer22?: true
    art21inc22?: true
    naf22art23?: true
    art22act23?: true
    art22hab23?: true
    art22mix23?: true
    art22rou23?: true
    art22fer23?: true
    art22inc23?: true
    naf09art23?: true
    art09act23?: true
    art09hab23?: true
    art09mix23?: true
    art09inc23?: true
    art09rou23?: true
    art09fer23?: true
    artcom0923?: true
  }

  export type Consommation_espaces_nafMaxAggregateInputType = {
    index?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
    naf09art10?: true
    art09act10?: true
    art09hab10?: true
    art09mix10?: true
    art09rou10?: true
    art09fer10?: true
    art09inc10?: true
    naf10art11?: true
    art10act11?: true
    art10hab11?: true
    art10mix11?: true
    art10rou11?: true
    art10fer11?: true
    art10inc11?: true
    naf11art12?: true
    art11act12?: true
    art11hab12?: true
    art11mix12?: true
    art11rou12?: true
    art11fer12?: true
    art11inc12?: true
    naf12art13?: true
    art12act13?: true
    art12hab13?: true
    art12mix13?: true
    art12rou13?: true
    art12fer13?: true
    art12inc13?: true
    naf13art14?: true
    art13act14?: true
    art13hab14?: true
    art13mix14?: true
    art13rou14?: true
    art13fer14?: true
    art13inc14?: true
    naf14art15?: true
    art14act15?: true
    art14hab15?: true
    art14mix15?: true
    art14rou15?: true
    art14fer15?: true
    art14inc15?: true
    naf15art16?: true
    art15act16?: true
    art15hab16?: true
    art15mix16?: true
    art15rou16?: true
    art15fer16?: true
    art15inc16?: true
    naf16art17?: true
    art16act17?: true
    art16hab17?: true
    art16mix17?: true
    art16rou17?: true
    art16fer17?: true
    art16inc17?: true
    naf17art18?: true
    art17act18?: true
    art17hab18?: true
    art17mix18?: true
    art17rou18?: true
    art17fer18?: true
    art17inc18?: true
    naf18art19?: true
    art18act19?: true
    art18hab19?: true
    art18mix19?: true
    art18rou19?: true
    art18fer19?: true
    art18inc19?: true
    naf19art20?: true
    art19act20?: true
    art19hab20?: true
    art19mix20?: true
    art19rou20?: true
    art19fer20?: true
    art19inc20?: true
    naf20art21?: true
    art20act21?: true
    art20hab21?: true
    art20mix21?: true
    art20rou21?: true
    art20fer21?: true
    art20inc21?: true
    naf21art22?: true
    art21act22?: true
    art21hab22?: true
    art21mix22?: true
    art21rou22?: true
    art21fer22?: true
    art21inc22?: true
    naf22art23?: true
    art22act23?: true
    art22hab23?: true
    art22mix23?: true
    art22rou23?: true
    art22fer23?: true
    art22inc23?: true
    naf09art23?: true
    art09act23?: true
    art09hab23?: true
    art09mix23?: true
    art09inc23?: true
    art09rou23?: true
    art09fer23?: true
    artcom0923?: true
  }

  export type Consommation_espaces_nafCountAggregateInputType = {
    index?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
    naf09art10?: true
    art09act10?: true
    art09hab10?: true
    art09mix10?: true
    art09rou10?: true
    art09fer10?: true
    art09inc10?: true
    naf10art11?: true
    art10act11?: true
    art10hab11?: true
    art10mix11?: true
    art10rou11?: true
    art10fer11?: true
    art10inc11?: true
    naf11art12?: true
    art11act12?: true
    art11hab12?: true
    art11mix12?: true
    art11rou12?: true
    art11fer12?: true
    art11inc12?: true
    naf12art13?: true
    art12act13?: true
    art12hab13?: true
    art12mix13?: true
    art12rou13?: true
    art12fer13?: true
    art12inc13?: true
    naf13art14?: true
    art13act14?: true
    art13hab14?: true
    art13mix14?: true
    art13rou14?: true
    art13fer14?: true
    art13inc14?: true
    naf14art15?: true
    art14act15?: true
    art14hab15?: true
    art14mix15?: true
    art14rou15?: true
    art14fer15?: true
    art14inc15?: true
    naf15art16?: true
    art15act16?: true
    art15hab16?: true
    art15mix16?: true
    art15rou16?: true
    art15fer16?: true
    art15inc16?: true
    naf16art17?: true
    art16act17?: true
    art16hab17?: true
    art16mix17?: true
    art16rou17?: true
    art16fer17?: true
    art16inc17?: true
    naf17art18?: true
    art17act18?: true
    art17hab18?: true
    art17mix18?: true
    art17rou18?: true
    art17fer18?: true
    art17inc18?: true
    naf18art19?: true
    art18act19?: true
    art18hab19?: true
    art18mix19?: true
    art18rou19?: true
    art18fer19?: true
    art18inc19?: true
    naf19art20?: true
    art19act20?: true
    art19hab20?: true
    art19mix20?: true
    art19rou20?: true
    art19fer20?: true
    art19inc20?: true
    naf20art21?: true
    art20act21?: true
    art20hab21?: true
    art20mix21?: true
    art20rou21?: true
    art20fer21?: true
    art20inc21?: true
    naf21art22?: true
    art21act22?: true
    art21hab22?: true
    art21mix22?: true
    art21rou22?: true
    art21fer22?: true
    art21inc22?: true
    naf22art23?: true
    art22act23?: true
    art22hab23?: true
    art22mix23?: true
    art22rou23?: true
    art22fer23?: true
    art22inc23?: true
    naf09art23?: true
    art09act23?: true
    art09hab23?: true
    art09mix23?: true
    art09inc23?: true
    art09rou23?: true
    art09fer23?: true
    artcom0923?: true
    _all?: true
  }

  export type Consommation_espaces_nafAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which consommation_espaces_naf to aggregate.
     */
    where?: consommation_espaces_nafWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consommation_espaces_nafs to fetch.
     */
    orderBy?: consommation_espaces_nafOrderByWithRelationInput | consommation_espaces_nafOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: consommation_espaces_nafWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consommation_espaces_nafs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consommation_espaces_nafs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned consommation_espaces_nafs
    **/
    _count?: true | Consommation_espaces_nafCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Consommation_espaces_nafAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Consommation_espaces_nafSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Consommation_espaces_nafMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Consommation_espaces_nafMaxAggregateInputType
  }

  export type GetConsommation_espaces_nafAggregateType<T extends Consommation_espaces_nafAggregateArgs> = {
        [P in keyof T & keyof AggregateConsommation_espaces_naf]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConsommation_espaces_naf[P]>
      : GetScalarType<T[P], AggregateConsommation_espaces_naf[P]>
  }




  export type consommation_espaces_nafGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: consommation_espaces_nafWhereInput
    orderBy?: consommation_espaces_nafOrderByWithAggregationInput | consommation_espaces_nafOrderByWithAggregationInput[]
    by: Consommation_espaces_nafScalarFieldEnum[] | Consommation_espaces_nafScalarFieldEnum
    having?: consommation_espaces_nafScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Consommation_espaces_nafCountAggregateInputType | true
    _avg?: Consommation_espaces_nafAvgAggregateInputType
    _sum?: Consommation_espaces_nafSumAggregateInputType
    _min?: Consommation_espaces_nafMinAggregateInputType
    _max?: Consommation_espaces_nafMaxAggregateInputType
  }

  export type Consommation_espaces_nafGroupByOutputType = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
    naf09art10: number | null
    art09act10: number | null
    art09hab10: number | null
    art09mix10: number | null
    art09rou10: number | null
    art09fer10: number | null
    art09inc10: number | null
    naf10art11: number | null
    art10act11: number | null
    art10hab11: number | null
    art10mix11: number | null
    art10rou11: number | null
    art10fer11: number | null
    art10inc11: number | null
    naf11art12: number | null
    art11act12: number | null
    art11hab12: number | null
    art11mix12: number | null
    art11rou12: number | null
    art11fer12: number | null
    art11inc12: number | null
    naf12art13: number | null
    art12act13: number | null
    art12hab13: number | null
    art12mix13: number | null
    art12rou13: number | null
    art12fer13: number | null
    art12inc13: number | null
    naf13art14: number | null
    art13act14: number | null
    art13hab14: number | null
    art13mix14: number | null
    art13rou14: number | null
    art13fer14: number | null
    art13inc14: number | null
    naf14art15: number | null
    art14act15: number | null
    art14hab15: number | null
    art14mix15: number | null
    art14rou15: number | null
    art14fer15: number | null
    art14inc15: number | null
    naf15art16: number | null
    art15act16: number | null
    art15hab16: number | null
    art15mix16: number | null
    art15rou16: number | null
    art15fer16: number | null
    art15inc16: number | null
    naf16art17: number | null
    art16act17: number | null
    art16hab17: number | null
    art16mix17: number | null
    art16rou17: number | null
    art16fer17: number | null
    art16inc17: number | null
    naf17art18: number | null
    art17act18: number | null
    art17hab18: number | null
    art17mix18: number | null
    art17rou18: number | null
    art17fer18: number | null
    art17inc18: number | null
    naf18art19: number | null
    art18act19: number | null
    art18hab19: number | null
    art18mix19: number | null
    art18rou19: number | null
    art18fer19: number | null
    art18inc19: number | null
    naf19art20: number | null
    art19act20: number | null
    art19hab20: number | null
    art19mix20: number | null
    art19rou20: number | null
    art19fer20: number | null
    art19inc20: number | null
    naf20art21: number | null
    art20act21: number | null
    art20hab21: number | null
    art20mix21: number | null
    art20rou21: number | null
    art20fer21: number | null
    art20inc21: number | null
    naf21art22: number | null
    art21act22: number | null
    art21hab22: number | null
    art21mix22: number | null
    art21rou22: number | null
    art21fer22: number | null
    art21inc22: number | null
    naf22art23: number | null
    art22act23: number | null
    art22hab23: number | null
    art22mix23: number | null
    art22rou23: number | null
    art22fer23: number | null
    art22inc23: number | null
    naf09art23: number | null
    art09act23: number | null
    art09hab23: number | null
    art09mix23: number | null
    art09inc23: number | null
    art09rou23: number | null
    art09fer23: number | null
    artcom0923: number | null
    _count: Consommation_espaces_nafCountAggregateOutputType | null
    _avg: Consommation_espaces_nafAvgAggregateOutputType | null
    _sum: Consommation_espaces_nafSumAggregateOutputType | null
    _min: Consommation_espaces_nafMinAggregateOutputType | null
    _max: Consommation_espaces_nafMaxAggregateOutputType | null
  }

  type GetConsommation_espaces_nafGroupByPayload<T extends consommation_espaces_nafGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Consommation_espaces_nafGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Consommation_espaces_nafGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Consommation_espaces_nafGroupByOutputType[P]>
            : GetScalarType<T[P], Consommation_espaces_nafGroupByOutputType[P]>
        }
      >
    >


  export type consommation_espaces_nafSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    naf09art10?: boolean
    art09act10?: boolean
    art09hab10?: boolean
    art09mix10?: boolean
    art09rou10?: boolean
    art09fer10?: boolean
    art09inc10?: boolean
    naf10art11?: boolean
    art10act11?: boolean
    art10hab11?: boolean
    art10mix11?: boolean
    art10rou11?: boolean
    art10fer11?: boolean
    art10inc11?: boolean
    naf11art12?: boolean
    art11act12?: boolean
    art11hab12?: boolean
    art11mix12?: boolean
    art11rou12?: boolean
    art11fer12?: boolean
    art11inc12?: boolean
    naf12art13?: boolean
    art12act13?: boolean
    art12hab13?: boolean
    art12mix13?: boolean
    art12rou13?: boolean
    art12fer13?: boolean
    art12inc13?: boolean
    naf13art14?: boolean
    art13act14?: boolean
    art13hab14?: boolean
    art13mix14?: boolean
    art13rou14?: boolean
    art13fer14?: boolean
    art13inc14?: boolean
    naf14art15?: boolean
    art14act15?: boolean
    art14hab15?: boolean
    art14mix15?: boolean
    art14rou15?: boolean
    art14fer15?: boolean
    art14inc15?: boolean
    naf15art16?: boolean
    art15act16?: boolean
    art15hab16?: boolean
    art15mix16?: boolean
    art15rou16?: boolean
    art15fer16?: boolean
    art15inc16?: boolean
    naf16art17?: boolean
    art16act17?: boolean
    art16hab17?: boolean
    art16mix17?: boolean
    art16rou17?: boolean
    art16fer17?: boolean
    art16inc17?: boolean
    naf17art18?: boolean
    art17act18?: boolean
    art17hab18?: boolean
    art17mix18?: boolean
    art17rou18?: boolean
    art17fer18?: boolean
    art17inc18?: boolean
    naf18art19?: boolean
    art18act19?: boolean
    art18hab19?: boolean
    art18mix19?: boolean
    art18rou19?: boolean
    art18fer19?: boolean
    art18inc19?: boolean
    naf19art20?: boolean
    art19act20?: boolean
    art19hab20?: boolean
    art19mix20?: boolean
    art19rou20?: boolean
    art19fer20?: boolean
    art19inc20?: boolean
    naf20art21?: boolean
    art20act21?: boolean
    art20hab21?: boolean
    art20mix21?: boolean
    art20rou21?: boolean
    art20fer21?: boolean
    art20inc21?: boolean
    naf21art22?: boolean
    art21act22?: boolean
    art21hab22?: boolean
    art21mix22?: boolean
    art21rou22?: boolean
    art21fer22?: boolean
    art21inc22?: boolean
    naf22art23?: boolean
    art22act23?: boolean
    art22hab23?: boolean
    art22mix23?: boolean
    art22rou23?: boolean
    art22fer23?: boolean
    art22inc23?: boolean
    naf09art23?: boolean
    art09act23?: boolean
    art09hab23?: boolean
    art09mix23?: boolean
    art09inc23?: boolean
    art09rou23?: boolean
    art09fer23?: boolean
    artcom0923?: boolean
  }, ExtArgs["result"]["consommation_espaces_naf"]>

  export type consommation_espaces_nafSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    naf09art10?: boolean
    art09act10?: boolean
    art09hab10?: boolean
    art09mix10?: boolean
    art09rou10?: boolean
    art09fer10?: boolean
    art09inc10?: boolean
    naf10art11?: boolean
    art10act11?: boolean
    art10hab11?: boolean
    art10mix11?: boolean
    art10rou11?: boolean
    art10fer11?: boolean
    art10inc11?: boolean
    naf11art12?: boolean
    art11act12?: boolean
    art11hab12?: boolean
    art11mix12?: boolean
    art11rou12?: boolean
    art11fer12?: boolean
    art11inc12?: boolean
    naf12art13?: boolean
    art12act13?: boolean
    art12hab13?: boolean
    art12mix13?: boolean
    art12rou13?: boolean
    art12fer13?: boolean
    art12inc13?: boolean
    naf13art14?: boolean
    art13act14?: boolean
    art13hab14?: boolean
    art13mix14?: boolean
    art13rou14?: boolean
    art13fer14?: boolean
    art13inc14?: boolean
    naf14art15?: boolean
    art14act15?: boolean
    art14hab15?: boolean
    art14mix15?: boolean
    art14rou15?: boolean
    art14fer15?: boolean
    art14inc15?: boolean
    naf15art16?: boolean
    art15act16?: boolean
    art15hab16?: boolean
    art15mix16?: boolean
    art15rou16?: boolean
    art15fer16?: boolean
    art15inc16?: boolean
    naf16art17?: boolean
    art16act17?: boolean
    art16hab17?: boolean
    art16mix17?: boolean
    art16rou17?: boolean
    art16fer17?: boolean
    art16inc17?: boolean
    naf17art18?: boolean
    art17act18?: boolean
    art17hab18?: boolean
    art17mix18?: boolean
    art17rou18?: boolean
    art17fer18?: boolean
    art17inc18?: boolean
    naf18art19?: boolean
    art18act19?: boolean
    art18hab19?: boolean
    art18mix19?: boolean
    art18rou19?: boolean
    art18fer19?: boolean
    art18inc19?: boolean
    naf19art20?: boolean
    art19act20?: boolean
    art19hab20?: boolean
    art19mix20?: boolean
    art19rou20?: boolean
    art19fer20?: boolean
    art19inc20?: boolean
    naf20art21?: boolean
    art20act21?: boolean
    art20hab21?: boolean
    art20mix21?: boolean
    art20rou21?: boolean
    art20fer21?: boolean
    art20inc21?: boolean
    naf21art22?: boolean
    art21act22?: boolean
    art21hab22?: boolean
    art21mix22?: boolean
    art21rou22?: boolean
    art21fer22?: boolean
    art21inc22?: boolean
    naf22art23?: boolean
    art22act23?: boolean
    art22hab23?: boolean
    art22mix23?: boolean
    art22rou23?: boolean
    art22fer23?: boolean
    art22inc23?: boolean
    naf09art23?: boolean
    art09act23?: boolean
    art09hab23?: boolean
    art09mix23?: boolean
    art09inc23?: boolean
    art09rou23?: boolean
    art09fer23?: boolean
    artcom0923?: boolean
  }, ExtArgs["result"]["consommation_espaces_naf"]>

  export type consommation_espaces_nafSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    naf09art10?: boolean
    art09act10?: boolean
    art09hab10?: boolean
    art09mix10?: boolean
    art09rou10?: boolean
    art09fer10?: boolean
    art09inc10?: boolean
    naf10art11?: boolean
    art10act11?: boolean
    art10hab11?: boolean
    art10mix11?: boolean
    art10rou11?: boolean
    art10fer11?: boolean
    art10inc11?: boolean
    naf11art12?: boolean
    art11act12?: boolean
    art11hab12?: boolean
    art11mix12?: boolean
    art11rou12?: boolean
    art11fer12?: boolean
    art11inc12?: boolean
    naf12art13?: boolean
    art12act13?: boolean
    art12hab13?: boolean
    art12mix13?: boolean
    art12rou13?: boolean
    art12fer13?: boolean
    art12inc13?: boolean
    naf13art14?: boolean
    art13act14?: boolean
    art13hab14?: boolean
    art13mix14?: boolean
    art13rou14?: boolean
    art13fer14?: boolean
    art13inc14?: boolean
    naf14art15?: boolean
    art14act15?: boolean
    art14hab15?: boolean
    art14mix15?: boolean
    art14rou15?: boolean
    art14fer15?: boolean
    art14inc15?: boolean
    naf15art16?: boolean
    art15act16?: boolean
    art15hab16?: boolean
    art15mix16?: boolean
    art15rou16?: boolean
    art15fer16?: boolean
    art15inc16?: boolean
    naf16art17?: boolean
    art16act17?: boolean
    art16hab17?: boolean
    art16mix17?: boolean
    art16rou17?: boolean
    art16fer17?: boolean
    art16inc17?: boolean
    naf17art18?: boolean
    art17act18?: boolean
    art17hab18?: boolean
    art17mix18?: boolean
    art17rou18?: boolean
    art17fer18?: boolean
    art17inc18?: boolean
    naf18art19?: boolean
    art18act19?: boolean
    art18hab19?: boolean
    art18mix19?: boolean
    art18rou19?: boolean
    art18fer19?: boolean
    art18inc19?: boolean
    naf19art20?: boolean
    art19act20?: boolean
    art19hab20?: boolean
    art19mix20?: boolean
    art19rou20?: boolean
    art19fer20?: boolean
    art19inc20?: boolean
    naf20art21?: boolean
    art20act21?: boolean
    art20hab21?: boolean
    art20mix21?: boolean
    art20rou21?: boolean
    art20fer21?: boolean
    art20inc21?: boolean
    naf21art22?: boolean
    art21act22?: boolean
    art21hab22?: boolean
    art21mix22?: boolean
    art21rou22?: boolean
    art21fer22?: boolean
    art21inc22?: boolean
    naf22art23?: boolean
    art22act23?: boolean
    art22hab23?: boolean
    art22mix23?: boolean
    art22rou23?: boolean
    art22fer23?: boolean
    art22inc23?: boolean
    naf09art23?: boolean
    art09act23?: boolean
    art09hab23?: boolean
    art09mix23?: boolean
    art09inc23?: boolean
    art09rou23?: boolean
    art09fer23?: boolean
    artcom0923?: boolean
  }, ExtArgs["result"]["consommation_espaces_naf"]>

  export type consommation_espaces_nafSelectScalar = {
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    naf09art10?: boolean
    art09act10?: boolean
    art09hab10?: boolean
    art09mix10?: boolean
    art09rou10?: boolean
    art09fer10?: boolean
    art09inc10?: boolean
    naf10art11?: boolean
    art10act11?: boolean
    art10hab11?: boolean
    art10mix11?: boolean
    art10rou11?: boolean
    art10fer11?: boolean
    art10inc11?: boolean
    naf11art12?: boolean
    art11act12?: boolean
    art11hab12?: boolean
    art11mix12?: boolean
    art11rou12?: boolean
    art11fer12?: boolean
    art11inc12?: boolean
    naf12art13?: boolean
    art12act13?: boolean
    art12hab13?: boolean
    art12mix13?: boolean
    art12rou13?: boolean
    art12fer13?: boolean
    art12inc13?: boolean
    naf13art14?: boolean
    art13act14?: boolean
    art13hab14?: boolean
    art13mix14?: boolean
    art13rou14?: boolean
    art13fer14?: boolean
    art13inc14?: boolean
    naf14art15?: boolean
    art14act15?: boolean
    art14hab15?: boolean
    art14mix15?: boolean
    art14rou15?: boolean
    art14fer15?: boolean
    art14inc15?: boolean
    naf15art16?: boolean
    art15act16?: boolean
    art15hab16?: boolean
    art15mix16?: boolean
    art15rou16?: boolean
    art15fer16?: boolean
    art15inc16?: boolean
    naf16art17?: boolean
    art16act17?: boolean
    art16hab17?: boolean
    art16mix17?: boolean
    art16rou17?: boolean
    art16fer17?: boolean
    art16inc17?: boolean
    naf17art18?: boolean
    art17act18?: boolean
    art17hab18?: boolean
    art17mix18?: boolean
    art17rou18?: boolean
    art17fer18?: boolean
    art17inc18?: boolean
    naf18art19?: boolean
    art18act19?: boolean
    art18hab19?: boolean
    art18mix19?: boolean
    art18rou19?: boolean
    art18fer19?: boolean
    art18inc19?: boolean
    naf19art20?: boolean
    art19act20?: boolean
    art19hab20?: boolean
    art19mix20?: boolean
    art19rou20?: boolean
    art19fer20?: boolean
    art19inc20?: boolean
    naf20art21?: boolean
    art20act21?: boolean
    art20hab21?: boolean
    art20mix21?: boolean
    art20rou21?: boolean
    art20fer21?: boolean
    art20inc21?: boolean
    naf21art22?: boolean
    art21act22?: boolean
    art21hab22?: boolean
    art21mix22?: boolean
    art21rou22?: boolean
    art21fer22?: boolean
    art21inc22?: boolean
    naf22art23?: boolean
    art22act23?: boolean
    art22hab23?: boolean
    art22mix23?: boolean
    art22rou23?: boolean
    art22fer23?: boolean
    art22inc23?: boolean
    naf09art23?: boolean
    art09act23?: boolean
    art09hab23?: boolean
    art09mix23?: boolean
    art09inc23?: boolean
    art09rou23?: boolean
    art09fer23?: boolean
    artcom0923?: boolean
  }

  export type consommation_espaces_nafOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"index" | "code_geographique" | "libelle_geographique" | "epci" | "libelle_epci" | "departement" | "libelle_departement" | "region" | "ept" | "libelle_petr" | "code_pnr" | "libelle_pnr" | "naf09art10" | "art09act10" | "art09hab10" | "art09mix10" | "art09rou10" | "art09fer10" | "art09inc10" | "naf10art11" | "art10act11" | "art10hab11" | "art10mix11" | "art10rou11" | "art10fer11" | "art10inc11" | "naf11art12" | "art11act12" | "art11hab12" | "art11mix12" | "art11rou12" | "art11fer12" | "art11inc12" | "naf12art13" | "art12act13" | "art12hab13" | "art12mix13" | "art12rou13" | "art12fer13" | "art12inc13" | "naf13art14" | "art13act14" | "art13hab14" | "art13mix14" | "art13rou14" | "art13fer14" | "art13inc14" | "naf14art15" | "art14act15" | "art14hab15" | "art14mix15" | "art14rou15" | "art14fer15" | "art14inc15" | "naf15art16" | "art15act16" | "art15hab16" | "art15mix16" | "art15rou16" | "art15fer16" | "art15inc16" | "naf16art17" | "art16act17" | "art16hab17" | "art16mix17" | "art16rou17" | "art16fer17" | "art16inc17" | "naf17art18" | "art17act18" | "art17hab18" | "art17mix18" | "art17rou18" | "art17fer18" | "art17inc18" | "naf18art19" | "art18act19" | "art18hab19" | "art18mix19" | "art18rou19" | "art18fer19" | "art18inc19" | "naf19art20" | "art19act20" | "art19hab20" | "art19mix20" | "art19rou20" | "art19fer20" | "art19inc20" | "naf20art21" | "art20act21" | "art20hab21" | "art20mix21" | "art20rou21" | "art20fer21" | "art20inc21" | "naf21art22" | "art21act22" | "art21hab22" | "art21mix22" | "art21rou22" | "art21fer22" | "art21inc22" | "naf22art23" | "art22act23" | "art22hab23" | "art22mix23" | "art22rou23" | "art22fer23" | "art22inc23" | "naf09art23" | "art09act23" | "art09hab23" | "art09mix23" | "art09inc23" | "art09rou23" | "art09fer23" | "artcom0923", ExtArgs["result"]["consommation_espaces_naf"]>

  export type $consommation_espaces_nafPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "consommation_espaces_naf"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      index: number
      code_geographique: string
      libelle_geographique: string
      epci: string
      libelle_epci: string
      departement: string
      libelle_departement: string
      region: number
      ept: string | null
      libelle_petr: string | null
      code_pnr: string | null
      libelle_pnr: string | null
      naf09art10: number | null
      art09act10: number | null
      art09hab10: number | null
      art09mix10: number | null
      art09rou10: number | null
      art09fer10: number | null
      art09inc10: number | null
      naf10art11: number | null
      art10act11: number | null
      art10hab11: number | null
      art10mix11: number | null
      art10rou11: number | null
      art10fer11: number | null
      art10inc11: number | null
      naf11art12: number | null
      art11act12: number | null
      art11hab12: number | null
      art11mix12: number | null
      art11rou12: number | null
      art11fer12: number | null
      art11inc12: number | null
      naf12art13: number | null
      art12act13: number | null
      art12hab13: number | null
      art12mix13: number | null
      art12rou13: number | null
      art12fer13: number | null
      art12inc13: number | null
      naf13art14: number | null
      art13act14: number | null
      art13hab14: number | null
      art13mix14: number | null
      art13rou14: number | null
      art13fer14: number | null
      art13inc14: number | null
      naf14art15: number | null
      art14act15: number | null
      art14hab15: number | null
      art14mix15: number | null
      art14rou15: number | null
      art14fer15: number | null
      art14inc15: number | null
      naf15art16: number | null
      art15act16: number | null
      art15hab16: number | null
      art15mix16: number | null
      art15rou16: number | null
      art15fer16: number | null
      art15inc16: number | null
      naf16art17: number | null
      art16act17: number | null
      art16hab17: number | null
      art16mix17: number | null
      art16rou17: number | null
      art16fer17: number | null
      art16inc17: number | null
      naf17art18: number | null
      art17act18: number | null
      art17hab18: number | null
      art17mix18: number | null
      art17rou18: number | null
      art17fer18: number | null
      art17inc18: number | null
      naf18art19: number | null
      art18act19: number | null
      art18hab19: number | null
      art18mix19: number | null
      art18rou19: number | null
      art18fer19: number | null
      art18inc19: number | null
      naf19art20: number | null
      art19act20: number | null
      art19hab20: number | null
      art19mix20: number | null
      art19rou20: number | null
      art19fer20: number | null
      art19inc20: number | null
      naf20art21: number | null
      art20act21: number | null
      art20hab21: number | null
      art20mix21: number | null
      art20rou21: number | null
      art20fer21: number | null
      art20inc21: number | null
      naf21art22: number | null
      art21act22: number | null
      art21hab22: number | null
      art21mix22: number | null
      art21rou22: number | null
      art21fer22: number | null
      art21inc22: number | null
      naf22art23: number | null
      art22act23: number | null
      art22hab23: number | null
      art22mix23: number | null
      art22rou23: number | null
      art22fer23: number | null
      art22inc23: number | null
      naf09art23: number | null
      art09act23: number | null
      art09hab23: number | null
      art09mix23: number | null
      art09inc23: number | null
      art09rou23: number | null
      art09fer23: number | null
      artcom0923: number | null
    }, ExtArgs["result"]["consommation_espaces_naf"]>
    composites: {}
  }

  type consommation_espaces_nafGetPayload<S extends boolean | null | undefined | consommation_espaces_nafDefaultArgs> = $Result.GetResult<Prisma.$consommation_espaces_nafPayload, S>

  type consommation_espaces_nafCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<consommation_espaces_nafFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Consommation_espaces_nafCountAggregateInputType | true
    }

  export interface consommation_espaces_nafDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['consommation_espaces_naf'], meta: { name: 'consommation_espaces_naf' } }
    /**
     * Find zero or one Consommation_espaces_naf that matches the filter.
     * @param {consommation_espaces_nafFindUniqueArgs} args - Arguments to find a Consommation_espaces_naf
     * @example
     * // Get one Consommation_espaces_naf
     * const consommation_espaces_naf = await prisma.consommation_espaces_naf.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends consommation_espaces_nafFindUniqueArgs>(args: SelectSubset<T, consommation_espaces_nafFindUniqueArgs<ExtArgs>>): Prisma__consommation_espaces_nafClient<$Result.GetResult<Prisma.$consommation_espaces_nafPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Consommation_espaces_naf that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {consommation_espaces_nafFindUniqueOrThrowArgs} args - Arguments to find a Consommation_espaces_naf
     * @example
     * // Get one Consommation_espaces_naf
     * const consommation_espaces_naf = await prisma.consommation_espaces_naf.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends consommation_espaces_nafFindUniqueOrThrowArgs>(args: SelectSubset<T, consommation_espaces_nafFindUniqueOrThrowArgs<ExtArgs>>): Prisma__consommation_espaces_nafClient<$Result.GetResult<Prisma.$consommation_espaces_nafPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Consommation_espaces_naf that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consommation_espaces_nafFindFirstArgs} args - Arguments to find a Consommation_espaces_naf
     * @example
     * // Get one Consommation_espaces_naf
     * const consommation_espaces_naf = await prisma.consommation_espaces_naf.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends consommation_espaces_nafFindFirstArgs>(args?: SelectSubset<T, consommation_espaces_nafFindFirstArgs<ExtArgs>>): Prisma__consommation_espaces_nafClient<$Result.GetResult<Prisma.$consommation_espaces_nafPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Consommation_espaces_naf that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consommation_espaces_nafFindFirstOrThrowArgs} args - Arguments to find a Consommation_espaces_naf
     * @example
     * // Get one Consommation_espaces_naf
     * const consommation_espaces_naf = await prisma.consommation_espaces_naf.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends consommation_espaces_nafFindFirstOrThrowArgs>(args?: SelectSubset<T, consommation_espaces_nafFindFirstOrThrowArgs<ExtArgs>>): Prisma__consommation_espaces_nafClient<$Result.GetResult<Prisma.$consommation_espaces_nafPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Consommation_espaces_nafs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consommation_espaces_nafFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Consommation_espaces_nafs
     * const consommation_espaces_nafs = await prisma.consommation_espaces_naf.findMany()
     * 
     * // Get first 10 Consommation_espaces_nafs
     * const consommation_espaces_nafs = await prisma.consommation_espaces_naf.findMany({ take: 10 })
     * 
     * // Only select the `index`
     * const consommation_espaces_nafWithIndexOnly = await prisma.consommation_espaces_naf.findMany({ select: { index: true } })
     * 
     */
    findMany<T extends consommation_espaces_nafFindManyArgs>(args?: SelectSubset<T, consommation_espaces_nafFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$consommation_espaces_nafPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Consommation_espaces_naf.
     * @param {consommation_espaces_nafCreateArgs} args - Arguments to create a Consommation_espaces_naf.
     * @example
     * // Create one Consommation_espaces_naf
     * const Consommation_espaces_naf = await prisma.consommation_espaces_naf.create({
     *   data: {
     *     // ... data to create a Consommation_espaces_naf
     *   }
     * })
     * 
     */
    create<T extends consommation_espaces_nafCreateArgs>(args: SelectSubset<T, consommation_espaces_nafCreateArgs<ExtArgs>>): Prisma__consommation_espaces_nafClient<$Result.GetResult<Prisma.$consommation_espaces_nafPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Consommation_espaces_nafs.
     * @param {consommation_espaces_nafCreateManyArgs} args - Arguments to create many Consommation_espaces_nafs.
     * @example
     * // Create many Consommation_espaces_nafs
     * const consommation_espaces_naf = await prisma.consommation_espaces_naf.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends consommation_espaces_nafCreateManyArgs>(args?: SelectSubset<T, consommation_espaces_nafCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Consommation_espaces_nafs and returns the data saved in the database.
     * @param {consommation_espaces_nafCreateManyAndReturnArgs} args - Arguments to create many Consommation_espaces_nafs.
     * @example
     * // Create many Consommation_espaces_nafs
     * const consommation_espaces_naf = await prisma.consommation_espaces_naf.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Consommation_espaces_nafs and only return the `index`
     * const consommation_espaces_nafWithIndexOnly = await prisma.consommation_espaces_naf.createManyAndReturn({
     *   select: { index: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends consommation_espaces_nafCreateManyAndReturnArgs>(args?: SelectSubset<T, consommation_espaces_nafCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$consommation_espaces_nafPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Consommation_espaces_naf.
     * @param {consommation_espaces_nafDeleteArgs} args - Arguments to delete one Consommation_espaces_naf.
     * @example
     * // Delete one Consommation_espaces_naf
     * const Consommation_espaces_naf = await prisma.consommation_espaces_naf.delete({
     *   where: {
     *     // ... filter to delete one Consommation_espaces_naf
     *   }
     * })
     * 
     */
    delete<T extends consommation_espaces_nafDeleteArgs>(args: SelectSubset<T, consommation_espaces_nafDeleteArgs<ExtArgs>>): Prisma__consommation_espaces_nafClient<$Result.GetResult<Prisma.$consommation_espaces_nafPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Consommation_espaces_naf.
     * @param {consommation_espaces_nafUpdateArgs} args - Arguments to update one Consommation_espaces_naf.
     * @example
     * // Update one Consommation_espaces_naf
     * const consommation_espaces_naf = await prisma.consommation_espaces_naf.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends consommation_espaces_nafUpdateArgs>(args: SelectSubset<T, consommation_espaces_nafUpdateArgs<ExtArgs>>): Prisma__consommation_espaces_nafClient<$Result.GetResult<Prisma.$consommation_espaces_nafPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Consommation_espaces_nafs.
     * @param {consommation_espaces_nafDeleteManyArgs} args - Arguments to filter Consommation_espaces_nafs to delete.
     * @example
     * // Delete a few Consommation_espaces_nafs
     * const { count } = await prisma.consommation_espaces_naf.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends consommation_espaces_nafDeleteManyArgs>(args?: SelectSubset<T, consommation_espaces_nafDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Consommation_espaces_nafs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consommation_espaces_nafUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Consommation_espaces_nafs
     * const consommation_espaces_naf = await prisma.consommation_espaces_naf.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends consommation_espaces_nafUpdateManyArgs>(args: SelectSubset<T, consommation_espaces_nafUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Consommation_espaces_nafs and returns the data updated in the database.
     * @param {consommation_espaces_nafUpdateManyAndReturnArgs} args - Arguments to update many Consommation_espaces_nafs.
     * @example
     * // Update many Consommation_espaces_nafs
     * const consommation_espaces_naf = await prisma.consommation_espaces_naf.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Consommation_espaces_nafs and only return the `index`
     * const consommation_espaces_nafWithIndexOnly = await prisma.consommation_espaces_naf.updateManyAndReturn({
     *   select: { index: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends consommation_espaces_nafUpdateManyAndReturnArgs>(args: SelectSubset<T, consommation_espaces_nafUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$consommation_espaces_nafPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Consommation_espaces_naf.
     * @param {consommation_espaces_nafUpsertArgs} args - Arguments to update or create a Consommation_espaces_naf.
     * @example
     * // Update or create a Consommation_espaces_naf
     * const consommation_espaces_naf = await prisma.consommation_espaces_naf.upsert({
     *   create: {
     *     // ... data to create a Consommation_espaces_naf
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Consommation_espaces_naf we want to update
     *   }
     * })
     */
    upsert<T extends consommation_espaces_nafUpsertArgs>(args: SelectSubset<T, consommation_espaces_nafUpsertArgs<ExtArgs>>): Prisma__consommation_espaces_nafClient<$Result.GetResult<Prisma.$consommation_espaces_nafPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Consommation_espaces_nafs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consommation_espaces_nafCountArgs} args - Arguments to filter Consommation_espaces_nafs to count.
     * @example
     * // Count the number of Consommation_espaces_nafs
     * const count = await prisma.consommation_espaces_naf.count({
     *   where: {
     *     // ... the filter for the Consommation_espaces_nafs we want to count
     *   }
     * })
    **/
    count<T extends consommation_espaces_nafCountArgs>(
      args?: Subset<T, consommation_espaces_nafCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Consommation_espaces_nafCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Consommation_espaces_naf.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Consommation_espaces_nafAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Consommation_espaces_nafAggregateArgs>(args: Subset<T, Consommation_espaces_nafAggregateArgs>): Prisma.PrismaPromise<GetConsommation_espaces_nafAggregateType<T>>

    /**
     * Group by Consommation_espaces_naf.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {consommation_espaces_nafGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends consommation_espaces_nafGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: consommation_espaces_nafGroupByArgs['orderBy'] }
        : { orderBy?: consommation_espaces_nafGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, consommation_espaces_nafGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConsommation_espaces_nafGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the consommation_espaces_naf model
   */
  readonly fields: consommation_espaces_nafFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for consommation_espaces_naf.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__consommation_espaces_nafClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the consommation_espaces_naf model
   */
  interface consommation_espaces_nafFieldRefs {
    readonly index: FieldRef<"consommation_espaces_naf", 'Int'>
    readonly code_geographique: FieldRef<"consommation_espaces_naf", 'String'>
    readonly libelle_geographique: FieldRef<"consommation_espaces_naf", 'String'>
    readonly epci: FieldRef<"consommation_espaces_naf", 'String'>
    readonly libelle_epci: FieldRef<"consommation_espaces_naf", 'String'>
    readonly departement: FieldRef<"consommation_espaces_naf", 'String'>
    readonly libelle_departement: FieldRef<"consommation_espaces_naf", 'String'>
    readonly region: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly ept: FieldRef<"consommation_espaces_naf", 'String'>
    readonly libelle_petr: FieldRef<"consommation_espaces_naf", 'String'>
    readonly code_pnr: FieldRef<"consommation_espaces_naf", 'String'>
    readonly libelle_pnr: FieldRef<"consommation_espaces_naf", 'String'>
    readonly naf09art10: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art09act10: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art09hab10: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art09mix10: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art09rou10: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art09fer10: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art09inc10: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly naf10art11: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art10act11: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art10hab11: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art10mix11: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art10rou11: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art10fer11: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art10inc11: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly naf11art12: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art11act12: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art11hab12: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art11mix12: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art11rou12: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art11fer12: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art11inc12: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly naf12art13: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art12act13: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art12hab13: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art12mix13: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art12rou13: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art12fer13: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art12inc13: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly naf13art14: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art13act14: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art13hab14: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art13mix14: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art13rou14: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art13fer14: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art13inc14: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly naf14art15: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art14act15: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art14hab15: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art14mix15: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art14rou15: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art14fer15: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art14inc15: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly naf15art16: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art15act16: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art15hab16: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art15mix16: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art15rou16: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art15fer16: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art15inc16: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly naf16art17: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art16act17: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art16hab17: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art16mix17: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art16rou17: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art16fer17: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art16inc17: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly naf17art18: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art17act18: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art17hab18: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art17mix18: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art17rou18: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art17fer18: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art17inc18: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly naf18art19: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art18act19: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art18hab19: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art18mix19: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art18rou19: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art18fer19: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art18inc19: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly naf19art20: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art19act20: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art19hab20: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art19mix20: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art19rou20: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art19fer20: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art19inc20: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly naf20art21: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art20act21: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art20hab21: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art20mix21: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art20rou21: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art20fer21: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art20inc21: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly naf21art22: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art21act22: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art21hab22: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art21mix22: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art21rou22: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art21fer22: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art21inc22: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly naf22art23: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art22act23: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art22hab23: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art22mix23: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art22rou23: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art22fer23: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art22inc23: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly naf09art23: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art09act23: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art09hab23: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art09mix23: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art09inc23: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art09rou23: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly art09fer23: FieldRef<"consommation_espaces_naf", 'Float'>
    readonly artcom0923: FieldRef<"consommation_espaces_naf", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * consommation_espaces_naf findUnique
   */
  export type consommation_espaces_nafFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consommation_espaces_naf
     */
    select?: consommation_espaces_nafSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consommation_espaces_naf
     */
    omit?: consommation_espaces_nafOmit<ExtArgs> | null
    /**
     * Filter, which consommation_espaces_naf to fetch.
     */
    where: consommation_espaces_nafWhereUniqueInput
  }

  /**
   * consommation_espaces_naf findUniqueOrThrow
   */
  export type consommation_espaces_nafFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consommation_espaces_naf
     */
    select?: consommation_espaces_nafSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consommation_espaces_naf
     */
    omit?: consommation_espaces_nafOmit<ExtArgs> | null
    /**
     * Filter, which consommation_espaces_naf to fetch.
     */
    where: consommation_espaces_nafWhereUniqueInput
  }

  /**
   * consommation_espaces_naf findFirst
   */
  export type consommation_espaces_nafFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consommation_espaces_naf
     */
    select?: consommation_espaces_nafSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consommation_espaces_naf
     */
    omit?: consommation_espaces_nafOmit<ExtArgs> | null
    /**
     * Filter, which consommation_espaces_naf to fetch.
     */
    where?: consommation_espaces_nafWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consommation_espaces_nafs to fetch.
     */
    orderBy?: consommation_espaces_nafOrderByWithRelationInput | consommation_espaces_nafOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for consommation_espaces_nafs.
     */
    cursor?: consommation_espaces_nafWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consommation_espaces_nafs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consommation_espaces_nafs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of consommation_espaces_nafs.
     */
    distinct?: Consommation_espaces_nafScalarFieldEnum | Consommation_espaces_nafScalarFieldEnum[]
  }

  /**
   * consommation_espaces_naf findFirstOrThrow
   */
  export type consommation_espaces_nafFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consommation_espaces_naf
     */
    select?: consommation_espaces_nafSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consommation_espaces_naf
     */
    omit?: consommation_espaces_nafOmit<ExtArgs> | null
    /**
     * Filter, which consommation_espaces_naf to fetch.
     */
    where?: consommation_espaces_nafWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consommation_espaces_nafs to fetch.
     */
    orderBy?: consommation_espaces_nafOrderByWithRelationInput | consommation_espaces_nafOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for consommation_espaces_nafs.
     */
    cursor?: consommation_espaces_nafWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consommation_espaces_nafs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consommation_espaces_nafs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of consommation_espaces_nafs.
     */
    distinct?: Consommation_espaces_nafScalarFieldEnum | Consommation_espaces_nafScalarFieldEnum[]
  }

  /**
   * consommation_espaces_naf findMany
   */
  export type consommation_espaces_nafFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consommation_espaces_naf
     */
    select?: consommation_espaces_nafSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consommation_espaces_naf
     */
    omit?: consommation_espaces_nafOmit<ExtArgs> | null
    /**
     * Filter, which consommation_espaces_nafs to fetch.
     */
    where?: consommation_espaces_nafWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of consommation_espaces_nafs to fetch.
     */
    orderBy?: consommation_espaces_nafOrderByWithRelationInput | consommation_espaces_nafOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing consommation_espaces_nafs.
     */
    cursor?: consommation_espaces_nafWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` consommation_espaces_nafs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` consommation_espaces_nafs.
     */
    skip?: number
    distinct?: Consommation_espaces_nafScalarFieldEnum | Consommation_espaces_nafScalarFieldEnum[]
  }

  /**
   * consommation_espaces_naf create
   */
  export type consommation_espaces_nafCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consommation_espaces_naf
     */
    select?: consommation_espaces_nafSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consommation_espaces_naf
     */
    omit?: consommation_espaces_nafOmit<ExtArgs> | null
    /**
     * The data needed to create a consommation_espaces_naf.
     */
    data: XOR<consommation_espaces_nafCreateInput, consommation_espaces_nafUncheckedCreateInput>
  }

  /**
   * consommation_espaces_naf createMany
   */
  export type consommation_espaces_nafCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many consommation_espaces_nafs.
     */
    data: consommation_espaces_nafCreateManyInput | consommation_espaces_nafCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * consommation_espaces_naf createManyAndReturn
   */
  export type consommation_espaces_nafCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consommation_espaces_naf
     */
    select?: consommation_espaces_nafSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the consommation_espaces_naf
     */
    omit?: consommation_espaces_nafOmit<ExtArgs> | null
    /**
     * The data used to create many consommation_espaces_nafs.
     */
    data: consommation_espaces_nafCreateManyInput | consommation_espaces_nafCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * consommation_espaces_naf update
   */
  export type consommation_espaces_nafUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consommation_espaces_naf
     */
    select?: consommation_espaces_nafSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consommation_espaces_naf
     */
    omit?: consommation_espaces_nafOmit<ExtArgs> | null
    /**
     * The data needed to update a consommation_espaces_naf.
     */
    data: XOR<consommation_espaces_nafUpdateInput, consommation_espaces_nafUncheckedUpdateInput>
    /**
     * Choose, which consommation_espaces_naf to update.
     */
    where: consommation_espaces_nafWhereUniqueInput
  }

  /**
   * consommation_espaces_naf updateMany
   */
  export type consommation_espaces_nafUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update consommation_espaces_nafs.
     */
    data: XOR<consommation_espaces_nafUpdateManyMutationInput, consommation_espaces_nafUncheckedUpdateManyInput>
    /**
     * Filter which consommation_espaces_nafs to update
     */
    where?: consommation_espaces_nafWhereInput
    /**
     * Limit how many consommation_espaces_nafs to update.
     */
    limit?: number
  }

  /**
   * consommation_espaces_naf updateManyAndReturn
   */
  export type consommation_espaces_nafUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consommation_espaces_naf
     */
    select?: consommation_espaces_nafSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the consommation_espaces_naf
     */
    omit?: consommation_espaces_nafOmit<ExtArgs> | null
    /**
     * The data used to update consommation_espaces_nafs.
     */
    data: XOR<consommation_espaces_nafUpdateManyMutationInput, consommation_espaces_nafUncheckedUpdateManyInput>
    /**
     * Filter which consommation_espaces_nafs to update
     */
    where?: consommation_espaces_nafWhereInput
    /**
     * Limit how many consommation_espaces_nafs to update.
     */
    limit?: number
  }

  /**
   * consommation_espaces_naf upsert
   */
  export type consommation_espaces_nafUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consommation_espaces_naf
     */
    select?: consommation_espaces_nafSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consommation_espaces_naf
     */
    omit?: consommation_espaces_nafOmit<ExtArgs> | null
    /**
     * The filter to search for the consommation_espaces_naf to update in case it exists.
     */
    where: consommation_espaces_nafWhereUniqueInput
    /**
     * In case the consommation_espaces_naf found by the `where` argument doesn't exist, create a new consommation_espaces_naf with this data.
     */
    create: XOR<consommation_espaces_nafCreateInput, consommation_espaces_nafUncheckedCreateInput>
    /**
     * In case the consommation_espaces_naf was found with the provided `where` argument, update it with this data.
     */
    update: XOR<consommation_espaces_nafUpdateInput, consommation_espaces_nafUncheckedUpdateInput>
  }

  /**
   * consommation_espaces_naf delete
   */
  export type consommation_espaces_nafDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consommation_espaces_naf
     */
    select?: consommation_espaces_nafSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consommation_espaces_naf
     */
    omit?: consommation_espaces_nafOmit<ExtArgs> | null
    /**
     * Filter which consommation_espaces_naf to delete.
     */
    where: consommation_espaces_nafWhereUniqueInput
  }

  /**
   * consommation_espaces_naf deleteMany
   */
  export type consommation_espaces_nafDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which consommation_espaces_nafs to delete
     */
    where?: consommation_espaces_nafWhereInput
    /**
     * Limit how many consommation_espaces_nafs to delete.
     */
    limit?: number
  }

  /**
   * consommation_espaces_naf without action
   */
  export type consommation_espaces_nafDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the consommation_espaces_naf
     */
    select?: consommation_espaces_nafSelect<ExtArgs> | null
    /**
     * Omit specific fields from the consommation_espaces_naf
     */
    omit?: consommation_espaces_nafOmit<ExtArgs> | null
  }


  /**
   * Model export_cours_d_eau
   */

  export type AggregateExport_cours_d_eau = {
    _count: Export_cours_d_eauCountAggregateOutputType | null
    _avg: Export_cours_d_eauAvgAggregateOutputType | null
    _sum: Export_cours_d_eauSumAggregateOutputType | null
    _min: Export_cours_d_eauMinAggregateOutputType | null
    _max: Export_cours_d_eauMaxAggregateOutputType | null
  }

  export type Export_cours_d_eauAvgAggregateOutputType = {
    index: number | null
    region: number | null
    longueur: number | null
  }

  export type Export_cours_d_eauSumAggregateOutputType = {
    index: number | null
    region: number | null
    longueur: number | null
  }

  export type Export_cours_d_eauMinAggregateOutputType = {
    index: number | null
    code_geographique: string | null
    libelle_geographique: string | null
    epci: string | null
    libelle_epci: string | null
    departement: string | null
    libelle_departement: string | null
    region: number | null
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
    cours_d_eau: string | null
    etat_ecologique: string | null
    longueur: number | null
  }

  export type Export_cours_d_eauMaxAggregateOutputType = {
    index: number | null
    code_geographique: string | null
    libelle_geographique: string | null
    epci: string | null
    libelle_epci: string | null
    departement: string | null
    libelle_departement: string | null
    region: number | null
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
    cours_d_eau: string | null
    etat_ecologique: string | null
    longueur: number | null
  }

  export type Export_cours_d_eauCountAggregateOutputType = {
    index: number
    code_geographique: number
    libelle_geographique: number
    epci: number
    libelle_epci: number
    departement: number
    libelle_departement: number
    region: number
    ept: number
    libelle_petr: number
    code_pnr: number
    libelle_pnr: number
    cours_d_eau: number
    etat_ecologique: number
    longueur: number
    _all: number
  }


  export type Export_cours_d_eauAvgAggregateInputType = {
    index?: true
    region?: true
    longueur?: true
  }

  export type Export_cours_d_eauSumAggregateInputType = {
    index?: true
    region?: true
    longueur?: true
  }

  export type Export_cours_d_eauMinAggregateInputType = {
    index?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
    cours_d_eau?: true
    etat_ecologique?: true
    longueur?: true
  }

  export type Export_cours_d_eauMaxAggregateInputType = {
    index?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
    cours_d_eau?: true
    etat_ecologique?: true
    longueur?: true
  }

  export type Export_cours_d_eauCountAggregateInputType = {
    index?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
    cours_d_eau?: true
    etat_ecologique?: true
    longueur?: true
    _all?: true
  }

  export type Export_cours_d_eauAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which export_cours_d_eau to aggregate.
     */
    where?: export_cours_d_eauWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of export_cours_d_eaus to fetch.
     */
    orderBy?: export_cours_d_eauOrderByWithRelationInput | export_cours_d_eauOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: export_cours_d_eauWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` export_cours_d_eaus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` export_cours_d_eaus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned export_cours_d_eaus
    **/
    _count?: true | Export_cours_d_eauCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Export_cours_d_eauAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Export_cours_d_eauSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Export_cours_d_eauMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Export_cours_d_eauMaxAggregateInputType
  }

  export type GetExport_cours_d_eauAggregateType<T extends Export_cours_d_eauAggregateArgs> = {
        [P in keyof T & keyof AggregateExport_cours_d_eau]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExport_cours_d_eau[P]>
      : GetScalarType<T[P], AggregateExport_cours_d_eau[P]>
  }




  export type export_cours_d_eauGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: export_cours_d_eauWhereInput
    orderBy?: export_cours_d_eauOrderByWithAggregationInput | export_cours_d_eauOrderByWithAggregationInput[]
    by: Export_cours_d_eauScalarFieldEnum[] | Export_cours_d_eauScalarFieldEnum
    having?: export_cours_d_eauScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Export_cours_d_eauCountAggregateInputType | true
    _avg?: Export_cours_d_eauAvgAggregateInputType
    _sum?: Export_cours_d_eauSumAggregateInputType
    _min?: Export_cours_d_eauMinAggregateInputType
    _max?: Export_cours_d_eauMaxAggregateInputType
  }

  export type Export_cours_d_eauGroupByOutputType = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
    cours_d_eau: string
    etat_ecologique: string | null
    longueur: number
    _count: Export_cours_d_eauCountAggregateOutputType | null
    _avg: Export_cours_d_eauAvgAggregateOutputType | null
    _sum: Export_cours_d_eauSumAggregateOutputType | null
    _min: Export_cours_d_eauMinAggregateOutputType | null
    _max: Export_cours_d_eauMaxAggregateOutputType | null
  }

  type GetExport_cours_d_eauGroupByPayload<T extends export_cours_d_eauGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Export_cours_d_eauGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Export_cours_d_eauGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Export_cours_d_eauGroupByOutputType[P]>
            : GetScalarType<T[P], Export_cours_d_eauGroupByOutputType[P]>
        }
      >
    >


  export type export_cours_d_eauSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    cours_d_eau?: boolean
    etat_ecologique?: boolean
    longueur?: boolean
  }, ExtArgs["result"]["export_cours_d_eau"]>

  export type export_cours_d_eauSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    cours_d_eau?: boolean
    etat_ecologique?: boolean
    longueur?: boolean
  }, ExtArgs["result"]["export_cours_d_eau"]>

  export type export_cours_d_eauSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    cours_d_eau?: boolean
    etat_ecologique?: boolean
    longueur?: boolean
  }, ExtArgs["result"]["export_cours_d_eau"]>

  export type export_cours_d_eauSelectScalar = {
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    cours_d_eau?: boolean
    etat_ecologique?: boolean
    longueur?: boolean
  }

  export type export_cours_d_eauOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"index" | "code_geographique" | "libelle_geographique" | "epci" | "libelle_epci" | "departement" | "libelle_departement" | "region" | "ept" | "libelle_petr" | "code_pnr" | "libelle_pnr" | "cours_d_eau" | "etat_ecologique" | "longueur", ExtArgs["result"]["export_cours_d_eau"]>

  export type $export_cours_d_eauPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "export_cours_d_eau"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      index: number
      code_geographique: string
      libelle_geographique: string
      epci: string
      libelle_epci: string
      departement: string
      libelle_departement: string
      region: number
      ept: string | null
      libelle_petr: string | null
      code_pnr: string | null
      libelle_pnr: string | null
      cours_d_eau: string
      etat_ecologique: string | null
      longueur: number
    }, ExtArgs["result"]["export_cours_d_eau"]>
    composites: {}
  }

  type export_cours_d_eauGetPayload<S extends boolean | null | undefined | export_cours_d_eauDefaultArgs> = $Result.GetResult<Prisma.$export_cours_d_eauPayload, S>

  type export_cours_d_eauCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<export_cours_d_eauFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Export_cours_d_eauCountAggregateInputType | true
    }

  export interface export_cours_d_eauDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['export_cours_d_eau'], meta: { name: 'export_cours_d_eau' } }
    /**
     * Find zero or one Export_cours_d_eau that matches the filter.
     * @param {export_cours_d_eauFindUniqueArgs} args - Arguments to find a Export_cours_d_eau
     * @example
     * // Get one Export_cours_d_eau
     * const export_cours_d_eau = await prisma.export_cours_d_eau.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends export_cours_d_eauFindUniqueArgs>(args: SelectSubset<T, export_cours_d_eauFindUniqueArgs<ExtArgs>>): Prisma__export_cours_d_eauClient<$Result.GetResult<Prisma.$export_cours_d_eauPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Export_cours_d_eau that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {export_cours_d_eauFindUniqueOrThrowArgs} args - Arguments to find a Export_cours_d_eau
     * @example
     * // Get one Export_cours_d_eau
     * const export_cours_d_eau = await prisma.export_cours_d_eau.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends export_cours_d_eauFindUniqueOrThrowArgs>(args: SelectSubset<T, export_cours_d_eauFindUniqueOrThrowArgs<ExtArgs>>): Prisma__export_cours_d_eauClient<$Result.GetResult<Prisma.$export_cours_d_eauPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Export_cours_d_eau that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {export_cours_d_eauFindFirstArgs} args - Arguments to find a Export_cours_d_eau
     * @example
     * // Get one Export_cours_d_eau
     * const export_cours_d_eau = await prisma.export_cours_d_eau.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends export_cours_d_eauFindFirstArgs>(args?: SelectSubset<T, export_cours_d_eauFindFirstArgs<ExtArgs>>): Prisma__export_cours_d_eauClient<$Result.GetResult<Prisma.$export_cours_d_eauPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Export_cours_d_eau that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {export_cours_d_eauFindFirstOrThrowArgs} args - Arguments to find a Export_cours_d_eau
     * @example
     * // Get one Export_cours_d_eau
     * const export_cours_d_eau = await prisma.export_cours_d_eau.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends export_cours_d_eauFindFirstOrThrowArgs>(args?: SelectSubset<T, export_cours_d_eauFindFirstOrThrowArgs<ExtArgs>>): Prisma__export_cours_d_eauClient<$Result.GetResult<Prisma.$export_cours_d_eauPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Export_cours_d_eaus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {export_cours_d_eauFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Export_cours_d_eaus
     * const export_cours_d_eaus = await prisma.export_cours_d_eau.findMany()
     * 
     * // Get first 10 Export_cours_d_eaus
     * const export_cours_d_eaus = await prisma.export_cours_d_eau.findMany({ take: 10 })
     * 
     * // Only select the `index`
     * const export_cours_d_eauWithIndexOnly = await prisma.export_cours_d_eau.findMany({ select: { index: true } })
     * 
     */
    findMany<T extends export_cours_d_eauFindManyArgs>(args?: SelectSubset<T, export_cours_d_eauFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$export_cours_d_eauPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Export_cours_d_eau.
     * @param {export_cours_d_eauCreateArgs} args - Arguments to create a Export_cours_d_eau.
     * @example
     * // Create one Export_cours_d_eau
     * const Export_cours_d_eau = await prisma.export_cours_d_eau.create({
     *   data: {
     *     // ... data to create a Export_cours_d_eau
     *   }
     * })
     * 
     */
    create<T extends export_cours_d_eauCreateArgs>(args: SelectSubset<T, export_cours_d_eauCreateArgs<ExtArgs>>): Prisma__export_cours_d_eauClient<$Result.GetResult<Prisma.$export_cours_d_eauPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Export_cours_d_eaus.
     * @param {export_cours_d_eauCreateManyArgs} args - Arguments to create many Export_cours_d_eaus.
     * @example
     * // Create many Export_cours_d_eaus
     * const export_cours_d_eau = await prisma.export_cours_d_eau.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends export_cours_d_eauCreateManyArgs>(args?: SelectSubset<T, export_cours_d_eauCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Export_cours_d_eaus and returns the data saved in the database.
     * @param {export_cours_d_eauCreateManyAndReturnArgs} args - Arguments to create many Export_cours_d_eaus.
     * @example
     * // Create many Export_cours_d_eaus
     * const export_cours_d_eau = await prisma.export_cours_d_eau.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Export_cours_d_eaus and only return the `index`
     * const export_cours_d_eauWithIndexOnly = await prisma.export_cours_d_eau.createManyAndReturn({
     *   select: { index: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends export_cours_d_eauCreateManyAndReturnArgs>(args?: SelectSubset<T, export_cours_d_eauCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$export_cours_d_eauPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Export_cours_d_eau.
     * @param {export_cours_d_eauDeleteArgs} args - Arguments to delete one Export_cours_d_eau.
     * @example
     * // Delete one Export_cours_d_eau
     * const Export_cours_d_eau = await prisma.export_cours_d_eau.delete({
     *   where: {
     *     // ... filter to delete one Export_cours_d_eau
     *   }
     * })
     * 
     */
    delete<T extends export_cours_d_eauDeleteArgs>(args: SelectSubset<T, export_cours_d_eauDeleteArgs<ExtArgs>>): Prisma__export_cours_d_eauClient<$Result.GetResult<Prisma.$export_cours_d_eauPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Export_cours_d_eau.
     * @param {export_cours_d_eauUpdateArgs} args - Arguments to update one Export_cours_d_eau.
     * @example
     * // Update one Export_cours_d_eau
     * const export_cours_d_eau = await prisma.export_cours_d_eau.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends export_cours_d_eauUpdateArgs>(args: SelectSubset<T, export_cours_d_eauUpdateArgs<ExtArgs>>): Prisma__export_cours_d_eauClient<$Result.GetResult<Prisma.$export_cours_d_eauPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Export_cours_d_eaus.
     * @param {export_cours_d_eauDeleteManyArgs} args - Arguments to filter Export_cours_d_eaus to delete.
     * @example
     * // Delete a few Export_cours_d_eaus
     * const { count } = await prisma.export_cours_d_eau.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends export_cours_d_eauDeleteManyArgs>(args?: SelectSubset<T, export_cours_d_eauDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Export_cours_d_eaus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {export_cours_d_eauUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Export_cours_d_eaus
     * const export_cours_d_eau = await prisma.export_cours_d_eau.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends export_cours_d_eauUpdateManyArgs>(args: SelectSubset<T, export_cours_d_eauUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Export_cours_d_eaus and returns the data updated in the database.
     * @param {export_cours_d_eauUpdateManyAndReturnArgs} args - Arguments to update many Export_cours_d_eaus.
     * @example
     * // Update many Export_cours_d_eaus
     * const export_cours_d_eau = await prisma.export_cours_d_eau.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Export_cours_d_eaus and only return the `index`
     * const export_cours_d_eauWithIndexOnly = await prisma.export_cours_d_eau.updateManyAndReturn({
     *   select: { index: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends export_cours_d_eauUpdateManyAndReturnArgs>(args: SelectSubset<T, export_cours_d_eauUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$export_cours_d_eauPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Export_cours_d_eau.
     * @param {export_cours_d_eauUpsertArgs} args - Arguments to update or create a Export_cours_d_eau.
     * @example
     * // Update or create a Export_cours_d_eau
     * const export_cours_d_eau = await prisma.export_cours_d_eau.upsert({
     *   create: {
     *     // ... data to create a Export_cours_d_eau
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Export_cours_d_eau we want to update
     *   }
     * })
     */
    upsert<T extends export_cours_d_eauUpsertArgs>(args: SelectSubset<T, export_cours_d_eauUpsertArgs<ExtArgs>>): Prisma__export_cours_d_eauClient<$Result.GetResult<Prisma.$export_cours_d_eauPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Export_cours_d_eaus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {export_cours_d_eauCountArgs} args - Arguments to filter Export_cours_d_eaus to count.
     * @example
     * // Count the number of Export_cours_d_eaus
     * const count = await prisma.export_cours_d_eau.count({
     *   where: {
     *     // ... the filter for the Export_cours_d_eaus we want to count
     *   }
     * })
    **/
    count<T extends export_cours_d_eauCountArgs>(
      args?: Subset<T, export_cours_d_eauCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Export_cours_d_eauCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Export_cours_d_eau.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Export_cours_d_eauAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Export_cours_d_eauAggregateArgs>(args: Subset<T, Export_cours_d_eauAggregateArgs>): Prisma.PrismaPromise<GetExport_cours_d_eauAggregateType<T>>

    /**
     * Group by Export_cours_d_eau.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {export_cours_d_eauGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends export_cours_d_eauGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: export_cours_d_eauGroupByArgs['orderBy'] }
        : { orderBy?: export_cours_d_eauGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, export_cours_d_eauGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExport_cours_d_eauGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the export_cours_d_eau model
   */
  readonly fields: export_cours_d_eauFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for export_cours_d_eau.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__export_cours_d_eauClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the export_cours_d_eau model
   */
  interface export_cours_d_eauFieldRefs {
    readonly index: FieldRef<"export_cours_d_eau", 'Int'>
    readonly code_geographique: FieldRef<"export_cours_d_eau", 'String'>
    readonly libelle_geographique: FieldRef<"export_cours_d_eau", 'String'>
    readonly epci: FieldRef<"export_cours_d_eau", 'String'>
    readonly libelle_epci: FieldRef<"export_cours_d_eau", 'String'>
    readonly departement: FieldRef<"export_cours_d_eau", 'String'>
    readonly libelle_departement: FieldRef<"export_cours_d_eau", 'String'>
    readonly region: FieldRef<"export_cours_d_eau", 'Float'>
    readonly ept: FieldRef<"export_cours_d_eau", 'String'>
    readonly libelle_petr: FieldRef<"export_cours_d_eau", 'String'>
    readonly code_pnr: FieldRef<"export_cours_d_eau", 'String'>
    readonly libelle_pnr: FieldRef<"export_cours_d_eau", 'String'>
    readonly cours_d_eau: FieldRef<"export_cours_d_eau", 'String'>
    readonly etat_ecologique: FieldRef<"export_cours_d_eau", 'String'>
    readonly longueur: FieldRef<"export_cours_d_eau", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * export_cours_d_eau findUnique
   */
  export type export_cours_d_eauFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the export_cours_d_eau
     */
    select?: export_cours_d_eauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the export_cours_d_eau
     */
    omit?: export_cours_d_eauOmit<ExtArgs> | null
    /**
     * Filter, which export_cours_d_eau to fetch.
     */
    where: export_cours_d_eauWhereUniqueInput
  }

  /**
   * export_cours_d_eau findUniqueOrThrow
   */
  export type export_cours_d_eauFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the export_cours_d_eau
     */
    select?: export_cours_d_eauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the export_cours_d_eau
     */
    omit?: export_cours_d_eauOmit<ExtArgs> | null
    /**
     * Filter, which export_cours_d_eau to fetch.
     */
    where: export_cours_d_eauWhereUniqueInput
  }

  /**
   * export_cours_d_eau findFirst
   */
  export type export_cours_d_eauFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the export_cours_d_eau
     */
    select?: export_cours_d_eauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the export_cours_d_eau
     */
    omit?: export_cours_d_eauOmit<ExtArgs> | null
    /**
     * Filter, which export_cours_d_eau to fetch.
     */
    where?: export_cours_d_eauWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of export_cours_d_eaus to fetch.
     */
    orderBy?: export_cours_d_eauOrderByWithRelationInput | export_cours_d_eauOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for export_cours_d_eaus.
     */
    cursor?: export_cours_d_eauWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` export_cours_d_eaus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` export_cours_d_eaus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of export_cours_d_eaus.
     */
    distinct?: Export_cours_d_eauScalarFieldEnum | Export_cours_d_eauScalarFieldEnum[]
  }

  /**
   * export_cours_d_eau findFirstOrThrow
   */
  export type export_cours_d_eauFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the export_cours_d_eau
     */
    select?: export_cours_d_eauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the export_cours_d_eau
     */
    omit?: export_cours_d_eauOmit<ExtArgs> | null
    /**
     * Filter, which export_cours_d_eau to fetch.
     */
    where?: export_cours_d_eauWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of export_cours_d_eaus to fetch.
     */
    orderBy?: export_cours_d_eauOrderByWithRelationInput | export_cours_d_eauOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for export_cours_d_eaus.
     */
    cursor?: export_cours_d_eauWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` export_cours_d_eaus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` export_cours_d_eaus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of export_cours_d_eaus.
     */
    distinct?: Export_cours_d_eauScalarFieldEnum | Export_cours_d_eauScalarFieldEnum[]
  }

  /**
   * export_cours_d_eau findMany
   */
  export type export_cours_d_eauFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the export_cours_d_eau
     */
    select?: export_cours_d_eauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the export_cours_d_eau
     */
    omit?: export_cours_d_eauOmit<ExtArgs> | null
    /**
     * Filter, which export_cours_d_eaus to fetch.
     */
    where?: export_cours_d_eauWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of export_cours_d_eaus to fetch.
     */
    orderBy?: export_cours_d_eauOrderByWithRelationInput | export_cours_d_eauOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing export_cours_d_eaus.
     */
    cursor?: export_cours_d_eauWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` export_cours_d_eaus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` export_cours_d_eaus.
     */
    skip?: number
    distinct?: Export_cours_d_eauScalarFieldEnum | Export_cours_d_eauScalarFieldEnum[]
  }

  /**
   * export_cours_d_eau create
   */
  export type export_cours_d_eauCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the export_cours_d_eau
     */
    select?: export_cours_d_eauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the export_cours_d_eau
     */
    omit?: export_cours_d_eauOmit<ExtArgs> | null
    /**
     * The data needed to create a export_cours_d_eau.
     */
    data: XOR<export_cours_d_eauCreateInput, export_cours_d_eauUncheckedCreateInput>
  }

  /**
   * export_cours_d_eau createMany
   */
  export type export_cours_d_eauCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many export_cours_d_eaus.
     */
    data: export_cours_d_eauCreateManyInput | export_cours_d_eauCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * export_cours_d_eau createManyAndReturn
   */
  export type export_cours_d_eauCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the export_cours_d_eau
     */
    select?: export_cours_d_eauSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the export_cours_d_eau
     */
    omit?: export_cours_d_eauOmit<ExtArgs> | null
    /**
     * The data used to create many export_cours_d_eaus.
     */
    data: export_cours_d_eauCreateManyInput | export_cours_d_eauCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * export_cours_d_eau update
   */
  export type export_cours_d_eauUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the export_cours_d_eau
     */
    select?: export_cours_d_eauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the export_cours_d_eau
     */
    omit?: export_cours_d_eauOmit<ExtArgs> | null
    /**
     * The data needed to update a export_cours_d_eau.
     */
    data: XOR<export_cours_d_eauUpdateInput, export_cours_d_eauUncheckedUpdateInput>
    /**
     * Choose, which export_cours_d_eau to update.
     */
    where: export_cours_d_eauWhereUniqueInput
  }

  /**
   * export_cours_d_eau updateMany
   */
  export type export_cours_d_eauUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update export_cours_d_eaus.
     */
    data: XOR<export_cours_d_eauUpdateManyMutationInput, export_cours_d_eauUncheckedUpdateManyInput>
    /**
     * Filter which export_cours_d_eaus to update
     */
    where?: export_cours_d_eauWhereInput
    /**
     * Limit how many export_cours_d_eaus to update.
     */
    limit?: number
  }

  /**
   * export_cours_d_eau updateManyAndReturn
   */
  export type export_cours_d_eauUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the export_cours_d_eau
     */
    select?: export_cours_d_eauSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the export_cours_d_eau
     */
    omit?: export_cours_d_eauOmit<ExtArgs> | null
    /**
     * The data used to update export_cours_d_eaus.
     */
    data: XOR<export_cours_d_eauUpdateManyMutationInput, export_cours_d_eauUncheckedUpdateManyInput>
    /**
     * Filter which export_cours_d_eaus to update
     */
    where?: export_cours_d_eauWhereInput
    /**
     * Limit how many export_cours_d_eaus to update.
     */
    limit?: number
  }

  /**
   * export_cours_d_eau upsert
   */
  export type export_cours_d_eauUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the export_cours_d_eau
     */
    select?: export_cours_d_eauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the export_cours_d_eau
     */
    omit?: export_cours_d_eauOmit<ExtArgs> | null
    /**
     * The filter to search for the export_cours_d_eau to update in case it exists.
     */
    where: export_cours_d_eauWhereUniqueInput
    /**
     * In case the export_cours_d_eau found by the `where` argument doesn't exist, create a new export_cours_d_eau with this data.
     */
    create: XOR<export_cours_d_eauCreateInput, export_cours_d_eauUncheckedCreateInput>
    /**
     * In case the export_cours_d_eau was found with the provided `where` argument, update it with this data.
     */
    update: XOR<export_cours_d_eauUpdateInput, export_cours_d_eauUncheckedUpdateInput>
  }

  /**
   * export_cours_d_eau delete
   */
  export type export_cours_d_eauDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the export_cours_d_eau
     */
    select?: export_cours_d_eauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the export_cours_d_eau
     */
    omit?: export_cours_d_eauOmit<ExtArgs> | null
    /**
     * Filter which export_cours_d_eau to delete.
     */
    where: export_cours_d_eauWhereUniqueInput
  }

  /**
   * export_cours_d_eau deleteMany
   */
  export type export_cours_d_eauDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which export_cours_d_eaus to delete
     */
    where?: export_cours_d_eauWhereInput
    /**
     * Limit how many export_cours_d_eaus to delete.
     */
    limit?: number
  }

  /**
   * export_cours_d_eau without action
   */
  export type export_cours_d_eauDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the export_cours_d_eau
     */
    select?: export_cours_d_eauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the export_cours_d_eau
     */
    omit?: export_cours_d_eauOmit<ExtArgs> | null
  }


  /**
   * Model feux_foret
   */

  export type AggregateFeux_foret = {
    _count: Feux_foretCountAggregateOutputType | null
    _avg: Feux_foretAvgAggregateOutputType | null
    _sum: Feux_foretSumAggregateOutputType | null
    _min: Feux_foretMinAggregateOutputType | null
    _max: Feux_foretMaxAggregateOutputType | null
  }

  export type Feux_foretAvgAggregateOutputType = {
    index: number | null
    region: number | null
    annee: number | null
    surface_parcourue: number | null
    surface_foret: number | null
    surface_maquis_garrigues: number | null
    autres_surfaces_naturelles_hors_foret: number | null
    surfaces_agricoles: number | null
    surfaces_non_boisees: number | null
    surfaces_non_boisees_artificialisees: number | null
    surfaces_non_boisees_naturelles: number | null
    surface_autres_terres_boisees: number | null
    autres_surfaces: number | null
  }

  export type Feux_foretSumAggregateOutputType = {
    index: number | null
    region: number | null
    annee: number | null
    surface_parcourue: number | null
    surface_foret: number | null
    surface_maquis_garrigues: number | null
    autres_surfaces_naturelles_hors_foret: number | null
    surfaces_agricoles: number | null
    surfaces_non_boisees: number | null
    surfaces_non_boisees_artificialisees: number | null
    surfaces_non_boisees_naturelles: number | null
    surface_autres_terres_boisees: number | null
    autres_surfaces: number | null
  }

  export type Feux_foretMinAggregateOutputType = {
    index: number | null
    code_geographique: string | null
    libelle_geographique: string | null
    epci: string | null
    libelle_epci: string | null
    departement: string | null
    libelle_departement: string | null
    region: number | null
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
    annee: number | null
    nature: string | null
    surface_parcourue: number | null
    surface_foret: number | null
    surface_maquis_garrigues: number | null
    autres_surfaces_naturelles_hors_foret: number | null
    surfaces_agricoles: number | null
    surfaces_non_boisees: number | null
    surfaces_non_boisees_artificialisees: number | null
    surfaces_non_boisees_naturelles: number | null
    surface_autres_terres_boisees: number | null
    autres_surfaces: number | null
  }

  export type Feux_foretMaxAggregateOutputType = {
    index: number | null
    code_geographique: string | null
    libelle_geographique: string | null
    epci: string | null
    libelle_epci: string | null
    departement: string | null
    libelle_departement: string | null
    region: number | null
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
    annee: number | null
    nature: string | null
    surface_parcourue: number | null
    surface_foret: number | null
    surface_maquis_garrigues: number | null
    autres_surfaces_naturelles_hors_foret: number | null
    surfaces_agricoles: number | null
    surfaces_non_boisees: number | null
    surfaces_non_boisees_artificialisees: number | null
    surfaces_non_boisees_naturelles: number | null
    surface_autres_terres_boisees: number | null
    autres_surfaces: number | null
  }

  export type Feux_foretCountAggregateOutputType = {
    index: number
    code_geographique: number
    libelle_geographique: number
    epci: number
    libelle_epci: number
    departement: number
    libelle_departement: number
    region: number
    ept: number
    libelle_petr: number
    code_pnr: number
    libelle_pnr: number
    annee: number
    nature: number
    surface_parcourue: number
    surface_foret: number
    surface_maquis_garrigues: number
    autres_surfaces_naturelles_hors_foret: number
    surfaces_agricoles: number
    surfaces_non_boisees: number
    surfaces_non_boisees_artificialisees: number
    surfaces_non_boisees_naturelles: number
    surface_autres_terres_boisees: number
    autres_surfaces: number
    _all: number
  }


  export type Feux_foretAvgAggregateInputType = {
    index?: true
    region?: true
    annee?: true
    surface_parcourue?: true
    surface_foret?: true
    surface_maquis_garrigues?: true
    autres_surfaces_naturelles_hors_foret?: true
    surfaces_agricoles?: true
    surfaces_non_boisees?: true
    surfaces_non_boisees_artificialisees?: true
    surfaces_non_boisees_naturelles?: true
    surface_autres_terres_boisees?: true
    autres_surfaces?: true
  }

  export type Feux_foretSumAggregateInputType = {
    index?: true
    region?: true
    annee?: true
    surface_parcourue?: true
    surface_foret?: true
    surface_maquis_garrigues?: true
    autres_surfaces_naturelles_hors_foret?: true
    surfaces_agricoles?: true
    surfaces_non_boisees?: true
    surfaces_non_boisees_artificialisees?: true
    surfaces_non_boisees_naturelles?: true
    surface_autres_terres_boisees?: true
    autres_surfaces?: true
  }

  export type Feux_foretMinAggregateInputType = {
    index?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
    annee?: true
    nature?: true
    surface_parcourue?: true
    surface_foret?: true
    surface_maquis_garrigues?: true
    autres_surfaces_naturelles_hors_foret?: true
    surfaces_agricoles?: true
    surfaces_non_boisees?: true
    surfaces_non_boisees_artificialisees?: true
    surfaces_non_boisees_naturelles?: true
    surface_autres_terres_boisees?: true
    autres_surfaces?: true
  }

  export type Feux_foretMaxAggregateInputType = {
    index?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
    annee?: true
    nature?: true
    surface_parcourue?: true
    surface_foret?: true
    surface_maquis_garrigues?: true
    autres_surfaces_naturelles_hors_foret?: true
    surfaces_agricoles?: true
    surfaces_non_boisees?: true
    surfaces_non_boisees_artificialisees?: true
    surfaces_non_boisees_naturelles?: true
    surface_autres_terres_boisees?: true
    autres_surfaces?: true
  }

  export type Feux_foretCountAggregateInputType = {
    index?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
    annee?: true
    nature?: true
    surface_parcourue?: true
    surface_foret?: true
    surface_maquis_garrigues?: true
    autres_surfaces_naturelles_hors_foret?: true
    surfaces_agricoles?: true
    surfaces_non_boisees?: true
    surfaces_non_boisees_artificialisees?: true
    surfaces_non_boisees_naturelles?: true
    surface_autres_terres_boisees?: true
    autres_surfaces?: true
    _all?: true
  }

  export type Feux_foretAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which feux_foret to aggregate.
     */
    where?: feux_foretWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feux_forets to fetch.
     */
    orderBy?: feux_foretOrderByWithRelationInput | feux_foretOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: feux_foretWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feux_forets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feux_forets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned feux_forets
    **/
    _count?: true | Feux_foretCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Feux_foretAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Feux_foretSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Feux_foretMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Feux_foretMaxAggregateInputType
  }

  export type GetFeux_foretAggregateType<T extends Feux_foretAggregateArgs> = {
        [P in keyof T & keyof AggregateFeux_foret]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeux_foret[P]>
      : GetScalarType<T[P], AggregateFeux_foret[P]>
  }




  export type feux_foretGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: feux_foretWhereInput
    orderBy?: feux_foretOrderByWithAggregationInput | feux_foretOrderByWithAggregationInput[]
    by: Feux_foretScalarFieldEnum[] | Feux_foretScalarFieldEnum
    having?: feux_foretScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Feux_foretCountAggregateInputType | true
    _avg?: Feux_foretAvgAggregateInputType
    _sum?: Feux_foretSumAggregateInputType
    _min?: Feux_foretMinAggregateInputType
    _max?: Feux_foretMaxAggregateInputType
  }

  export type Feux_foretGroupByOutputType = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
    annee: number
    nature: string | null
    surface_parcourue: number
    surface_foret: number | null
    surface_maquis_garrigues: number | null
    autres_surfaces_naturelles_hors_foret: number | null
    surfaces_agricoles: number | null
    surfaces_non_boisees: number | null
    surfaces_non_boisees_artificialisees: number | null
    surfaces_non_boisees_naturelles: number | null
    surface_autres_terres_boisees: number | null
    autres_surfaces: number | null
    _count: Feux_foretCountAggregateOutputType | null
    _avg: Feux_foretAvgAggregateOutputType | null
    _sum: Feux_foretSumAggregateOutputType | null
    _min: Feux_foretMinAggregateOutputType | null
    _max: Feux_foretMaxAggregateOutputType | null
  }

  type GetFeux_foretGroupByPayload<T extends feux_foretGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Feux_foretGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Feux_foretGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Feux_foretGroupByOutputType[P]>
            : GetScalarType<T[P], Feux_foretGroupByOutputType[P]>
        }
      >
    >


  export type feux_foretSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    annee?: boolean
    nature?: boolean
    surface_parcourue?: boolean
    surface_foret?: boolean
    surface_maquis_garrigues?: boolean
    autres_surfaces_naturelles_hors_foret?: boolean
    surfaces_agricoles?: boolean
    surfaces_non_boisees?: boolean
    surfaces_non_boisees_artificialisees?: boolean
    surfaces_non_boisees_naturelles?: boolean
    surface_autres_terres_boisees?: boolean
    autres_surfaces?: boolean
  }, ExtArgs["result"]["feux_foret"]>

  export type feux_foretSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    annee?: boolean
    nature?: boolean
    surface_parcourue?: boolean
    surface_foret?: boolean
    surface_maquis_garrigues?: boolean
    autres_surfaces_naturelles_hors_foret?: boolean
    surfaces_agricoles?: boolean
    surfaces_non_boisees?: boolean
    surfaces_non_boisees_artificialisees?: boolean
    surfaces_non_boisees_naturelles?: boolean
    surface_autres_terres_boisees?: boolean
    autres_surfaces?: boolean
  }, ExtArgs["result"]["feux_foret"]>

  export type feux_foretSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    annee?: boolean
    nature?: boolean
    surface_parcourue?: boolean
    surface_foret?: boolean
    surface_maquis_garrigues?: boolean
    autres_surfaces_naturelles_hors_foret?: boolean
    surfaces_agricoles?: boolean
    surfaces_non_boisees?: boolean
    surfaces_non_boisees_artificialisees?: boolean
    surfaces_non_boisees_naturelles?: boolean
    surface_autres_terres_boisees?: boolean
    autres_surfaces?: boolean
  }, ExtArgs["result"]["feux_foret"]>

  export type feux_foretSelectScalar = {
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    annee?: boolean
    nature?: boolean
    surface_parcourue?: boolean
    surface_foret?: boolean
    surface_maquis_garrigues?: boolean
    autres_surfaces_naturelles_hors_foret?: boolean
    surfaces_agricoles?: boolean
    surfaces_non_boisees?: boolean
    surfaces_non_boisees_artificialisees?: boolean
    surfaces_non_boisees_naturelles?: boolean
    surface_autres_terres_boisees?: boolean
    autres_surfaces?: boolean
  }

  export type feux_foretOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"index" | "code_geographique" | "libelle_geographique" | "epci" | "libelle_epci" | "departement" | "libelle_departement" | "region" | "ept" | "libelle_petr" | "code_pnr" | "libelle_pnr" | "annee" | "nature" | "surface_parcourue" | "surface_foret" | "surface_maquis_garrigues" | "autres_surfaces_naturelles_hors_foret" | "surfaces_agricoles" | "surfaces_non_boisees" | "surfaces_non_boisees_artificialisees" | "surfaces_non_boisees_naturelles" | "surface_autres_terres_boisees" | "autres_surfaces", ExtArgs["result"]["feux_foret"]>

  export type $feux_foretPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "feux_foret"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      index: number
      code_geographique: string
      libelle_geographique: string
      epci: string
      libelle_epci: string
      departement: string
      libelle_departement: string
      region: number
      ept: string | null
      libelle_petr: string | null
      code_pnr: string | null
      libelle_pnr: string | null
      annee: number
      nature: string | null
      surface_parcourue: number
      surface_foret: number | null
      surface_maquis_garrigues: number | null
      autres_surfaces_naturelles_hors_foret: number | null
      surfaces_agricoles: number | null
      surfaces_non_boisees: number | null
      surfaces_non_boisees_artificialisees: number | null
      surfaces_non_boisees_naturelles: number | null
      surface_autres_terres_boisees: number | null
      autres_surfaces: number | null
    }, ExtArgs["result"]["feux_foret"]>
    composites: {}
  }

  type feux_foretGetPayload<S extends boolean | null | undefined | feux_foretDefaultArgs> = $Result.GetResult<Prisma.$feux_foretPayload, S>

  type feux_foretCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<feux_foretFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Feux_foretCountAggregateInputType | true
    }

  export interface feux_foretDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['feux_foret'], meta: { name: 'feux_foret' } }
    /**
     * Find zero or one Feux_foret that matches the filter.
     * @param {feux_foretFindUniqueArgs} args - Arguments to find a Feux_foret
     * @example
     * // Get one Feux_foret
     * const feux_foret = await prisma.feux_foret.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends feux_foretFindUniqueArgs>(args: SelectSubset<T, feux_foretFindUniqueArgs<ExtArgs>>): Prisma__feux_foretClient<$Result.GetResult<Prisma.$feux_foretPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Feux_foret that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {feux_foretFindUniqueOrThrowArgs} args - Arguments to find a Feux_foret
     * @example
     * // Get one Feux_foret
     * const feux_foret = await prisma.feux_foret.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends feux_foretFindUniqueOrThrowArgs>(args: SelectSubset<T, feux_foretFindUniqueOrThrowArgs<ExtArgs>>): Prisma__feux_foretClient<$Result.GetResult<Prisma.$feux_foretPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feux_foret that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feux_foretFindFirstArgs} args - Arguments to find a Feux_foret
     * @example
     * // Get one Feux_foret
     * const feux_foret = await prisma.feux_foret.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends feux_foretFindFirstArgs>(args?: SelectSubset<T, feux_foretFindFirstArgs<ExtArgs>>): Prisma__feux_foretClient<$Result.GetResult<Prisma.$feux_foretPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feux_foret that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feux_foretFindFirstOrThrowArgs} args - Arguments to find a Feux_foret
     * @example
     * // Get one Feux_foret
     * const feux_foret = await prisma.feux_foret.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends feux_foretFindFirstOrThrowArgs>(args?: SelectSubset<T, feux_foretFindFirstOrThrowArgs<ExtArgs>>): Prisma__feux_foretClient<$Result.GetResult<Prisma.$feux_foretPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Feux_forets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feux_foretFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Feux_forets
     * const feux_forets = await prisma.feux_foret.findMany()
     * 
     * // Get first 10 Feux_forets
     * const feux_forets = await prisma.feux_foret.findMany({ take: 10 })
     * 
     * // Only select the `index`
     * const feux_foretWithIndexOnly = await prisma.feux_foret.findMany({ select: { index: true } })
     * 
     */
    findMany<T extends feux_foretFindManyArgs>(args?: SelectSubset<T, feux_foretFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$feux_foretPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Feux_foret.
     * @param {feux_foretCreateArgs} args - Arguments to create a Feux_foret.
     * @example
     * // Create one Feux_foret
     * const Feux_foret = await prisma.feux_foret.create({
     *   data: {
     *     // ... data to create a Feux_foret
     *   }
     * })
     * 
     */
    create<T extends feux_foretCreateArgs>(args: SelectSubset<T, feux_foretCreateArgs<ExtArgs>>): Prisma__feux_foretClient<$Result.GetResult<Prisma.$feux_foretPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Feux_forets.
     * @param {feux_foretCreateManyArgs} args - Arguments to create many Feux_forets.
     * @example
     * // Create many Feux_forets
     * const feux_foret = await prisma.feux_foret.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends feux_foretCreateManyArgs>(args?: SelectSubset<T, feux_foretCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Feux_forets and returns the data saved in the database.
     * @param {feux_foretCreateManyAndReturnArgs} args - Arguments to create many Feux_forets.
     * @example
     * // Create many Feux_forets
     * const feux_foret = await prisma.feux_foret.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Feux_forets and only return the `index`
     * const feux_foretWithIndexOnly = await prisma.feux_foret.createManyAndReturn({
     *   select: { index: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends feux_foretCreateManyAndReturnArgs>(args?: SelectSubset<T, feux_foretCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$feux_foretPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Feux_foret.
     * @param {feux_foretDeleteArgs} args - Arguments to delete one Feux_foret.
     * @example
     * // Delete one Feux_foret
     * const Feux_foret = await prisma.feux_foret.delete({
     *   where: {
     *     // ... filter to delete one Feux_foret
     *   }
     * })
     * 
     */
    delete<T extends feux_foretDeleteArgs>(args: SelectSubset<T, feux_foretDeleteArgs<ExtArgs>>): Prisma__feux_foretClient<$Result.GetResult<Prisma.$feux_foretPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Feux_foret.
     * @param {feux_foretUpdateArgs} args - Arguments to update one Feux_foret.
     * @example
     * // Update one Feux_foret
     * const feux_foret = await prisma.feux_foret.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends feux_foretUpdateArgs>(args: SelectSubset<T, feux_foretUpdateArgs<ExtArgs>>): Prisma__feux_foretClient<$Result.GetResult<Prisma.$feux_foretPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Feux_forets.
     * @param {feux_foretDeleteManyArgs} args - Arguments to filter Feux_forets to delete.
     * @example
     * // Delete a few Feux_forets
     * const { count } = await prisma.feux_foret.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends feux_foretDeleteManyArgs>(args?: SelectSubset<T, feux_foretDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feux_forets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feux_foretUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Feux_forets
     * const feux_foret = await prisma.feux_foret.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends feux_foretUpdateManyArgs>(args: SelectSubset<T, feux_foretUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feux_forets and returns the data updated in the database.
     * @param {feux_foretUpdateManyAndReturnArgs} args - Arguments to update many Feux_forets.
     * @example
     * // Update many Feux_forets
     * const feux_foret = await prisma.feux_foret.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Feux_forets and only return the `index`
     * const feux_foretWithIndexOnly = await prisma.feux_foret.updateManyAndReturn({
     *   select: { index: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends feux_foretUpdateManyAndReturnArgs>(args: SelectSubset<T, feux_foretUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$feux_foretPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Feux_foret.
     * @param {feux_foretUpsertArgs} args - Arguments to update or create a Feux_foret.
     * @example
     * // Update or create a Feux_foret
     * const feux_foret = await prisma.feux_foret.upsert({
     *   create: {
     *     // ... data to create a Feux_foret
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feux_foret we want to update
     *   }
     * })
     */
    upsert<T extends feux_foretUpsertArgs>(args: SelectSubset<T, feux_foretUpsertArgs<ExtArgs>>): Prisma__feux_foretClient<$Result.GetResult<Prisma.$feux_foretPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Feux_forets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feux_foretCountArgs} args - Arguments to filter Feux_forets to count.
     * @example
     * // Count the number of Feux_forets
     * const count = await prisma.feux_foret.count({
     *   where: {
     *     // ... the filter for the Feux_forets we want to count
     *   }
     * })
    **/
    count<T extends feux_foretCountArgs>(
      args?: Subset<T, feux_foretCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Feux_foretCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feux_foret.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Feux_foretAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Feux_foretAggregateArgs>(args: Subset<T, Feux_foretAggregateArgs>): Prisma.PrismaPromise<GetFeux_foretAggregateType<T>>

    /**
     * Group by Feux_foret.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feux_foretGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends feux_foretGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: feux_foretGroupByArgs['orderBy'] }
        : { orderBy?: feux_foretGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, feux_foretGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeux_foretGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the feux_foret model
   */
  readonly fields: feux_foretFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for feux_foret.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__feux_foretClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the feux_foret model
   */
  interface feux_foretFieldRefs {
    readonly index: FieldRef<"feux_foret", 'Int'>
    readonly code_geographique: FieldRef<"feux_foret", 'String'>
    readonly libelle_geographique: FieldRef<"feux_foret", 'String'>
    readonly epci: FieldRef<"feux_foret", 'String'>
    readonly libelle_epci: FieldRef<"feux_foret", 'String'>
    readonly departement: FieldRef<"feux_foret", 'String'>
    readonly libelle_departement: FieldRef<"feux_foret", 'String'>
    readonly region: FieldRef<"feux_foret", 'Float'>
    readonly ept: FieldRef<"feux_foret", 'String'>
    readonly libelle_petr: FieldRef<"feux_foret", 'String'>
    readonly code_pnr: FieldRef<"feux_foret", 'String'>
    readonly libelle_pnr: FieldRef<"feux_foret", 'String'>
    readonly annee: FieldRef<"feux_foret", 'Float'>
    readonly nature: FieldRef<"feux_foret", 'String'>
    readonly surface_parcourue: FieldRef<"feux_foret", 'Float'>
    readonly surface_foret: FieldRef<"feux_foret", 'Float'>
    readonly surface_maquis_garrigues: FieldRef<"feux_foret", 'Float'>
    readonly autres_surfaces_naturelles_hors_foret: FieldRef<"feux_foret", 'Float'>
    readonly surfaces_agricoles: FieldRef<"feux_foret", 'Float'>
    readonly surfaces_non_boisees: FieldRef<"feux_foret", 'Float'>
    readonly surfaces_non_boisees_artificialisees: FieldRef<"feux_foret", 'Float'>
    readonly surfaces_non_boisees_naturelles: FieldRef<"feux_foret", 'Float'>
    readonly surface_autres_terres_boisees: FieldRef<"feux_foret", 'Float'>
    readonly autres_surfaces: FieldRef<"feux_foret", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * feux_foret findUnique
   */
  export type feux_foretFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feux_foret
     */
    select?: feux_foretSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feux_foret
     */
    omit?: feux_foretOmit<ExtArgs> | null
    /**
     * Filter, which feux_foret to fetch.
     */
    where: feux_foretWhereUniqueInput
  }

  /**
   * feux_foret findUniqueOrThrow
   */
  export type feux_foretFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feux_foret
     */
    select?: feux_foretSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feux_foret
     */
    omit?: feux_foretOmit<ExtArgs> | null
    /**
     * Filter, which feux_foret to fetch.
     */
    where: feux_foretWhereUniqueInput
  }

  /**
   * feux_foret findFirst
   */
  export type feux_foretFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feux_foret
     */
    select?: feux_foretSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feux_foret
     */
    omit?: feux_foretOmit<ExtArgs> | null
    /**
     * Filter, which feux_foret to fetch.
     */
    where?: feux_foretWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feux_forets to fetch.
     */
    orderBy?: feux_foretOrderByWithRelationInput | feux_foretOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for feux_forets.
     */
    cursor?: feux_foretWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feux_forets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feux_forets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of feux_forets.
     */
    distinct?: Feux_foretScalarFieldEnum | Feux_foretScalarFieldEnum[]
  }

  /**
   * feux_foret findFirstOrThrow
   */
  export type feux_foretFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feux_foret
     */
    select?: feux_foretSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feux_foret
     */
    omit?: feux_foretOmit<ExtArgs> | null
    /**
     * Filter, which feux_foret to fetch.
     */
    where?: feux_foretWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feux_forets to fetch.
     */
    orderBy?: feux_foretOrderByWithRelationInput | feux_foretOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for feux_forets.
     */
    cursor?: feux_foretWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feux_forets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feux_forets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of feux_forets.
     */
    distinct?: Feux_foretScalarFieldEnum | Feux_foretScalarFieldEnum[]
  }

  /**
   * feux_foret findMany
   */
  export type feux_foretFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feux_foret
     */
    select?: feux_foretSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feux_foret
     */
    omit?: feux_foretOmit<ExtArgs> | null
    /**
     * Filter, which feux_forets to fetch.
     */
    where?: feux_foretWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feux_forets to fetch.
     */
    orderBy?: feux_foretOrderByWithRelationInput | feux_foretOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing feux_forets.
     */
    cursor?: feux_foretWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feux_forets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feux_forets.
     */
    skip?: number
    distinct?: Feux_foretScalarFieldEnum | Feux_foretScalarFieldEnum[]
  }

  /**
   * feux_foret create
   */
  export type feux_foretCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feux_foret
     */
    select?: feux_foretSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feux_foret
     */
    omit?: feux_foretOmit<ExtArgs> | null
    /**
     * The data needed to create a feux_foret.
     */
    data: XOR<feux_foretCreateInput, feux_foretUncheckedCreateInput>
  }

  /**
   * feux_foret createMany
   */
  export type feux_foretCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many feux_forets.
     */
    data: feux_foretCreateManyInput | feux_foretCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * feux_foret createManyAndReturn
   */
  export type feux_foretCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feux_foret
     */
    select?: feux_foretSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the feux_foret
     */
    omit?: feux_foretOmit<ExtArgs> | null
    /**
     * The data used to create many feux_forets.
     */
    data: feux_foretCreateManyInput | feux_foretCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * feux_foret update
   */
  export type feux_foretUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feux_foret
     */
    select?: feux_foretSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feux_foret
     */
    omit?: feux_foretOmit<ExtArgs> | null
    /**
     * The data needed to update a feux_foret.
     */
    data: XOR<feux_foretUpdateInput, feux_foretUncheckedUpdateInput>
    /**
     * Choose, which feux_foret to update.
     */
    where: feux_foretWhereUniqueInput
  }

  /**
   * feux_foret updateMany
   */
  export type feux_foretUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update feux_forets.
     */
    data: XOR<feux_foretUpdateManyMutationInput, feux_foretUncheckedUpdateManyInput>
    /**
     * Filter which feux_forets to update
     */
    where?: feux_foretWhereInput
    /**
     * Limit how many feux_forets to update.
     */
    limit?: number
  }

  /**
   * feux_foret updateManyAndReturn
   */
  export type feux_foretUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feux_foret
     */
    select?: feux_foretSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the feux_foret
     */
    omit?: feux_foretOmit<ExtArgs> | null
    /**
     * The data used to update feux_forets.
     */
    data: XOR<feux_foretUpdateManyMutationInput, feux_foretUncheckedUpdateManyInput>
    /**
     * Filter which feux_forets to update
     */
    where?: feux_foretWhereInput
    /**
     * Limit how many feux_forets to update.
     */
    limit?: number
  }

  /**
   * feux_foret upsert
   */
  export type feux_foretUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feux_foret
     */
    select?: feux_foretSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feux_foret
     */
    omit?: feux_foretOmit<ExtArgs> | null
    /**
     * The filter to search for the feux_foret to update in case it exists.
     */
    where: feux_foretWhereUniqueInput
    /**
     * In case the feux_foret found by the `where` argument doesn't exist, create a new feux_foret with this data.
     */
    create: XOR<feux_foretCreateInput, feux_foretUncheckedCreateInput>
    /**
     * In case the feux_foret was found with the provided `where` argument, update it with this data.
     */
    update: XOR<feux_foretUpdateInput, feux_foretUncheckedUpdateInput>
  }

  /**
   * feux_foret delete
   */
  export type feux_foretDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feux_foret
     */
    select?: feux_foretSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feux_foret
     */
    omit?: feux_foretOmit<ExtArgs> | null
    /**
     * Filter which feux_foret to delete.
     */
    where: feux_foretWhereUniqueInput
  }

  /**
   * feux_foret deleteMany
   */
  export type feux_foretDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which feux_forets to delete
     */
    where?: feux_foretWhereInput
    /**
     * Limit how many feux_forets to delete.
     */
    limit?: number
  }

  /**
   * feux_foret without action
   */
  export type feux_foretDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feux_foret
     */
    select?: feux_foretSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feux_foret
     */
    omit?: feux_foretOmit<ExtArgs> | null
  }


  /**
   * Model lcz_couverture
   */

  export type AggregateLcz_couverture = {
    _count: Lcz_couvertureCountAggregateOutputType | null
    _avg: Lcz_couvertureAvgAggregateOutputType | null
    _sum: Lcz_couvertureSumAggregateOutputType | null
    _min: Lcz_couvertureMinAggregateOutputType | null
    _max: Lcz_couvertureMaxAggregateOutputType | null
  }

  export type Lcz_couvertureAvgAggregateOutputType = {
    index: number | null
    region: number | null
    couverture_lcz: number | null
  }

  export type Lcz_couvertureSumAggregateOutputType = {
    index: number | null
    region: number | null
    couverture_lcz: number | null
  }

  export type Lcz_couvertureMinAggregateOutputType = {
    index: number | null
    code_geographique: string | null
    libelle_geographique: string | null
    epci: string | null
    libelle_epci: string | null
    departement: string | null
    libelle_departement: string | null
    region: number | null
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
    couverture_lcz: number | null
  }

  export type Lcz_couvertureMaxAggregateOutputType = {
    index: number | null
    code_geographique: string | null
    libelle_geographique: string | null
    epci: string | null
    libelle_epci: string | null
    departement: string | null
    libelle_departement: string | null
    region: number | null
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
    couverture_lcz: number | null
  }

  export type Lcz_couvertureCountAggregateOutputType = {
    index: number
    code_geographique: number
    libelle_geographique: number
    epci: number
    libelle_epci: number
    departement: number
    libelle_departement: number
    region: number
    ept: number
    libelle_petr: number
    code_pnr: number
    libelle_pnr: number
    couverture_lcz: number
    _all: number
  }


  export type Lcz_couvertureAvgAggregateInputType = {
    index?: true
    region?: true
    couverture_lcz?: true
  }

  export type Lcz_couvertureSumAggregateInputType = {
    index?: true
    region?: true
    couverture_lcz?: true
  }

  export type Lcz_couvertureMinAggregateInputType = {
    index?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
    couverture_lcz?: true
  }

  export type Lcz_couvertureMaxAggregateInputType = {
    index?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
    couverture_lcz?: true
  }

  export type Lcz_couvertureCountAggregateInputType = {
    index?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
    couverture_lcz?: true
    _all?: true
  }

  export type Lcz_couvertureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lcz_couverture to aggregate.
     */
    where?: lcz_couvertureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lcz_couvertures to fetch.
     */
    orderBy?: lcz_couvertureOrderByWithRelationInput | lcz_couvertureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: lcz_couvertureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lcz_couvertures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lcz_couvertures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned lcz_couvertures
    **/
    _count?: true | Lcz_couvertureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Lcz_couvertureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Lcz_couvertureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Lcz_couvertureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Lcz_couvertureMaxAggregateInputType
  }

  export type GetLcz_couvertureAggregateType<T extends Lcz_couvertureAggregateArgs> = {
        [P in keyof T & keyof AggregateLcz_couverture]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLcz_couverture[P]>
      : GetScalarType<T[P], AggregateLcz_couverture[P]>
  }




  export type lcz_couvertureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: lcz_couvertureWhereInput
    orderBy?: lcz_couvertureOrderByWithAggregationInput | lcz_couvertureOrderByWithAggregationInput[]
    by: Lcz_couvertureScalarFieldEnum[] | Lcz_couvertureScalarFieldEnum
    having?: lcz_couvertureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Lcz_couvertureCountAggregateInputType | true
    _avg?: Lcz_couvertureAvgAggregateInputType
    _sum?: Lcz_couvertureSumAggregateInputType
    _min?: Lcz_couvertureMinAggregateInputType
    _max?: Lcz_couvertureMaxAggregateInputType
  }

  export type Lcz_couvertureGroupByOutputType = {
    index: number
    code_geographique: string
    libelle_geographique: string | null
    epci: string | null
    libelle_epci: string | null
    departement: string | null
    libelle_departement: string | null
    region: number | null
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
    couverture_lcz: number
    _count: Lcz_couvertureCountAggregateOutputType | null
    _avg: Lcz_couvertureAvgAggregateOutputType | null
    _sum: Lcz_couvertureSumAggregateOutputType | null
    _min: Lcz_couvertureMinAggregateOutputType | null
    _max: Lcz_couvertureMaxAggregateOutputType | null
  }

  type GetLcz_couvertureGroupByPayload<T extends lcz_couvertureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Lcz_couvertureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Lcz_couvertureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Lcz_couvertureGroupByOutputType[P]>
            : GetScalarType<T[P], Lcz_couvertureGroupByOutputType[P]>
        }
      >
    >


  export type lcz_couvertureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    couverture_lcz?: boolean
  }, ExtArgs["result"]["lcz_couverture"]>

  export type lcz_couvertureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    couverture_lcz?: boolean
  }, ExtArgs["result"]["lcz_couverture"]>

  export type lcz_couvertureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    couverture_lcz?: boolean
  }, ExtArgs["result"]["lcz_couverture"]>

  export type lcz_couvertureSelectScalar = {
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    couverture_lcz?: boolean
  }

  export type lcz_couvertureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"index" | "code_geographique" | "libelle_geographique" | "epci" | "libelle_epci" | "departement" | "libelle_departement" | "region" | "ept" | "libelle_petr" | "code_pnr" | "libelle_pnr" | "couverture_lcz", ExtArgs["result"]["lcz_couverture"]>

  export type $lcz_couverturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "lcz_couverture"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      index: number
      code_geographique: string
      libelle_geographique: string | null
      epci: string | null
      libelle_epci: string | null
      departement: string | null
      libelle_departement: string | null
      region: number | null
      ept: string | null
      libelle_petr: string | null
      code_pnr: string | null
      libelle_pnr: string | null
      couverture_lcz: number
    }, ExtArgs["result"]["lcz_couverture"]>
    composites: {}
  }

  type lcz_couvertureGetPayload<S extends boolean | null | undefined | lcz_couvertureDefaultArgs> = $Result.GetResult<Prisma.$lcz_couverturePayload, S>

  type lcz_couvertureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<lcz_couvertureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Lcz_couvertureCountAggregateInputType | true
    }

  export interface lcz_couvertureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['lcz_couverture'], meta: { name: 'lcz_couverture' } }
    /**
     * Find zero or one Lcz_couverture that matches the filter.
     * @param {lcz_couvertureFindUniqueArgs} args - Arguments to find a Lcz_couverture
     * @example
     * // Get one Lcz_couverture
     * const lcz_couverture = await prisma.lcz_couverture.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends lcz_couvertureFindUniqueArgs>(args: SelectSubset<T, lcz_couvertureFindUniqueArgs<ExtArgs>>): Prisma__lcz_couvertureClient<$Result.GetResult<Prisma.$lcz_couverturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lcz_couverture that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {lcz_couvertureFindUniqueOrThrowArgs} args - Arguments to find a Lcz_couverture
     * @example
     * // Get one Lcz_couverture
     * const lcz_couverture = await prisma.lcz_couverture.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends lcz_couvertureFindUniqueOrThrowArgs>(args: SelectSubset<T, lcz_couvertureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__lcz_couvertureClient<$Result.GetResult<Prisma.$lcz_couverturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lcz_couverture that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lcz_couvertureFindFirstArgs} args - Arguments to find a Lcz_couverture
     * @example
     * // Get one Lcz_couverture
     * const lcz_couverture = await prisma.lcz_couverture.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends lcz_couvertureFindFirstArgs>(args?: SelectSubset<T, lcz_couvertureFindFirstArgs<ExtArgs>>): Prisma__lcz_couvertureClient<$Result.GetResult<Prisma.$lcz_couverturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lcz_couverture that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lcz_couvertureFindFirstOrThrowArgs} args - Arguments to find a Lcz_couverture
     * @example
     * // Get one Lcz_couverture
     * const lcz_couverture = await prisma.lcz_couverture.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends lcz_couvertureFindFirstOrThrowArgs>(args?: SelectSubset<T, lcz_couvertureFindFirstOrThrowArgs<ExtArgs>>): Prisma__lcz_couvertureClient<$Result.GetResult<Prisma.$lcz_couverturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lcz_couvertures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lcz_couvertureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lcz_couvertures
     * const lcz_couvertures = await prisma.lcz_couverture.findMany()
     * 
     * // Get first 10 Lcz_couvertures
     * const lcz_couvertures = await prisma.lcz_couverture.findMany({ take: 10 })
     * 
     * // Only select the `index`
     * const lcz_couvertureWithIndexOnly = await prisma.lcz_couverture.findMany({ select: { index: true } })
     * 
     */
    findMany<T extends lcz_couvertureFindManyArgs>(args?: SelectSubset<T, lcz_couvertureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lcz_couverturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lcz_couverture.
     * @param {lcz_couvertureCreateArgs} args - Arguments to create a Lcz_couverture.
     * @example
     * // Create one Lcz_couverture
     * const Lcz_couverture = await prisma.lcz_couverture.create({
     *   data: {
     *     // ... data to create a Lcz_couverture
     *   }
     * })
     * 
     */
    create<T extends lcz_couvertureCreateArgs>(args: SelectSubset<T, lcz_couvertureCreateArgs<ExtArgs>>): Prisma__lcz_couvertureClient<$Result.GetResult<Prisma.$lcz_couverturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lcz_couvertures.
     * @param {lcz_couvertureCreateManyArgs} args - Arguments to create many Lcz_couvertures.
     * @example
     * // Create many Lcz_couvertures
     * const lcz_couverture = await prisma.lcz_couverture.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends lcz_couvertureCreateManyArgs>(args?: SelectSubset<T, lcz_couvertureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lcz_couvertures and returns the data saved in the database.
     * @param {lcz_couvertureCreateManyAndReturnArgs} args - Arguments to create many Lcz_couvertures.
     * @example
     * // Create many Lcz_couvertures
     * const lcz_couverture = await prisma.lcz_couverture.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lcz_couvertures and only return the `index`
     * const lcz_couvertureWithIndexOnly = await prisma.lcz_couverture.createManyAndReturn({
     *   select: { index: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends lcz_couvertureCreateManyAndReturnArgs>(args?: SelectSubset<T, lcz_couvertureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lcz_couverturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lcz_couverture.
     * @param {lcz_couvertureDeleteArgs} args - Arguments to delete one Lcz_couverture.
     * @example
     * // Delete one Lcz_couverture
     * const Lcz_couverture = await prisma.lcz_couverture.delete({
     *   where: {
     *     // ... filter to delete one Lcz_couverture
     *   }
     * })
     * 
     */
    delete<T extends lcz_couvertureDeleteArgs>(args: SelectSubset<T, lcz_couvertureDeleteArgs<ExtArgs>>): Prisma__lcz_couvertureClient<$Result.GetResult<Prisma.$lcz_couverturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lcz_couverture.
     * @param {lcz_couvertureUpdateArgs} args - Arguments to update one Lcz_couverture.
     * @example
     * // Update one Lcz_couverture
     * const lcz_couverture = await prisma.lcz_couverture.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends lcz_couvertureUpdateArgs>(args: SelectSubset<T, lcz_couvertureUpdateArgs<ExtArgs>>): Prisma__lcz_couvertureClient<$Result.GetResult<Prisma.$lcz_couverturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lcz_couvertures.
     * @param {lcz_couvertureDeleteManyArgs} args - Arguments to filter Lcz_couvertures to delete.
     * @example
     * // Delete a few Lcz_couvertures
     * const { count } = await prisma.lcz_couverture.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends lcz_couvertureDeleteManyArgs>(args?: SelectSubset<T, lcz_couvertureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lcz_couvertures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lcz_couvertureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lcz_couvertures
     * const lcz_couverture = await prisma.lcz_couverture.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends lcz_couvertureUpdateManyArgs>(args: SelectSubset<T, lcz_couvertureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lcz_couvertures and returns the data updated in the database.
     * @param {lcz_couvertureUpdateManyAndReturnArgs} args - Arguments to update many Lcz_couvertures.
     * @example
     * // Update many Lcz_couvertures
     * const lcz_couverture = await prisma.lcz_couverture.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Lcz_couvertures and only return the `index`
     * const lcz_couvertureWithIndexOnly = await prisma.lcz_couverture.updateManyAndReturn({
     *   select: { index: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends lcz_couvertureUpdateManyAndReturnArgs>(args: SelectSubset<T, lcz_couvertureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lcz_couverturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lcz_couverture.
     * @param {lcz_couvertureUpsertArgs} args - Arguments to update or create a Lcz_couverture.
     * @example
     * // Update or create a Lcz_couverture
     * const lcz_couverture = await prisma.lcz_couverture.upsert({
     *   create: {
     *     // ... data to create a Lcz_couverture
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lcz_couverture we want to update
     *   }
     * })
     */
    upsert<T extends lcz_couvertureUpsertArgs>(args: SelectSubset<T, lcz_couvertureUpsertArgs<ExtArgs>>): Prisma__lcz_couvertureClient<$Result.GetResult<Prisma.$lcz_couverturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lcz_couvertures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lcz_couvertureCountArgs} args - Arguments to filter Lcz_couvertures to count.
     * @example
     * // Count the number of Lcz_couvertures
     * const count = await prisma.lcz_couverture.count({
     *   where: {
     *     // ... the filter for the Lcz_couvertures we want to count
     *   }
     * })
    **/
    count<T extends lcz_couvertureCountArgs>(
      args?: Subset<T, lcz_couvertureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Lcz_couvertureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lcz_couverture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Lcz_couvertureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Lcz_couvertureAggregateArgs>(args: Subset<T, Lcz_couvertureAggregateArgs>): Prisma.PrismaPromise<GetLcz_couvertureAggregateType<T>>

    /**
     * Group by Lcz_couverture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lcz_couvertureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends lcz_couvertureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: lcz_couvertureGroupByArgs['orderBy'] }
        : { orderBy?: lcz_couvertureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, lcz_couvertureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLcz_couvertureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the lcz_couverture model
   */
  readonly fields: lcz_couvertureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for lcz_couverture.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__lcz_couvertureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the lcz_couverture model
   */
  interface lcz_couvertureFieldRefs {
    readonly index: FieldRef<"lcz_couverture", 'Int'>
    readonly code_geographique: FieldRef<"lcz_couverture", 'String'>
    readonly libelle_geographique: FieldRef<"lcz_couverture", 'String'>
    readonly epci: FieldRef<"lcz_couverture", 'String'>
    readonly libelle_epci: FieldRef<"lcz_couverture", 'String'>
    readonly departement: FieldRef<"lcz_couverture", 'String'>
    readonly libelle_departement: FieldRef<"lcz_couverture", 'String'>
    readonly region: FieldRef<"lcz_couverture", 'Float'>
    readonly ept: FieldRef<"lcz_couverture", 'String'>
    readonly libelle_petr: FieldRef<"lcz_couverture", 'String'>
    readonly code_pnr: FieldRef<"lcz_couverture", 'String'>
    readonly libelle_pnr: FieldRef<"lcz_couverture", 'String'>
    readonly couverture_lcz: FieldRef<"lcz_couverture", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * lcz_couverture findUnique
   */
  export type lcz_couvertureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lcz_couverture
     */
    select?: lcz_couvertureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lcz_couverture
     */
    omit?: lcz_couvertureOmit<ExtArgs> | null
    /**
     * Filter, which lcz_couverture to fetch.
     */
    where: lcz_couvertureWhereUniqueInput
  }

  /**
   * lcz_couverture findUniqueOrThrow
   */
  export type lcz_couvertureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lcz_couverture
     */
    select?: lcz_couvertureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lcz_couverture
     */
    omit?: lcz_couvertureOmit<ExtArgs> | null
    /**
     * Filter, which lcz_couverture to fetch.
     */
    where: lcz_couvertureWhereUniqueInput
  }

  /**
   * lcz_couverture findFirst
   */
  export type lcz_couvertureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lcz_couverture
     */
    select?: lcz_couvertureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lcz_couverture
     */
    omit?: lcz_couvertureOmit<ExtArgs> | null
    /**
     * Filter, which lcz_couverture to fetch.
     */
    where?: lcz_couvertureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lcz_couvertures to fetch.
     */
    orderBy?: lcz_couvertureOrderByWithRelationInput | lcz_couvertureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lcz_couvertures.
     */
    cursor?: lcz_couvertureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lcz_couvertures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lcz_couvertures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lcz_couvertures.
     */
    distinct?: Lcz_couvertureScalarFieldEnum | Lcz_couvertureScalarFieldEnum[]
  }

  /**
   * lcz_couverture findFirstOrThrow
   */
  export type lcz_couvertureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lcz_couverture
     */
    select?: lcz_couvertureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lcz_couverture
     */
    omit?: lcz_couvertureOmit<ExtArgs> | null
    /**
     * Filter, which lcz_couverture to fetch.
     */
    where?: lcz_couvertureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lcz_couvertures to fetch.
     */
    orderBy?: lcz_couvertureOrderByWithRelationInput | lcz_couvertureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lcz_couvertures.
     */
    cursor?: lcz_couvertureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lcz_couvertures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lcz_couvertures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lcz_couvertures.
     */
    distinct?: Lcz_couvertureScalarFieldEnum | Lcz_couvertureScalarFieldEnum[]
  }

  /**
   * lcz_couverture findMany
   */
  export type lcz_couvertureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lcz_couverture
     */
    select?: lcz_couvertureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lcz_couverture
     */
    omit?: lcz_couvertureOmit<ExtArgs> | null
    /**
     * Filter, which lcz_couvertures to fetch.
     */
    where?: lcz_couvertureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lcz_couvertures to fetch.
     */
    orderBy?: lcz_couvertureOrderByWithRelationInput | lcz_couvertureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing lcz_couvertures.
     */
    cursor?: lcz_couvertureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lcz_couvertures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lcz_couvertures.
     */
    skip?: number
    distinct?: Lcz_couvertureScalarFieldEnum | Lcz_couvertureScalarFieldEnum[]
  }

  /**
   * lcz_couverture create
   */
  export type lcz_couvertureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lcz_couverture
     */
    select?: lcz_couvertureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lcz_couverture
     */
    omit?: lcz_couvertureOmit<ExtArgs> | null
    /**
     * The data needed to create a lcz_couverture.
     */
    data: XOR<lcz_couvertureCreateInput, lcz_couvertureUncheckedCreateInput>
  }

  /**
   * lcz_couverture createMany
   */
  export type lcz_couvertureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many lcz_couvertures.
     */
    data: lcz_couvertureCreateManyInput | lcz_couvertureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * lcz_couverture createManyAndReturn
   */
  export type lcz_couvertureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lcz_couverture
     */
    select?: lcz_couvertureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the lcz_couverture
     */
    omit?: lcz_couvertureOmit<ExtArgs> | null
    /**
     * The data used to create many lcz_couvertures.
     */
    data: lcz_couvertureCreateManyInput | lcz_couvertureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * lcz_couverture update
   */
  export type lcz_couvertureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lcz_couverture
     */
    select?: lcz_couvertureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lcz_couverture
     */
    omit?: lcz_couvertureOmit<ExtArgs> | null
    /**
     * The data needed to update a lcz_couverture.
     */
    data: XOR<lcz_couvertureUpdateInput, lcz_couvertureUncheckedUpdateInput>
    /**
     * Choose, which lcz_couverture to update.
     */
    where: lcz_couvertureWhereUniqueInput
  }

  /**
   * lcz_couverture updateMany
   */
  export type lcz_couvertureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update lcz_couvertures.
     */
    data: XOR<lcz_couvertureUpdateManyMutationInput, lcz_couvertureUncheckedUpdateManyInput>
    /**
     * Filter which lcz_couvertures to update
     */
    where?: lcz_couvertureWhereInput
    /**
     * Limit how many lcz_couvertures to update.
     */
    limit?: number
  }

  /**
   * lcz_couverture updateManyAndReturn
   */
  export type lcz_couvertureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lcz_couverture
     */
    select?: lcz_couvertureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the lcz_couverture
     */
    omit?: lcz_couvertureOmit<ExtArgs> | null
    /**
     * The data used to update lcz_couvertures.
     */
    data: XOR<lcz_couvertureUpdateManyMutationInput, lcz_couvertureUncheckedUpdateManyInput>
    /**
     * Filter which lcz_couvertures to update
     */
    where?: lcz_couvertureWhereInput
    /**
     * Limit how many lcz_couvertures to update.
     */
    limit?: number
  }

  /**
   * lcz_couverture upsert
   */
  export type lcz_couvertureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lcz_couverture
     */
    select?: lcz_couvertureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lcz_couverture
     */
    omit?: lcz_couvertureOmit<ExtArgs> | null
    /**
     * The filter to search for the lcz_couverture to update in case it exists.
     */
    where: lcz_couvertureWhereUniqueInput
    /**
     * In case the lcz_couverture found by the `where` argument doesn't exist, create a new lcz_couverture with this data.
     */
    create: XOR<lcz_couvertureCreateInput, lcz_couvertureUncheckedCreateInput>
    /**
     * In case the lcz_couverture was found with the provided `where` argument, update it with this data.
     */
    update: XOR<lcz_couvertureUpdateInput, lcz_couvertureUncheckedUpdateInput>
  }

  /**
   * lcz_couverture delete
   */
  export type lcz_couvertureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lcz_couverture
     */
    select?: lcz_couvertureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lcz_couverture
     */
    omit?: lcz_couvertureOmit<ExtArgs> | null
    /**
     * Filter which lcz_couverture to delete.
     */
    where: lcz_couvertureWhereUniqueInput
  }

  /**
   * lcz_couverture deleteMany
   */
  export type lcz_couvertureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lcz_couvertures to delete
     */
    where?: lcz_couvertureWhereInput
    /**
     * Limit how many lcz_couvertures to delete.
     */
    limit?: number
  }

  /**
   * lcz_couverture without action
   */
  export type lcz_couvertureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lcz_couverture
     */
    select?: lcz_couvertureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the lcz_couverture
     */
    omit?: lcz_couvertureOmit<ExtArgs> | null
  }


  /**
   * Model patch4c
   */

  export type AggregatePatch4c = {
    _count: Patch4cCountAggregateOutputType | null
    _avg: Patch4cAvgAggregateOutputType | null
    _sum: Patch4cSumAggregateOutputType | null
    _min: Patch4cMinAggregateOutputType | null
    _max: Patch4cMaxAggregateOutputType | null
  }

  export type Patch4cAvgAggregateOutputType = {
    index: number | null
    niveaux_marins: number | null
    feux_foret: number | null
    secheresse_sols: number | null
    fortes_precipitations: number | null
    fortes_chaleurs: number | null
  }

  export type Patch4cSumAggregateOutputType = {
    index: number | null
    niveaux_marins: number | null
    feux_foret: number | null
    secheresse_sols: number | null
    fortes_precipitations: number | null
    fortes_chaleurs: number | null
  }

  export type Patch4cMinAggregateOutputType = {
    index: number | null
    code_geographique: string | null
    niveaux_marins: number | null
    feux_foret: number | null
    secheresse_sols: number | null
    fortes_precipitations: number | null
    fortes_chaleurs: number | null
  }

  export type Patch4cMaxAggregateOutputType = {
    index: number | null
    code_geographique: string | null
    niveaux_marins: number | null
    feux_foret: number | null
    secheresse_sols: number | null
    fortes_precipitations: number | null
    fortes_chaleurs: number | null
  }

  export type Patch4cCountAggregateOutputType = {
    index: number
    code_geographique: number
    niveaux_marins: number
    feux_foret: number
    secheresse_sols: number
    fortes_precipitations: number
    fortes_chaleurs: number
    _all: number
  }


  export type Patch4cAvgAggregateInputType = {
    index?: true
    niveaux_marins?: true
    feux_foret?: true
    secheresse_sols?: true
    fortes_precipitations?: true
    fortes_chaleurs?: true
  }

  export type Patch4cSumAggregateInputType = {
    index?: true
    niveaux_marins?: true
    feux_foret?: true
    secheresse_sols?: true
    fortes_precipitations?: true
    fortes_chaleurs?: true
  }

  export type Patch4cMinAggregateInputType = {
    index?: true
    code_geographique?: true
    niveaux_marins?: true
    feux_foret?: true
    secheresse_sols?: true
    fortes_precipitations?: true
    fortes_chaleurs?: true
  }

  export type Patch4cMaxAggregateInputType = {
    index?: true
    code_geographique?: true
    niveaux_marins?: true
    feux_foret?: true
    secheresse_sols?: true
    fortes_precipitations?: true
    fortes_chaleurs?: true
  }

  export type Patch4cCountAggregateInputType = {
    index?: true
    code_geographique?: true
    niveaux_marins?: true
    feux_foret?: true
    secheresse_sols?: true
    fortes_precipitations?: true
    fortes_chaleurs?: true
    _all?: true
  }

  export type Patch4cAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which patch4c to aggregate.
     */
    where?: patch4cWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patch4cs to fetch.
     */
    orderBy?: patch4cOrderByWithRelationInput | patch4cOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: patch4cWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patch4cs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patch4cs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned patch4cs
    **/
    _count?: true | Patch4cCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Patch4cAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Patch4cSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Patch4cMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Patch4cMaxAggregateInputType
  }

  export type GetPatch4cAggregateType<T extends Patch4cAggregateArgs> = {
        [P in keyof T & keyof AggregatePatch4c]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatch4c[P]>
      : GetScalarType<T[P], AggregatePatch4c[P]>
  }




  export type patch4cGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: patch4cWhereInput
    orderBy?: patch4cOrderByWithAggregationInput | patch4cOrderByWithAggregationInput[]
    by: Patch4cScalarFieldEnum[] | Patch4cScalarFieldEnum
    having?: patch4cScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Patch4cCountAggregateInputType | true
    _avg?: Patch4cAvgAggregateInputType
    _sum?: Patch4cSumAggregateInputType
    _min?: Patch4cMinAggregateInputType
    _max?: Patch4cMaxAggregateInputType
  }

  export type Patch4cGroupByOutputType = {
    index: number
    code_geographique: string
    niveaux_marins: number | null
    feux_foret: number
    secheresse_sols: number
    fortes_precipitations: number
    fortes_chaleurs: number
    _count: Patch4cCountAggregateOutputType | null
    _avg: Patch4cAvgAggregateOutputType | null
    _sum: Patch4cSumAggregateOutputType | null
    _min: Patch4cMinAggregateOutputType | null
    _max: Patch4cMaxAggregateOutputType | null
  }

  type GetPatch4cGroupByPayload<T extends patch4cGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Patch4cGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Patch4cGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Patch4cGroupByOutputType[P]>
            : GetScalarType<T[P], Patch4cGroupByOutputType[P]>
        }
      >
    >


  export type patch4cSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    niveaux_marins?: boolean
    feux_foret?: boolean
    secheresse_sols?: boolean
    fortes_precipitations?: boolean
    fortes_chaleurs?: boolean
  }, ExtArgs["result"]["patch4c"]>

  export type patch4cSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    niveaux_marins?: boolean
    feux_foret?: boolean
    secheresse_sols?: boolean
    fortes_precipitations?: boolean
    fortes_chaleurs?: boolean
  }, ExtArgs["result"]["patch4c"]>

  export type patch4cSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    niveaux_marins?: boolean
    feux_foret?: boolean
    secheresse_sols?: boolean
    fortes_precipitations?: boolean
    fortes_chaleurs?: boolean
  }, ExtArgs["result"]["patch4c"]>

  export type patch4cSelectScalar = {
    index?: boolean
    code_geographique?: boolean
    niveaux_marins?: boolean
    feux_foret?: boolean
    secheresse_sols?: boolean
    fortes_precipitations?: boolean
    fortes_chaleurs?: boolean
  }

  export type patch4cOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"index" | "code_geographique" | "niveaux_marins" | "feux_foret" | "secheresse_sols" | "fortes_precipitations" | "fortes_chaleurs", ExtArgs["result"]["patch4c"]>

  export type $patch4cPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "patch4c"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      index: number
      code_geographique: string
      niveaux_marins: number | null
      feux_foret: number
      secheresse_sols: number
      fortes_precipitations: number
      fortes_chaleurs: number
    }, ExtArgs["result"]["patch4c"]>
    composites: {}
  }

  type patch4cGetPayload<S extends boolean | null | undefined | patch4cDefaultArgs> = $Result.GetResult<Prisma.$patch4cPayload, S>

  type patch4cCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<patch4cFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Patch4cCountAggregateInputType | true
    }

  export interface patch4cDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['patch4c'], meta: { name: 'patch4c' } }
    /**
     * Find zero or one Patch4c that matches the filter.
     * @param {patch4cFindUniqueArgs} args - Arguments to find a Patch4c
     * @example
     * // Get one Patch4c
     * const patch4c = await prisma.patch4c.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends patch4cFindUniqueArgs>(args: SelectSubset<T, patch4cFindUniqueArgs<ExtArgs>>): Prisma__patch4cClient<$Result.GetResult<Prisma.$patch4cPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Patch4c that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {patch4cFindUniqueOrThrowArgs} args - Arguments to find a Patch4c
     * @example
     * // Get one Patch4c
     * const patch4c = await prisma.patch4c.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends patch4cFindUniqueOrThrowArgs>(args: SelectSubset<T, patch4cFindUniqueOrThrowArgs<ExtArgs>>): Prisma__patch4cClient<$Result.GetResult<Prisma.$patch4cPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patch4c that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patch4cFindFirstArgs} args - Arguments to find a Patch4c
     * @example
     * // Get one Patch4c
     * const patch4c = await prisma.patch4c.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends patch4cFindFirstArgs>(args?: SelectSubset<T, patch4cFindFirstArgs<ExtArgs>>): Prisma__patch4cClient<$Result.GetResult<Prisma.$patch4cPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patch4c that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patch4cFindFirstOrThrowArgs} args - Arguments to find a Patch4c
     * @example
     * // Get one Patch4c
     * const patch4c = await prisma.patch4c.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends patch4cFindFirstOrThrowArgs>(args?: SelectSubset<T, patch4cFindFirstOrThrowArgs<ExtArgs>>): Prisma__patch4cClient<$Result.GetResult<Prisma.$patch4cPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Patch4cs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patch4cFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patch4cs
     * const patch4cs = await prisma.patch4c.findMany()
     * 
     * // Get first 10 Patch4cs
     * const patch4cs = await prisma.patch4c.findMany({ take: 10 })
     * 
     * // Only select the `index`
     * const patch4cWithIndexOnly = await prisma.patch4c.findMany({ select: { index: true } })
     * 
     */
    findMany<T extends patch4cFindManyArgs>(args?: SelectSubset<T, patch4cFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$patch4cPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Patch4c.
     * @param {patch4cCreateArgs} args - Arguments to create a Patch4c.
     * @example
     * // Create one Patch4c
     * const Patch4c = await prisma.patch4c.create({
     *   data: {
     *     // ... data to create a Patch4c
     *   }
     * })
     * 
     */
    create<T extends patch4cCreateArgs>(args: SelectSubset<T, patch4cCreateArgs<ExtArgs>>): Prisma__patch4cClient<$Result.GetResult<Prisma.$patch4cPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Patch4cs.
     * @param {patch4cCreateManyArgs} args - Arguments to create many Patch4cs.
     * @example
     * // Create many Patch4cs
     * const patch4c = await prisma.patch4c.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends patch4cCreateManyArgs>(args?: SelectSubset<T, patch4cCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Patch4cs and returns the data saved in the database.
     * @param {patch4cCreateManyAndReturnArgs} args - Arguments to create many Patch4cs.
     * @example
     * // Create many Patch4cs
     * const patch4c = await prisma.patch4c.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Patch4cs and only return the `index`
     * const patch4cWithIndexOnly = await prisma.patch4c.createManyAndReturn({
     *   select: { index: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends patch4cCreateManyAndReturnArgs>(args?: SelectSubset<T, patch4cCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$patch4cPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Patch4c.
     * @param {patch4cDeleteArgs} args - Arguments to delete one Patch4c.
     * @example
     * // Delete one Patch4c
     * const Patch4c = await prisma.patch4c.delete({
     *   where: {
     *     // ... filter to delete one Patch4c
     *   }
     * })
     * 
     */
    delete<T extends patch4cDeleteArgs>(args: SelectSubset<T, patch4cDeleteArgs<ExtArgs>>): Prisma__patch4cClient<$Result.GetResult<Prisma.$patch4cPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Patch4c.
     * @param {patch4cUpdateArgs} args - Arguments to update one Patch4c.
     * @example
     * // Update one Patch4c
     * const patch4c = await prisma.patch4c.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends patch4cUpdateArgs>(args: SelectSubset<T, patch4cUpdateArgs<ExtArgs>>): Prisma__patch4cClient<$Result.GetResult<Prisma.$patch4cPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Patch4cs.
     * @param {patch4cDeleteManyArgs} args - Arguments to filter Patch4cs to delete.
     * @example
     * // Delete a few Patch4cs
     * const { count } = await prisma.patch4c.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends patch4cDeleteManyArgs>(args?: SelectSubset<T, patch4cDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patch4cs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patch4cUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patch4cs
     * const patch4c = await prisma.patch4c.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends patch4cUpdateManyArgs>(args: SelectSubset<T, patch4cUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patch4cs and returns the data updated in the database.
     * @param {patch4cUpdateManyAndReturnArgs} args - Arguments to update many Patch4cs.
     * @example
     * // Update many Patch4cs
     * const patch4c = await prisma.patch4c.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Patch4cs and only return the `index`
     * const patch4cWithIndexOnly = await prisma.patch4c.updateManyAndReturn({
     *   select: { index: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends patch4cUpdateManyAndReturnArgs>(args: SelectSubset<T, patch4cUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$patch4cPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Patch4c.
     * @param {patch4cUpsertArgs} args - Arguments to update or create a Patch4c.
     * @example
     * // Update or create a Patch4c
     * const patch4c = await prisma.patch4c.upsert({
     *   create: {
     *     // ... data to create a Patch4c
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patch4c we want to update
     *   }
     * })
     */
    upsert<T extends patch4cUpsertArgs>(args: SelectSubset<T, patch4cUpsertArgs<ExtArgs>>): Prisma__patch4cClient<$Result.GetResult<Prisma.$patch4cPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Patch4cs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patch4cCountArgs} args - Arguments to filter Patch4cs to count.
     * @example
     * // Count the number of Patch4cs
     * const count = await prisma.patch4c.count({
     *   where: {
     *     // ... the filter for the Patch4cs we want to count
     *   }
     * })
    **/
    count<T extends patch4cCountArgs>(
      args?: Subset<T, patch4cCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Patch4cCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patch4c.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Patch4cAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Patch4cAggregateArgs>(args: Subset<T, Patch4cAggregateArgs>): Prisma.PrismaPromise<GetPatch4cAggregateType<T>>

    /**
     * Group by Patch4c.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patch4cGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends patch4cGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: patch4cGroupByArgs['orderBy'] }
        : { orderBy?: patch4cGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, patch4cGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatch4cGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the patch4c model
   */
  readonly fields: patch4cFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for patch4c.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__patch4cClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the patch4c model
   */
  interface patch4cFieldRefs {
    readonly index: FieldRef<"patch4c", 'Int'>
    readonly code_geographique: FieldRef<"patch4c", 'String'>
    readonly niveaux_marins: FieldRef<"patch4c", 'Float'>
    readonly feux_foret: FieldRef<"patch4c", 'Float'>
    readonly secheresse_sols: FieldRef<"patch4c", 'Float'>
    readonly fortes_precipitations: FieldRef<"patch4c", 'Float'>
    readonly fortes_chaleurs: FieldRef<"patch4c", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * patch4c findUnique
   */
  export type patch4cFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patch4c
     */
    select?: patch4cSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patch4c
     */
    omit?: patch4cOmit<ExtArgs> | null
    /**
     * Filter, which patch4c to fetch.
     */
    where: patch4cWhereUniqueInput
  }

  /**
   * patch4c findUniqueOrThrow
   */
  export type patch4cFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patch4c
     */
    select?: patch4cSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patch4c
     */
    omit?: patch4cOmit<ExtArgs> | null
    /**
     * Filter, which patch4c to fetch.
     */
    where: patch4cWhereUniqueInput
  }

  /**
   * patch4c findFirst
   */
  export type patch4cFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patch4c
     */
    select?: patch4cSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patch4c
     */
    omit?: patch4cOmit<ExtArgs> | null
    /**
     * Filter, which patch4c to fetch.
     */
    where?: patch4cWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patch4cs to fetch.
     */
    orderBy?: patch4cOrderByWithRelationInput | patch4cOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for patch4cs.
     */
    cursor?: patch4cWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patch4cs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patch4cs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of patch4cs.
     */
    distinct?: Patch4cScalarFieldEnum | Patch4cScalarFieldEnum[]
  }

  /**
   * patch4c findFirstOrThrow
   */
  export type patch4cFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patch4c
     */
    select?: patch4cSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patch4c
     */
    omit?: patch4cOmit<ExtArgs> | null
    /**
     * Filter, which patch4c to fetch.
     */
    where?: patch4cWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patch4cs to fetch.
     */
    orderBy?: patch4cOrderByWithRelationInput | patch4cOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for patch4cs.
     */
    cursor?: patch4cWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patch4cs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patch4cs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of patch4cs.
     */
    distinct?: Patch4cScalarFieldEnum | Patch4cScalarFieldEnum[]
  }

  /**
   * patch4c findMany
   */
  export type patch4cFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patch4c
     */
    select?: patch4cSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patch4c
     */
    omit?: patch4cOmit<ExtArgs> | null
    /**
     * Filter, which patch4cs to fetch.
     */
    where?: patch4cWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patch4cs to fetch.
     */
    orderBy?: patch4cOrderByWithRelationInput | patch4cOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing patch4cs.
     */
    cursor?: patch4cWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patch4cs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patch4cs.
     */
    skip?: number
    distinct?: Patch4cScalarFieldEnum | Patch4cScalarFieldEnum[]
  }

  /**
   * patch4c create
   */
  export type patch4cCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patch4c
     */
    select?: patch4cSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patch4c
     */
    omit?: patch4cOmit<ExtArgs> | null
    /**
     * The data needed to create a patch4c.
     */
    data: XOR<patch4cCreateInput, patch4cUncheckedCreateInput>
  }

  /**
   * patch4c createMany
   */
  export type patch4cCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many patch4cs.
     */
    data: patch4cCreateManyInput | patch4cCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * patch4c createManyAndReturn
   */
  export type patch4cCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patch4c
     */
    select?: patch4cSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the patch4c
     */
    omit?: patch4cOmit<ExtArgs> | null
    /**
     * The data used to create many patch4cs.
     */
    data: patch4cCreateManyInput | patch4cCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * patch4c update
   */
  export type patch4cUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patch4c
     */
    select?: patch4cSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patch4c
     */
    omit?: patch4cOmit<ExtArgs> | null
    /**
     * The data needed to update a patch4c.
     */
    data: XOR<patch4cUpdateInput, patch4cUncheckedUpdateInput>
    /**
     * Choose, which patch4c to update.
     */
    where: patch4cWhereUniqueInput
  }

  /**
   * patch4c updateMany
   */
  export type patch4cUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update patch4cs.
     */
    data: XOR<patch4cUpdateManyMutationInput, patch4cUncheckedUpdateManyInput>
    /**
     * Filter which patch4cs to update
     */
    where?: patch4cWhereInput
    /**
     * Limit how many patch4cs to update.
     */
    limit?: number
  }

  /**
   * patch4c updateManyAndReturn
   */
  export type patch4cUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patch4c
     */
    select?: patch4cSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the patch4c
     */
    omit?: patch4cOmit<ExtArgs> | null
    /**
     * The data used to update patch4cs.
     */
    data: XOR<patch4cUpdateManyMutationInput, patch4cUncheckedUpdateManyInput>
    /**
     * Filter which patch4cs to update
     */
    where?: patch4cWhereInput
    /**
     * Limit how many patch4cs to update.
     */
    limit?: number
  }

  /**
   * patch4c upsert
   */
  export type patch4cUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patch4c
     */
    select?: patch4cSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patch4c
     */
    omit?: patch4cOmit<ExtArgs> | null
    /**
     * The filter to search for the patch4c to update in case it exists.
     */
    where: patch4cWhereUniqueInput
    /**
     * In case the patch4c found by the `where` argument doesn't exist, create a new patch4c with this data.
     */
    create: XOR<patch4cCreateInput, patch4cUncheckedCreateInput>
    /**
     * In case the patch4c was found with the provided `where` argument, update it with this data.
     */
    update: XOR<patch4cUpdateInput, patch4cUncheckedUpdateInput>
  }

  /**
   * patch4c delete
   */
  export type patch4cDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patch4c
     */
    select?: patch4cSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patch4c
     */
    omit?: patch4cOmit<ExtArgs> | null
    /**
     * Filter which patch4c to delete.
     */
    where: patch4cWhereUniqueInput
  }

  /**
   * patch4c deleteMany
   */
  export type patch4cDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which patch4cs to delete
     */
    where?: patch4cWhereInput
    /**
     * Limit how many patch4cs to delete.
     */
    limit?: number
  }

  /**
   * patch4c without action
   */
  export type patch4cDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patch4c
     */
    select?: patch4cSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patch4c
     */
    omit?: patch4cOmit<ExtArgs> | null
  }


  /**
   * Model prelevements_eau
   */

  export type AggregatePrelevements_eau = {
    _count: Prelevements_eauCountAggregateOutputType | null
    _avg: Prelevements_eauAvgAggregateOutputType | null
    _sum: Prelevements_eauSumAggregateOutputType | null
    _min: Prelevements_eauMinAggregateOutputType | null
    _max: Prelevements_eauMaxAggregateOutputType | null
  }

  export type Prelevements_eauAvgAggregateOutputType = {
    index: number | null
    region: number | null
  }

  export type Prelevements_eauSumAggregateOutputType = {
    index: number | null
    region: number | null
  }

  export type Prelevements_eauMinAggregateOutputType = {
    index: number | null
    code_geographique: string | null
    libelle_geographique: string | null
    epci: string | null
    libelle_epci: string | null
    departement: string | null
    libelle_departement: string | null
    region: number | null
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
    libelle_sous_champ: string | null
    A2020: string | null
    A2019: string | null
    A2018: string | null
    A2017: string | null
    A2016: string | null
    A2015: string | null
    A2014: string | null
    A2013: string | null
    A2012: string | null
    A2011: string | null
    A2010: string | null
    A2009: string | null
    A2008: string | null
    sous_champ: string | null
  }

  export type Prelevements_eauMaxAggregateOutputType = {
    index: number | null
    code_geographique: string | null
    libelle_geographique: string | null
    epci: string | null
    libelle_epci: string | null
    departement: string | null
    libelle_departement: string | null
    region: number | null
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
    libelle_sous_champ: string | null
    A2020: string | null
    A2019: string | null
    A2018: string | null
    A2017: string | null
    A2016: string | null
    A2015: string | null
    A2014: string | null
    A2013: string | null
    A2012: string | null
    A2011: string | null
    A2010: string | null
    A2009: string | null
    A2008: string | null
    sous_champ: string | null
  }

  export type Prelevements_eauCountAggregateOutputType = {
    index: number
    code_geographique: number
    libelle_geographique: number
    epci: number
    libelle_epci: number
    departement: number
    libelle_departement: number
    region: number
    ept: number
    libelle_petr: number
    code_pnr: number
    libelle_pnr: number
    libelle_sous_champ: number
    A2020: number
    A2019: number
    A2018: number
    A2017: number
    A2016: number
    A2015: number
    A2014: number
    A2013: number
    A2012: number
    A2011: number
    A2010: number
    A2009: number
    A2008: number
    sous_champ: number
    _all: number
  }


  export type Prelevements_eauAvgAggregateInputType = {
    index?: true
    region?: true
  }

  export type Prelevements_eauSumAggregateInputType = {
    index?: true
    region?: true
  }

  export type Prelevements_eauMinAggregateInputType = {
    index?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
    libelle_sous_champ?: true
    A2020?: true
    A2019?: true
    A2018?: true
    A2017?: true
    A2016?: true
    A2015?: true
    A2014?: true
    A2013?: true
    A2012?: true
    A2011?: true
    A2010?: true
    A2009?: true
    A2008?: true
    sous_champ?: true
  }

  export type Prelevements_eauMaxAggregateInputType = {
    index?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
    libelle_sous_champ?: true
    A2020?: true
    A2019?: true
    A2018?: true
    A2017?: true
    A2016?: true
    A2015?: true
    A2014?: true
    A2013?: true
    A2012?: true
    A2011?: true
    A2010?: true
    A2009?: true
    A2008?: true
    sous_champ?: true
  }

  export type Prelevements_eauCountAggregateInputType = {
    index?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
    libelle_sous_champ?: true
    A2020?: true
    A2019?: true
    A2018?: true
    A2017?: true
    A2016?: true
    A2015?: true
    A2014?: true
    A2013?: true
    A2012?: true
    A2011?: true
    A2010?: true
    A2009?: true
    A2008?: true
    sous_champ?: true
    _all?: true
  }

  export type Prelevements_eauAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which prelevements_eau to aggregate.
     */
    where?: prelevements_eauWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prelevements_eaus to fetch.
     */
    orderBy?: prelevements_eauOrderByWithRelationInput | prelevements_eauOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: prelevements_eauWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prelevements_eaus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prelevements_eaus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned prelevements_eaus
    **/
    _count?: true | Prelevements_eauCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Prelevements_eauAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Prelevements_eauSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Prelevements_eauMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Prelevements_eauMaxAggregateInputType
  }

  export type GetPrelevements_eauAggregateType<T extends Prelevements_eauAggregateArgs> = {
        [P in keyof T & keyof AggregatePrelevements_eau]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrelevements_eau[P]>
      : GetScalarType<T[P], AggregatePrelevements_eau[P]>
  }




  export type prelevements_eauGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: prelevements_eauWhereInput
    orderBy?: prelevements_eauOrderByWithAggregationInput | prelevements_eauOrderByWithAggregationInput[]
    by: Prelevements_eauScalarFieldEnum[] | Prelevements_eauScalarFieldEnum
    having?: prelevements_eauScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Prelevements_eauCountAggregateInputType | true
    _avg?: Prelevements_eauAvgAggregateInputType
    _sum?: Prelevements_eauSumAggregateInputType
    _min?: Prelevements_eauMinAggregateInputType
    _max?: Prelevements_eauMaxAggregateInputType
  }

  export type Prelevements_eauGroupByOutputType = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
    libelle_sous_champ: string | null
    A2020: string | null
    A2019: string | null
    A2018: string | null
    A2017: string | null
    A2016: string | null
    A2015: string | null
    A2014: string | null
    A2013: string | null
    A2012: string | null
    A2011: string | null
    A2010: string | null
    A2009: string | null
    A2008: string | null
    sous_champ: string | null
    _count: Prelevements_eauCountAggregateOutputType | null
    _avg: Prelevements_eauAvgAggregateOutputType | null
    _sum: Prelevements_eauSumAggregateOutputType | null
    _min: Prelevements_eauMinAggregateOutputType | null
    _max: Prelevements_eauMaxAggregateOutputType | null
  }

  type GetPrelevements_eauGroupByPayload<T extends prelevements_eauGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Prelevements_eauGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Prelevements_eauGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Prelevements_eauGroupByOutputType[P]>
            : GetScalarType<T[P], Prelevements_eauGroupByOutputType[P]>
        }
      >
    >


  export type prelevements_eauSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    libelle_sous_champ?: boolean
    A2020?: boolean
    A2019?: boolean
    A2018?: boolean
    A2017?: boolean
    A2016?: boolean
    A2015?: boolean
    A2014?: boolean
    A2013?: boolean
    A2012?: boolean
    A2011?: boolean
    A2010?: boolean
    A2009?: boolean
    A2008?: boolean
    sous_champ?: boolean
  }, ExtArgs["result"]["prelevements_eau"]>

  export type prelevements_eauSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    libelle_sous_champ?: boolean
    A2020?: boolean
    A2019?: boolean
    A2018?: boolean
    A2017?: boolean
    A2016?: boolean
    A2015?: boolean
    A2014?: boolean
    A2013?: boolean
    A2012?: boolean
    A2011?: boolean
    A2010?: boolean
    A2009?: boolean
    A2008?: boolean
    sous_champ?: boolean
  }, ExtArgs["result"]["prelevements_eau"]>

  export type prelevements_eauSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    libelle_sous_champ?: boolean
    A2020?: boolean
    A2019?: boolean
    A2018?: boolean
    A2017?: boolean
    A2016?: boolean
    A2015?: boolean
    A2014?: boolean
    A2013?: boolean
    A2012?: boolean
    A2011?: boolean
    A2010?: boolean
    A2009?: boolean
    A2008?: boolean
    sous_champ?: boolean
  }, ExtArgs["result"]["prelevements_eau"]>

  export type prelevements_eauSelectScalar = {
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    libelle_sous_champ?: boolean
    A2020?: boolean
    A2019?: boolean
    A2018?: boolean
    A2017?: boolean
    A2016?: boolean
    A2015?: boolean
    A2014?: boolean
    A2013?: boolean
    A2012?: boolean
    A2011?: boolean
    A2010?: boolean
    A2009?: boolean
    A2008?: boolean
    sous_champ?: boolean
  }

  export type prelevements_eauOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"index" | "code_geographique" | "libelle_geographique" | "epci" | "libelle_epci" | "departement" | "libelle_departement" | "region" | "ept" | "libelle_petr" | "code_pnr" | "libelle_pnr" | "libelle_sous_champ" | "A2020" | "A2019" | "A2018" | "A2017" | "A2016" | "A2015" | "A2014" | "A2013" | "A2012" | "A2011" | "A2010" | "A2009" | "A2008" | "sous_champ", ExtArgs["result"]["prelevements_eau"]>

  export type $prelevements_eauPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "prelevements_eau"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      index: number
      code_geographique: string
      libelle_geographique: string
      epci: string
      libelle_epci: string
      departement: string
      libelle_departement: string
      region: number
      ept: string | null
      libelle_petr: string | null
      code_pnr: string | null
      libelle_pnr: string | null
      libelle_sous_champ: string | null
      A2020: string | null
      A2019: string | null
      A2018: string | null
      A2017: string | null
      A2016: string | null
      A2015: string | null
      A2014: string | null
      A2013: string | null
      A2012: string | null
      A2011: string | null
      A2010: string | null
      A2009: string | null
      A2008: string | null
      sous_champ: string | null
    }, ExtArgs["result"]["prelevements_eau"]>
    composites: {}
  }

  type prelevements_eauGetPayload<S extends boolean | null | undefined | prelevements_eauDefaultArgs> = $Result.GetResult<Prisma.$prelevements_eauPayload, S>

  type prelevements_eauCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<prelevements_eauFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Prelevements_eauCountAggregateInputType | true
    }

  export interface prelevements_eauDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['prelevements_eau'], meta: { name: 'prelevements_eau' } }
    /**
     * Find zero or one Prelevements_eau that matches the filter.
     * @param {prelevements_eauFindUniqueArgs} args - Arguments to find a Prelevements_eau
     * @example
     * // Get one Prelevements_eau
     * const prelevements_eau = await prisma.prelevements_eau.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends prelevements_eauFindUniqueArgs>(args: SelectSubset<T, prelevements_eauFindUniqueArgs<ExtArgs>>): Prisma__prelevements_eauClient<$Result.GetResult<Prisma.$prelevements_eauPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Prelevements_eau that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {prelevements_eauFindUniqueOrThrowArgs} args - Arguments to find a Prelevements_eau
     * @example
     * // Get one Prelevements_eau
     * const prelevements_eau = await prisma.prelevements_eau.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends prelevements_eauFindUniqueOrThrowArgs>(args: SelectSubset<T, prelevements_eauFindUniqueOrThrowArgs<ExtArgs>>): Prisma__prelevements_eauClient<$Result.GetResult<Prisma.$prelevements_eauPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Prelevements_eau that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prelevements_eauFindFirstArgs} args - Arguments to find a Prelevements_eau
     * @example
     * // Get one Prelevements_eau
     * const prelevements_eau = await prisma.prelevements_eau.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends prelevements_eauFindFirstArgs>(args?: SelectSubset<T, prelevements_eauFindFirstArgs<ExtArgs>>): Prisma__prelevements_eauClient<$Result.GetResult<Prisma.$prelevements_eauPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Prelevements_eau that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prelevements_eauFindFirstOrThrowArgs} args - Arguments to find a Prelevements_eau
     * @example
     * // Get one Prelevements_eau
     * const prelevements_eau = await prisma.prelevements_eau.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends prelevements_eauFindFirstOrThrowArgs>(args?: SelectSubset<T, prelevements_eauFindFirstOrThrowArgs<ExtArgs>>): Prisma__prelevements_eauClient<$Result.GetResult<Prisma.$prelevements_eauPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Prelevements_eaus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prelevements_eauFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prelevements_eaus
     * const prelevements_eaus = await prisma.prelevements_eau.findMany()
     * 
     * // Get first 10 Prelevements_eaus
     * const prelevements_eaus = await prisma.prelevements_eau.findMany({ take: 10 })
     * 
     * // Only select the `index`
     * const prelevements_eauWithIndexOnly = await prisma.prelevements_eau.findMany({ select: { index: true } })
     * 
     */
    findMany<T extends prelevements_eauFindManyArgs>(args?: SelectSubset<T, prelevements_eauFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$prelevements_eauPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Prelevements_eau.
     * @param {prelevements_eauCreateArgs} args - Arguments to create a Prelevements_eau.
     * @example
     * // Create one Prelevements_eau
     * const Prelevements_eau = await prisma.prelevements_eau.create({
     *   data: {
     *     // ... data to create a Prelevements_eau
     *   }
     * })
     * 
     */
    create<T extends prelevements_eauCreateArgs>(args: SelectSubset<T, prelevements_eauCreateArgs<ExtArgs>>): Prisma__prelevements_eauClient<$Result.GetResult<Prisma.$prelevements_eauPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Prelevements_eaus.
     * @param {prelevements_eauCreateManyArgs} args - Arguments to create many Prelevements_eaus.
     * @example
     * // Create many Prelevements_eaus
     * const prelevements_eau = await prisma.prelevements_eau.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends prelevements_eauCreateManyArgs>(args?: SelectSubset<T, prelevements_eauCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Prelevements_eaus and returns the data saved in the database.
     * @param {prelevements_eauCreateManyAndReturnArgs} args - Arguments to create many Prelevements_eaus.
     * @example
     * // Create many Prelevements_eaus
     * const prelevements_eau = await prisma.prelevements_eau.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Prelevements_eaus and only return the `index`
     * const prelevements_eauWithIndexOnly = await prisma.prelevements_eau.createManyAndReturn({
     *   select: { index: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends prelevements_eauCreateManyAndReturnArgs>(args?: SelectSubset<T, prelevements_eauCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$prelevements_eauPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Prelevements_eau.
     * @param {prelevements_eauDeleteArgs} args - Arguments to delete one Prelevements_eau.
     * @example
     * // Delete one Prelevements_eau
     * const Prelevements_eau = await prisma.prelevements_eau.delete({
     *   where: {
     *     // ... filter to delete one Prelevements_eau
     *   }
     * })
     * 
     */
    delete<T extends prelevements_eauDeleteArgs>(args: SelectSubset<T, prelevements_eauDeleteArgs<ExtArgs>>): Prisma__prelevements_eauClient<$Result.GetResult<Prisma.$prelevements_eauPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Prelevements_eau.
     * @param {prelevements_eauUpdateArgs} args - Arguments to update one Prelevements_eau.
     * @example
     * // Update one Prelevements_eau
     * const prelevements_eau = await prisma.prelevements_eau.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends prelevements_eauUpdateArgs>(args: SelectSubset<T, prelevements_eauUpdateArgs<ExtArgs>>): Prisma__prelevements_eauClient<$Result.GetResult<Prisma.$prelevements_eauPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Prelevements_eaus.
     * @param {prelevements_eauDeleteManyArgs} args - Arguments to filter Prelevements_eaus to delete.
     * @example
     * // Delete a few Prelevements_eaus
     * const { count } = await prisma.prelevements_eau.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends prelevements_eauDeleteManyArgs>(args?: SelectSubset<T, prelevements_eauDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prelevements_eaus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prelevements_eauUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prelevements_eaus
     * const prelevements_eau = await prisma.prelevements_eau.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends prelevements_eauUpdateManyArgs>(args: SelectSubset<T, prelevements_eauUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prelevements_eaus and returns the data updated in the database.
     * @param {prelevements_eauUpdateManyAndReturnArgs} args - Arguments to update many Prelevements_eaus.
     * @example
     * // Update many Prelevements_eaus
     * const prelevements_eau = await prisma.prelevements_eau.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Prelevements_eaus and only return the `index`
     * const prelevements_eauWithIndexOnly = await prisma.prelevements_eau.updateManyAndReturn({
     *   select: { index: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends prelevements_eauUpdateManyAndReturnArgs>(args: SelectSubset<T, prelevements_eauUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$prelevements_eauPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Prelevements_eau.
     * @param {prelevements_eauUpsertArgs} args - Arguments to update or create a Prelevements_eau.
     * @example
     * // Update or create a Prelevements_eau
     * const prelevements_eau = await prisma.prelevements_eau.upsert({
     *   create: {
     *     // ... data to create a Prelevements_eau
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prelevements_eau we want to update
     *   }
     * })
     */
    upsert<T extends prelevements_eauUpsertArgs>(args: SelectSubset<T, prelevements_eauUpsertArgs<ExtArgs>>): Prisma__prelevements_eauClient<$Result.GetResult<Prisma.$prelevements_eauPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Prelevements_eaus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prelevements_eauCountArgs} args - Arguments to filter Prelevements_eaus to count.
     * @example
     * // Count the number of Prelevements_eaus
     * const count = await prisma.prelevements_eau.count({
     *   where: {
     *     // ... the filter for the Prelevements_eaus we want to count
     *   }
     * })
    **/
    count<T extends prelevements_eauCountArgs>(
      args?: Subset<T, prelevements_eauCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Prelevements_eauCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prelevements_eau.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Prelevements_eauAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Prelevements_eauAggregateArgs>(args: Subset<T, Prelevements_eauAggregateArgs>): Prisma.PrismaPromise<GetPrelevements_eauAggregateType<T>>

    /**
     * Group by Prelevements_eau.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {prelevements_eauGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends prelevements_eauGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: prelevements_eauGroupByArgs['orderBy'] }
        : { orderBy?: prelevements_eauGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, prelevements_eauGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrelevements_eauGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the prelevements_eau model
   */
  readonly fields: prelevements_eauFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for prelevements_eau.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__prelevements_eauClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the prelevements_eau model
   */
  interface prelevements_eauFieldRefs {
    readonly index: FieldRef<"prelevements_eau", 'Int'>
    readonly code_geographique: FieldRef<"prelevements_eau", 'String'>
    readonly libelle_geographique: FieldRef<"prelevements_eau", 'String'>
    readonly epci: FieldRef<"prelevements_eau", 'String'>
    readonly libelle_epci: FieldRef<"prelevements_eau", 'String'>
    readonly departement: FieldRef<"prelevements_eau", 'String'>
    readonly libelle_departement: FieldRef<"prelevements_eau", 'String'>
    readonly region: FieldRef<"prelevements_eau", 'Int'>
    readonly ept: FieldRef<"prelevements_eau", 'String'>
    readonly libelle_petr: FieldRef<"prelevements_eau", 'String'>
    readonly code_pnr: FieldRef<"prelevements_eau", 'String'>
    readonly libelle_pnr: FieldRef<"prelevements_eau", 'String'>
    readonly libelle_sous_champ: FieldRef<"prelevements_eau", 'String'>
    readonly A2020: FieldRef<"prelevements_eau", 'String'>
    readonly A2019: FieldRef<"prelevements_eau", 'String'>
    readonly A2018: FieldRef<"prelevements_eau", 'String'>
    readonly A2017: FieldRef<"prelevements_eau", 'String'>
    readonly A2016: FieldRef<"prelevements_eau", 'String'>
    readonly A2015: FieldRef<"prelevements_eau", 'String'>
    readonly A2014: FieldRef<"prelevements_eau", 'String'>
    readonly A2013: FieldRef<"prelevements_eau", 'String'>
    readonly A2012: FieldRef<"prelevements_eau", 'String'>
    readonly A2011: FieldRef<"prelevements_eau", 'String'>
    readonly A2010: FieldRef<"prelevements_eau", 'String'>
    readonly A2009: FieldRef<"prelevements_eau", 'String'>
    readonly A2008: FieldRef<"prelevements_eau", 'String'>
    readonly sous_champ: FieldRef<"prelevements_eau", 'String'>
  }
    

  // Custom InputTypes
  /**
   * prelevements_eau findUnique
   */
  export type prelevements_eauFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prelevements_eau
     */
    select?: prelevements_eauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the prelevements_eau
     */
    omit?: prelevements_eauOmit<ExtArgs> | null
    /**
     * Filter, which prelevements_eau to fetch.
     */
    where: prelevements_eauWhereUniqueInput
  }

  /**
   * prelevements_eau findUniqueOrThrow
   */
  export type prelevements_eauFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prelevements_eau
     */
    select?: prelevements_eauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the prelevements_eau
     */
    omit?: prelevements_eauOmit<ExtArgs> | null
    /**
     * Filter, which prelevements_eau to fetch.
     */
    where: prelevements_eauWhereUniqueInput
  }

  /**
   * prelevements_eau findFirst
   */
  export type prelevements_eauFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prelevements_eau
     */
    select?: prelevements_eauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the prelevements_eau
     */
    omit?: prelevements_eauOmit<ExtArgs> | null
    /**
     * Filter, which prelevements_eau to fetch.
     */
    where?: prelevements_eauWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prelevements_eaus to fetch.
     */
    orderBy?: prelevements_eauOrderByWithRelationInput | prelevements_eauOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for prelevements_eaus.
     */
    cursor?: prelevements_eauWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prelevements_eaus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prelevements_eaus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of prelevements_eaus.
     */
    distinct?: Prelevements_eauScalarFieldEnum | Prelevements_eauScalarFieldEnum[]
  }

  /**
   * prelevements_eau findFirstOrThrow
   */
  export type prelevements_eauFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prelevements_eau
     */
    select?: prelevements_eauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the prelevements_eau
     */
    omit?: prelevements_eauOmit<ExtArgs> | null
    /**
     * Filter, which prelevements_eau to fetch.
     */
    where?: prelevements_eauWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prelevements_eaus to fetch.
     */
    orderBy?: prelevements_eauOrderByWithRelationInput | prelevements_eauOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for prelevements_eaus.
     */
    cursor?: prelevements_eauWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prelevements_eaus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prelevements_eaus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of prelevements_eaus.
     */
    distinct?: Prelevements_eauScalarFieldEnum | Prelevements_eauScalarFieldEnum[]
  }

  /**
   * prelevements_eau findMany
   */
  export type prelevements_eauFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prelevements_eau
     */
    select?: prelevements_eauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the prelevements_eau
     */
    omit?: prelevements_eauOmit<ExtArgs> | null
    /**
     * Filter, which prelevements_eaus to fetch.
     */
    where?: prelevements_eauWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of prelevements_eaus to fetch.
     */
    orderBy?: prelevements_eauOrderByWithRelationInput | prelevements_eauOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing prelevements_eaus.
     */
    cursor?: prelevements_eauWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` prelevements_eaus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` prelevements_eaus.
     */
    skip?: number
    distinct?: Prelevements_eauScalarFieldEnum | Prelevements_eauScalarFieldEnum[]
  }

  /**
   * prelevements_eau create
   */
  export type prelevements_eauCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prelevements_eau
     */
    select?: prelevements_eauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the prelevements_eau
     */
    omit?: prelevements_eauOmit<ExtArgs> | null
    /**
     * The data needed to create a prelevements_eau.
     */
    data: XOR<prelevements_eauCreateInput, prelevements_eauUncheckedCreateInput>
  }

  /**
   * prelevements_eau createMany
   */
  export type prelevements_eauCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many prelevements_eaus.
     */
    data: prelevements_eauCreateManyInput | prelevements_eauCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * prelevements_eau createManyAndReturn
   */
  export type prelevements_eauCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prelevements_eau
     */
    select?: prelevements_eauSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the prelevements_eau
     */
    omit?: prelevements_eauOmit<ExtArgs> | null
    /**
     * The data used to create many prelevements_eaus.
     */
    data: prelevements_eauCreateManyInput | prelevements_eauCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * prelevements_eau update
   */
  export type prelevements_eauUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prelevements_eau
     */
    select?: prelevements_eauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the prelevements_eau
     */
    omit?: prelevements_eauOmit<ExtArgs> | null
    /**
     * The data needed to update a prelevements_eau.
     */
    data: XOR<prelevements_eauUpdateInput, prelevements_eauUncheckedUpdateInput>
    /**
     * Choose, which prelevements_eau to update.
     */
    where: prelevements_eauWhereUniqueInput
  }

  /**
   * prelevements_eau updateMany
   */
  export type prelevements_eauUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update prelevements_eaus.
     */
    data: XOR<prelevements_eauUpdateManyMutationInput, prelevements_eauUncheckedUpdateManyInput>
    /**
     * Filter which prelevements_eaus to update
     */
    where?: prelevements_eauWhereInput
    /**
     * Limit how many prelevements_eaus to update.
     */
    limit?: number
  }

  /**
   * prelevements_eau updateManyAndReturn
   */
  export type prelevements_eauUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prelevements_eau
     */
    select?: prelevements_eauSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the prelevements_eau
     */
    omit?: prelevements_eauOmit<ExtArgs> | null
    /**
     * The data used to update prelevements_eaus.
     */
    data: XOR<prelevements_eauUpdateManyMutationInput, prelevements_eauUncheckedUpdateManyInput>
    /**
     * Filter which prelevements_eaus to update
     */
    where?: prelevements_eauWhereInput
    /**
     * Limit how many prelevements_eaus to update.
     */
    limit?: number
  }

  /**
   * prelevements_eau upsert
   */
  export type prelevements_eauUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prelevements_eau
     */
    select?: prelevements_eauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the prelevements_eau
     */
    omit?: prelevements_eauOmit<ExtArgs> | null
    /**
     * The filter to search for the prelevements_eau to update in case it exists.
     */
    where: prelevements_eauWhereUniqueInput
    /**
     * In case the prelevements_eau found by the `where` argument doesn't exist, create a new prelevements_eau with this data.
     */
    create: XOR<prelevements_eauCreateInput, prelevements_eauUncheckedCreateInput>
    /**
     * In case the prelevements_eau was found with the provided `where` argument, update it with this data.
     */
    update: XOR<prelevements_eauUpdateInput, prelevements_eauUncheckedUpdateInput>
  }

  /**
   * prelevements_eau delete
   */
  export type prelevements_eauDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prelevements_eau
     */
    select?: prelevements_eauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the prelevements_eau
     */
    omit?: prelevements_eauOmit<ExtArgs> | null
    /**
     * Filter which prelevements_eau to delete.
     */
    where: prelevements_eauWhereUniqueInput
  }

  /**
   * prelevements_eau deleteMany
   */
  export type prelevements_eauDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which prelevements_eaus to delete
     */
    where?: prelevements_eauWhereInput
    /**
     * Limit how many prelevements_eaus to delete.
     */
    limit?: number
  }

  /**
   * prelevements_eau without action
   */
  export type prelevements_eauDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the prelevements_eau
     */
    select?: prelevements_eauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the prelevements_eau
     */
    omit?: prelevements_eauOmit<ExtArgs> | null
  }


  /**
   * Model qualite_sites_baignade
   */

  export type AggregateQualite_sites_baignade = {
    _count: Qualite_sites_baignadeCountAggregateOutputType | null
    _avg: Qualite_sites_baignadeAvgAggregateOutputType | null
    _sum: Qualite_sites_baignadeSumAggregateOutputType | null
    _min: Qualite_sites_baignadeMinAggregateOutputType | null
    _max: Qualite_sites_baignadeMaxAggregateOutputType | null
  }

  export type Qualite_sites_baignadeAvgAggregateOutputType = {
    index: number | null
    LONG: number | null
    LAT: number | null
  }

  export type Qualite_sites_baignadeSumAggregateOutputType = {
    index: number | null
    LONG: number | null
    LAT: number | null
  }

  export type Qualite_sites_baignadeMinAggregateOutputType = {
    index: number | null
    DEP_NOM: string | null
    DEP_NUM: string | null
    TYPE: string | null
    COMMUNE: string | null
    POINT: string | null
    LONG: number | null
    LAT: number | null
    QEB_2013: string | null
    QEB_2014: string | null
    QEB_2015: string | null
    QEB_2016: string | null
    QEB_2017: string | null
    QEB_2018: string | null
    QEB_2019: string | null
    QEB_2020: string | null
  }

  export type Qualite_sites_baignadeMaxAggregateOutputType = {
    index: number | null
    DEP_NOM: string | null
    DEP_NUM: string | null
    TYPE: string | null
    COMMUNE: string | null
    POINT: string | null
    LONG: number | null
    LAT: number | null
    QEB_2013: string | null
    QEB_2014: string | null
    QEB_2015: string | null
    QEB_2016: string | null
    QEB_2017: string | null
    QEB_2018: string | null
    QEB_2019: string | null
    QEB_2020: string | null
  }

  export type Qualite_sites_baignadeCountAggregateOutputType = {
    index: number
    DEP_NOM: number
    DEP_NUM: number
    TYPE: number
    COMMUNE: number
    POINT: number
    LONG: number
    LAT: number
    QEB_2013: number
    QEB_2014: number
    QEB_2015: number
    QEB_2016: number
    QEB_2017: number
    QEB_2018: number
    QEB_2019: number
    QEB_2020: number
    _all: number
  }


  export type Qualite_sites_baignadeAvgAggregateInputType = {
    index?: true
    LONG?: true
    LAT?: true
  }

  export type Qualite_sites_baignadeSumAggregateInputType = {
    index?: true
    LONG?: true
    LAT?: true
  }

  export type Qualite_sites_baignadeMinAggregateInputType = {
    index?: true
    DEP_NOM?: true
    DEP_NUM?: true
    TYPE?: true
    COMMUNE?: true
    POINT?: true
    LONG?: true
    LAT?: true
    QEB_2013?: true
    QEB_2014?: true
    QEB_2015?: true
    QEB_2016?: true
    QEB_2017?: true
    QEB_2018?: true
    QEB_2019?: true
    QEB_2020?: true
  }

  export type Qualite_sites_baignadeMaxAggregateInputType = {
    index?: true
    DEP_NOM?: true
    DEP_NUM?: true
    TYPE?: true
    COMMUNE?: true
    POINT?: true
    LONG?: true
    LAT?: true
    QEB_2013?: true
    QEB_2014?: true
    QEB_2015?: true
    QEB_2016?: true
    QEB_2017?: true
    QEB_2018?: true
    QEB_2019?: true
    QEB_2020?: true
  }

  export type Qualite_sites_baignadeCountAggregateInputType = {
    index?: true
    DEP_NOM?: true
    DEP_NUM?: true
    TYPE?: true
    COMMUNE?: true
    POINT?: true
    LONG?: true
    LAT?: true
    QEB_2013?: true
    QEB_2014?: true
    QEB_2015?: true
    QEB_2016?: true
    QEB_2017?: true
    QEB_2018?: true
    QEB_2019?: true
    QEB_2020?: true
    _all?: true
  }

  export type Qualite_sites_baignadeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which qualite_sites_baignade to aggregate.
     */
    where?: qualite_sites_baignadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qualite_sites_baignades to fetch.
     */
    orderBy?: qualite_sites_baignadeOrderByWithRelationInput | qualite_sites_baignadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: qualite_sites_baignadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qualite_sites_baignades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qualite_sites_baignades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned qualite_sites_baignades
    **/
    _count?: true | Qualite_sites_baignadeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Qualite_sites_baignadeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Qualite_sites_baignadeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Qualite_sites_baignadeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Qualite_sites_baignadeMaxAggregateInputType
  }

  export type GetQualite_sites_baignadeAggregateType<T extends Qualite_sites_baignadeAggregateArgs> = {
        [P in keyof T & keyof AggregateQualite_sites_baignade]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQualite_sites_baignade[P]>
      : GetScalarType<T[P], AggregateQualite_sites_baignade[P]>
  }




  export type qualite_sites_baignadeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: qualite_sites_baignadeWhereInput
    orderBy?: qualite_sites_baignadeOrderByWithAggregationInput | qualite_sites_baignadeOrderByWithAggregationInput[]
    by: Qualite_sites_baignadeScalarFieldEnum[] | Qualite_sites_baignadeScalarFieldEnum
    having?: qualite_sites_baignadeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Qualite_sites_baignadeCountAggregateInputType | true
    _avg?: Qualite_sites_baignadeAvgAggregateInputType
    _sum?: Qualite_sites_baignadeSumAggregateInputType
    _min?: Qualite_sites_baignadeMinAggregateInputType
    _max?: Qualite_sites_baignadeMaxAggregateInputType
  }

  export type Qualite_sites_baignadeGroupByOutputType = {
    index: number
    DEP_NOM: string
    DEP_NUM: string
    TYPE: string
    COMMUNE: string
    POINT: string
    LONG: number
    LAT: number
    QEB_2013: string | null
    QEB_2014: string | null
    QEB_2015: string | null
    QEB_2016: string | null
    QEB_2017: string | null
    QEB_2018: string | null
    QEB_2019: string | null
    QEB_2020: string | null
    _count: Qualite_sites_baignadeCountAggregateOutputType | null
    _avg: Qualite_sites_baignadeAvgAggregateOutputType | null
    _sum: Qualite_sites_baignadeSumAggregateOutputType | null
    _min: Qualite_sites_baignadeMinAggregateOutputType | null
    _max: Qualite_sites_baignadeMaxAggregateOutputType | null
  }

  type GetQualite_sites_baignadeGroupByPayload<T extends qualite_sites_baignadeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Qualite_sites_baignadeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Qualite_sites_baignadeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Qualite_sites_baignadeGroupByOutputType[P]>
            : GetScalarType<T[P], Qualite_sites_baignadeGroupByOutputType[P]>
        }
      >
    >


  export type qualite_sites_baignadeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    DEP_NOM?: boolean
    DEP_NUM?: boolean
    TYPE?: boolean
    COMMUNE?: boolean
    POINT?: boolean
    LONG?: boolean
    LAT?: boolean
    QEB_2013?: boolean
    QEB_2014?: boolean
    QEB_2015?: boolean
    QEB_2016?: boolean
    QEB_2017?: boolean
    QEB_2018?: boolean
    QEB_2019?: boolean
    QEB_2020?: boolean
  }, ExtArgs["result"]["qualite_sites_baignade"]>

  export type qualite_sites_baignadeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    DEP_NOM?: boolean
    DEP_NUM?: boolean
    TYPE?: boolean
    COMMUNE?: boolean
    POINT?: boolean
    LONG?: boolean
    LAT?: boolean
    QEB_2013?: boolean
    QEB_2014?: boolean
    QEB_2015?: boolean
    QEB_2016?: boolean
    QEB_2017?: boolean
    QEB_2018?: boolean
    QEB_2019?: boolean
    QEB_2020?: boolean
  }, ExtArgs["result"]["qualite_sites_baignade"]>

  export type qualite_sites_baignadeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    DEP_NOM?: boolean
    DEP_NUM?: boolean
    TYPE?: boolean
    COMMUNE?: boolean
    POINT?: boolean
    LONG?: boolean
    LAT?: boolean
    QEB_2013?: boolean
    QEB_2014?: boolean
    QEB_2015?: boolean
    QEB_2016?: boolean
    QEB_2017?: boolean
    QEB_2018?: boolean
    QEB_2019?: boolean
    QEB_2020?: boolean
  }, ExtArgs["result"]["qualite_sites_baignade"]>

  export type qualite_sites_baignadeSelectScalar = {
    index?: boolean
    DEP_NOM?: boolean
    DEP_NUM?: boolean
    TYPE?: boolean
    COMMUNE?: boolean
    POINT?: boolean
    LONG?: boolean
    LAT?: boolean
    QEB_2013?: boolean
    QEB_2014?: boolean
    QEB_2015?: boolean
    QEB_2016?: boolean
    QEB_2017?: boolean
    QEB_2018?: boolean
    QEB_2019?: boolean
    QEB_2020?: boolean
  }

  export type qualite_sites_baignadeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"index" | "DEP_NOM" | "DEP_NUM" | "TYPE" | "COMMUNE" | "POINT" | "LONG" | "LAT" | "QEB_2013" | "QEB_2014" | "QEB_2015" | "QEB_2016" | "QEB_2017" | "QEB_2018" | "QEB_2019" | "QEB_2020", ExtArgs["result"]["qualite_sites_baignade"]>

  export type $qualite_sites_baignadePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "qualite_sites_baignade"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      index: number
      DEP_NOM: string
      DEP_NUM: string
      TYPE: string
      COMMUNE: string
      POINT: string
      LONG: number
      LAT: number
      QEB_2013: string | null
      QEB_2014: string | null
      QEB_2015: string | null
      QEB_2016: string | null
      QEB_2017: string | null
      QEB_2018: string | null
      QEB_2019: string | null
      QEB_2020: string | null
    }, ExtArgs["result"]["qualite_sites_baignade"]>
    composites: {}
  }

  type qualite_sites_baignadeGetPayload<S extends boolean | null | undefined | qualite_sites_baignadeDefaultArgs> = $Result.GetResult<Prisma.$qualite_sites_baignadePayload, S>

  type qualite_sites_baignadeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<qualite_sites_baignadeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Qualite_sites_baignadeCountAggregateInputType | true
    }

  export interface qualite_sites_baignadeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['qualite_sites_baignade'], meta: { name: 'qualite_sites_baignade' } }
    /**
     * Find zero or one Qualite_sites_baignade that matches the filter.
     * @param {qualite_sites_baignadeFindUniqueArgs} args - Arguments to find a Qualite_sites_baignade
     * @example
     * // Get one Qualite_sites_baignade
     * const qualite_sites_baignade = await prisma.qualite_sites_baignade.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends qualite_sites_baignadeFindUniqueArgs>(args: SelectSubset<T, qualite_sites_baignadeFindUniqueArgs<ExtArgs>>): Prisma__qualite_sites_baignadeClient<$Result.GetResult<Prisma.$qualite_sites_baignadePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Qualite_sites_baignade that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {qualite_sites_baignadeFindUniqueOrThrowArgs} args - Arguments to find a Qualite_sites_baignade
     * @example
     * // Get one Qualite_sites_baignade
     * const qualite_sites_baignade = await prisma.qualite_sites_baignade.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends qualite_sites_baignadeFindUniqueOrThrowArgs>(args: SelectSubset<T, qualite_sites_baignadeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__qualite_sites_baignadeClient<$Result.GetResult<Prisma.$qualite_sites_baignadePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Qualite_sites_baignade that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qualite_sites_baignadeFindFirstArgs} args - Arguments to find a Qualite_sites_baignade
     * @example
     * // Get one Qualite_sites_baignade
     * const qualite_sites_baignade = await prisma.qualite_sites_baignade.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends qualite_sites_baignadeFindFirstArgs>(args?: SelectSubset<T, qualite_sites_baignadeFindFirstArgs<ExtArgs>>): Prisma__qualite_sites_baignadeClient<$Result.GetResult<Prisma.$qualite_sites_baignadePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Qualite_sites_baignade that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qualite_sites_baignadeFindFirstOrThrowArgs} args - Arguments to find a Qualite_sites_baignade
     * @example
     * // Get one Qualite_sites_baignade
     * const qualite_sites_baignade = await prisma.qualite_sites_baignade.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends qualite_sites_baignadeFindFirstOrThrowArgs>(args?: SelectSubset<T, qualite_sites_baignadeFindFirstOrThrowArgs<ExtArgs>>): Prisma__qualite_sites_baignadeClient<$Result.GetResult<Prisma.$qualite_sites_baignadePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Qualite_sites_baignades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qualite_sites_baignadeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Qualite_sites_baignades
     * const qualite_sites_baignades = await prisma.qualite_sites_baignade.findMany()
     * 
     * // Get first 10 Qualite_sites_baignades
     * const qualite_sites_baignades = await prisma.qualite_sites_baignade.findMany({ take: 10 })
     * 
     * // Only select the `index`
     * const qualite_sites_baignadeWithIndexOnly = await prisma.qualite_sites_baignade.findMany({ select: { index: true } })
     * 
     */
    findMany<T extends qualite_sites_baignadeFindManyArgs>(args?: SelectSubset<T, qualite_sites_baignadeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$qualite_sites_baignadePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Qualite_sites_baignade.
     * @param {qualite_sites_baignadeCreateArgs} args - Arguments to create a Qualite_sites_baignade.
     * @example
     * // Create one Qualite_sites_baignade
     * const Qualite_sites_baignade = await prisma.qualite_sites_baignade.create({
     *   data: {
     *     // ... data to create a Qualite_sites_baignade
     *   }
     * })
     * 
     */
    create<T extends qualite_sites_baignadeCreateArgs>(args: SelectSubset<T, qualite_sites_baignadeCreateArgs<ExtArgs>>): Prisma__qualite_sites_baignadeClient<$Result.GetResult<Prisma.$qualite_sites_baignadePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Qualite_sites_baignades.
     * @param {qualite_sites_baignadeCreateManyArgs} args - Arguments to create many Qualite_sites_baignades.
     * @example
     * // Create many Qualite_sites_baignades
     * const qualite_sites_baignade = await prisma.qualite_sites_baignade.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends qualite_sites_baignadeCreateManyArgs>(args?: SelectSubset<T, qualite_sites_baignadeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Qualite_sites_baignades and returns the data saved in the database.
     * @param {qualite_sites_baignadeCreateManyAndReturnArgs} args - Arguments to create many Qualite_sites_baignades.
     * @example
     * // Create many Qualite_sites_baignades
     * const qualite_sites_baignade = await prisma.qualite_sites_baignade.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Qualite_sites_baignades and only return the `index`
     * const qualite_sites_baignadeWithIndexOnly = await prisma.qualite_sites_baignade.createManyAndReturn({
     *   select: { index: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends qualite_sites_baignadeCreateManyAndReturnArgs>(args?: SelectSubset<T, qualite_sites_baignadeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$qualite_sites_baignadePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Qualite_sites_baignade.
     * @param {qualite_sites_baignadeDeleteArgs} args - Arguments to delete one Qualite_sites_baignade.
     * @example
     * // Delete one Qualite_sites_baignade
     * const Qualite_sites_baignade = await prisma.qualite_sites_baignade.delete({
     *   where: {
     *     // ... filter to delete one Qualite_sites_baignade
     *   }
     * })
     * 
     */
    delete<T extends qualite_sites_baignadeDeleteArgs>(args: SelectSubset<T, qualite_sites_baignadeDeleteArgs<ExtArgs>>): Prisma__qualite_sites_baignadeClient<$Result.GetResult<Prisma.$qualite_sites_baignadePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Qualite_sites_baignade.
     * @param {qualite_sites_baignadeUpdateArgs} args - Arguments to update one Qualite_sites_baignade.
     * @example
     * // Update one Qualite_sites_baignade
     * const qualite_sites_baignade = await prisma.qualite_sites_baignade.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends qualite_sites_baignadeUpdateArgs>(args: SelectSubset<T, qualite_sites_baignadeUpdateArgs<ExtArgs>>): Prisma__qualite_sites_baignadeClient<$Result.GetResult<Prisma.$qualite_sites_baignadePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Qualite_sites_baignades.
     * @param {qualite_sites_baignadeDeleteManyArgs} args - Arguments to filter Qualite_sites_baignades to delete.
     * @example
     * // Delete a few Qualite_sites_baignades
     * const { count } = await prisma.qualite_sites_baignade.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends qualite_sites_baignadeDeleteManyArgs>(args?: SelectSubset<T, qualite_sites_baignadeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Qualite_sites_baignades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qualite_sites_baignadeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Qualite_sites_baignades
     * const qualite_sites_baignade = await prisma.qualite_sites_baignade.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends qualite_sites_baignadeUpdateManyArgs>(args: SelectSubset<T, qualite_sites_baignadeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Qualite_sites_baignades and returns the data updated in the database.
     * @param {qualite_sites_baignadeUpdateManyAndReturnArgs} args - Arguments to update many Qualite_sites_baignades.
     * @example
     * // Update many Qualite_sites_baignades
     * const qualite_sites_baignade = await prisma.qualite_sites_baignade.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Qualite_sites_baignades and only return the `index`
     * const qualite_sites_baignadeWithIndexOnly = await prisma.qualite_sites_baignade.updateManyAndReturn({
     *   select: { index: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends qualite_sites_baignadeUpdateManyAndReturnArgs>(args: SelectSubset<T, qualite_sites_baignadeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$qualite_sites_baignadePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Qualite_sites_baignade.
     * @param {qualite_sites_baignadeUpsertArgs} args - Arguments to update or create a Qualite_sites_baignade.
     * @example
     * // Update or create a Qualite_sites_baignade
     * const qualite_sites_baignade = await prisma.qualite_sites_baignade.upsert({
     *   create: {
     *     // ... data to create a Qualite_sites_baignade
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Qualite_sites_baignade we want to update
     *   }
     * })
     */
    upsert<T extends qualite_sites_baignadeUpsertArgs>(args: SelectSubset<T, qualite_sites_baignadeUpsertArgs<ExtArgs>>): Prisma__qualite_sites_baignadeClient<$Result.GetResult<Prisma.$qualite_sites_baignadePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Qualite_sites_baignades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qualite_sites_baignadeCountArgs} args - Arguments to filter Qualite_sites_baignades to count.
     * @example
     * // Count the number of Qualite_sites_baignades
     * const count = await prisma.qualite_sites_baignade.count({
     *   where: {
     *     // ... the filter for the Qualite_sites_baignades we want to count
     *   }
     * })
    **/
    count<T extends qualite_sites_baignadeCountArgs>(
      args?: Subset<T, qualite_sites_baignadeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Qualite_sites_baignadeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Qualite_sites_baignade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Qualite_sites_baignadeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Qualite_sites_baignadeAggregateArgs>(args: Subset<T, Qualite_sites_baignadeAggregateArgs>): Prisma.PrismaPromise<GetQualite_sites_baignadeAggregateType<T>>

    /**
     * Group by Qualite_sites_baignade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {qualite_sites_baignadeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends qualite_sites_baignadeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: qualite_sites_baignadeGroupByArgs['orderBy'] }
        : { orderBy?: qualite_sites_baignadeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, qualite_sites_baignadeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQualite_sites_baignadeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the qualite_sites_baignade model
   */
  readonly fields: qualite_sites_baignadeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for qualite_sites_baignade.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__qualite_sites_baignadeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the qualite_sites_baignade model
   */
  interface qualite_sites_baignadeFieldRefs {
    readonly index: FieldRef<"qualite_sites_baignade", 'Int'>
    readonly DEP_NOM: FieldRef<"qualite_sites_baignade", 'String'>
    readonly DEP_NUM: FieldRef<"qualite_sites_baignade", 'String'>
    readonly TYPE: FieldRef<"qualite_sites_baignade", 'String'>
    readonly COMMUNE: FieldRef<"qualite_sites_baignade", 'String'>
    readonly POINT: FieldRef<"qualite_sites_baignade", 'String'>
    readonly LONG: FieldRef<"qualite_sites_baignade", 'Float'>
    readonly LAT: FieldRef<"qualite_sites_baignade", 'Float'>
    readonly QEB_2013: FieldRef<"qualite_sites_baignade", 'String'>
    readonly QEB_2014: FieldRef<"qualite_sites_baignade", 'String'>
    readonly QEB_2015: FieldRef<"qualite_sites_baignade", 'String'>
    readonly QEB_2016: FieldRef<"qualite_sites_baignade", 'String'>
    readonly QEB_2017: FieldRef<"qualite_sites_baignade", 'String'>
    readonly QEB_2018: FieldRef<"qualite_sites_baignade", 'String'>
    readonly QEB_2019: FieldRef<"qualite_sites_baignade", 'String'>
    readonly QEB_2020: FieldRef<"qualite_sites_baignade", 'String'>
  }
    

  // Custom InputTypes
  /**
   * qualite_sites_baignade findUnique
   */
  export type qualite_sites_baignadeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qualite_sites_baignade
     */
    select?: qualite_sites_baignadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qualite_sites_baignade
     */
    omit?: qualite_sites_baignadeOmit<ExtArgs> | null
    /**
     * Filter, which qualite_sites_baignade to fetch.
     */
    where: qualite_sites_baignadeWhereUniqueInput
  }

  /**
   * qualite_sites_baignade findUniqueOrThrow
   */
  export type qualite_sites_baignadeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qualite_sites_baignade
     */
    select?: qualite_sites_baignadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qualite_sites_baignade
     */
    omit?: qualite_sites_baignadeOmit<ExtArgs> | null
    /**
     * Filter, which qualite_sites_baignade to fetch.
     */
    where: qualite_sites_baignadeWhereUniqueInput
  }

  /**
   * qualite_sites_baignade findFirst
   */
  export type qualite_sites_baignadeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qualite_sites_baignade
     */
    select?: qualite_sites_baignadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qualite_sites_baignade
     */
    omit?: qualite_sites_baignadeOmit<ExtArgs> | null
    /**
     * Filter, which qualite_sites_baignade to fetch.
     */
    where?: qualite_sites_baignadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qualite_sites_baignades to fetch.
     */
    orderBy?: qualite_sites_baignadeOrderByWithRelationInput | qualite_sites_baignadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for qualite_sites_baignades.
     */
    cursor?: qualite_sites_baignadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qualite_sites_baignades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qualite_sites_baignades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of qualite_sites_baignades.
     */
    distinct?: Qualite_sites_baignadeScalarFieldEnum | Qualite_sites_baignadeScalarFieldEnum[]
  }

  /**
   * qualite_sites_baignade findFirstOrThrow
   */
  export type qualite_sites_baignadeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qualite_sites_baignade
     */
    select?: qualite_sites_baignadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qualite_sites_baignade
     */
    omit?: qualite_sites_baignadeOmit<ExtArgs> | null
    /**
     * Filter, which qualite_sites_baignade to fetch.
     */
    where?: qualite_sites_baignadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qualite_sites_baignades to fetch.
     */
    orderBy?: qualite_sites_baignadeOrderByWithRelationInput | qualite_sites_baignadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for qualite_sites_baignades.
     */
    cursor?: qualite_sites_baignadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qualite_sites_baignades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qualite_sites_baignades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of qualite_sites_baignades.
     */
    distinct?: Qualite_sites_baignadeScalarFieldEnum | Qualite_sites_baignadeScalarFieldEnum[]
  }

  /**
   * qualite_sites_baignade findMany
   */
  export type qualite_sites_baignadeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qualite_sites_baignade
     */
    select?: qualite_sites_baignadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qualite_sites_baignade
     */
    omit?: qualite_sites_baignadeOmit<ExtArgs> | null
    /**
     * Filter, which qualite_sites_baignades to fetch.
     */
    where?: qualite_sites_baignadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of qualite_sites_baignades to fetch.
     */
    orderBy?: qualite_sites_baignadeOrderByWithRelationInput | qualite_sites_baignadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing qualite_sites_baignades.
     */
    cursor?: qualite_sites_baignadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` qualite_sites_baignades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` qualite_sites_baignades.
     */
    skip?: number
    distinct?: Qualite_sites_baignadeScalarFieldEnum | Qualite_sites_baignadeScalarFieldEnum[]
  }

  /**
   * qualite_sites_baignade create
   */
  export type qualite_sites_baignadeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qualite_sites_baignade
     */
    select?: qualite_sites_baignadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qualite_sites_baignade
     */
    omit?: qualite_sites_baignadeOmit<ExtArgs> | null
    /**
     * The data needed to create a qualite_sites_baignade.
     */
    data: XOR<qualite_sites_baignadeCreateInput, qualite_sites_baignadeUncheckedCreateInput>
  }

  /**
   * qualite_sites_baignade createMany
   */
  export type qualite_sites_baignadeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many qualite_sites_baignades.
     */
    data: qualite_sites_baignadeCreateManyInput | qualite_sites_baignadeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * qualite_sites_baignade createManyAndReturn
   */
  export type qualite_sites_baignadeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qualite_sites_baignade
     */
    select?: qualite_sites_baignadeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the qualite_sites_baignade
     */
    omit?: qualite_sites_baignadeOmit<ExtArgs> | null
    /**
     * The data used to create many qualite_sites_baignades.
     */
    data: qualite_sites_baignadeCreateManyInput | qualite_sites_baignadeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * qualite_sites_baignade update
   */
  export type qualite_sites_baignadeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qualite_sites_baignade
     */
    select?: qualite_sites_baignadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qualite_sites_baignade
     */
    omit?: qualite_sites_baignadeOmit<ExtArgs> | null
    /**
     * The data needed to update a qualite_sites_baignade.
     */
    data: XOR<qualite_sites_baignadeUpdateInput, qualite_sites_baignadeUncheckedUpdateInput>
    /**
     * Choose, which qualite_sites_baignade to update.
     */
    where: qualite_sites_baignadeWhereUniqueInput
  }

  /**
   * qualite_sites_baignade updateMany
   */
  export type qualite_sites_baignadeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update qualite_sites_baignades.
     */
    data: XOR<qualite_sites_baignadeUpdateManyMutationInput, qualite_sites_baignadeUncheckedUpdateManyInput>
    /**
     * Filter which qualite_sites_baignades to update
     */
    where?: qualite_sites_baignadeWhereInput
    /**
     * Limit how many qualite_sites_baignades to update.
     */
    limit?: number
  }

  /**
   * qualite_sites_baignade updateManyAndReturn
   */
  export type qualite_sites_baignadeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qualite_sites_baignade
     */
    select?: qualite_sites_baignadeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the qualite_sites_baignade
     */
    omit?: qualite_sites_baignadeOmit<ExtArgs> | null
    /**
     * The data used to update qualite_sites_baignades.
     */
    data: XOR<qualite_sites_baignadeUpdateManyMutationInput, qualite_sites_baignadeUncheckedUpdateManyInput>
    /**
     * Filter which qualite_sites_baignades to update
     */
    where?: qualite_sites_baignadeWhereInput
    /**
     * Limit how many qualite_sites_baignades to update.
     */
    limit?: number
  }

  /**
   * qualite_sites_baignade upsert
   */
  export type qualite_sites_baignadeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qualite_sites_baignade
     */
    select?: qualite_sites_baignadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qualite_sites_baignade
     */
    omit?: qualite_sites_baignadeOmit<ExtArgs> | null
    /**
     * The filter to search for the qualite_sites_baignade to update in case it exists.
     */
    where: qualite_sites_baignadeWhereUniqueInput
    /**
     * In case the qualite_sites_baignade found by the `where` argument doesn't exist, create a new qualite_sites_baignade with this data.
     */
    create: XOR<qualite_sites_baignadeCreateInput, qualite_sites_baignadeUncheckedCreateInput>
    /**
     * In case the qualite_sites_baignade was found with the provided `where` argument, update it with this data.
     */
    update: XOR<qualite_sites_baignadeUpdateInput, qualite_sites_baignadeUncheckedUpdateInput>
  }

  /**
   * qualite_sites_baignade delete
   */
  export type qualite_sites_baignadeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qualite_sites_baignade
     */
    select?: qualite_sites_baignadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qualite_sites_baignade
     */
    omit?: qualite_sites_baignadeOmit<ExtArgs> | null
    /**
     * Filter which qualite_sites_baignade to delete.
     */
    where: qualite_sites_baignadeWhereUniqueInput
  }

  /**
   * qualite_sites_baignade deleteMany
   */
  export type qualite_sites_baignadeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which qualite_sites_baignades to delete
     */
    where?: qualite_sites_baignadeWhereInput
    /**
     * Limit how many qualite_sites_baignades to delete.
     */
    limit?: number
  }

  /**
   * qualite_sites_baignade without action
   */
  export type qualite_sites_baignadeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the qualite_sites_baignade
     */
    select?: qualite_sites_baignadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the qualite_sites_baignade
     */
    omit?: qualite_sites_baignadeOmit<ExtArgs> | null
  }


  /**
   * Model ressources_eau
   */

  export type AggregateRessources_eau = {
    _count: Ressources_eauCountAggregateOutputType | null
    _avg: Ressources_eauAvgAggregateOutputType | null
    _sum: Ressources_eauSumAggregateOutputType | null
    _min: Ressources_eauMinAggregateOutputType | null
    _max: Ressources_eauMaxAggregateOutputType | null
  }

  export type Ressources_eauAvgAggregateOutputType = {
    index: number | null
    A2020: number | null
    A2019: number | null
    A2018: number | null
    A2017: number | null
    A2016: number | null
    A2015: number | null
    A2014: number | null
    A2013: number | null
    A2012: number | null
    A2011: number | null
    A2010: number | null
    A2009: number | null
    A2008: number | null
    region: number | null
  }

  export type Ressources_eauSumAggregateOutputType = {
    index: number | null
    A2020: number | null
    A2019: number | null
    A2018: number | null
    A2017: number | null
    A2016: number | null
    A2015: number | null
    A2014: number | null
    A2013: number | null
    A2012: number | null
    A2011: number | null
    A2010: number | null
    A2009: number | null
    A2008: number | null
    region: number | null
  }

  export type Ressources_eauMinAggregateOutputType = {
    index: number | null
    code_geographique: string | null
    LIBELLE_SOUS_CHAMP: string | null
    A2020: number | null
    A2019: number | null
    A2018: number | null
    A2017: number | null
    A2016: number | null
    A2015: number | null
    A2014: number | null
    A2013: number | null
    A2012: number | null
    A2011: number | null
    A2010: number | null
    A2009: number | null
    A2008: number | null
    SOUS_CHAMP: string | null
    libelle_geographique: string | null
    epci: string | null
    libelle_epci: string | null
    departement: string | null
    libelle_departement: string | null
    region: number | null
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
  }

  export type Ressources_eauMaxAggregateOutputType = {
    index: number | null
    code_geographique: string | null
    LIBELLE_SOUS_CHAMP: string | null
    A2020: number | null
    A2019: number | null
    A2018: number | null
    A2017: number | null
    A2016: number | null
    A2015: number | null
    A2014: number | null
    A2013: number | null
    A2012: number | null
    A2011: number | null
    A2010: number | null
    A2009: number | null
    A2008: number | null
    SOUS_CHAMP: string | null
    libelle_geographique: string | null
    epci: string | null
    libelle_epci: string | null
    departement: string | null
    libelle_departement: string | null
    region: number | null
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
  }

  export type Ressources_eauCountAggregateOutputType = {
    index: number
    code_geographique: number
    LIBELLE_SOUS_CHAMP: number
    A2020: number
    A2019: number
    A2018: number
    A2017: number
    A2016: number
    A2015: number
    A2014: number
    A2013: number
    A2012: number
    A2011: number
    A2010: number
    A2009: number
    A2008: number
    SOUS_CHAMP: number
    libelle_geographique: number
    epci: number
    libelle_epci: number
    departement: number
    libelle_departement: number
    region: number
    ept: number
    libelle_petr: number
    code_pnr: number
    libelle_pnr: number
    _all: number
  }


  export type Ressources_eauAvgAggregateInputType = {
    index?: true
    A2020?: true
    A2019?: true
    A2018?: true
    A2017?: true
    A2016?: true
    A2015?: true
    A2014?: true
    A2013?: true
    A2012?: true
    A2011?: true
    A2010?: true
    A2009?: true
    A2008?: true
    region?: true
  }

  export type Ressources_eauSumAggregateInputType = {
    index?: true
    A2020?: true
    A2019?: true
    A2018?: true
    A2017?: true
    A2016?: true
    A2015?: true
    A2014?: true
    A2013?: true
    A2012?: true
    A2011?: true
    A2010?: true
    A2009?: true
    A2008?: true
    region?: true
  }

  export type Ressources_eauMinAggregateInputType = {
    index?: true
    code_geographique?: true
    LIBELLE_SOUS_CHAMP?: true
    A2020?: true
    A2019?: true
    A2018?: true
    A2017?: true
    A2016?: true
    A2015?: true
    A2014?: true
    A2013?: true
    A2012?: true
    A2011?: true
    A2010?: true
    A2009?: true
    A2008?: true
    SOUS_CHAMP?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
  }

  export type Ressources_eauMaxAggregateInputType = {
    index?: true
    code_geographique?: true
    LIBELLE_SOUS_CHAMP?: true
    A2020?: true
    A2019?: true
    A2018?: true
    A2017?: true
    A2016?: true
    A2015?: true
    A2014?: true
    A2013?: true
    A2012?: true
    A2011?: true
    A2010?: true
    A2009?: true
    A2008?: true
    SOUS_CHAMP?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
  }

  export type Ressources_eauCountAggregateInputType = {
    index?: true
    code_geographique?: true
    LIBELLE_SOUS_CHAMP?: true
    A2020?: true
    A2019?: true
    A2018?: true
    A2017?: true
    A2016?: true
    A2015?: true
    A2014?: true
    A2013?: true
    A2012?: true
    A2011?: true
    A2010?: true
    A2009?: true
    A2008?: true
    SOUS_CHAMP?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
    _all?: true
  }

  export type Ressources_eauAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ressources_eau to aggregate.
     */
    where?: ressources_eauWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ressources_eaus to fetch.
     */
    orderBy?: ressources_eauOrderByWithRelationInput | ressources_eauOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ressources_eauWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ressources_eaus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ressources_eaus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ressources_eaus
    **/
    _count?: true | Ressources_eauCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ressources_eauAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ressources_eauSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ressources_eauMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ressources_eauMaxAggregateInputType
  }

  export type GetRessources_eauAggregateType<T extends Ressources_eauAggregateArgs> = {
        [P in keyof T & keyof AggregateRessources_eau]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRessources_eau[P]>
      : GetScalarType<T[P], AggregateRessources_eau[P]>
  }




  export type ressources_eauGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ressources_eauWhereInput
    orderBy?: ressources_eauOrderByWithAggregationInput | ressources_eauOrderByWithAggregationInput[]
    by: Ressources_eauScalarFieldEnum[] | Ressources_eauScalarFieldEnum
    having?: ressources_eauScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ressources_eauCountAggregateInputType | true
    _avg?: Ressources_eauAvgAggregateInputType
    _sum?: Ressources_eauSumAggregateInputType
    _min?: Ressources_eauMinAggregateInputType
    _max?: Ressources_eauMaxAggregateInputType
  }

  export type Ressources_eauGroupByOutputType = {
    index: number
    code_geographique: string
    LIBELLE_SOUS_CHAMP: string
    A2020: number
    A2019: number
    A2018: number
    A2017: number
    A2016: number
    A2015: number
    A2014: number
    A2013: number
    A2012: number
    A2011: number
    A2010: number
    A2009: number
    A2008: number
    SOUS_CHAMP: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
    _count: Ressources_eauCountAggregateOutputType | null
    _avg: Ressources_eauAvgAggregateOutputType | null
    _sum: Ressources_eauSumAggregateOutputType | null
    _min: Ressources_eauMinAggregateOutputType | null
    _max: Ressources_eauMaxAggregateOutputType | null
  }

  type GetRessources_eauGroupByPayload<T extends ressources_eauGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Ressources_eauGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ressources_eauGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ressources_eauGroupByOutputType[P]>
            : GetScalarType<T[P], Ressources_eauGroupByOutputType[P]>
        }
      >
    >


  export type ressources_eauSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    LIBELLE_SOUS_CHAMP?: boolean
    A2020?: boolean
    A2019?: boolean
    A2018?: boolean
    A2017?: boolean
    A2016?: boolean
    A2015?: boolean
    A2014?: boolean
    A2013?: boolean
    A2012?: boolean
    A2011?: boolean
    A2010?: boolean
    A2009?: boolean
    A2008?: boolean
    SOUS_CHAMP?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
  }, ExtArgs["result"]["ressources_eau"]>

  export type ressources_eauSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    LIBELLE_SOUS_CHAMP?: boolean
    A2020?: boolean
    A2019?: boolean
    A2018?: boolean
    A2017?: boolean
    A2016?: boolean
    A2015?: boolean
    A2014?: boolean
    A2013?: boolean
    A2012?: boolean
    A2011?: boolean
    A2010?: boolean
    A2009?: boolean
    A2008?: boolean
    SOUS_CHAMP?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
  }, ExtArgs["result"]["ressources_eau"]>

  export type ressources_eauSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    LIBELLE_SOUS_CHAMP?: boolean
    A2020?: boolean
    A2019?: boolean
    A2018?: boolean
    A2017?: boolean
    A2016?: boolean
    A2015?: boolean
    A2014?: boolean
    A2013?: boolean
    A2012?: boolean
    A2011?: boolean
    A2010?: boolean
    A2009?: boolean
    A2008?: boolean
    SOUS_CHAMP?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
  }, ExtArgs["result"]["ressources_eau"]>

  export type ressources_eauSelectScalar = {
    index?: boolean
    code_geographique?: boolean
    LIBELLE_SOUS_CHAMP?: boolean
    A2020?: boolean
    A2019?: boolean
    A2018?: boolean
    A2017?: boolean
    A2016?: boolean
    A2015?: boolean
    A2014?: boolean
    A2013?: boolean
    A2012?: boolean
    A2011?: boolean
    A2010?: boolean
    A2009?: boolean
    A2008?: boolean
    SOUS_CHAMP?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
  }

  export type ressources_eauOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"index" | "code_geographique" | "LIBELLE_SOUS_CHAMP" | "A2020" | "A2019" | "A2018" | "A2017" | "A2016" | "A2015" | "A2014" | "A2013" | "A2012" | "A2011" | "A2010" | "A2009" | "A2008" | "SOUS_CHAMP" | "libelle_geographique" | "epci" | "libelle_epci" | "departement" | "libelle_departement" | "region" | "ept" | "libelle_petr" | "code_pnr" | "libelle_pnr", ExtArgs["result"]["ressources_eau"]>

  export type $ressources_eauPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ressources_eau"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      index: number
      code_geographique: string
      LIBELLE_SOUS_CHAMP: string
      A2020: number
      A2019: number
      A2018: number
      A2017: number
      A2016: number
      A2015: number
      A2014: number
      A2013: number
      A2012: number
      A2011: number
      A2010: number
      A2009: number
      A2008: number
      SOUS_CHAMP: string
      libelle_geographique: string
      epci: string
      libelle_epci: string
      departement: string
      libelle_departement: string
      region: number
      ept: string | null
      libelle_petr: string | null
      code_pnr: string | null
      libelle_pnr: string | null
    }, ExtArgs["result"]["ressources_eau"]>
    composites: {}
  }

  type ressources_eauGetPayload<S extends boolean | null | undefined | ressources_eauDefaultArgs> = $Result.GetResult<Prisma.$ressources_eauPayload, S>

  type ressources_eauCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ressources_eauFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Ressources_eauCountAggregateInputType | true
    }

  export interface ressources_eauDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ressources_eau'], meta: { name: 'ressources_eau' } }
    /**
     * Find zero or one Ressources_eau that matches the filter.
     * @param {ressources_eauFindUniqueArgs} args - Arguments to find a Ressources_eau
     * @example
     * // Get one Ressources_eau
     * const ressources_eau = await prisma.ressources_eau.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ressources_eauFindUniqueArgs>(args: SelectSubset<T, ressources_eauFindUniqueArgs<ExtArgs>>): Prisma__ressources_eauClient<$Result.GetResult<Prisma.$ressources_eauPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ressources_eau that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ressources_eauFindUniqueOrThrowArgs} args - Arguments to find a Ressources_eau
     * @example
     * // Get one Ressources_eau
     * const ressources_eau = await prisma.ressources_eau.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ressources_eauFindUniqueOrThrowArgs>(args: SelectSubset<T, ressources_eauFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ressources_eauClient<$Result.GetResult<Prisma.$ressources_eauPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ressources_eau that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ressources_eauFindFirstArgs} args - Arguments to find a Ressources_eau
     * @example
     * // Get one Ressources_eau
     * const ressources_eau = await prisma.ressources_eau.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ressources_eauFindFirstArgs>(args?: SelectSubset<T, ressources_eauFindFirstArgs<ExtArgs>>): Prisma__ressources_eauClient<$Result.GetResult<Prisma.$ressources_eauPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ressources_eau that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ressources_eauFindFirstOrThrowArgs} args - Arguments to find a Ressources_eau
     * @example
     * // Get one Ressources_eau
     * const ressources_eau = await prisma.ressources_eau.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ressources_eauFindFirstOrThrowArgs>(args?: SelectSubset<T, ressources_eauFindFirstOrThrowArgs<ExtArgs>>): Prisma__ressources_eauClient<$Result.GetResult<Prisma.$ressources_eauPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ressources_eaus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ressources_eauFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ressources_eaus
     * const ressources_eaus = await prisma.ressources_eau.findMany()
     * 
     * // Get first 10 Ressources_eaus
     * const ressources_eaus = await prisma.ressources_eau.findMany({ take: 10 })
     * 
     * // Only select the `index`
     * const ressources_eauWithIndexOnly = await prisma.ressources_eau.findMany({ select: { index: true } })
     * 
     */
    findMany<T extends ressources_eauFindManyArgs>(args?: SelectSubset<T, ressources_eauFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ressources_eauPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ressources_eau.
     * @param {ressources_eauCreateArgs} args - Arguments to create a Ressources_eau.
     * @example
     * // Create one Ressources_eau
     * const Ressources_eau = await prisma.ressources_eau.create({
     *   data: {
     *     // ... data to create a Ressources_eau
     *   }
     * })
     * 
     */
    create<T extends ressources_eauCreateArgs>(args: SelectSubset<T, ressources_eauCreateArgs<ExtArgs>>): Prisma__ressources_eauClient<$Result.GetResult<Prisma.$ressources_eauPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ressources_eaus.
     * @param {ressources_eauCreateManyArgs} args - Arguments to create many Ressources_eaus.
     * @example
     * // Create many Ressources_eaus
     * const ressources_eau = await prisma.ressources_eau.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ressources_eauCreateManyArgs>(args?: SelectSubset<T, ressources_eauCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ressources_eaus and returns the data saved in the database.
     * @param {ressources_eauCreateManyAndReturnArgs} args - Arguments to create many Ressources_eaus.
     * @example
     * // Create many Ressources_eaus
     * const ressources_eau = await prisma.ressources_eau.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ressources_eaus and only return the `index`
     * const ressources_eauWithIndexOnly = await prisma.ressources_eau.createManyAndReturn({
     *   select: { index: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ressources_eauCreateManyAndReturnArgs>(args?: SelectSubset<T, ressources_eauCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ressources_eauPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ressources_eau.
     * @param {ressources_eauDeleteArgs} args - Arguments to delete one Ressources_eau.
     * @example
     * // Delete one Ressources_eau
     * const Ressources_eau = await prisma.ressources_eau.delete({
     *   where: {
     *     // ... filter to delete one Ressources_eau
     *   }
     * })
     * 
     */
    delete<T extends ressources_eauDeleteArgs>(args: SelectSubset<T, ressources_eauDeleteArgs<ExtArgs>>): Prisma__ressources_eauClient<$Result.GetResult<Prisma.$ressources_eauPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ressources_eau.
     * @param {ressources_eauUpdateArgs} args - Arguments to update one Ressources_eau.
     * @example
     * // Update one Ressources_eau
     * const ressources_eau = await prisma.ressources_eau.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ressources_eauUpdateArgs>(args: SelectSubset<T, ressources_eauUpdateArgs<ExtArgs>>): Prisma__ressources_eauClient<$Result.GetResult<Prisma.$ressources_eauPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ressources_eaus.
     * @param {ressources_eauDeleteManyArgs} args - Arguments to filter Ressources_eaus to delete.
     * @example
     * // Delete a few Ressources_eaus
     * const { count } = await prisma.ressources_eau.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ressources_eauDeleteManyArgs>(args?: SelectSubset<T, ressources_eauDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ressources_eaus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ressources_eauUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ressources_eaus
     * const ressources_eau = await prisma.ressources_eau.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ressources_eauUpdateManyArgs>(args: SelectSubset<T, ressources_eauUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ressources_eaus and returns the data updated in the database.
     * @param {ressources_eauUpdateManyAndReturnArgs} args - Arguments to update many Ressources_eaus.
     * @example
     * // Update many Ressources_eaus
     * const ressources_eau = await prisma.ressources_eau.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ressources_eaus and only return the `index`
     * const ressources_eauWithIndexOnly = await prisma.ressources_eau.updateManyAndReturn({
     *   select: { index: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ressources_eauUpdateManyAndReturnArgs>(args: SelectSubset<T, ressources_eauUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ressources_eauPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ressources_eau.
     * @param {ressources_eauUpsertArgs} args - Arguments to update or create a Ressources_eau.
     * @example
     * // Update or create a Ressources_eau
     * const ressources_eau = await prisma.ressources_eau.upsert({
     *   create: {
     *     // ... data to create a Ressources_eau
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ressources_eau we want to update
     *   }
     * })
     */
    upsert<T extends ressources_eauUpsertArgs>(args: SelectSubset<T, ressources_eauUpsertArgs<ExtArgs>>): Prisma__ressources_eauClient<$Result.GetResult<Prisma.$ressources_eauPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ressources_eaus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ressources_eauCountArgs} args - Arguments to filter Ressources_eaus to count.
     * @example
     * // Count the number of Ressources_eaus
     * const count = await prisma.ressources_eau.count({
     *   where: {
     *     // ... the filter for the Ressources_eaus we want to count
     *   }
     * })
    **/
    count<T extends ressources_eauCountArgs>(
      args?: Subset<T, ressources_eauCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ressources_eauCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ressources_eau.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ressources_eauAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ressources_eauAggregateArgs>(args: Subset<T, Ressources_eauAggregateArgs>): Prisma.PrismaPromise<GetRessources_eauAggregateType<T>>

    /**
     * Group by Ressources_eau.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ressources_eauGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ressources_eauGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ressources_eauGroupByArgs['orderBy'] }
        : { orderBy?: ressources_eauGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ressources_eauGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRessources_eauGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ressources_eau model
   */
  readonly fields: ressources_eauFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ressources_eau.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ressources_eauClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ressources_eau model
   */
  interface ressources_eauFieldRefs {
    readonly index: FieldRef<"ressources_eau", 'Int'>
    readonly code_geographique: FieldRef<"ressources_eau", 'String'>
    readonly LIBELLE_SOUS_CHAMP: FieldRef<"ressources_eau", 'String'>
    readonly A2020: FieldRef<"ressources_eau", 'Float'>
    readonly A2019: FieldRef<"ressources_eau", 'Float'>
    readonly A2018: FieldRef<"ressources_eau", 'Float'>
    readonly A2017: FieldRef<"ressources_eau", 'Float'>
    readonly A2016: FieldRef<"ressources_eau", 'Float'>
    readonly A2015: FieldRef<"ressources_eau", 'Float'>
    readonly A2014: FieldRef<"ressources_eau", 'Float'>
    readonly A2013: FieldRef<"ressources_eau", 'Float'>
    readonly A2012: FieldRef<"ressources_eau", 'Float'>
    readonly A2011: FieldRef<"ressources_eau", 'Float'>
    readonly A2010: FieldRef<"ressources_eau", 'Float'>
    readonly A2009: FieldRef<"ressources_eau", 'Float'>
    readonly A2008: FieldRef<"ressources_eau", 'Float'>
    readonly SOUS_CHAMP: FieldRef<"ressources_eau", 'String'>
    readonly libelle_geographique: FieldRef<"ressources_eau", 'String'>
    readonly epci: FieldRef<"ressources_eau", 'String'>
    readonly libelle_epci: FieldRef<"ressources_eau", 'String'>
    readonly departement: FieldRef<"ressources_eau", 'String'>
    readonly libelle_departement: FieldRef<"ressources_eau", 'String'>
    readonly region: FieldRef<"ressources_eau", 'Float'>
    readonly ept: FieldRef<"ressources_eau", 'String'>
    readonly libelle_petr: FieldRef<"ressources_eau", 'String'>
    readonly code_pnr: FieldRef<"ressources_eau", 'String'>
    readonly libelle_pnr: FieldRef<"ressources_eau", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ressources_eau findUnique
   */
  export type ressources_eauFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ressources_eau
     */
    select?: ressources_eauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ressources_eau
     */
    omit?: ressources_eauOmit<ExtArgs> | null
    /**
     * Filter, which ressources_eau to fetch.
     */
    where: ressources_eauWhereUniqueInput
  }

  /**
   * ressources_eau findUniqueOrThrow
   */
  export type ressources_eauFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ressources_eau
     */
    select?: ressources_eauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ressources_eau
     */
    omit?: ressources_eauOmit<ExtArgs> | null
    /**
     * Filter, which ressources_eau to fetch.
     */
    where: ressources_eauWhereUniqueInput
  }

  /**
   * ressources_eau findFirst
   */
  export type ressources_eauFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ressources_eau
     */
    select?: ressources_eauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ressources_eau
     */
    omit?: ressources_eauOmit<ExtArgs> | null
    /**
     * Filter, which ressources_eau to fetch.
     */
    where?: ressources_eauWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ressources_eaus to fetch.
     */
    orderBy?: ressources_eauOrderByWithRelationInput | ressources_eauOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ressources_eaus.
     */
    cursor?: ressources_eauWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ressources_eaus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ressources_eaus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ressources_eaus.
     */
    distinct?: Ressources_eauScalarFieldEnum | Ressources_eauScalarFieldEnum[]
  }

  /**
   * ressources_eau findFirstOrThrow
   */
  export type ressources_eauFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ressources_eau
     */
    select?: ressources_eauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ressources_eau
     */
    omit?: ressources_eauOmit<ExtArgs> | null
    /**
     * Filter, which ressources_eau to fetch.
     */
    where?: ressources_eauWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ressources_eaus to fetch.
     */
    orderBy?: ressources_eauOrderByWithRelationInput | ressources_eauOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ressources_eaus.
     */
    cursor?: ressources_eauWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ressources_eaus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ressources_eaus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ressources_eaus.
     */
    distinct?: Ressources_eauScalarFieldEnum | Ressources_eauScalarFieldEnum[]
  }

  /**
   * ressources_eau findMany
   */
  export type ressources_eauFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ressources_eau
     */
    select?: ressources_eauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ressources_eau
     */
    omit?: ressources_eauOmit<ExtArgs> | null
    /**
     * Filter, which ressources_eaus to fetch.
     */
    where?: ressources_eauWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ressources_eaus to fetch.
     */
    orderBy?: ressources_eauOrderByWithRelationInput | ressources_eauOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ressources_eaus.
     */
    cursor?: ressources_eauWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ressources_eaus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ressources_eaus.
     */
    skip?: number
    distinct?: Ressources_eauScalarFieldEnum | Ressources_eauScalarFieldEnum[]
  }

  /**
   * ressources_eau create
   */
  export type ressources_eauCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ressources_eau
     */
    select?: ressources_eauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ressources_eau
     */
    omit?: ressources_eauOmit<ExtArgs> | null
    /**
     * The data needed to create a ressources_eau.
     */
    data: XOR<ressources_eauCreateInput, ressources_eauUncheckedCreateInput>
  }

  /**
   * ressources_eau createMany
   */
  export type ressources_eauCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ressources_eaus.
     */
    data: ressources_eauCreateManyInput | ressources_eauCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ressources_eau createManyAndReturn
   */
  export type ressources_eauCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ressources_eau
     */
    select?: ressources_eauSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ressources_eau
     */
    omit?: ressources_eauOmit<ExtArgs> | null
    /**
     * The data used to create many ressources_eaus.
     */
    data: ressources_eauCreateManyInput | ressources_eauCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ressources_eau update
   */
  export type ressources_eauUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ressources_eau
     */
    select?: ressources_eauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ressources_eau
     */
    omit?: ressources_eauOmit<ExtArgs> | null
    /**
     * The data needed to update a ressources_eau.
     */
    data: XOR<ressources_eauUpdateInput, ressources_eauUncheckedUpdateInput>
    /**
     * Choose, which ressources_eau to update.
     */
    where: ressources_eauWhereUniqueInput
  }

  /**
   * ressources_eau updateMany
   */
  export type ressources_eauUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ressources_eaus.
     */
    data: XOR<ressources_eauUpdateManyMutationInput, ressources_eauUncheckedUpdateManyInput>
    /**
     * Filter which ressources_eaus to update
     */
    where?: ressources_eauWhereInput
    /**
     * Limit how many ressources_eaus to update.
     */
    limit?: number
  }

  /**
   * ressources_eau updateManyAndReturn
   */
  export type ressources_eauUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ressources_eau
     */
    select?: ressources_eauSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ressources_eau
     */
    omit?: ressources_eauOmit<ExtArgs> | null
    /**
     * The data used to update ressources_eaus.
     */
    data: XOR<ressources_eauUpdateManyMutationInput, ressources_eauUncheckedUpdateManyInput>
    /**
     * Filter which ressources_eaus to update
     */
    where?: ressources_eauWhereInput
    /**
     * Limit how many ressources_eaus to update.
     */
    limit?: number
  }

  /**
   * ressources_eau upsert
   */
  export type ressources_eauUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ressources_eau
     */
    select?: ressources_eauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ressources_eau
     */
    omit?: ressources_eauOmit<ExtArgs> | null
    /**
     * The filter to search for the ressources_eau to update in case it exists.
     */
    where: ressources_eauWhereUniqueInput
    /**
     * In case the ressources_eau found by the `where` argument doesn't exist, create a new ressources_eau with this data.
     */
    create: XOR<ressources_eauCreateInput, ressources_eauUncheckedCreateInput>
    /**
     * In case the ressources_eau was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ressources_eauUpdateInput, ressources_eauUncheckedUpdateInput>
  }

  /**
   * ressources_eau delete
   */
  export type ressources_eauDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ressources_eau
     */
    select?: ressources_eauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ressources_eau
     */
    omit?: ressources_eauOmit<ExtArgs> | null
    /**
     * Filter which ressources_eau to delete.
     */
    where: ressources_eauWhereUniqueInput
  }

  /**
   * ressources_eau deleteMany
   */
  export type ressources_eauDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ressources_eaus to delete
     */
    where?: ressources_eauWhereInput
    /**
     * Limit how many ressources_eaus to delete.
     */
    limit?: number
  }

  /**
   * ressources_eau without action
   */
  export type ressources_eauDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ressources_eau
     */
    select?: ressources_eauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ressources_eau
     */
    omit?: ressources_eauOmit<ExtArgs> | null
  }


  /**
   * Model rga
   */

  export type AggregateRga = {
    _count: RgaCountAggregateOutputType | null
    _avg: RgaAvgAggregateOutputType | null
    _sum: RgaSumAggregateOutputType | null
    _min: RgaMinAggregateOutputType | null
    _max: RgaMaxAggregateOutputType | null
  }

  export type RgaAvgAggregateOutputType = {
    index: number | null
    region: number | null
    nb_logement: number | null
    nb_logement_alea_moyen_fort: number | null
    nb_logement_alea_faible: number | null
    nb_logement_sans_alea: number | null
    nb_logement_alea_moyen_fort_avant_1920: number | null
    nb_logement_alea_moyen_fort_1920_1945: number | null
    nb_logement_alea_moyen_fort_1945_1975: number | null
    nb_logement_alea_moyen_fort_apres_1975: number | null
    nb_logement_alea_faible_avant_1920: number | null
    nb_logement_alea_faible_1920_1945: number | null
    nb_logement_alea_faible_1945_1975: number | null
    nb_logement_alea_faible_apres_1975: number | null
    surface_commune: number | null
    surface_alea_faible_commune: number | null
    surface_alea_moyen_fort_commune: number | null
    part_logement_alea_moyen_fort_avant_1920: number | null
    part_logement_alea_moyen_fort_1920_1945: number | null
    part_logement_alea_moyen_fort_1945_1975: number | null
    part_logement_alea_moyen_fort_apres_1975: number | null
    part_logement_alea_faible_avant_1920: number | null
    part_logement_alea_faible_1920_1945: number | null
    part_logement_alea_faible_1945_1975: number | null
    part_logement_alea_faible_apres_1975: number | null
    part_alea_faible_commune: number | null
    part_alea_moyen_fort_commune: number | null
  }

  export type RgaSumAggregateOutputType = {
    index: number | null
    region: number | null
    nb_logement: number | null
    nb_logement_alea_moyen_fort: number | null
    nb_logement_alea_faible: number | null
    nb_logement_sans_alea: number | null
    nb_logement_alea_moyen_fort_avant_1920: number | null
    nb_logement_alea_moyen_fort_1920_1945: number | null
    nb_logement_alea_moyen_fort_1945_1975: number | null
    nb_logement_alea_moyen_fort_apres_1975: number | null
    nb_logement_alea_faible_avant_1920: number | null
    nb_logement_alea_faible_1920_1945: number | null
    nb_logement_alea_faible_1945_1975: number | null
    nb_logement_alea_faible_apres_1975: number | null
    surface_commune: number | null
    surface_alea_faible_commune: number | null
    surface_alea_moyen_fort_commune: number | null
    part_logement_alea_moyen_fort_avant_1920: number | null
    part_logement_alea_moyen_fort_1920_1945: number | null
    part_logement_alea_moyen_fort_1945_1975: number | null
    part_logement_alea_moyen_fort_apres_1975: number | null
    part_logement_alea_faible_avant_1920: number | null
    part_logement_alea_faible_1920_1945: number | null
    part_logement_alea_faible_1945_1975: number | null
    part_logement_alea_faible_apres_1975: number | null
    part_alea_faible_commune: number | null
    part_alea_moyen_fort_commune: number | null
  }

  export type RgaMinAggregateOutputType = {
    index: number | null
    code_geographique: string | null
    libelle_geographique: string | null
    epci: string | null
    libelle_epci: string | null
    departement: string | null
    libelle_departement: string | null
    region: number | null
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
    nb_logement: number | null
    nb_logement_alea_moyen_fort: number | null
    nb_logement_alea_faible: number | null
    nb_logement_sans_alea: number | null
    nb_logement_alea_moyen_fort_avant_1920: number | null
    nb_logement_alea_moyen_fort_1920_1945: number | null
    nb_logement_alea_moyen_fort_1945_1975: number | null
    nb_logement_alea_moyen_fort_apres_1975: number | null
    nb_logement_alea_faible_avant_1920: number | null
    nb_logement_alea_faible_1920_1945: number | null
    nb_logement_alea_faible_1945_1975: number | null
    nb_logement_alea_faible_apres_1975: number | null
    surface_commune: number | null
    surface_alea_faible_commune: number | null
    surface_alea_moyen_fort_commune: number | null
    part_logement_alea_moyen_fort_avant_1920: number | null
    part_logement_alea_moyen_fort_1920_1945: number | null
    part_logement_alea_moyen_fort_1945_1975: number | null
    part_logement_alea_moyen_fort_apres_1975: number | null
    part_logement_alea_faible_avant_1920: number | null
    part_logement_alea_faible_1920_1945: number | null
    part_logement_alea_faible_1945_1975: number | null
    part_logement_alea_faible_apres_1975: number | null
    part_alea_faible_commune: number | null
    part_alea_moyen_fort_commune: number | null
  }

  export type RgaMaxAggregateOutputType = {
    index: number | null
    code_geographique: string | null
    libelle_geographique: string | null
    epci: string | null
    libelle_epci: string | null
    departement: string | null
    libelle_departement: string | null
    region: number | null
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
    nb_logement: number | null
    nb_logement_alea_moyen_fort: number | null
    nb_logement_alea_faible: number | null
    nb_logement_sans_alea: number | null
    nb_logement_alea_moyen_fort_avant_1920: number | null
    nb_logement_alea_moyen_fort_1920_1945: number | null
    nb_logement_alea_moyen_fort_1945_1975: number | null
    nb_logement_alea_moyen_fort_apres_1975: number | null
    nb_logement_alea_faible_avant_1920: number | null
    nb_logement_alea_faible_1920_1945: number | null
    nb_logement_alea_faible_1945_1975: number | null
    nb_logement_alea_faible_apres_1975: number | null
    surface_commune: number | null
    surface_alea_faible_commune: number | null
    surface_alea_moyen_fort_commune: number | null
    part_logement_alea_moyen_fort_avant_1920: number | null
    part_logement_alea_moyen_fort_1920_1945: number | null
    part_logement_alea_moyen_fort_1945_1975: number | null
    part_logement_alea_moyen_fort_apres_1975: number | null
    part_logement_alea_faible_avant_1920: number | null
    part_logement_alea_faible_1920_1945: number | null
    part_logement_alea_faible_1945_1975: number | null
    part_logement_alea_faible_apres_1975: number | null
    part_alea_faible_commune: number | null
    part_alea_moyen_fort_commune: number | null
  }

  export type RgaCountAggregateOutputType = {
    index: number
    code_geographique: number
    libelle_geographique: number
    epci: number
    libelle_epci: number
    departement: number
    libelle_departement: number
    region: number
    ept: number
    libelle_petr: number
    code_pnr: number
    libelle_pnr: number
    nb_logement: number
    nb_logement_alea_moyen_fort: number
    nb_logement_alea_faible: number
    nb_logement_sans_alea: number
    nb_logement_alea_moyen_fort_avant_1920: number
    nb_logement_alea_moyen_fort_1920_1945: number
    nb_logement_alea_moyen_fort_1945_1975: number
    nb_logement_alea_moyen_fort_apres_1975: number
    nb_logement_alea_faible_avant_1920: number
    nb_logement_alea_faible_1920_1945: number
    nb_logement_alea_faible_1945_1975: number
    nb_logement_alea_faible_apres_1975: number
    surface_commune: number
    surface_alea_faible_commune: number
    surface_alea_moyen_fort_commune: number
    part_logement_alea_moyen_fort_avant_1920: number
    part_logement_alea_moyen_fort_1920_1945: number
    part_logement_alea_moyen_fort_1945_1975: number
    part_logement_alea_moyen_fort_apres_1975: number
    part_logement_alea_faible_avant_1920: number
    part_logement_alea_faible_1920_1945: number
    part_logement_alea_faible_1945_1975: number
    part_logement_alea_faible_apres_1975: number
    part_alea_faible_commune: number
    part_alea_moyen_fort_commune: number
    _all: number
  }


  export type RgaAvgAggregateInputType = {
    index?: true
    region?: true
    nb_logement?: true
    nb_logement_alea_moyen_fort?: true
    nb_logement_alea_faible?: true
    nb_logement_sans_alea?: true
    nb_logement_alea_moyen_fort_avant_1920?: true
    nb_logement_alea_moyen_fort_1920_1945?: true
    nb_logement_alea_moyen_fort_1945_1975?: true
    nb_logement_alea_moyen_fort_apres_1975?: true
    nb_logement_alea_faible_avant_1920?: true
    nb_logement_alea_faible_1920_1945?: true
    nb_logement_alea_faible_1945_1975?: true
    nb_logement_alea_faible_apres_1975?: true
    surface_commune?: true
    surface_alea_faible_commune?: true
    surface_alea_moyen_fort_commune?: true
    part_logement_alea_moyen_fort_avant_1920?: true
    part_logement_alea_moyen_fort_1920_1945?: true
    part_logement_alea_moyen_fort_1945_1975?: true
    part_logement_alea_moyen_fort_apres_1975?: true
    part_logement_alea_faible_avant_1920?: true
    part_logement_alea_faible_1920_1945?: true
    part_logement_alea_faible_1945_1975?: true
    part_logement_alea_faible_apres_1975?: true
    part_alea_faible_commune?: true
    part_alea_moyen_fort_commune?: true
  }

  export type RgaSumAggregateInputType = {
    index?: true
    region?: true
    nb_logement?: true
    nb_logement_alea_moyen_fort?: true
    nb_logement_alea_faible?: true
    nb_logement_sans_alea?: true
    nb_logement_alea_moyen_fort_avant_1920?: true
    nb_logement_alea_moyen_fort_1920_1945?: true
    nb_logement_alea_moyen_fort_1945_1975?: true
    nb_logement_alea_moyen_fort_apres_1975?: true
    nb_logement_alea_faible_avant_1920?: true
    nb_logement_alea_faible_1920_1945?: true
    nb_logement_alea_faible_1945_1975?: true
    nb_logement_alea_faible_apres_1975?: true
    surface_commune?: true
    surface_alea_faible_commune?: true
    surface_alea_moyen_fort_commune?: true
    part_logement_alea_moyen_fort_avant_1920?: true
    part_logement_alea_moyen_fort_1920_1945?: true
    part_logement_alea_moyen_fort_1945_1975?: true
    part_logement_alea_moyen_fort_apres_1975?: true
    part_logement_alea_faible_avant_1920?: true
    part_logement_alea_faible_1920_1945?: true
    part_logement_alea_faible_1945_1975?: true
    part_logement_alea_faible_apres_1975?: true
    part_alea_faible_commune?: true
    part_alea_moyen_fort_commune?: true
  }

  export type RgaMinAggregateInputType = {
    index?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
    nb_logement?: true
    nb_logement_alea_moyen_fort?: true
    nb_logement_alea_faible?: true
    nb_logement_sans_alea?: true
    nb_logement_alea_moyen_fort_avant_1920?: true
    nb_logement_alea_moyen_fort_1920_1945?: true
    nb_logement_alea_moyen_fort_1945_1975?: true
    nb_logement_alea_moyen_fort_apres_1975?: true
    nb_logement_alea_faible_avant_1920?: true
    nb_logement_alea_faible_1920_1945?: true
    nb_logement_alea_faible_1945_1975?: true
    nb_logement_alea_faible_apres_1975?: true
    surface_commune?: true
    surface_alea_faible_commune?: true
    surface_alea_moyen_fort_commune?: true
    part_logement_alea_moyen_fort_avant_1920?: true
    part_logement_alea_moyen_fort_1920_1945?: true
    part_logement_alea_moyen_fort_1945_1975?: true
    part_logement_alea_moyen_fort_apres_1975?: true
    part_logement_alea_faible_avant_1920?: true
    part_logement_alea_faible_1920_1945?: true
    part_logement_alea_faible_1945_1975?: true
    part_logement_alea_faible_apres_1975?: true
    part_alea_faible_commune?: true
    part_alea_moyen_fort_commune?: true
  }

  export type RgaMaxAggregateInputType = {
    index?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
    nb_logement?: true
    nb_logement_alea_moyen_fort?: true
    nb_logement_alea_faible?: true
    nb_logement_sans_alea?: true
    nb_logement_alea_moyen_fort_avant_1920?: true
    nb_logement_alea_moyen_fort_1920_1945?: true
    nb_logement_alea_moyen_fort_1945_1975?: true
    nb_logement_alea_moyen_fort_apres_1975?: true
    nb_logement_alea_faible_avant_1920?: true
    nb_logement_alea_faible_1920_1945?: true
    nb_logement_alea_faible_1945_1975?: true
    nb_logement_alea_faible_apres_1975?: true
    surface_commune?: true
    surface_alea_faible_commune?: true
    surface_alea_moyen_fort_commune?: true
    part_logement_alea_moyen_fort_avant_1920?: true
    part_logement_alea_moyen_fort_1920_1945?: true
    part_logement_alea_moyen_fort_1945_1975?: true
    part_logement_alea_moyen_fort_apres_1975?: true
    part_logement_alea_faible_avant_1920?: true
    part_logement_alea_faible_1920_1945?: true
    part_logement_alea_faible_1945_1975?: true
    part_logement_alea_faible_apres_1975?: true
    part_alea_faible_commune?: true
    part_alea_moyen_fort_commune?: true
  }

  export type RgaCountAggregateInputType = {
    index?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
    nb_logement?: true
    nb_logement_alea_moyen_fort?: true
    nb_logement_alea_faible?: true
    nb_logement_sans_alea?: true
    nb_logement_alea_moyen_fort_avant_1920?: true
    nb_logement_alea_moyen_fort_1920_1945?: true
    nb_logement_alea_moyen_fort_1945_1975?: true
    nb_logement_alea_moyen_fort_apres_1975?: true
    nb_logement_alea_faible_avant_1920?: true
    nb_logement_alea_faible_1920_1945?: true
    nb_logement_alea_faible_1945_1975?: true
    nb_logement_alea_faible_apres_1975?: true
    surface_commune?: true
    surface_alea_faible_commune?: true
    surface_alea_moyen_fort_commune?: true
    part_logement_alea_moyen_fort_avant_1920?: true
    part_logement_alea_moyen_fort_1920_1945?: true
    part_logement_alea_moyen_fort_1945_1975?: true
    part_logement_alea_moyen_fort_apres_1975?: true
    part_logement_alea_faible_avant_1920?: true
    part_logement_alea_faible_1920_1945?: true
    part_logement_alea_faible_1945_1975?: true
    part_logement_alea_faible_apres_1975?: true
    part_alea_faible_commune?: true
    part_alea_moyen_fort_commune?: true
    _all?: true
  }

  export type RgaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rga to aggregate.
     */
    where?: rgaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rgas to fetch.
     */
    orderBy?: rgaOrderByWithRelationInput | rgaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rgaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rgas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rgas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rgas
    **/
    _count?: true | RgaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RgaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RgaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RgaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RgaMaxAggregateInputType
  }

  export type GetRgaAggregateType<T extends RgaAggregateArgs> = {
        [P in keyof T & keyof AggregateRga]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRga[P]>
      : GetScalarType<T[P], AggregateRga[P]>
  }




  export type rgaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rgaWhereInput
    orderBy?: rgaOrderByWithAggregationInput | rgaOrderByWithAggregationInput[]
    by: RgaScalarFieldEnum[] | RgaScalarFieldEnum
    having?: rgaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RgaCountAggregateInputType | true
    _avg?: RgaAvgAggregateInputType
    _sum?: RgaSumAggregateInputType
    _min?: RgaMinAggregateInputType
    _max?: RgaMaxAggregateInputType
  }

  export type RgaGroupByOutputType = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
    nb_logement: number
    nb_logement_alea_moyen_fort: number
    nb_logement_alea_faible: number
    nb_logement_sans_alea: number
    nb_logement_alea_moyen_fort_avant_1920: number
    nb_logement_alea_moyen_fort_1920_1945: number
    nb_logement_alea_moyen_fort_1945_1975: number
    nb_logement_alea_moyen_fort_apres_1975: number
    nb_logement_alea_faible_avant_1920: number
    nb_logement_alea_faible_1920_1945: number
    nb_logement_alea_faible_1945_1975: number
    nb_logement_alea_faible_apres_1975: number
    surface_commune: number
    surface_alea_faible_commune: number
    surface_alea_moyen_fort_commune: number
    part_logement_alea_moyen_fort_avant_1920: number
    part_logement_alea_moyen_fort_1920_1945: number
    part_logement_alea_moyen_fort_1945_1975: number
    part_logement_alea_moyen_fort_apres_1975: number
    part_logement_alea_faible_avant_1920: number
    part_logement_alea_faible_1920_1945: number
    part_logement_alea_faible_1945_1975: number
    part_logement_alea_faible_apres_1975: number
    part_alea_faible_commune: number
    part_alea_moyen_fort_commune: number
    _count: RgaCountAggregateOutputType | null
    _avg: RgaAvgAggregateOutputType | null
    _sum: RgaSumAggregateOutputType | null
    _min: RgaMinAggregateOutputType | null
    _max: RgaMaxAggregateOutputType | null
  }

  type GetRgaGroupByPayload<T extends rgaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RgaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RgaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RgaGroupByOutputType[P]>
            : GetScalarType<T[P], RgaGroupByOutputType[P]>
        }
      >
    >


  export type rgaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    nb_logement?: boolean
    nb_logement_alea_moyen_fort?: boolean
    nb_logement_alea_faible?: boolean
    nb_logement_sans_alea?: boolean
    nb_logement_alea_moyen_fort_avant_1920?: boolean
    nb_logement_alea_moyen_fort_1920_1945?: boolean
    nb_logement_alea_moyen_fort_1945_1975?: boolean
    nb_logement_alea_moyen_fort_apres_1975?: boolean
    nb_logement_alea_faible_avant_1920?: boolean
    nb_logement_alea_faible_1920_1945?: boolean
    nb_logement_alea_faible_1945_1975?: boolean
    nb_logement_alea_faible_apres_1975?: boolean
    surface_commune?: boolean
    surface_alea_faible_commune?: boolean
    surface_alea_moyen_fort_commune?: boolean
    part_logement_alea_moyen_fort_avant_1920?: boolean
    part_logement_alea_moyen_fort_1920_1945?: boolean
    part_logement_alea_moyen_fort_1945_1975?: boolean
    part_logement_alea_moyen_fort_apres_1975?: boolean
    part_logement_alea_faible_avant_1920?: boolean
    part_logement_alea_faible_1920_1945?: boolean
    part_logement_alea_faible_1945_1975?: boolean
    part_logement_alea_faible_apres_1975?: boolean
    part_alea_faible_commune?: boolean
    part_alea_moyen_fort_commune?: boolean
  }, ExtArgs["result"]["rga"]>

  export type rgaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    nb_logement?: boolean
    nb_logement_alea_moyen_fort?: boolean
    nb_logement_alea_faible?: boolean
    nb_logement_sans_alea?: boolean
    nb_logement_alea_moyen_fort_avant_1920?: boolean
    nb_logement_alea_moyen_fort_1920_1945?: boolean
    nb_logement_alea_moyen_fort_1945_1975?: boolean
    nb_logement_alea_moyen_fort_apres_1975?: boolean
    nb_logement_alea_faible_avant_1920?: boolean
    nb_logement_alea_faible_1920_1945?: boolean
    nb_logement_alea_faible_1945_1975?: boolean
    nb_logement_alea_faible_apres_1975?: boolean
    surface_commune?: boolean
    surface_alea_faible_commune?: boolean
    surface_alea_moyen_fort_commune?: boolean
    part_logement_alea_moyen_fort_avant_1920?: boolean
    part_logement_alea_moyen_fort_1920_1945?: boolean
    part_logement_alea_moyen_fort_1945_1975?: boolean
    part_logement_alea_moyen_fort_apres_1975?: boolean
    part_logement_alea_faible_avant_1920?: boolean
    part_logement_alea_faible_1920_1945?: boolean
    part_logement_alea_faible_1945_1975?: boolean
    part_logement_alea_faible_apres_1975?: boolean
    part_alea_faible_commune?: boolean
    part_alea_moyen_fort_commune?: boolean
  }, ExtArgs["result"]["rga"]>

  export type rgaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    nb_logement?: boolean
    nb_logement_alea_moyen_fort?: boolean
    nb_logement_alea_faible?: boolean
    nb_logement_sans_alea?: boolean
    nb_logement_alea_moyen_fort_avant_1920?: boolean
    nb_logement_alea_moyen_fort_1920_1945?: boolean
    nb_logement_alea_moyen_fort_1945_1975?: boolean
    nb_logement_alea_moyen_fort_apres_1975?: boolean
    nb_logement_alea_faible_avant_1920?: boolean
    nb_logement_alea_faible_1920_1945?: boolean
    nb_logement_alea_faible_1945_1975?: boolean
    nb_logement_alea_faible_apres_1975?: boolean
    surface_commune?: boolean
    surface_alea_faible_commune?: boolean
    surface_alea_moyen_fort_commune?: boolean
    part_logement_alea_moyen_fort_avant_1920?: boolean
    part_logement_alea_moyen_fort_1920_1945?: boolean
    part_logement_alea_moyen_fort_1945_1975?: boolean
    part_logement_alea_moyen_fort_apres_1975?: boolean
    part_logement_alea_faible_avant_1920?: boolean
    part_logement_alea_faible_1920_1945?: boolean
    part_logement_alea_faible_1945_1975?: boolean
    part_logement_alea_faible_apres_1975?: boolean
    part_alea_faible_commune?: boolean
    part_alea_moyen_fort_commune?: boolean
  }, ExtArgs["result"]["rga"]>

  export type rgaSelectScalar = {
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    nb_logement?: boolean
    nb_logement_alea_moyen_fort?: boolean
    nb_logement_alea_faible?: boolean
    nb_logement_sans_alea?: boolean
    nb_logement_alea_moyen_fort_avant_1920?: boolean
    nb_logement_alea_moyen_fort_1920_1945?: boolean
    nb_logement_alea_moyen_fort_1945_1975?: boolean
    nb_logement_alea_moyen_fort_apres_1975?: boolean
    nb_logement_alea_faible_avant_1920?: boolean
    nb_logement_alea_faible_1920_1945?: boolean
    nb_logement_alea_faible_1945_1975?: boolean
    nb_logement_alea_faible_apres_1975?: boolean
    surface_commune?: boolean
    surface_alea_faible_commune?: boolean
    surface_alea_moyen_fort_commune?: boolean
    part_logement_alea_moyen_fort_avant_1920?: boolean
    part_logement_alea_moyen_fort_1920_1945?: boolean
    part_logement_alea_moyen_fort_1945_1975?: boolean
    part_logement_alea_moyen_fort_apres_1975?: boolean
    part_logement_alea_faible_avant_1920?: boolean
    part_logement_alea_faible_1920_1945?: boolean
    part_logement_alea_faible_1945_1975?: boolean
    part_logement_alea_faible_apres_1975?: boolean
    part_alea_faible_commune?: boolean
    part_alea_moyen_fort_commune?: boolean
  }

  export type rgaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"index" | "code_geographique" | "libelle_geographique" | "epci" | "libelle_epci" | "departement" | "libelle_departement" | "region" | "ept" | "libelle_petr" | "code_pnr" | "libelle_pnr" | "nb_logement" | "nb_logement_alea_moyen_fort" | "nb_logement_alea_faible" | "nb_logement_sans_alea" | "nb_logement_alea_moyen_fort_avant_1920" | "nb_logement_alea_moyen_fort_1920_1945" | "nb_logement_alea_moyen_fort_1945_1975" | "nb_logement_alea_moyen_fort_apres_1975" | "nb_logement_alea_faible_avant_1920" | "nb_logement_alea_faible_1920_1945" | "nb_logement_alea_faible_1945_1975" | "nb_logement_alea_faible_apres_1975" | "surface_commune" | "surface_alea_faible_commune" | "surface_alea_moyen_fort_commune" | "part_logement_alea_moyen_fort_avant_1920" | "part_logement_alea_moyen_fort_1920_1945" | "part_logement_alea_moyen_fort_1945_1975" | "part_logement_alea_moyen_fort_apres_1975" | "part_logement_alea_faible_avant_1920" | "part_logement_alea_faible_1920_1945" | "part_logement_alea_faible_1945_1975" | "part_logement_alea_faible_apres_1975" | "part_alea_faible_commune" | "part_alea_moyen_fort_commune", ExtArgs["result"]["rga"]>

  export type $rgaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "rga"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      index: number
      code_geographique: string
      libelle_geographique: string
      epci: string
      libelle_epci: string
      departement: string
      libelle_departement: string
      region: number
      ept: string | null
      libelle_petr: string | null
      code_pnr: string | null
      libelle_pnr: string | null
      nb_logement: number
      nb_logement_alea_moyen_fort: number
      nb_logement_alea_faible: number
      nb_logement_sans_alea: number
      nb_logement_alea_moyen_fort_avant_1920: number
      nb_logement_alea_moyen_fort_1920_1945: number
      nb_logement_alea_moyen_fort_1945_1975: number
      nb_logement_alea_moyen_fort_apres_1975: number
      nb_logement_alea_faible_avant_1920: number
      nb_logement_alea_faible_1920_1945: number
      nb_logement_alea_faible_1945_1975: number
      nb_logement_alea_faible_apres_1975: number
      surface_commune: number
      surface_alea_faible_commune: number
      surface_alea_moyen_fort_commune: number
      part_logement_alea_moyen_fort_avant_1920: number
      part_logement_alea_moyen_fort_1920_1945: number
      part_logement_alea_moyen_fort_1945_1975: number
      part_logement_alea_moyen_fort_apres_1975: number
      part_logement_alea_faible_avant_1920: number
      part_logement_alea_faible_1920_1945: number
      part_logement_alea_faible_1945_1975: number
      part_logement_alea_faible_apres_1975: number
      part_alea_faible_commune: number
      part_alea_moyen_fort_commune: number
    }, ExtArgs["result"]["rga"]>
    composites: {}
  }

  type rgaGetPayload<S extends boolean | null | undefined | rgaDefaultArgs> = $Result.GetResult<Prisma.$rgaPayload, S>

  type rgaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<rgaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RgaCountAggregateInputType | true
    }

  export interface rgaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['rga'], meta: { name: 'rga' } }
    /**
     * Find zero or one Rga that matches the filter.
     * @param {rgaFindUniqueArgs} args - Arguments to find a Rga
     * @example
     * // Get one Rga
     * const rga = await prisma.rga.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rgaFindUniqueArgs>(args: SelectSubset<T, rgaFindUniqueArgs<ExtArgs>>): Prisma__rgaClient<$Result.GetResult<Prisma.$rgaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Rga that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {rgaFindUniqueOrThrowArgs} args - Arguments to find a Rga
     * @example
     * // Get one Rga
     * const rga = await prisma.rga.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rgaFindUniqueOrThrowArgs>(args: SelectSubset<T, rgaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rgaClient<$Result.GetResult<Prisma.$rgaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rga that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rgaFindFirstArgs} args - Arguments to find a Rga
     * @example
     * // Get one Rga
     * const rga = await prisma.rga.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rgaFindFirstArgs>(args?: SelectSubset<T, rgaFindFirstArgs<ExtArgs>>): Prisma__rgaClient<$Result.GetResult<Prisma.$rgaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rga that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rgaFindFirstOrThrowArgs} args - Arguments to find a Rga
     * @example
     * // Get one Rga
     * const rga = await prisma.rga.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rgaFindFirstOrThrowArgs>(args?: SelectSubset<T, rgaFindFirstOrThrowArgs<ExtArgs>>): Prisma__rgaClient<$Result.GetResult<Prisma.$rgaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rgas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rgaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rgas
     * const rgas = await prisma.rga.findMany()
     * 
     * // Get first 10 Rgas
     * const rgas = await prisma.rga.findMany({ take: 10 })
     * 
     * // Only select the `index`
     * const rgaWithIndexOnly = await prisma.rga.findMany({ select: { index: true } })
     * 
     */
    findMany<T extends rgaFindManyArgs>(args?: SelectSubset<T, rgaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rgaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Rga.
     * @param {rgaCreateArgs} args - Arguments to create a Rga.
     * @example
     * // Create one Rga
     * const Rga = await prisma.rga.create({
     *   data: {
     *     // ... data to create a Rga
     *   }
     * })
     * 
     */
    create<T extends rgaCreateArgs>(args: SelectSubset<T, rgaCreateArgs<ExtArgs>>): Prisma__rgaClient<$Result.GetResult<Prisma.$rgaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rgas.
     * @param {rgaCreateManyArgs} args - Arguments to create many Rgas.
     * @example
     * // Create many Rgas
     * const rga = await prisma.rga.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rgaCreateManyArgs>(args?: SelectSubset<T, rgaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rgas and returns the data saved in the database.
     * @param {rgaCreateManyAndReturnArgs} args - Arguments to create many Rgas.
     * @example
     * // Create many Rgas
     * const rga = await prisma.rga.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rgas and only return the `index`
     * const rgaWithIndexOnly = await prisma.rga.createManyAndReturn({
     *   select: { index: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends rgaCreateManyAndReturnArgs>(args?: SelectSubset<T, rgaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rgaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Rga.
     * @param {rgaDeleteArgs} args - Arguments to delete one Rga.
     * @example
     * // Delete one Rga
     * const Rga = await prisma.rga.delete({
     *   where: {
     *     // ... filter to delete one Rga
     *   }
     * })
     * 
     */
    delete<T extends rgaDeleteArgs>(args: SelectSubset<T, rgaDeleteArgs<ExtArgs>>): Prisma__rgaClient<$Result.GetResult<Prisma.$rgaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Rga.
     * @param {rgaUpdateArgs} args - Arguments to update one Rga.
     * @example
     * // Update one Rga
     * const rga = await prisma.rga.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rgaUpdateArgs>(args: SelectSubset<T, rgaUpdateArgs<ExtArgs>>): Prisma__rgaClient<$Result.GetResult<Prisma.$rgaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rgas.
     * @param {rgaDeleteManyArgs} args - Arguments to filter Rgas to delete.
     * @example
     * // Delete a few Rgas
     * const { count } = await prisma.rga.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rgaDeleteManyArgs>(args?: SelectSubset<T, rgaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rgas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rgaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rgas
     * const rga = await prisma.rga.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rgaUpdateManyArgs>(args: SelectSubset<T, rgaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rgas and returns the data updated in the database.
     * @param {rgaUpdateManyAndReturnArgs} args - Arguments to update many Rgas.
     * @example
     * // Update many Rgas
     * const rga = await prisma.rga.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Rgas and only return the `index`
     * const rgaWithIndexOnly = await prisma.rga.updateManyAndReturn({
     *   select: { index: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends rgaUpdateManyAndReturnArgs>(args: SelectSubset<T, rgaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rgaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Rga.
     * @param {rgaUpsertArgs} args - Arguments to update or create a Rga.
     * @example
     * // Update or create a Rga
     * const rga = await prisma.rga.upsert({
     *   create: {
     *     // ... data to create a Rga
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rga we want to update
     *   }
     * })
     */
    upsert<T extends rgaUpsertArgs>(args: SelectSubset<T, rgaUpsertArgs<ExtArgs>>): Prisma__rgaClient<$Result.GetResult<Prisma.$rgaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rgas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rgaCountArgs} args - Arguments to filter Rgas to count.
     * @example
     * // Count the number of Rgas
     * const count = await prisma.rga.count({
     *   where: {
     *     // ... the filter for the Rgas we want to count
     *   }
     * })
    **/
    count<T extends rgaCountArgs>(
      args?: Subset<T, rgaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RgaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rga.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RgaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RgaAggregateArgs>(args: Subset<T, RgaAggregateArgs>): Prisma.PrismaPromise<GetRgaAggregateType<T>>

    /**
     * Group by Rga.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rgaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rgaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rgaGroupByArgs['orderBy'] }
        : { orderBy?: rgaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rgaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRgaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the rga model
   */
  readonly fields: rgaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for rga.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rgaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the rga model
   */
  interface rgaFieldRefs {
    readonly index: FieldRef<"rga", 'Int'>
    readonly code_geographique: FieldRef<"rga", 'String'>
    readonly libelle_geographique: FieldRef<"rga", 'String'>
    readonly epci: FieldRef<"rga", 'String'>
    readonly libelle_epci: FieldRef<"rga", 'String'>
    readonly departement: FieldRef<"rga", 'String'>
    readonly libelle_departement: FieldRef<"rga", 'String'>
    readonly region: FieldRef<"rga", 'Float'>
    readonly ept: FieldRef<"rga", 'String'>
    readonly libelle_petr: FieldRef<"rga", 'String'>
    readonly code_pnr: FieldRef<"rga", 'String'>
    readonly libelle_pnr: FieldRef<"rga", 'String'>
    readonly nb_logement: FieldRef<"rga", 'Int'>
    readonly nb_logement_alea_moyen_fort: FieldRef<"rga", 'Int'>
    readonly nb_logement_alea_faible: FieldRef<"rga", 'Int'>
    readonly nb_logement_sans_alea: FieldRef<"rga", 'Int'>
    readonly nb_logement_alea_moyen_fort_avant_1920: FieldRef<"rga", 'Int'>
    readonly nb_logement_alea_moyen_fort_1920_1945: FieldRef<"rga", 'Int'>
    readonly nb_logement_alea_moyen_fort_1945_1975: FieldRef<"rga", 'Int'>
    readonly nb_logement_alea_moyen_fort_apres_1975: FieldRef<"rga", 'Int'>
    readonly nb_logement_alea_faible_avant_1920: FieldRef<"rga", 'Int'>
    readonly nb_logement_alea_faible_1920_1945: FieldRef<"rga", 'Int'>
    readonly nb_logement_alea_faible_1945_1975: FieldRef<"rga", 'Int'>
    readonly nb_logement_alea_faible_apres_1975: FieldRef<"rga", 'Int'>
    readonly surface_commune: FieldRef<"rga", 'Int'>
    readonly surface_alea_faible_commune: FieldRef<"rga", 'Int'>
    readonly surface_alea_moyen_fort_commune: FieldRef<"rga", 'Int'>
    readonly part_logement_alea_moyen_fort_avant_1920: FieldRef<"rga", 'Int'>
    readonly part_logement_alea_moyen_fort_1920_1945: FieldRef<"rga", 'Int'>
    readonly part_logement_alea_moyen_fort_1945_1975: FieldRef<"rga", 'Int'>
    readonly part_logement_alea_moyen_fort_apres_1975: FieldRef<"rga", 'Int'>
    readonly part_logement_alea_faible_avant_1920: FieldRef<"rga", 'Int'>
    readonly part_logement_alea_faible_1920_1945: FieldRef<"rga", 'Int'>
    readonly part_logement_alea_faible_1945_1975: FieldRef<"rga", 'Int'>
    readonly part_logement_alea_faible_apres_1975: FieldRef<"rga", 'Int'>
    readonly part_alea_faible_commune: FieldRef<"rga", 'Int'>
    readonly part_alea_moyen_fort_commune: FieldRef<"rga", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * rga findUnique
   */
  export type rgaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rga
     */
    select?: rgaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rga
     */
    omit?: rgaOmit<ExtArgs> | null
    /**
     * Filter, which rga to fetch.
     */
    where: rgaWhereUniqueInput
  }

  /**
   * rga findUniqueOrThrow
   */
  export type rgaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rga
     */
    select?: rgaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rga
     */
    omit?: rgaOmit<ExtArgs> | null
    /**
     * Filter, which rga to fetch.
     */
    where: rgaWhereUniqueInput
  }

  /**
   * rga findFirst
   */
  export type rgaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rga
     */
    select?: rgaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rga
     */
    omit?: rgaOmit<ExtArgs> | null
    /**
     * Filter, which rga to fetch.
     */
    where?: rgaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rgas to fetch.
     */
    orderBy?: rgaOrderByWithRelationInput | rgaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rgas.
     */
    cursor?: rgaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rgas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rgas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rgas.
     */
    distinct?: RgaScalarFieldEnum | RgaScalarFieldEnum[]
  }

  /**
   * rga findFirstOrThrow
   */
  export type rgaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rga
     */
    select?: rgaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rga
     */
    omit?: rgaOmit<ExtArgs> | null
    /**
     * Filter, which rga to fetch.
     */
    where?: rgaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rgas to fetch.
     */
    orderBy?: rgaOrderByWithRelationInput | rgaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rgas.
     */
    cursor?: rgaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rgas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rgas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rgas.
     */
    distinct?: RgaScalarFieldEnum | RgaScalarFieldEnum[]
  }

  /**
   * rga findMany
   */
  export type rgaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rga
     */
    select?: rgaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rga
     */
    omit?: rgaOmit<ExtArgs> | null
    /**
     * Filter, which rgas to fetch.
     */
    where?: rgaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rgas to fetch.
     */
    orderBy?: rgaOrderByWithRelationInput | rgaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rgas.
     */
    cursor?: rgaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rgas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rgas.
     */
    skip?: number
    distinct?: RgaScalarFieldEnum | RgaScalarFieldEnum[]
  }

  /**
   * rga create
   */
  export type rgaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rga
     */
    select?: rgaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rga
     */
    omit?: rgaOmit<ExtArgs> | null
    /**
     * The data needed to create a rga.
     */
    data: XOR<rgaCreateInput, rgaUncheckedCreateInput>
  }

  /**
   * rga createMany
   */
  export type rgaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rgas.
     */
    data: rgaCreateManyInput | rgaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * rga createManyAndReturn
   */
  export type rgaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rga
     */
    select?: rgaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the rga
     */
    omit?: rgaOmit<ExtArgs> | null
    /**
     * The data used to create many rgas.
     */
    data: rgaCreateManyInput | rgaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * rga update
   */
  export type rgaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rga
     */
    select?: rgaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rga
     */
    omit?: rgaOmit<ExtArgs> | null
    /**
     * The data needed to update a rga.
     */
    data: XOR<rgaUpdateInput, rgaUncheckedUpdateInput>
    /**
     * Choose, which rga to update.
     */
    where: rgaWhereUniqueInput
  }

  /**
   * rga updateMany
   */
  export type rgaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rgas.
     */
    data: XOR<rgaUpdateManyMutationInput, rgaUncheckedUpdateManyInput>
    /**
     * Filter which rgas to update
     */
    where?: rgaWhereInput
    /**
     * Limit how many rgas to update.
     */
    limit?: number
  }

  /**
   * rga updateManyAndReturn
   */
  export type rgaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rga
     */
    select?: rgaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the rga
     */
    omit?: rgaOmit<ExtArgs> | null
    /**
     * The data used to update rgas.
     */
    data: XOR<rgaUpdateManyMutationInput, rgaUncheckedUpdateManyInput>
    /**
     * Filter which rgas to update
     */
    where?: rgaWhereInput
    /**
     * Limit how many rgas to update.
     */
    limit?: number
  }

  /**
   * rga upsert
   */
  export type rgaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rga
     */
    select?: rgaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rga
     */
    omit?: rgaOmit<ExtArgs> | null
    /**
     * The filter to search for the rga to update in case it exists.
     */
    where: rgaWhereUniqueInput
    /**
     * In case the rga found by the `where` argument doesn't exist, create a new rga with this data.
     */
    create: XOR<rgaCreateInput, rgaUncheckedCreateInput>
    /**
     * In case the rga was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rgaUpdateInput, rgaUncheckedUpdateInput>
  }

  /**
   * rga delete
   */
  export type rgaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rga
     */
    select?: rgaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rga
     */
    omit?: rgaOmit<ExtArgs> | null
    /**
     * Filter which rga to delete.
     */
    where: rgaWhereUniqueInput
  }

  /**
   * rga deleteMany
   */
  export type rgaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rgas to delete
     */
    where?: rgaWhereInput
    /**
     * Limit how many rgas to delete.
     */
    limit?: number
  }

  /**
   * rga without action
   */
  export type rgaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rga
     */
    select?: rgaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rga
     */
    omit?: rgaOmit<ExtArgs> | null
  }


  /**
   * Model surfaces_agricoles
   */

  export type AggregateSurfaces_agricoles = {
    _count: Surfaces_agricolesCountAggregateOutputType | null
    _avg: Surfaces_agricolesAvgAggregateOutputType | null
    _sum: Surfaces_agricolesSumAggregateOutputType | null
    _min: Surfaces_agricolesMinAggregateOutputType | null
    _max: Surfaces_agricolesMaxAggregateOutputType | null
  }

  export type Surfaces_agricolesAvgAggregateOutputType = {
    index: number | null
    exploitation_sau: number | null
    exploitation_sau_terres_arables: number | null
    exploitation_sau_terres_arables_cereales: number | null
    exploitation_sau_terres_arables_oleagineux: number | null
    exploitation_sau_terres_arables_fourrageres: number | null
    exploitation_sau_terres_arables_tubercules: number | null
    exploitation_sau_terres_arables_legumes_melons_fraises: number | null
    exploitation_sau_terres_arables_fleurs: number | null
    exploitation_sau_terres_arables_autres: number | null
    exploitation_sau_cultures_permanentes: number | null
    exploitation_sau_cultures_permanentes_vigne: number | null
    exploitation_sau_cultures_permanentes_fruits: number | null
    exploitation_sau_cultures_permanentes_autres: number | null
    exploitation_sau_herbe: number | null
    exploitation_sau_herbe_prairies_productives: number | null
    exploitation_sau_herbe_prairies_peu_productives: number | null
    exploitation_sau_herbe_subventions: number | null
    exploitation_sau_herbe_bois_patures: number | null
    exploitation_sau_jardins: number | null
    superficie_sau: number | null
    superficie_sau_terres_arables: number | null
    superficie_sau_terres_arables_cereales: number | null
    superficie_sau_terres_arables_oleagineux: number | null
    superficie_sau_terres_arables_fourrageres: number | null
    superficie_sau_terres_arables_tubercules: number | null
    superficie_sau_terres_arables_legumes_melons_fraises: number | null
    superficie_sau_terres_arables_fleurs: number | null
    superficie_sau_terres_arables_autres: number | null
    superficie_sau_cultures_permanentes: number | null
    superficie_sau_cultures_permanentes_vigne: number | null
    superficie_sau_cultures_permanentes_fruits: number | null
    superficie_sau_cultures_permanentes_autres: number | null
    superficie_sau_herbe: number | null
    superficie_sau_herbe_prairies_productives: number | null
    superficie_sau_herbe_prairies_peu_productives: number | null
    superficie_sau_herbe_subventions: number | null
    superficie_sau_herbe_bois_patures: number | null
    superficie_sau_jardins: number | null
  }

  export type Surfaces_agricolesSumAggregateOutputType = {
    index: number | null
    exploitation_sau: number | null
    exploitation_sau_terres_arables: number | null
    exploitation_sau_terres_arables_cereales: number | null
    exploitation_sau_terres_arables_oleagineux: number | null
    exploitation_sau_terres_arables_fourrageres: number | null
    exploitation_sau_terres_arables_tubercules: number | null
    exploitation_sau_terres_arables_legumes_melons_fraises: number | null
    exploitation_sau_terres_arables_fleurs: number | null
    exploitation_sau_terres_arables_autres: number | null
    exploitation_sau_cultures_permanentes: number | null
    exploitation_sau_cultures_permanentes_vigne: number | null
    exploitation_sau_cultures_permanentes_fruits: number | null
    exploitation_sau_cultures_permanentes_autres: number | null
    exploitation_sau_herbe: number | null
    exploitation_sau_herbe_prairies_productives: number | null
    exploitation_sau_herbe_prairies_peu_productives: number | null
    exploitation_sau_herbe_subventions: number | null
    exploitation_sau_herbe_bois_patures: number | null
    exploitation_sau_jardins: number | null
    superficie_sau: number | null
    superficie_sau_terres_arables: number | null
    superficie_sau_terres_arables_cereales: number | null
    superficie_sau_terres_arables_oleagineux: number | null
    superficie_sau_terres_arables_fourrageres: number | null
    superficie_sau_terres_arables_tubercules: number | null
    superficie_sau_terres_arables_legumes_melons_fraises: number | null
    superficie_sau_terres_arables_fleurs: number | null
    superficie_sau_terres_arables_autres: number | null
    superficie_sau_cultures_permanentes: number | null
    superficie_sau_cultures_permanentes_vigne: number | null
    superficie_sau_cultures_permanentes_fruits: number | null
    superficie_sau_cultures_permanentes_autres: number | null
    superficie_sau_herbe: number | null
    superficie_sau_herbe_prairies_productives: number | null
    superficie_sau_herbe_prairies_peu_productives: number | null
    superficie_sau_herbe_subventions: number | null
    superficie_sau_herbe_bois_patures: number | null
    superficie_sau_jardins: number | null
  }

  export type Surfaces_agricolesMinAggregateOutputType = {
    index: number | null
    epci: string | null
    exploitation_sau: number | null
    exploitation_sau_terres_arables: number | null
    exploitation_sau_terres_arables_cereales: number | null
    exploitation_sau_terres_arables_oleagineux: number | null
    exploitation_sau_terres_arables_fourrageres: number | null
    exploitation_sau_terres_arables_tubercules: number | null
    exploitation_sau_terres_arables_legumes_melons_fraises: number | null
    exploitation_sau_terres_arables_fleurs: number | null
    exploitation_sau_terres_arables_autres: number | null
    exploitation_sau_cultures_permanentes: number | null
    exploitation_sau_cultures_permanentes_vigne: number | null
    exploitation_sau_cultures_permanentes_fruits: number | null
    exploitation_sau_cultures_permanentes_autres: number | null
    exploitation_sau_herbe: number | null
    exploitation_sau_herbe_prairies_productives: number | null
    exploitation_sau_herbe_prairies_peu_productives: number | null
    exploitation_sau_herbe_subventions: number | null
    exploitation_sau_herbe_bois_patures: number | null
    exploitation_sau_jardins: number | null
    superficie_sau: number | null
    superficie_sau_terres_arables: number | null
    superficie_sau_terres_arables_cereales: number | null
    superficie_sau_terres_arables_oleagineux: number | null
    superficie_sau_terres_arables_fourrageres: number | null
    superficie_sau_terres_arables_tubercules: number | null
    superficie_sau_terres_arables_legumes_melons_fraises: number | null
    superficie_sau_terres_arables_fleurs: number | null
    superficie_sau_terres_arables_autres: number | null
    superficie_sau_cultures_permanentes: number | null
    superficie_sau_cultures_permanentes_vigne: number | null
    superficie_sau_cultures_permanentes_fruits: number | null
    superficie_sau_cultures_permanentes_autres: number | null
    superficie_sau_herbe: number | null
    superficie_sau_herbe_prairies_productives: number | null
    superficie_sau_herbe_prairies_peu_productives: number | null
    superficie_sau_herbe_subventions: number | null
    superficie_sau_herbe_bois_patures: number | null
    superficie_sau_jardins: number | null
  }

  export type Surfaces_agricolesMaxAggregateOutputType = {
    index: number | null
    epci: string | null
    exploitation_sau: number | null
    exploitation_sau_terres_arables: number | null
    exploitation_sau_terres_arables_cereales: number | null
    exploitation_sau_terres_arables_oleagineux: number | null
    exploitation_sau_terres_arables_fourrageres: number | null
    exploitation_sau_terres_arables_tubercules: number | null
    exploitation_sau_terres_arables_legumes_melons_fraises: number | null
    exploitation_sau_terres_arables_fleurs: number | null
    exploitation_sau_terres_arables_autres: number | null
    exploitation_sau_cultures_permanentes: number | null
    exploitation_sau_cultures_permanentes_vigne: number | null
    exploitation_sau_cultures_permanentes_fruits: number | null
    exploitation_sau_cultures_permanentes_autres: number | null
    exploitation_sau_herbe: number | null
    exploitation_sau_herbe_prairies_productives: number | null
    exploitation_sau_herbe_prairies_peu_productives: number | null
    exploitation_sau_herbe_subventions: number | null
    exploitation_sau_herbe_bois_patures: number | null
    exploitation_sau_jardins: number | null
    superficie_sau: number | null
    superficie_sau_terres_arables: number | null
    superficie_sau_terres_arables_cereales: number | null
    superficie_sau_terres_arables_oleagineux: number | null
    superficie_sau_terres_arables_fourrageres: number | null
    superficie_sau_terres_arables_tubercules: number | null
    superficie_sau_terres_arables_legumes_melons_fraises: number | null
    superficie_sau_terres_arables_fleurs: number | null
    superficie_sau_terres_arables_autres: number | null
    superficie_sau_cultures_permanentes: number | null
    superficie_sau_cultures_permanentes_vigne: number | null
    superficie_sau_cultures_permanentes_fruits: number | null
    superficie_sau_cultures_permanentes_autres: number | null
    superficie_sau_herbe: number | null
    superficie_sau_herbe_prairies_productives: number | null
    superficie_sau_herbe_prairies_peu_productives: number | null
    superficie_sau_herbe_subventions: number | null
    superficie_sau_herbe_bois_patures: number | null
    superficie_sau_jardins: number | null
  }

  export type Surfaces_agricolesCountAggregateOutputType = {
    index: number
    epci: number
    exploitation_sau: number
    exploitation_sau_terres_arables: number
    exploitation_sau_terres_arables_cereales: number
    exploitation_sau_terres_arables_oleagineux: number
    exploitation_sau_terres_arables_fourrageres: number
    exploitation_sau_terres_arables_tubercules: number
    exploitation_sau_terres_arables_legumes_melons_fraises: number
    exploitation_sau_terres_arables_fleurs: number
    exploitation_sau_terres_arables_autres: number
    exploitation_sau_cultures_permanentes: number
    exploitation_sau_cultures_permanentes_vigne: number
    exploitation_sau_cultures_permanentes_fruits: number
    exploitation_sau_cultures_permanentes_autres: number
    exploitation_sau_herbe: number
    exploitation_sau_herbe_prairies_productives: number
    exploitation_sau_herbe_prairies_peu_productives: number
    exploitation_sau_herbe_subventions: number
    exploitation_sau_herbe_bois_patures: number
    exploitation_sau_jardins: number
    superficie_sau: number
    superficie_sau_terres_arables: number
    superficie_sau_terres_arables_cereales: number
    superficie_sau_terres_arables_oleagineux: number
    superficie_sau_terres_arables_fourrageres: number
    superficie_sau_terres_arables_tubercules: number
    superficie_sau_terres_arables_legumes_melons_fraises: number
    superficie_sau_terres_arables_fleurs: number
    superficie_sau_terres_arables_autres: number
    superficie_sau_cultures_permanentes: number
    superficie_sau_cultures_permanentes_vigne: number
    superficie_sau_cultures_permanentes_fruits: number
    superficie_sau_cultures_permanentes_autres: number
    superficie_sau_herbe: number
    superficie_sau_herbe_prairies_productives: number
    superficie_sau_herbe_prairies_peu_productives: number
    superficie_sau_herbe_subventions: number
    superficie_sau_herbe_bois_patures: number
    superficie_sau_jardins: number
    _all: number
  }


  export type Surfaces_agricolesAvgAggregateInputType = {
    index?: true
    exploitation_sau?: true
    exploitation_sau_terres_arables?: true
    exploitation_sau_terres_arables_cereales?: true
    exploitation_sau_terres_arables_oleagineux?: true
    exploitation_sau_terres_arables_fourrageres?: true
    exploitation_sau_terres_arables_tubercules?: true
    exploitation_sau_terres_arables_legumes_melons_fraises?: true
    exploitation_sau_terres_arables_fleurs?: true
    exploitation_sau_terres_arables_autres?: true
    exploitation_sau_cultures_permanentes?: true
    exploitation_sau_cultures_permanentes_vigne?: true
    exploitation_sau_cultures_permanentes_fruits?: true
    exploitation_sau_cultures_permanentes_autres?: true
    exploitation_sau_herbe?: true
    exploitation_sau_herbe_prairies_productives?: true
    exploitation_sau_herbe_prairies_peu_productives?: true
    exploitation_sau_herbe_subventions?: true
    exploitation_sau_herbe_bois_patures?: true
    exploitation_sau_jardins?: true
    superficie_sau?: true
    superficie_sau_terres_arables?: true
    superficie_sau_terres_arables_cereales?: true
    superficie_sau_terres_arables_oleagineux?: true
    superficie_sau_terres_arables_fourrageres?: true
    superficie_sau_terres_arables_tubercules?: true
    superficie_sau_terres_arables_legumes_melons_fraises?: true
    superficie_sau_terres_arables_fleurs?: true
    superficie_sau_terres_arables_autres?: true
    superficie_sau_cultures_permanentes?: true
    superficie_sau_cultures_permanentes_vigne?: true
    superficie_sau_cultures_permanentes_fruits?: true
    superficie_sau_cultures_permanentes_autres?: true
    superficie_sau_herbe?: true
    superficie_sau_herbe_prairies_productives?: true
    superficie_sau_herbe_prairies_peu_productives?: true
    superficie_sau_herbe_subventions?: true
    superficie_sau_herbe_bois_patures?: true
    superficie_sau_jardins?: true
  }

  export type Surfaces_agricolesSumAggregateInputType = {
    index?: true
    exploitation_sau?: true
    exploitation_sau_terres_arables?: true
    exploitation_sau_terres_arables_cereales?: true
    exploitation_sau_terres_arables_oleagineux?: true
    exploitation_sau_terres_arables_fourrageres?: true
    exploitation_sau_terres_arables_tubercules?: true
    exploitation_sau_terres_arables_legumes_melons_fraises?: true
    exploitation_sau_terres_arables_fleurs?: true
    exploitation_sau_terres_arables_autres?: true
    exploitation_sau_cultures_permanentes?: true
    exploitation_sau_cultures_permanentes_vigne?: true
    exploitation_sau_cultures_permanentes_fruits?: true
    exploitation_sau_cultures_permanentes_autres?: true
    exploitation_sau_herbe?: true
    exploitation_sau_herbe_prairies_productives?: true
    exploitation_sau_herbe_prairies_peu_productives?: true
    exploitation_sau_herbe_subventions?: true
    exploitation_sau_herbe_bois_patures?: true
    exploitation_sau_jardins?: true
    superficie_sau?: true
    superficie_sau_terres_arables?: true
    superficie_sau_terres_arables_cereales?: true
    superficie_sau_terres_arables_oleagineux?: true
    superficie_sau_terres_arables_fourrageres?: true
    superficie_sau_terres_arables_tubercules?: true
    superficie_sau_terres_arables_legumes_melons_fraises?: true
    superficie_sau_terres_arables_fleurs?: true
    superficie_sau_terres_arables_autres?: true
    superficie_sau_cultures_permanentes?: true
    superficie_sau_cultures_permanentes_vigne?: true
    superficie_sau_cultures_permanentes_fruits?: true
    superficie_sau_cultures_permanentes_autres?: true
    superficie_sau_herbe?: true
    superficie_sau_herbe_prairies_productives?: true
    superficie_sau_herbe_prairies_peu_productives?: true
    superficie_sau_herbe_subventions?: true
    superficie_sau_herbe_bois_patures?: true
    superficie_sau_jardins?: true
  }

  export type Surfaces_agricolesMinAggregateInputType = {
    index?: true
    epci?: true
    exploitation_sau?: true
    exploitation_sau_terres_arables?: true
    exploitation_sau_terres_arables_cereales?: true
    exploitation_sau_terres_arables_oleagineux?: true
    exploitation_sau_terres_arables_fourrageres?: true
    exploitation_sau_terres_arables_tubercules?: true
    exploitation_sau_terres_arables_legumes_melons_fraises?: true
    exploitation_sau_terres_arables_fleurs?: true
    exploitation_sau_terres_arables_autres?: true
    exploitation_sau_cultures_permanentes?: true
    exploitation_sau_cultures_permanentes_vigne?: true
    exploitation_sau_cultures_permanentes_fruits?: true
    exploitation_sau_cultures_permanentes_autres?: true
    exploitation_sau_herbe?: true
    exploitation_sau_herbe_prairies_productives?: true
    exploitation_sau_herbe_prairies_peu_productives?: true
    exploitation_sau_herbe_subventions?: true
    exploitation_sau_herbe_bois_patures?: true
    exploitation_sau_jardins?: true
    superficie_sau?: true
    superficie_sau_terres_arables?: true
    superficie_sau_terres_arables_cereales?: true
    superficie_sau_terres_arables_oleagineux?: true
    superficie_sau_terres_arables_fourrageres?: true
    superficie_sau_terres_arables_tubercules?: true
    superficie_sau_terres_arables_legumes_melons_fraises?: true
    superficie_sau_terres_arables_fleurs?: true
    superficie_sau_terres_arables_autres?: true
    superficie_sau_cultures_permanentes?: true
    superficie_sau_cultures_permanentes_vigne?: true
    superficie_sau_cultures_permanentes_fruits?: true
    superficie_sau_cultures_permanentes_autres?: true
    superficie_sau_herbe?: true
    superficie_sau_herbe_prairies_productives?: true
    superficie_sau_herbe_prairies_peu_productives?: true
    superficie_sau_herbe_subventions?: true
    superficie_sau_herbe_bois_patures?: true
    superficie_sau_jardins?: true
  }

  export type Surfaces_agricolesMaxAggregateInputType = {
    index?: true
    epci?: true
    exploitation_sau?: true
    exploitation_sau_terres_arables?: true
    exploitation_sau_terres_arables_cereales?: true
    exploitation_sau_terres_arables_oleagineux?: true
    exploitation_sau_terres_arables_fourrageres?: true
    exploitation_sau_terres_arables_tubercules?: true
    exploitation_sau_terres_arables_legumes_melons_fraises?: true
    exploitation_sau_terres_arables_fleurs?: true
    exploitation_sau_terres_arables_autres?: true
    exploitation_sau_cultures_permanentes?: true
    exploitation_sau_cultures_permanentes_vigne?: true
    exploitation_sau_cultures_permanentes_fruits?: true
    exploitation_sau_cultures_permanentes_autres?: true
    exploitation_sau_herbe?: true
    exploitation_sau_herbe_prairies_productives?: true
    exploitation_sau_herbe_prairies_peu_productives?: true
    exploitation_sau_herbe_subventions?: true
    exploitation_sau_herbe_bois_patures?: true
    exploitation_sau_jardins?: true
    superficie_sau?: true
    superficie_sau_terres_arables?: true
    superficie_sau_terres_arables_cereales?: true
    superficie_sau_terres_arables_oleagineux?: true
    superficie_sau_terres_arables_fourrageres?: true
    superficie_sau_terres_arables_tubercules?: true
    superficie_sau_terres_arables_legumes_melons_fraises?: true
    superficie_sau_terres_arables_fleurs?: true
    superficie_sau_terres_arables_autres?: true
    superficie_sau_cultures_permanentes?: true
    superficie_sau_cultures_permanentes_vigne?: true
    superficie_sau_cultures_permanentes_fruits?: true
    superficie_sau_cultures_permanentes_autres?: true
    superficie_sau_herbe?: true
    superficie_sau_herbe_prairies_productives?: true
    superficie_sau_herbe_prairies_peu_productives?: true
    superficie_sau_herbe_subventions?: true
    superficie_sau_herbe_bois_patures?: true
    superficie_sau_jardins?: true
  }

  export type Surfaces_agricolesCountAggregateInputType = {
    index?: true
    epci?: true
    exploitation_sau?: true
    exploitation_sau_terres_arables?: true
    exploitation_sau_terres_arables_cereales?: true
    exploitation_sau_terres_arables_oleagineux?: true
    exploitation_sau_terres_arables_fourrageres?: true
    exploitation_sau_terres_arables_tubercules?: true
    exploitation_sau_terres_arables_legumes_melons_fraises?: true
    exploitation_sau_terres_arables_fleurs?: true
    exploitation_sau_terres_arables_autres?: true
    exploitation_sau_cultures_permanentes?: true
    exploitation_sau_cultures_permanentes_vigne?: true
    exploitation_sau_cultures_permanentes_fruits?: true
    exploitation_sau_cultures_permanentes_autres?: true
    exploitation_sau_herbe?: true
    exploitation_sau_herbe_prairies_productives?: true
    exploitation_sau_herbe_prairies_peu_productives?: true
    exploitation_sau_herbe_subventions?: true
    exploitation_sau_herbe_bois_patures?: true
    exploitation_sau_jardins?: true
    superficie_sau?: true
    superficie_sau_terres_arables?: true
    superficie_sau_terres_arables_cereales?: true
    superficie_sau_terres_arables_oleagineux?: true
    superficie_sau_terres_arables_fourrageres?: true
    superficie_sau_terres_arables_tubercules?: true
    superficie_sau_terres_arables_legumes_melons_fraises?: true
    superficie_sau_terres_arables_fleurs?: true
    superficie_sau_terres_arables_autres?: true
    superficie_sau_cultures_permanentes?: true
    superficie_sau_cultures_permanentes_vigne?: true
    superficie_sau_cultures_permanentes_fruits?: true
    superficie_sau_cultures_permanentes_autres?: true
    superficie_sau_herbe?: true
    superficie_sau_herbe_prairies_productives?: true
    superficie_sau_herbe_prairies_peu_productives?: true
    superficie_sau_herbe_subventions?: true
    superficie_sau_herbe_bois_patures?: true
    superficie_sau_jardins?: true
    _all?: true
  }

  export type Surfaces_agricolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which surfaces_agricoles to aggregate.
     */
    where?: surfaces_agricolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of surfaces_agricoles to fetch.
     */
    orderBy?: surfaces_agricolesOrderByWithRelationInput | surfaces_agricolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: surfaces_agricolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` surfaces_agricoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` surfaces_agricoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned surfaces_agricoles
    **/
    _count?: true | Surfaces_agricolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Surfaces_agricolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Surfaces_agricolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Surfaces_agricolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Surfaces_agricolesMaxAggregateInputType
  }

  export type GetSurfaces_agricolesAggregateType<T extends Surfaces_agricolesAggregateArgs> = {
        [P in keyof T & keyof AggregateSurfaces_agricoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSurfaces_agricoles[P]>
      : GetScalarType<T[P], AggregateSurfaces_agricoles[P]>
  }




  export type surfaces_agricolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: surfaces_agricolesWhereInput
    orderBy?: surfaces_agricolesOrderByWithAggregationInput | surfaces_agricolesOrderByWithAggregationInput[]
    by: Surfaces_agricolesScalarFieldEnum[] | Surfaces_agricolesScalarFieldEnum
    having?: surfaces_agricolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Surfaces_agricolesCountAggregateInputType | true
    _avg?: Surfaces_agricolesAvgAggregateInputType
    _sum?: Surfaces_agricolesSumAggregateInputType
    _min?: Surfaces_agricolesMinAggregateInputType
    _max?: Surfaces_agricolesMaxAggregateInputType
  }

  export type Surfaces_agricolesGroupByOutputType = {
    index: number
    epci: string
    exploitation_sau: number
    exploitation_sau_terres_arables: number
    exploitation_sau_terres_arables_cereales: number
    exploitation_sau_terres_arables_oleagineux: number
    exploitation_sau_terres_arables_fourrageres: number
    exploitation_sau_terres_arables_tubercules: number
    exploitation_sau_terres_arables_legumes_melons_fraises: number
    exploitation_sau_terres_arables_fleurs: number
    exploitation_sau_terres_arables_autres: number
    exploitation_sau_cultures_permanentes: number
    exploitation_sau_cultures_permanentes_vigne: number
    exploitation_sau_cultures_permanentes_fruits: number
    exploitation_sau_cultures_permanentes_autres: number
    exploitation_sau_herbe: number
    exploitation_sau_herbe_prairies_productives: number
    exploitation_sau_herbe_prairies_peu_productives: number
    exploitation_sau_herbe_subventions: number
    exploitation_sau_herbe_bois_patures: number
    exploitation_sau_jardins: number
    superficie_sau: number
    superficie_sau_terres_arables: number
    superficie_sau_terres_arables_cereales: number
    superficie_sau_terres_arables_oleagineux: number
    superficie_sau_terres_arables_fourrageres: number
    superficie_sau_terres_arables_tubercules: number
    superficie_sau_terres_arables_legumes_melons_fraises: number
    superficie_sau_terres_arables_fleurs: number
    superficie_sau_terres_arables_autres: number
    superficie_sau_cultures_permanentes: number
    superficie_sau_cultures_permanentes_vigne: number
    superficie_sau_cultures_permanentes_fruits: number
    superficie_sau_cultures_permanentes_autres: number
    superficie_sau_herbe: number
    superficie_sau_herbe_prairies_productives: number
    superficie_sau_herbe_prairies_peu_productives: number
    superficie_sau_herbe_subventions: number
    superficie_sau_herbe_bois_patures: number
    superficie_sau_jardins: number
    _count: Surfaces_agricolesCountAggregateOutputType | null
    _avg: Surfaces_agricolesAvgAggregateOutputType | null
    _sum: Surfaces_agricolesSumAggregateOutputType | null
    _min: Surfaces_agricolesMinAggregateOutputType | null
    _max: Surfaces_agricolesMaxAggregateOutputType | null
  }

  type GetSurfaces_agricolesGroupByPayload<T extends surfaces_agricolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Surfaces_agricolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Surfaces_agricolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Surfaces_agricolesGroupByOutputType[P]>
            : GetScalarType<T[P], Surfaces_agricolesGroupByOutputType[P]>
        }
      >
    >


  export type surfaces_agricolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    epci?: boolean
    exploitation_sau?: boolean
    exploitation_sau_terres_arables?: boolean
    exploitation_sau_terres_arables_cereales?: boolean
    exploitation_sau_terres_arables_oleagineux?: boolean
    exploitation_sau_terres_arables_fourrageres?: boolean
    exploitation_sau_terres_arables_tubercules?: boolean
    exploitation_sau_terres_arables_legumes_melons_fraises?: boolean
    exploitation_sau_terres_arables_fleurs?: boolean
    exploitation_sau_terres_arables_autres?: boolean
    exploitation_sau_cultures_permanentes?: boolean
    exploitation_sau_cultures_permanentes_vigne?: boolean
    exploitation_sau_cultures_permanentes_fruits?: boolean
    exploitation_sau_cultures_permanentes_autres?: boolean
    exploitation_sau_herbe?: boolean
    exploitation_sau_herbe_prairies_productives?: boolean
    exploitation_sau_herbe_prairies_peu_productives?: boolean
    exploitation_sau_herbe_subventions?: boolean
    exploitation_sau_herbe_bois_patures?: boolean
    exploitation_sau_jardins?: boolean
    superficie_sau?: boolean
    superficie_sau_terres_arables?: boolean
    superficie_sau_terres_arables_cereales?: boolean
    superficie_sau_terres_arables_oleagineux?: boolean
    superficie_sau_terres_arables_fourrageres?: boolean
    superficie_sau_terres_arables_tubercules?: boolean
    superficie_sau_terres_arables_legumes_melons_fraises?: boolean
    superficie_sau_terres_arables_fleurs?: boolean
    superficie_sau_terres_arables_autres?: boolean
    superficie_sau_cultures_permanentes?: boolean
    superficie_sau_cultures_permanentes_vigne?: boolean
    superficie_sau_cultures_permanentes_fruits?: boolean
    superficie_sau_cultures_permanentes_autres?: boolean
    superficie_sau_herbe?: boolean
    superficie_sau_herbe_prairies_productives?: boolean
    superficie_sau_herbe_prairies_peu_productives?: boolean
    superficie_sau_herbe_subventions?: boolean
    superficie_sau_herbe_bois_patures?: boolean
    superficie_sau_jardins?: boolean
  }, ExtArgs["result"]["surfaces_agricoles"]>

  export type surfaces_agricolesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    epci?: boolean
    exploitation_sau?: boolean
    exploitation_sau_terres_arables?: boolean
    exploitation_sau_terres_arables_cereales?: boolean
    exploitation_sau_terres_arables_oleagineux?: boolean
    exploitation_sau_terres_arables_fourrageres?: boolean
    exploitation_sau_terres_arables_tubercules?: boolean
    exploitation_sau_terres_arables_legumes_melons_fraises?: boolean
    exploitation_sau_terres_arables_fleurs?: boolean
    exploitation_sau_terres_arables_autres?: boolean
    exploitation_sau_cultures_permanentes?: boolean
    exploitation_sau_cultures_permanentes_vigne?: boolean
    exploitation_sau_cultures_permanentes_fruits?: boolean
    exploitation_sau_cultures_permanentes_autres?: boolean
    exploitation_sau_herbe?: boolean
    exploitation_sau_herbe_prairies_productives?: boolean
    exploitation_sau_herbe_prairies_peu_productives?: boolean
    exploitation_sau_herbe_subventions?: boolean
    exploitation_sau_herbe_bois_patures?: boolean
    exploitation_sau_jardins?: boolean
    superficie_sau?: boolean
    superficie_sau_terres_arables?: boolean
    superficie_sau_terres_arables_cereales?: boolean
    superficie_sau_terres_arables_oleagineux?: boolean
    superficie_sau_terres_arables_fourrageres?: boolean
    superficie_sau_terres_arables_tubercules?: boolean
    superficie_sau_terres_arables_legumes_melons_fraises?: boolean
    superficie_sau_terres_arables_fleurs?: boolean
    superficie_sau_terres_arables_autres?: boolean
    superficie_sau_cultures_permanentes?: boolean
    superficie_sau_cultures_permanentes_vigne?: boolean
    superficie_sau_cultures_permanentes_fruits?: boolean
    superficie_sau_cultures_permanentes_autres?: boolean
    superficie_sau_herbe?: boolean
    superficie_sau_herbe_prairies_productives?: boolean
    superficie_sau_herbe_prairies_peu_productives?: boolean
    superficie_sau_herbe_subventions?: boolean
    superficie_sau_herbe_bois_patures?: boolean
    superficie_sau_jardins?: boolean
  }, ExtArgs["result"]["surfaces_agricoles"]>

  export type surfaces_agricolesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    epci?: boolean
    exploitation_sau?: boolean
    exploitation_sau_terres_arables?: boolean
    exploitation_sau_terres_arables_cereales?: boolean
    exploitation_sau_terres_arables_oleagineux?: boolean
    exploitation_sau_terres_arables_fourrageres?: boolean
    exploitation_sau_terres_arables_tubercules?: boolean
    exploitation_sau_terres_arables_legumes_melons_fraises?: boolean
    exploitation_sau_terres_arables_fleurs?: boolean
    exploitation_sau_terres_arables_autres?: boolean
    exploitation_sau_cultures_permanentes?: boolean
    exploitation_sau_cultures_permanentes_vigne?: boolean
    exploitation_sau_cultures_permanentes_fruits?: boolean
    exploitation_sau_cultures_permanentes_autres?: boolean
    exploitation_sau_herbe?: boolean
    exploitation_sau_herbe_prairies_productives?: boolean
    exploitation_sau_herbe_prairies_peu_productives?: boolean
    exploitation_sau_herbe_subventions?: boolean
    exploitation_sau_herbe_bois_patures?: boolean
    exploitation_sau_jardins?: boolean
    superficie_sau?: boolean
    superficie_sau_terres_arables?: boolean
    superficie_sau_terres_arables_cereales?: boolean
    superficie_sau_terres_arables_oleagineux?: boolean
    superficie_sau_terres_arables_fourrageres?: boolean
    superficie_sau_terres_arables_tubercules?: boolean
    superficie_sau_terres_arables_legumes_melons_fraises?: boolean
    superficie_sau_terres_arables_fleurs?: boolean
    superficie_sau_terres_arables_autres?: boolean
    superficie_sau_cultures_permanentes?: boolean
    superficie_sau_cultures_permanentes_vigne?: boolean
    superficie_sau_cultures_permanentes_fruits?: boolean
    superficie_sau_cultures_permanentes_autres?: boolean
    superficie_sau_herbe?: boolean
    superficie_sau_herbe_prairies_productives?: boolean
    superficie_sau_herbe_prairies_peu_productives?: boolean
    superficie_sau_herbe_subventions?: boolean
    superficie_sau_herbe_bois_patures?: boolean
    superficie_sau_jardins?: boolean
  }, ExtArgs["result"]["surfaces_agricoles"]>

  export type surfaces_agricolesSelectScalar = {
    index?: boolean
    epci?: boolean
    exploitation_sau?: boolean
    exploitation_sau_terres_arables?: boolean
    exploitation_sau_terres_arables_cereales?: boolean
    exploitation_sau_terres_arables_oleagineux?: boolean
    exploitation_sau_terres_arables_fourrageres?: boolean
    exploitation_sau_terres_arables_tubercules?: boolean
    exploitation_sau_terres_arables_legumes_melons_fraises?: boolean
    exploitation_sau_terres_arables_fleurs?: boolean
    exploitation_sau_terres_arables_autres?: boolean
    exploitation_sau_cultures_permanentes?: boolean
    exploitation_sau_cultures_permanentes_vigne?: boolean
    exploitation_sau_cultures_permanentes_fruits?: boolean
    exploitation_sau_cultures_permanentes_autres?: boolean
    exploitation_sau_herbe?: boolean
    exploitation_sau_herbe_prairies_productives?: boolean
    exploitation_sau_herbe_prairies_peu_productives?: boolean
    exploitation_sau_herbe_subventions?: boolean
    exploitation_sau_herbe_bois_patures?: boolean
    exploitation_sau_jardins?: boolean
    superficie_sau?: boolean
    superficie_sau_terres_arables?: boolean
    superficie_sau_terres_arables_cereales?: boolean
    superficie_sau_terres_arables_oleagineux?: boolean
    superficie_sau_terres_arables_fourrageres?: boolean
    superficie_sau_terres_arables_tubercules?: boolean
    superficie_sau_terres_arables_legumes_melons_fraises?: boolean
    superficie_sau_terres_arables_fleurs?: boolean
    superficie_sau_terres_arables_autres?: boolean
    superficie_sau_cultures_permanentes?: boolean
    superficie_sau_cultures_permanentes_vigne?: boolean
    superficie_sau_cultures_permanentes_fruits?: boolean
    superficie_sau_cultures_permanentes_autres?: boolean
    superficie_sau_herbe?: boolean
    superficie_sau_herbe_prairies_productives?: boolean
    superficie_sau_herbe_prairies_peu_productives?: boolean
    superficie_sau_herbe_subventions?: boolean
    superficie_sau_herbe_bois_patures?: boolean
    superficie_sau_jardins?: boolean
  }

  export type surfaces_agricolesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"index" | "epci" | "exploitation_sau" | "exploitation_sau_terres_arables" | "exploitation_sau_terres_arables_cereales" | "exploitation_sau_terres_arables_oleagineux" | "exploitation_sau_terres_arables_fourrageres" | "exploitation_sau_terres_arables_tubercules" | "exploitation_sau_terres_arables_legumes_melons_fraises" | "exploitation_sau_terres_arables_fleurs" | "exploitation_sau_terres_arables_autres" | "exploitation_sau_cultures_permanentes" | "exploitation_sau_cultures_permanentes_vigne" | "exploitation_sau_cultures_permanentes_fruits" | "exploitation_sau_cultures_permanentes_autres" | "exploitation_sau_herbe" | "exploitation_sau_herbe_prairies_productives" | "exploitation_sau_herbe_prairies_peu_productives" | "exploitation_sau_herbe_subventions" | "exploitation_sau_herbe_bois_patures" | "exploitation_sau_jardins" | "superficie_sau" | "superficie_sau_terres_arables" | "superficie_sau_terres_arables_cereales" | "superficie_sau_terres_arables_oleagineux" | "superficie_sau_terres_arables_fourrageres" | "superficie_sau_terres_arables_tubercules" | "superficie_sau_terres_arables_legumes_melons_fraises" | "superficie_sau_terres_arables_fleurs" | "superficie_sau_terres_arables_autres" | "superficie_sau_cultures_permanentes" | "superficie_sau_cultures_permanentes_vigne" | "superficie_sau_cultures_permanentes_fruits" | "superficie_sau_cultures_permanentes_autres" | "superficie_sau_herbe" | "superficie_sau_herbe_prairies_productives" | "superficie_sau_herbe_prairies_peu_productives" | "superficie_sau_herbe_subventions" | "superficie_sau_herbe_bois_patures" | "superficie_sau_jardins", ExtArgs["result"]["surfaces_agricoles"]>

  export type $surfaces_agricolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "surfaces_agricoles"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      index: number
      epci: string
      exploitation_sau: number
      exploitation_sau_terres_arables: number
      exploitation_sau_terres_arables_cereales: number
      exploitation_sau_terres_arables_oleagineux: number
      exploitation_sau_terres_arables_fourrageres: number
      exploitation_sau_terres_arables_tubercules: number
      exploitation_sau_terres_arables_legumes_melons_fraises: number
      exploitation_sau_terres_arables_fleurs: number
      exploitation_sau_terres_arables_autres: number
      exploitation_sau_cultures_permanentes: number
      exploitation_sau_cultures_permanentes_vigne: number
      exploitation_sau_cultures_permanentes_fruits: number
      exploitation_sau_cultures_permanentes_autres: number
      exploitation_sau_herbe: number
      exploitation_sau_herbe_prairies_productives: number
      exploitation_sau_herbe_prairies_peu_productives: number
      exploitation_sau_herbe_subventions: number
      exploitation_sau_herbe_bois_patures: number
      exploitation_sau_jardins: number
      superficie_sau: number
      superficie_sau_terres_arables: number
      superficie_sau_terres_arables_cereales: number
      superficie_sau_terres_arables_oleagineux: number
      superficie_sau_terres_arables_fourrageres: number
      superficie_sau_terres_arables_tubercules: number
      superficie_sau_terres_arables_legumes_melons_fraises: number
      superficie_sau_terres_arables_fleurs: number
      superficie_sau_terres_arables_autres: number
      superficie_sau_cultures_permanentes: number
      superficie_sau_cultures_permanentes_vigne: number
      superficie_sau_cultures_permanentes_fruits: number
      superficie_sau_cultures_permanentes_autres: number
      superficie_sau_herbe: number
      superficie_sau_herbe_prairies_productives: number
      superficie_sau_herbe_prairies_peu_productives: number
      superficie_sau_herbe_subventions: number
      superficie_sau_herbe_bois_patures: number
      superficie_sau_jardins: number
    }, ExtArgs["result"]["surfaces_agricoles"]>
    composites: {}
  }

  type surfaces_agricolesGetPayload<S extends boolean | null | undefined | surfaces_agricolesDefaultArgs> = $Result.GetResult<Prisma.$surfaces_agricolesPayload, S>

  type surfaces_agricolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<surfaces_agricolesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Surfaces_agricolesCountAggregateInputType | true
    }

  export interface surfaces_agricolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['surfaces_agricoles'], meta: { name: 'surfaces_agricoles' } }
    /**
     * Find zero or one Surfaces_agricoles that matches the filter.
     * @param {surfaces_agricolesFindUniqueArgs} args - Arguments to find a Surfaces_agricoles
     * @example
     * // Get one Surfaces_agricoles
     * const surfaces_agricoles = await prisma.surfaces_agricoles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends surfaces_agricolesFindUniqueArgs>(args: SelectSubset<T, surfaces_agricolesFindUniqueArgs<ExtArgs>>): Prisma__surfaces_agricolesClient<$Result.GetResult<Prisma.$surfaces_agricolesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Surfaces_agricoles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {surfaces_agricolesFindUniqueOrThrowArgs} args - Arguments to find a Surfaces_agricoles
     * @example
     * // Get one Surfaces_agricoles
     * const surfaces_agricoles = await prisma.surfaces_agricoles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends surfaces_agricolesFindUniqueOrThrowArgs>(args: SelectSubset<T, surfaces_agricolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__surfaces_agricolesClient<$Result.GetResult<Prisma.$surfaces_agricolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Surfaces_agricoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surfaces_agricolesFindFirstArgs} args - Arguments to find a Surfaces_agricoles
     * @example
     * // Get one Surfaces_agricoles
     * const surfaces_agricoles = await prisma.surfaces_agricoles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends surfaces_agricolesFindFirstArgs>(args?: SelectSubset<T, surfaces_agricolesFindFirstArgs<ExtArgs>>): Prisma__surfaces_agricolesClient<$Result.GetResult<Prisma.$surfaces_agricolesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Surfaces_agricoles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surfaces_agricolesFindFirstOrThrowArgs} args - Arguments to find a Surfaces_agricoles
     * @example
     * // Get one Surfaces_agricoles
     * const surfaces_agricoles = await prisma.surfaces_agricoles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends surfaces_agricolesFindFirstOrThrowArgs>(args?: SelectSubset<T, surfaces_agricolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__surfaces_agricolesClient<$Result.GetResult<Prisma.$surfaces_agricolesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Surfaces_agricoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surfaces_agricolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Surfaces_agricoles
     * const surfaces_agricoles = await prisma.surfaces_agricoles.findMany()
     * 
     * // Get first 10 Surfaces_agricoles
     * const surfaces_agricoles = await prisma.surfaces_agricoles.findMany({ take: 10 })
     * 
     * // Only select the `index`
     * const surfaces_agricolesWithIndexOnly = await prisma.surfaces_agricoles.findMany({ select: { index: true } })
     * 
     */
    findMany<T extends surfaces_agricolesFindManyArgs>(args?: SelectSubset<T, surfaces_agricolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$surfaces_agricolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Surfaces_agricoles.
     * @param {surfaces_agricolesCreateArgs} args - Arguments to create a Surfaces_agricoles.
     * @example
     * // Create one Surfaces_agricoles
     * const Surfaces_agricoles = await prisma.surfaces_agricoles.create({
     *   data: {
     *     // ... data to create a Surfaces_agricoles
     *   }
     * })
     * 
     */
    create<T extends surfaces_agricolesCreateArgs>(args: SelectSubset<T, surfaces_agricolesCreateArgs<ExtArgs>>): Prisma__surfaces_agricolesClient<$Result.GetResult<Prisma.$surfaces_agricolesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Surfaces_agricoles.
     * @param {surfaces_agricolesCreateManyArgs} args - Arguments to create many Surfaces_agricoles.
     * @example
     * // Create many Surfaces_agricoles
     * const surfaces_agricoles = await prisma.surfaces_agricoles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends surfaces_agricolesCreateManyArgs>(args?: SelectSubset<T, surfaces_agricolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Surfaces_agricoles and returns the data saved in the database.
     * @param {surfaces_agricolesCreateManyAndReturnArgs} args - Arguments to create many Surfaces_agricoles.
     * @example
     * // Create many Surfaces_agricoles
     * const surfaces_agricoles = await prisma.surfaces_agricoles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Surfaces_agricoles and only return the `index`
     * const surfaces_agricolesWithIndexOnly = await prisma.surfaces_agricoles.createManyAndReturn({
     *   select: { index: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends surfaces_agricolesCreateManyAndReturnArgs>(args?: SelectSubset<T, surfaces_agricolesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$surfaces_agricolesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Surfaces_agricoles.
     * @param {surfaces_agricolesDeleteArgs} args - Arguments to delete one Surfaces_agricoles.
     * @example
     * // Delete one Surfaces_agricoles
     * const Surfaces_agricoles = await prisma.surfaces_agricoles.delete({
     *   where: {
     *     // ... filter to delete one Surfaces_agricoles
     *   }
     * })
     * 
     */
    delete<T extends surfaces_agricolesDeleteArgs>(args: SelectSubset<T, surfaces_agricolesDeleteArgs<ExtArgs>>): Prisma__surfaces_agricolesClient<$Result.GetResult<Prisma.$surfaces_agricolesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Surfaces_agricoles.
     * @param {surfaces_agricolesUpdateArgs} args - Arguments to update one Surfaces_agricoles.
     * @example
     * // Update one Surfaces_agricoles
     * const surfaces_agricoles = await prisma.surfaces_agricoles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends surfaces_agricolesUpdateArgs>(args: SelectSubset<T, surfaces_agricolesUpdateArgs<ExtArgs>>): Prisma__surfaces_agricolesClient<$Result.GetResult<Prisma.$surfaces_agricolesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Surfaces_agricoles.
     * @param {surfaces_agricolesDeleteManyArgs} args - Arguments to filter Surfaces_agricoles to delete.
     * @example
     * // Delete a few Surfaces_agricoles
     * const { count } = await prisma.surfaces_agricoles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends surfaces_agricolesDeleteManyArgs>(args?: SelectSubset<T, surfaces_agricolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Surfaces_agricoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surfaces_agricolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Surfaces_agricoles
     * const surfaces_agricoles = await prisma.surfaces_agricoles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends surfaces_agricolesUpdateManyArgs>(args: SelectSubset<T, surfaces_agricolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Surfaces_agricoles and returns the data updated in the database.
     * @param {surfaces_agricolesUpdateManyAndReturnArgs} args - Arguments to update many Surfaces_agricoles.
     * @example
     * // Update many Surfaces_agricoles
     * const surfaces_agricoles = await prisma.surfaces_agricoles.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Surfaces_agricoles and only return the `index`
     * const surfaces_agricolesWithIndexOnly = await prisma.surfaces_agricoles.updateManyAndReturn({
     *   select: { index: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends surfaces_agricolesUpdateManyAndReturnArgs>(args: SelectSubset<T, surfaces_agricolesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$surfaces_agricolesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Surfaces_agricoles.
     * @param {surfaces_agricolesUpsertArgs} args - Arguments to update or create a Surfaces_agricoles.
     * @example
     * // Update or create a Surfaces_agricoles
     * const surfaces_agricoles = await prisma.surfaces_agricoles.upsert({
     *   create: {
     *     // ... data to create a Surfaces_agricoles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Surfaces_agricoles we want to update
     *   }
     * })
     */
    upsert<T extends surfaces_agricolesUpsertArgs>(args: SelectSubset<T, surfaces_agricolesUpsertArgs<ExtArgs>>): Prisma__surfaces_agricolesClient<$Result.GetResult<Prisma.$surfaces_agricolesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Surfaces_agricoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surfaces_agricolesCountArgs} args - Arguments to filter Surfaces_agricoles to count.
     * @example
     * // Count the number of Surfaces_agricoles
     * const count = await prisma.surfaces_agricoles.count({
     *   where: {
     *     // ... the filter for the Surfaces_agricoles we want to count
     *   }
     * })
    **/
    count<T extends surfaces_agricolesCountArgs>(
      args?: Subset<T, surfaces_agricolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Surfaces_agricolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Surfaces_agricoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Surfaces_agricolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Surfaces_agricolesAggregateArgs>(args: Subset<T, Surfaces_agricolesAggregateArgs>): Prisma.PrismaPromise<GetSurfaces_agricolesAggregateType<T>>

    /**
     * Group by Surfaces_agricoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surfaces_agricolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends surfaces_agricolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: surfaces_agricolesGroupByArgs['orderBy'] }
        : { orderBy?: surfaces_agricolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, surfaces_agricolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSurfaces_agricolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the surfaces_agricoles model
   */
  readonly fields: surfaces_agricolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for surfaces_agricoles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__surfaces_agricolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the surfaces_agricoles model
   */
  interface surfaces_agricolesFieldRefs {
    readonly index: FieldRef<"surfaces_agricoles", 'Int'>
    readonly epci: FieldRef<"surfaces_agricoles", 'String'>
    readonly exploitation_sau: FieldRef<"surfaces_agricoles", 'Float'>
    readonly exploitation_sau_terres_arables: FieldRef<"surfaces_agricoles", 'Float'>
    readonly exploitation_sau_terres_arables_cereales: FieldRef<"surfaces_agricoles", 'Float'>
    readonly exploitation_sau_terres_arables_oleagineux: FieldRef<"surfaces_agricoles", 'Float'>
    readonly exploitation_sau_terres_arables_fourrageres: FieldRef<"surfaces_agricoles", 'Float'>
    readonly exploitation_sau_terres_arables_tubercules: FieldRef<"surfaces_agricoles", 'Float'>
    readonly exploitation_sau_terres_arables_legumes_melons_fraises: FieldRef<"surfaces_agricoles", 'Float'>
    readonly exploitation_sau_terres_arables_fleurs: FieldRef<"surfaces_agricoles", 'Float'>
    readonly exploitation_sau_terres_arables_autres: FieldRef<"surfaces_agricoles", 'Float'>
    readonly exploitation_sau_cultures_permanentes: FieldRef<"surfaces_agricoles", 'Float'>
    readonly exploitation_sau_cultures_permanentes_vigne: FieldRef<"surfaces_agricoles", 'Float'>
    readonly exploitation_sau_cultures_permanentes_fruits: FieldRef<"surfaces_agricoles", 'Float'>
    readonly exploitation_sau_cultures_permanentes_autres: FieldRef<"surfaces_agricoles", 'Float'>
    readonly exploitation_sau_herbe: FieldRef<"surfaces_agricoles", 'Float'>
    readonly exploitation_sau_herbe_prairies_productives: FieldRef<"surfaces_agricoles", 'Float'>
    readonly exploitation_sau_herbe_prairies_peu_productives: FieldRef<"surfaces_agricoles", 'Float'>
    readonly exploitation_sau_herbe_subventions: FieldRef<"surfaces_agricoles", 'Float'>
    readonly exploitation_sau_herbe_bois_patures: FieldRef<"surfaces_agricoles", 'Float'>
    readonly exploitation_sau_jardins: FieldRef<"surfaces_agricoles", 'Float'>
    readonly superficie_sau: FieldRef<"surfaces_agricoles", 'Float'>
    readonly superficie_sau_terres_arables: FieldRef<"surfaces_agricoles", 'Float'>
    readonly superficie_sau_terres_arables_cereales: FieldRef<"surfaces_agricoles", 'Float'>
    readonly superficie_sau_terres_arables_oleagineux: FieldRef<"surfaces_agricoles", 'Float'>
    readonly superficie_sau_terres_arables_fourrageres: FieldRef<"surfaces_agricoles", 'Float'>
    readonly superficie_sau_terres_arables_tubercules: FieldRef<"surfaces_agricoles", 'Float'>
    readonly superficie_sau_terres_arables_legumes_melons_fraises: FieldRef<"surfaces_agricoles", 'Float'>
    readonly superficie_sau_terres_arables_fleurs: FieldRef<"surfaces_agricoles", 'Float'>
    readonly superficie_sau_terres_arables_autres: FieldRef<"surfaces_agricoles", 'Float'>
    readonly superficie_sau_cultures_permanentes: FieldRef<"surfaces_agricoles", 'Float'>
    readonly superficie_sau_cultures_permanentes_vigne: FieldRef<"surfaces_agricoles", 'Float'>
    readonly superficie_sau_cultures_permanentes_fruits: FieldRef<"surfaces_agricoles", 'Float'>
    readonly superficie_sau_cultures_permanentes_autres: FieldRef<"surfaces_agricoles", 'Float'>
    readonly superficie_sau_herbe: FieldRef<"surfaces_agricoles", 'Float'>
    readonly superficie_sau_herbe_prairies_productives: FieldRef<"surfaces_agricoles", 'Float'>
    readonly superficie_sau_herbe_prairies_peu_productives: FieldRef<"surfaces_agricoles", 'Float'>
    readonly superficie_sau_herbe_subventions: FieldRef<"surfaces_agricoles", 'Float'>
    readonly superficie_sau_herbe_bois_patures: FieldRef<"surfaces_agricoles", 'Float'>
    readonly superficie_sau_jardins: FieldRef<"surfaces_agricoles", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * surfaces_agricoles findUnique
   */
  export type surfaces_agricolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surfaces_agricoles
     */
    select?: surfaces_agricolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surfaces_agricoles
     */
    omit?: surfaces_agricolesOmit<ExtArgs> | null
    /**
     * Filter, which surfaces_agricoles to fetch.
     */
    where: surfaces_agricolesWhereUniqueInput
  }

  /**
   * surfaces_agricoles findUniqueOrThrow
   */
  export type surfaces_agricolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surfaces_agricoles
     */
    select?: surfaces_agricolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surfaces_agricoles
     */
    omit?: surfaces_agricolesOmit<ExtArgs> | null
    /**
     * Filter, which surfaces_agricoles to fetch.
     */
    where: surfaces_agricolesWhereUniqueInput
  }

  /**
   * surfaces_agricoles findFirst
   */
  export type surfaces_agricolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surfaces_agricoles
     */
    select?: surfaces_agricolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surfaces_agricoles
     */
    omit?: surfaces_agricolesOmit<ExtArgs> | null
    /**
     * Filter, which surfaces_agricoles to fetch.
     */
    where?: surfaces_agricolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of surfaces_agricoles to fetch.
     */
    orderBy?: surfaces_agricolesOrderByWithRelationInput | surfaces_agricolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for surfaces_agricoles.
     */
    cursor?: surfaces_agricolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` surfaces_agricoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` surfaces_agricoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of surfaces_agricoles.
     */
    distinct?: Surfaces_agricolesScalarFieldEnum | Surfaces_agricolesScalarFieldEnum[]
  }

  /**
   * surfaces_agricoles findFirstOrThrow
   */
  export type surfaces_agricolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surfaces_agricoles
     */
    select?: surfaces_agricolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surfaces_agricoles
     */
    omit?: surfaces_agricolesOmit<ExtArgs> | null
    /**
     * Filter, which surfaces_agricoles to fetch.
     */
    where?: surfaces_agricolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of surfaces_agricoles to fetch.
     */
    orderBy?: surfaces_agricolesOrderByWithRelationInput | surfaces_agricolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for surfaces_agricoles.
     */
    cursor?: surfaces_agricolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` surfaces_agricoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` surfaces_agricoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of surfaces_agricoles.
     */
    distinct?: Surfaces_agricolesScalarFieldEnum | Surfaces_agricolesScalarFieldEnum[]
  }

  /**
   * surfaces_agricoles findMany
   */
  export type surfaces_agricolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surfaces_agricoles
     */
    select?: surfaces_agricolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surfaces_agricoles
     */
    omit?: surfaces_agricolesOmit<ExtArgs> | null
    /**
     * Filter, which surfaces_agricoles to fetch.
     */
    where?: surfaces_agricolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of surfaces_agricoles to fetch.
     */
    orderBy?: surfaces_agricolesOrderByWithRelationInput | surfaces_agricolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing surfaces_agricoles.
     */
    cursor?: surfaces_agricolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` surfaces_agricoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` surfaces_agricoles.
     */
    skip?: number
    distinct?: Surfaces_agricolesScalarFieldEnum | Surfaces_agricolesScalarFieldEnum[]
  }

  /**
   * surfaces_agricoles create
   */
  export type surfaces_agricolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surfaces_agricoles
     */
    select?: surfaces_agricolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surfaces_agricoles
     */
    omit?: surfaces_agricolesOmit<ExtArgs> | null
    /**
     * The data needed to create a surfaces_agricoles.
     */
    data: XOR<surfaces_agricolesCreateInput, surfaces_agricolesUncheckedCreateInput>
  }

  /**
   * surfaces_agricoles createMany
   */
  export type surfaces_agricolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many surfaces_agricoles.
     */
    data: surfaces_agricolesCreateManyInput | surfaces_agricolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * surfaces_agricoles createManyAndReturn
   */
  export type surfaces_agricolesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surfaces_agricoles
     */
    select?: surfaces_agricolesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the surfaces_agricoles
     */
    omit?: surfaces_agricolesOmit<ExtArgs> | null
    /**
     * The data used to create many surfaces_agricoles.
     */
    data: surfaces_agricolesCreateManyInput | surfaces_agricolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * surfaces_agricoles update
   */
  export type surfaces_agricolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surfaces_agricoles
     */
    select?: surfaces_agricolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surfaces_agricoles
     */
    omit?: surfaces_agricolesOmit<ExtArgs> | null
    /**
     * The data needed to update a surfaces_agricoles.
     */
    data: XOR<surfaces_agricolesUpdateInput, surfaces_agricolesUncheckedUpdateInput>
    /**
     * Choose, which surfaces_agricoles to update.
     */
    where: surfaces_agricolesWhereUniqueInput
  }

  /**
   * surfaces_agricoles updateMany
   */
  export type surfaces_agricolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update surfaces_agricoles.
     */
    data: XOR<surfaces_agricolesUpdateManyMutationInput, surfaces_agricolesUncheckedUpdateManyInput>
    /**
     * Filter which surfaces_agricoles to update
     */
    where?: surfaces_agricolesWhereInput
    /**
     * Limit how many surfaces_agricoles to update.
     */
    limit?: number
  }

  /**
   * surfaces_agricoles updateManyAndReturn
   */
  export type surfaces_agricolesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surfaces_agricoles
     */
    select?: surfaces_agricolesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the surfaces_agricoles
     */
    omit?: surfaces_agricolesOmit<ExtArgs> | null
    /**
     * The data used to update surfaces_agricoles.
     */
    data: XOR<surfaces_agricolesUpdateManyMutationInput, surfaces_agricolesUncheckedUpdateManyInput>
    /**
     * Filter which surfaces_agricoles to update
     */
    where?: surfaces_agricolesWhereInput
    /**
     * Limit how many surfaces_agricoles to update.
     */
    limit?: number
  }

  /**
   * surfaces_agricoles upsert
   */
  export type surfaces_agricolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surfaces_agricoles
     */
    select?: surfaces_agricolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surfaces_agricoles
     */
    omit?: surfaces_agricolesOmit<ExtArgs> | null
    /**
     * The filter to search for the surfaces_agricoles to update in case it exists.
     */
    where: surfaces_agricolesWhereUniqueInput
    /**
     * In case the surfaces_agricoles found by the `where` argument doesn't exist, create a new surfaces_agricoles with this data.
     */
    create: XOR<surfaces_agricolesCreateInput, surfaces_agricolesUncheckedCreateInput>
    /**
     * In case the surfaces_agricoles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<surfaces_agricolesUpdateInput, surfaces_agricolesUncheckedUpdateInput>
  }

  /**
   * surfaces_agricoles delete
   */
  export type surfaces_agricolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surfaces_agricoles
     */
    select?: surfaces_agricolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surfaces_agricoles
     */
    omit?: surfaces_agricolesOmit<ExtArgs> | null
    /**
     * Filter which surfaces_agricoles to delete.
     */
    where: surfaces_agricolesWhereUniqueInput
  }

  /**
   * surfaces_agricoles deleteMany
   */
  export type surfaces_agricolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which surfaces_agricoles to delete
     */
    where?: surfaces_agricolesWhereInput
    /**
     * Limit how many surfaces_agricoles to delete.
     */
    limit?: number
  }

  /**
   * surfaces_agricoles without action
   */
  export type surfaces_agricolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surfaces_agricoles
     */
    select?: surfaces_agricolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surfaces_agricoles
     */
    omit?: surfaces_agricolesOmit<ExtArgs> | null
  }


  /**
   * Model surfaces_protegees
   */

  export type AggregateSurfaces_protegees = {
    _count: Surfaces_protegeesCountAggregateOutputType | null
    _avg: Surfaces_protegeesAvgAggregateOutputType | null
    _sum: Surfaces_protegeesSumAggregateOutputType | null
    _min: Surfaces_protegeesMinAggregateOutputType | null
    _max: Surfaces_protegeesMaxAggregateOutputType | null
  }

  export type Surfaces_protegeesAvgAggregateOutputType = {
    index: number | null
    region: number | null
  }

  export type Surfaces_protegeesSumAggregateOutputType = {
    index: number | null
    region: number | null
  }

  export type Surfaces_protegeesMinAggregateOutputType = {
    index: number | null
    code_geographique: string | null
    PNC: string | null
    RAMSAR: string | null
    PNR: string | null
    PNP: string | null
    FOR_PRO: string | null
    ZZZ: string | null
    ZNIEFF2: string | null
    ZNIEFF1: string | null
    RNR: string | null
    TOU_PRO: string | null
    NATURA: string | null
    ZPS: string | null
    SIC: string | null
    CELRL: string | null
    BIO: string | null
    APB: string | null
    RN: string | null
    RBFD: string | null
    RNCFS: string | null
    libelle_geographique: string | null
    epci: string | null
    libelle_epci: string | null
    departement: string | null
    region: number | null
  }

  export type Surfaces_protegeesMaxAggregateOutputType = {
    index: number | null
    code_geographique: string | null
    PNC: string | null
    RAMSAR: string | null
    PNR: string | null
    PNP: string | null
    FOR_PRO: string | null
    ZZZ: string | null
    ZNIEFF2: string | null
    ZNIEFF1: string | null
    RNR: string | null
    TOU_PRO: string | null
    NATURA: string | null
    ZPS: string | null
    SIC: string | null
    CELRL: string | null
    BIO: string | null
    APB: string | null
    RN: string | null
    RBFD: string | null
    RNCFS: string | null
    libelle_geographique: string | null
    epci: string | null
    libelle_epci: string | null
    departement: string | null
    region: number | null
  }

  export type Surfaces_protegeesCountAggregateOutputType = {
    index: number
    code_geographique: number
    PNC: number
    RAMSAR: number
    PNR: number
    PNP: number
    FOR_PRO: number
    ZZZ: number
    ZNIEFF2: number
    ZNIEFF1: number
    RNR: number
    TOU_PRO: number
    NATURA: number
    ZPS: number
    SIC: number
    CELRL: number
    BIO: number
    APB: number
    RN: number
    RBFD: number
    RNCFS: number
    libelle_geographique: number
    epci: number
    libelle_epci: number
    departement: number
    region: number
    _all: number
  }


  export type Surfaces_protegeesAvgAggregateInputType = {
    index?: true
    region?: true
  }

  export type Surfaces_protegeesSumAggregateInputType = {
    index?: true
    region?: true
  }

  export type Surfaces_protegeesMinAggregateInputType = {
    index?: true
    code_geographique?: true
    PNC?: true
    RAMSAR?: true
    PNR?: true
    PNP?: true
    FOR_PRO?: true
    ZZZ?: true
    ZNIEFF2?: true
    ZNIEFF1?: true
    RNR?: true
    TOU_PRO?: true
    NATURA?: true
    ZPS?: true
    SIC?: true
    CELRL?: true
    BIO?: true
    APB?: true
    RN?: true
    RBFD?: true
    RNCFS?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    region?: true
  }

  export type Surfaces_protegeesMaxAggregateInputType = {
    index?: true
    code_geographique?: true
    PNC?: true
    RAMSAR?: true
    PNR?: true
    PNP?: true
    FOR_PRO?: true
    ZZZ?: true
    ZNIEFF2?: true
    ZNIEFF1?: true
    RNR?: true
    TOU_PRO?: true
    NATURA?: true
    ZPS?: true
    SIC?: true
    CELRL?: true
    BIO?: true
    APB?: true
    RN?: true
    RBFD?: true
    RNCFS?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    region?: true
  }

  export type Surfaces_protegeesCountAggregateInputType = {
    index?: true
    code_geographique?: true
    PNC?: true
    RAMSAR?: true
    PNR?: true
    PNP?: true
    FOR_PRO?: true
    ZZZ?: true
    ZNIEFF2?: true
    ZNIEFF1?: true
    RNR?: true
    TOU_PRO?: true
    NATURA?: true
    ZPS?: true
    SIC?: true
    CELRL?: true
    BIO?: true
    APB?: true
    RN?: true
    RBFD?: true
    RNCFS?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    region?: true
    _all?: true
  }

  export type Surfaces_protegeesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which surfaces_protegees to aggregate.
     */
    where?: surfaces_protegeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of surfaces_protegees to fetch.
     */
    orderBy?: surfaces_protegeesOrderByWithRelationInput | surfaces_protegeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: surfaces_protegeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` surfaces_protegees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` surfaces_protegees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned surfaces_protegees
    **/
    _count?: true | Surfaces_protegeesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Surfaces_protegeesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Surfaces_protegeesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Surfaces_protegeesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Surfaces_protegeesMaxAggregateInputType
  }

  export type GetSurfaces_protegeesAggregateType<T extends Surfaces_protegeesAggregateArgs> = {
        [P in keyof T & keyof AggregateSurfaces_protegees]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSurfaces_protegees[P]>
      : GetScalarType<T[P], AggregateSurfaces_protegees[P]>
  }




  export type surfaces_protegeesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: surfaces_protegeesWhereInput
    orderBy?: surfaces_protegeesOrderByWithAggregationInput | surfaces_protegeesOrderByWithAggregationInput[]
    by: Surfaces_protegeesScalarFieldEnum[] | Surfaces_protegeesScalarFieldEnum
    having?: surfaces_protegeesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Surfaces_protegeesCountAggregateInputType | true
    _avg?: Surfaces_protegeesAvgAggregateInputType
    _sum?: Surfaces_protegeesSumAggregateInputType
    _min?: Surfaces_protegeesMinAggregateInputType
    _max?: Surfaces_protegeesMaxAggregateInputType
  }

  export type Surfaces_protegeesGroupByOutputType = {
    index: number
    code_geographique: string
    PNC: string | null
    RAMSAR: string | null
    PNR: string | null
    PNP: string | null
    FOR_PRO: string | null
    ZZZ: string | null
    ZNIEFF2: string | null
    ZNIEFF1: string | null
    RNR: string | null
    TOU_PRO: string | null
    NATURA: string | null
    ZPS: string | null
    SIC: string | null
    CELRL: string | null
    BIO: string | null
    APB: string | null
    RN: string | null
    RBFD: string | null
    RNCFS: string | null
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    region: number
    _count: Surfaces_protegeesCountAggregateOutputType | null
    _avg: Surfaces_protegeesAvgAggregateOutputType | null
    _sum: Surfaces_protegeesSumAggregateOutputType | null
    _min: Surfaces_protegeesMinAggregateOutputType | null
    _max: Surfaces_protegeesMaxAggregateOutputType | null
  }

  type GetSurfaces_protegeesGroupByPayload<T extends surfaces_protegeesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Surfaces_protegeesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Surfaces_protegeesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Surfaces_protegeesGroupByOutputType[P]>
            : GetScalarType<T[P], Surfaces_protegeesGroupByOutputType[P]>
        }
      >
    >


  export type surfaces_protegeesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    PNC?: boolean
    RAMSAR?: boolean
    PNR?: boolean
    PNP?: boolean
    FOR_PRO?: boolean
    ZZZ?: boolean
    ZNIEFF2?: boolean
    ZNIEFF1?: boolean
    RNR?: boolean
    TOU_PRO?: boolean
    NATURA?: boolean
    ZPS?: boolean
    SIC?: boolean
    CELRL?: boolean
    BIO?: boolean
    APB?: boolean
    RN?: boolean
    RBFD?: boolean
    RNCFS?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    region?: boolean
  }, ExtArgs["result"]["surfaces_protegees"]>

  export type surfaces_protegeesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    PNC?: boolean
    RAMSAR?: boolean
    PNR?: boolean
    PNP?: boolean
    FOR_PRO?: boolean
    ZZZ?: boolean
    ZNIEFF2?: boolean
    ZNIEFF1?: boolean
    RNR?: boolean
    TOU_PRO?: boolean
    NATURA?: boolean
    ZPS?: boolean
    SIC?: boolean
    CELRL?: boolean
    BIO?: boolean
    APB?: boolean
    RN?: boolean
    RBFD?: boolean
    RNCFS?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    region?: boolean
  }, ExtArgs["result"]["surfaces_protegees"]>

  export type surfaces_protegeesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    PNC?: boolean
    RAMSAR?: boolean
    PNR?: boolean
    PNP?: boolean
    FOR_PRO?: boolean
    ZZZ?: boolean
    ZNIEFF2?: boolean
    ZNIEFF1?: boolean
    RNR?: boolean
    TOU_PRO?: boolean
    NATURA?: boolean
    ZPS?: boolean
    SIC?: boolean
    CELRL?: boolean
    BIO?: boolean
    APB?: boolean
    RN?: boolean
    RBFD?: boolean
    RNCFS?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    region?: boolean
  }, ExtArgs["result"]["surfaces_protegees"]>

  export type surfaces_protegeesSelectScalar = {
    index?: boolean
    code_geographique?: boolean
    PNC?: boolean
    RAMSAR?: boolean
    PNR?: boolean
    PNP?: boolean
    FOR_PRO?: boolean
    ZZZ?: boolean
    ZNIEFF2?: boolean
    ZNIEFF1?: boolean
    RNR?: boolean
    TOU_PRO?: boolean
    NATURA?: boolean
    ZPS?: boolean
    SIC?: boolean
    CELRL?: boolean
    BIO?: boolean
    APB?: boolean
    RN?: boolean
    RBFD?: boolean
    RNCFS?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    region?: boolean
  }

  export type surfaces_protegeesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"index" | "code_geographique" | "PNC" | "RAMSAR" | "PNR" | "PNP" | "FOR_PRO" | "ZZZ" | "ZNIEFF2" | "ZNIEFF1" | "RNR" | "TOU_PRO" | "NATURA" | "ZPS" | "SIC" | "CELRL" | "BIO" | "APB" | "RN" | "RBFD" | "RNCFS" | "libelle_geographique" | "epci" | "libelle_epci" | "departement" | "region", ExtArgs["result"]["surfaces_protegees"]>

  export type $surfaces_protegeesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "surfaces_protegees"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      index: number
      code_geographique: string
      PNC: string | null
      RAMSAR: string | null
      PNR: string | null
      PNP: string | null
      FOR_PRO: string | null
      ZZZ: string | null
      ZNIEFF2: string | null
      ZNIEFF1: string | null
      RNR: string | null
      TOU_PRO: string | null
      NATURA: string | null
      ZPS: string | null
      SIC: string | null
      CELRL: string | null
      BIO: string | null
      APB: string | null
      RN: string | null
      RBFD: string | null
      RNCFS: string | null
      libelle_geographique: string
      epci: string
      libelle_epci: string
      departement: string
      region: number
    }, ExtArgs["result"]["surfaces_protegees"]>
    composites: {}
  }

  type surfaces_protegeesGetPayload<S extends boolean | null | undefined | surfaces_protegeesDefaultArgs> = $Result.GetResult<Prisma.$surfaces_protegeesPayload, S>

  type surfaces_protegeesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<surfaces_protegeesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Surfaces_protegeesCountAggregateInputType | true
    }

  export interface surfaces_protegeesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['surfaces_protegees'], meta: { name: 'surfaces_protegees' } }
    /**
     * Find zero or one Surfaces_protegees that matches the filter.
     * @param {surfaces_protegeesFindUniqueArgs} args - Arguments to find a Surfaces_protegees
     * @example
     * // Get one Surfaces_protegees
     * const surfaces_protegees = await prisma.surfaces_protegees.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends surfaces_protegeesFindUniqueArgs>(args: SelectSubset<T, surfaces_protegeesFindUniqueArgs<ExtArgs>>): Prisma__surfaces_protegeesClient<$Result.GetResult<Prisma.$surfaces_protegeesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Surfaces_protegees that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {surfaces_protegeesFindUniqueOrThrowArgs} args - Arguments to find a Surfaces_protegees
     * @example
     * // Get one Surfaces_protegees
     * const surfaces_protegees = await prisma.surfaces_protegees.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends surfaces_protegeesFindUniqueOrThrowArgs>(args: SelectSubset<T, surfaces_protegeesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__surfaces_protegeesClient<$Result.GetResult<Prisma.$surfaces_protegeesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Surfaces_protegees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surfaces_protegeesFindFirstArgs} args - Arguments to find a Surfaces_protegees
     * @example
     * // Get one Surfaces_protegees
     * const surfaces_protegees = await prisma.surfaces_protegees.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends surfaces_protegeesFindFirstArgs>(args?: SelectSubset<T, surfaces_protegeesFindFirstArgs<ExtArgs>>): Prisma__surfaces_protegeesClient<$Result.GetResult<Prisma.$surfaces_protegeesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Surfaces_protegees that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surfaces_protegeesFindFirstOrThrowArgs} args - Arguments to find a Surfaces_protegees
     * @example
     * // Get one Surfaces_protegees
     * const surfaces_protegees = await prisma.surfaces_protegees.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends surfaces_protegeesFindFirstOrThrowArgs>(args?: SelectSubset<T, surfaces_protegeesFindFirstOrThrowArgs<ExtArgs>>): Prisma__surfaces_protegeesClient<$Result.GetResult<Prisma.$surfaces_protegeesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Surfaces_protegees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surfaces_protegeesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Surfaces_protegees
     * const surfaces_protegees = await prisma.surfaces_protegees.findMany()
     * 
     * // Get first 10 Surfaces_protegees
     * const surfaces_protegees = await prisma.surfaces_protegees.findMany({ take: 10 })
     * 
     * // Only select the `index`
     * const surfaces_protegeesWithIndexOnly = await prisma.surfaces_protegees.findMany({ select: { index: true } })
     * 
     */
    findMany<T extends surfaces_protegeesFindManyArgs>(args?: SelectSubset<T, surfaces_protegeesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$surfaces_protegeesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Surfaces_protegees.
     * @param {surfaces_protegeesCreateArgs} args - Arguments to create a Surfaces_protegees.
     * @example
     * // Create one Surfaces_protegees
     * const Surfaces_protegees = await prisma.surfaces_protegees.create({
     *   data: {
     *     // ... data to create a Surfaces_protegees
     *   }
     * })
     * 
     */
    create<T extends surfaces_protegeesCreateArgs>(args: SelectSubset<T, surfaces_protegeesCreateArgs<ExtArgs>>): Prisma__surfaces_protegeesClient<$Result.GetResult<Prisma.$surfaces_protegeesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Surfaces_protegees.
     * @param {surfaces_protegeesCreateManyArgs} args - Arguments to create many Surfaces_protegees.
     * @example
     * // Create many Surfaces_protegees
     * const surfaces_protegees = await prisma.surfaces_protegees.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends surfaces_protegeesCreateManyArgs>(args?: SelectSubset<T, surfaces_protegeesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Surfaces_protegees and returns the data saved in the database.
     * @param {surfaces_protegeesCreateManyAndReturnArgs} args - Arguments to create many Surfaces_protegees.
     * @example
     * // Create many Surfaces_protegees
     * const surfaces_protegees = await prisma.surfaces_protegees.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Surfaces_protegees and only return the `index`
     * const surfaces_protegeesWithIndexOnly = await prisma.surfaces_protegees.createManyAndReturn({
     *   select: { index: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends surfaces_protegeesCreateManyAndReturnArgs>(args?: SelectSubset<T, surfaces_protegeesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$surfaces_protegeesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Surfaces_protegees.
     * @param {surfaces_protegeesDeleteArgs} args - Arguments to delete one Surfaces_protegees.
     * @example
     * // Delete one Surfaces_protegees
     * const Surfaces_protegees = await prisma.surfaces_protegees.delete({
     *   where: {
     *     // ... filter to delete one Surfaces_protegees
     *   }
     * })
     * 
     */
    delete<T extends surfaces_protegeesDeleteArgs>(args: SelectSubset<T, surfaces_protegeesDeleteArgs<ExtArgs>>): Prisma__surfaces_protegeesClient<$Result.GetResult<Prisma.$surfaces_protegeesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Surfaces_protegees.
     * @param {surfaces_protegeesUpdateArgs} args - Arguments to update one Surfaces_protegees.
     * @example
     * // Update one Surfaces_protegees
     * const surfaces_protegees = await prisma.surfaces_protegees.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends surfaces_protegeesUpdateArgs>(args: SelectSubset<T, surfaces_protegeesUpdateArgs<ExtArgs>>): Prisma__surfaces_protegeesClient<$Result.GetResult<Prisma.$surfaces_protegeesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Surfaces_protegees.
     * @param {surfaces_protegeesDeleteManyArgs} args - Arguments to filter Surfaces_protegees to delete.
     * @example
     * // Delete a few Surfaces_protegees
     * const { count } = await prisma.surfaces_protegees.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends surfaces_protegeesDeleteManyArgs>(args?: SelectSubset<T, surfaces_protegeesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Surfaces_protegees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surfaces_protegeesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Surfaces_protegees
     * const surfaces_protegees = await prisma.surfaces_protegees.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends surfaces_protegeesUpdateManyArgs>(args: SelectSubset<T, surfaces_protegeesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Surfaces_protegees and returns the data updated in the database.
     * @param {surfaces_protegeesUpdateManyAndReturnArgs} args - Arguments to update many Surfaces_protegees.
     * @example
     * // Update many Surfaces_protegees
     * const surfaces_protegees = await prisma.surfaces_protegees.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Surfaces_protegees and only return the `index`
     * const surfaces_protegeesWithIndexOnly = await prisma.surfaces_protegees.updateManyAndReturn({
     *   select: { index: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends surfaces_protegeesUpdateManyAndReturnArgs>(args: SelectSubset<T, surfaces_protegeesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$surfaces_protegeesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Surfaces_protegees.
     * @param {surfaces_protegeesUpsertArgs} args - Arguments to update or create a Surfaces_protegees.
     * @example
     * // Update or create a Surfaces_protegees
     * const surfaces_protegees = await prisma.surfaces_protegees.upsert({
     *   create: {
     *     // ... data to create a Surfaces_protegees
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Surfaces_protegees we want to update
     *   }
     * })
     */
    upsert<T extends surfaces_protegeesUpsertArgs>(args: SelectSubset<T, surfaces_protegeesUpsertArgs<ExtArgs>>): Prisma__surfaces_protegeesClient<$Result.GetResult<Prisma.$surfaces_protegeesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Surfaces_protegees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surfaces_protegeesCountArgs} args - Arguments to filter Surfaces_protegees to count.
     * @example
     * // Count the number of Surfaces_protegees
     * const count = await prisma.surfaces_protegees.count({
     *   where: {
     *     // ... the filter for the Surfaces_protegees we want to count
     *   }
     * })
    **/
    count<T extends surfaces_protegeesCountArgs>(
      args?: Subset<T, surfaces_protegeesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Surfaces_protegeesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Surfaces_protegees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Surfaces_protegeesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Surfaces_protegeesAggregateArgs>(args: Subset<T, Surfaces_protegeesAggregateArgs>): Prisma.PrismaPromise<GetSurfaces_protegeesAggregateType<T>>

    /**
     * Group by Surfaces_protegees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {surfaces_protegeesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends surfaces_protegeesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: surfaces_protegeesGroupByArgs['orderBy'] }
        : { orderBy?: surfaces_protegeesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, surfaces_protegeesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSurfaces_protegeesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the surfaces_protegees model
   */
  readonly fields: surfaces_protegeesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for surfaces_protegees.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__surfaces_protegeesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the surfaces_protegees model
   */
  interface surfaces_protegeesFieldRefs {
    readonly index: FieldRef<"surfaces_protegees", 'Int'>
    readonly code_geographique: FieldRef<"surfaces_protegees", 'String'>
    readonly PNC: FieldRef<"surfaces_protegees", 'String'>
    readonly RAMSAR: FieldRef<"surfaces_protegees", 'String'>
    readonly PNR: FieldRef<"surfaces_protegees", 'String'>
    readonly PNP: FieldRef<"surfaces_protegees", 'String'>
    readonly FOR_PRO: FieldRef<"surfaces_protegees", 'String'>
    readonly ZZZ: FieldRef<"surfaces_protegees", 'String'>
    readonly ZNIEFF2: FieldRef<"surfaces_protegees", 'String'>
    readonly ZNIEFF1: FieldRef<"surfaces_protegees", 'String'>
    readonly RNR: FieldRef<"surfaces_protegees", 'String'>
    readonly TOU_PRO: FieldRef<"surfaces_protegees", 'String'>
    readonly NATURA: FieldRef<"surfaces_protegees", 'String'>
    readonly ZPS: FieldRef<"surfaces_protegees", 'String'>
    readonly SIC: FieldRef<"surfaces_protegees", 'String'>
    readonly CELRL: FieldRef<"surfaces_protegees", 'String'>
    readonly BIO: FieldRef<"surfaces_protegees", 'String'>
    readonly APB: FieldRef<"surfaces_protegees", 'String'>
    readonly RN: FieldRef<"surfaces_protegees", 'String'>
    readonly RBFD: FieldRef<"surfaces_protegees", 'String'>
    readonly RNCFS: FieldRef<"surfaces_protegees", 'String'>
    readonly libelle_geographique: FieldRef<"surfaces_protegees", 'String'>
    readonly epci: FieldRef<"surfaces_protegees", 'String'>
    readonly libelle_epci: FieldRef<"surfaces_protegees", 'String'>
    readonly departement: FieldRef<"surfaces_protegees", 'String'>
    readonly region: FieldRef<"surfaces_protegees", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * surfaces_protegees findUnique
   */
  export type surfaces_protegeesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surfaces_protegees
     */
    select?: surfaces_protegeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surfaces_protegees
     */
    omit?: surfaces_protegeesOmit<ExtArgs> | null
    /**
     * Filter, which surfaces_protegees to fetch.
     */
    where: surfaces_protegeesWhereUniqueInput
  }

  /**
   * surfaces_protegees findUniqueOrThrow
   */
  export type surfaces_protegeesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surfaces_protegees
     */
    select?: surfaces_protegeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surfaces_protegees
     */
    omit?: surfaces_protegeesOmit<ExtArgs> | null
    /**
     * Filter, which surfaces_protegees to fetch.
     */
    where: surfaces_protegeesWhereUniqueInput
  }

  /**
   * surfaces_protegees findFirst
   */
  export type surfaces_protegeesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surfaces_protegees
     */
    select?: surfaces_protegeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surfaces_protegees
     */
    omit?: surfaces_protegeesOmit<ExtArgs> | null
    /**
     * Filter, which surfaces_protegees to fetch.
     */
    where?: surfaces_protegeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of surfaces_protegees to fetch.
     */
    orderBy?: surfaces_protegeesOrderByWithRelationInput | surfaces_protegeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for surfaces_protegees.
     */
    cursor?: surfaces_protegeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` surfaces_protegees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` surfaces_protegees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of surfaces_protegees.
     */
    distinct?: Surfaces_protegeesScalarFieldEnum | Surfaces_protegeesScalarFieldEnum[]
  }

  /**
   * surfaces_protegees findFirstOrThrow
   */
  export type surfaces_protegeesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surfaces_protegees
     */
    select?: surfaces_protegeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surfaces_protegees
     */
    omit?: surfaces_protegeesOmit<ExtArgs> | null
    /**
     * Filter, which surfaces_protegees to fetch.
     */
    where?: surfaces_protegeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of surfaces_protegees to fetch.
     */
    orderBy?: surfaces_protegeesOrderByWithRelationInput | surfaces_protegeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for surfaces_protegees.
     */
    cursor?: surfaces_protegeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` surfaces_protegees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` surfaces_protegees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of surfaces_protegees.
     */
    distinct?: Surfaces_protegeesScalarFieldEnum | Surfaces_protegeesScalarFieldEnum[]
  }

  /**
   * surfaces_protegees findMany
   */
  export type surfaces_protegeesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surfaces_protegees
     */
    select?: surfaces_protegeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surfaces_protegees
     */
    omit?: surfaces_protegeesOmit<ExtArgs> | null
    /**
     * Filter, which surfaces_protegees to fetch.
     */
    where?: surfaces_protegeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of surfaces_protegees to fetch.
     */
    orderBy?: surfaces_protegeesOrderByWithRelationInput | surfaces_protegeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing surfaces_protegees.
     */
    cursor?: surfaces_protegeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` surfaces_protegees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` surfaces_protegees.
     */
    skip?: number
    distinct?: Surfaces_protegeesScalarFieldEnum | Surfaces_protegeesScalarFieldEnum[]
  }

  /**
   * surfaces_protegees create
   */
  export type surfaces_protegeesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surfaces_protegees
     */
    select?: surfaces_protegeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surfaces_protegees
     */
    omit?: surfaces_protegeesOmit<ExtArgs> | null
    /**
     * The data needed to create a surfaces_protegees.
     */
    data: XOR<surfaces_protegeesCreateInput, surfaces_protegeesUncheckedCreateInput>
  }

  /**
   * surfaces_protegees createMany
   */
  export type surfaces_protegeesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many surfaces_protegees.
     */
    data: surfaces_protegeesCreateManyInput | surfaces_protegeesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * surfaces_protegees createManyAndReturn
   */
  export type surfaces_protegeesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surfaces_protegees
     */
    select?: surfaces_protegeesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the surfaces_protegees
     */
    omit?: surfaces_protegeesOmit<ExtArgs> | null
    /**
     * The data used to create many surfaces_protegees.
     */
    data: surfaces_protegeesCreateManyInput | surfaces_protegeesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * surfaces_protegees update
   */
  export type surfaces_protegeesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surfaces_protegees
     */
    select?: surfaces_protegeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surfaces_protegees
     */
    omit?: surfaces_protegeesOmit<ExtArgs> | null
    /**
     * The data needed to update a surfaces_protegees.
     */
    data: XOR<surfaces_protegeesUpdateInput, surfaces_protegeesUncheckedUpdateInput>
    /**
     * Choose, which surfaces_protegees to update.
     */
    where: surfaces_protegeesWhereUniqueInput
  }

  /**
   * surfaces_protegees updateMany
   */
  export type surfaces_protegeesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update surfaces_protegees.
     */
    data: XOR<surfaces_protegeesUpdateManyMutationInput, surfaces_protegeesUncheckedUpdateManyInput>
    /**
     * Filter which surfaces_protegees to update
     */
    where?: surfaces_protegeesWhereInput
    /**
     * Limit how many surfaces_protegees to update.
     */
    limit?: number
  }

  /**
   * surfaces_protegees updateManyAndReturn
   */
  export type surfaces_protegeesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surfaces_protegees
     */
    select?: surfaces_protegeesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the surfaces_protegees
     */
    omit?: surfaces_protegeesOmit<ExtArgs> | null
    /**
     * The data used to update surfaces_protegees.
     */
    data: XOR<surfaces_protegeesUpdateManyMutationInput, surfaces_protegeesUncheckedUpdateManyInput>
    /**
     * Filter which surfaces_protegees to update
     */
    where?: surfaces_protegeesWhereInput
    /**
     * Limit how many surfaces_protegees to update.
     */
    limit?: number
  }

  /**
   * surfaces_protegees upsert
   */
  export type surfaces_protegeesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surfaces_protegees
     */
    select?: surfaces_protegeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surfaces_protegees
     */
    omit?: surfaces_protegeesOmit<ExtArgs> | null
    /**
     * The filter to search for the surfaces_protegees to update in case it exists.
     */
    where: surfaces_protegeesWhereUniqueInput
    /**
     * In case the surfaces_protegees found by the `where` argument doesn't exist, create a new surfaces_protegees with this data.
     */
    create: XOR<surfaces_protegeesCreateInput, surfaces_protegeesUncheckedCreateInput>
    /**
     * In case the surfaces_protegees was found with the provided `where` argument, update it with this data.
     */
    update: XOR<surfaces_protegeesUpdateInput, surfaces_protegeesUncheckedUpdateInput>
  }

  /**
   * surfaces_protegees delete
   */
  export type surfaces_protegeesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surfaces_protegees
     */
    select?: surfaces_protegeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surfaces_protegees
     */
    omit?: surfaces_protegeesOmit<ExtArgs> | null
    /**
     * Filter which surfaces_protegees to delete.
     */
    where: surfaces_protegeesWhereUniqueInput
  }

  /**
   * surfaces_protegees deleteMany
   */
  export type surfaces_protegeesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which surfaces_protegees to delete
     */
    where?: surfaces_protegeesWhereInput
    /**
     * Limit how many surfaces_protegees to delete.
     */
    limit?: number
  }

  /**
   * surfaces_protegees without action
   */
  export type surfaces_protegeesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the surfaces_protegees
     */
    select?: surfaces_protegeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the surfaces_protegees
     */
    omit?: surfaces_protegeesOmit<ExtArgs> | null
  }


  /**
   * Model table_commune
   */

  export type AggregateTable_commune = {
    _count: Table_communeCountAggregateOutputType | null
    _avg: Table_communeAvgAggregateOutputType | null
    _sum: Table_communeSumAggregateOutputType | null
    _min: Table_communeMinAggregateOutputType | null
    _max: Table_communeMaxAggregateOutputType | null
  }

  export type Table_communeAvgAggregateOutputType = {
    index: number | null
    region: number | null
  }

  export type Table_communeSumAggregateOutputType = {
    index: number | null
    region: number | null
  }

  export type Table_communeMinAggregateOutputType = {
    index: number | null
    code_geographique: string | null
    libelle_geographique: string | null
    epci: string | null
    libelle_epci: string | null
    departement: string | null
    libelle_departement: string | null
    region: number | null
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
    atlas_biodiversite_nom: string | null
    atlas_biodiversite_annee_debut: string | null
    atlas_biodiversite_avancement: string | null
    type_touristique: string | null
    otex_12_postes: string | null
    part_irr_sau_2020: string | null
    agriculture_part_over_55: string | null
    couverture_lcz: string | null
  }

  export type Table_communeMaxAggregateOutputType = {
    index: number | null
    code_geographique: string | null
    libelle_geographique: string | null
    epci: string | null
    libelle_epci: string | null
    departement: string | null
    libelle_departement: string | null
    region: number | null
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
    atlas_biodiversite_nom: string | null
    atlas_biodiversite_annee_debut: string | null
    atlas_biodiversite_avancement: string | null
    type_touristique: string | null
    otex_12_postes: string | null
    part_irr_sau_2020: string | null
    agriculture_part_over_55: string | null
    couverture_lcz: string | null
  }

  export type Table_communeCountAggregateOutputType = {
    index: number
    code_geographique: number
    libelle_geographique: number
    epci: number
    libelle_epci: number
    departement: number
    libelle_departement: number
    region: number
    ept: number
    libelle_petr: number
    code_pnr: number
    libelle_pnr: number
    atlas_biodiversite_nom: number
    atlas_biodiversite_annee_debut: number
    atlas_biodiversite_avancement: number
    type_touristique: number
    otex_12_postes: number
    part_irr_sau_2020: number
    agriculture_part_over_55: number
    couverture_lcz: number
    _all: number
  }


  export type Table_communeAvgAggregateInputType = {
    index?: true
    region?: true
  }

  export type Table_communeSumAggregateInputType = {
    index?: true
    region?: true
  }

  export type Table_communeMinAggregateInputType = {
    index?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
    atlas_biodiversite_nom?: true
    atlas_biodiversite_annee_debut?: true
    atlas_biodiversite_avancement?: true
    type_touristique?: true
    otex_12_postes?: true
    part_irr_sau_2020?: true
    agriculture_part_over_55?: true
    couverture_lcz?: true
  }

  export type Table_communeMaxAggregateInputType = {
    index?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
    atlas_biodiversite_nom?: true
    atlas_biodiversite_annee_debut?: true
    atlas_biodiversite_avancement?: true
    type_touristique?: true
    otex_12_postes?: true
    part_irr_sau_2020?: true
    agriculture_part_over_55?: true
    couverture_lcz?: true
  }

  export type Table_communeCountAggregateInputType = {
    index?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
    atlas_biodiversite_nom?: true
    atlas_biodiversite_annee_debut?: true
    atlas_biodiversite_avancement?: true
    type_touristique?: true
    otex_12_postes?: true
    part_irr_sau_2020?: true
    agriculture_part_over_55?: true
    couverture_lcz?: true
    _all?: true
  }

  export type Table_communeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which table_commune to aggregate.
     */
    where?: table_communeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of table_communes to fetch.
     */
    orderBy?: table_communeOrderByWithRelationInput | table_communeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: table_communeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` table_communes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` table_communes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned table_communes
    **/
    _count?: true | Table_communeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Table_communeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Table_communeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Table_communeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Table_communeMaxAggregateInputType
  }

  export type GetTable_communeAggregateType<T extends Table_communeAggregateArgs> = {
        [P in keyof T & keyof AggregateTable_commune]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTable_commune[P]>
      : GetScalarType<T[P], AggregateTable_commune[P]>
  }




  export type table_communeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: table_communeWhereInput
    orderBy?: table_communeOrderByWithAggregationInput | table_communeOrderByWithAggregationInput[]
    by: Table_communeScalarFieldEnum[] | Table_communeScalarFieldEnum
    having?: table_communeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Table_communeCountAggregateInputType | true
    _avg?: Table_communeAvgAggregateInputType
    _sum?: Table_communeSumAggregateInputType
    _min?: Table_communeMinAggregateInputType
    _max?: Table_communeMaxAggregateInputType
  }

  export type Table_communeGroupByOutputType = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
    atlas_biodiversite_nom: string | null
    atlas_biodiversite_annee_debut: string | null
    atlas_biodiversite_avancement: string | null
    type_touristique: string | null
    otex_12_postes: string | null
    part_irr_sau_2020: string | null
    agriculture_part_over_55: string | null
    couverture_lcz: string | null
    _count: Table_communeCountAggregateOutputType | null
    _avg: Table_communeAvgAggregateOutputType | null
    _sum: Table_communeSumAggregateOutputType | null
    _min: Table_communeMinAggregateOutputType | null
    _max: Table_communeMaxAggregateOutputType | null
  }

  type GetTable_communeGroupByPayload<T extends table_communeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Table_communeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Table_communeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Table_communeGroupByOutputType[P]>
            : GetScalarType<T[P], Table_communeGroupByOutputType[P]>
        }
      >
    >


  export type table_communeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    atlas_biodiversite_nom?: boolean
    atlas_biodiversite_annee_debut?: boolean
    atlas_biodiversite_avancement?: boolean
    type_touristique?: boolean
    otex_12_postes?: boolean
    part_irr_sau_2020?: boolean
    agriculture_part_over_55?: boolean
    couverture_lcz?: boolean
  }, ExtArgs["result"]["table_commune"]>

  export type table_communeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    atlas_biodiversite_nom?: boolean
    atlas_biodiversite_annee_debut?: boolean
    atlas_biodiversite_avancement?: boolean
    type_touristique?: boolean
    otex_12_postes?: boolean
    part_irr_sau_2020?: boolean
    agriculture_part_over_55?: boolean
    couverture_lcz?: boolean
  }, ExtArgs["result"]["table_commune"]>

  export type table_communeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    atlas_biodiversite_nom?: boolean
    atlas_biodiversite_annee_debut?: boolean
    atlas_biodiversite_avancement?: boolean
    type_touristique?: boolean
    otex_12_postes?: boolean
    part_irr_sau_2020?: boolean
    agriculture_part_over_55?: boolean
    couverture_lcz?: boolean
  }, ExtArgs["result"]["table_commune"]>

  export type table_communeSelectScalar = {
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    atlas_biodiversite_nom?: boolean
    atlas_biodiversite_annee_debut?: boolean
    atlas_biodiversite_avancement?: boolean
    type_touristique?: boolean
    otex_12_postes?: boolean
    part_irr_sau_2020?: boolean
    agriculture_part_over_55?: boolean
    couverture_lcz?: boolean
  }

  export type table_communeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"index" | "code_geographique" | "libelle_geographique" | "epci" | "libelle_epci" | "departement" | "libelle_departement" | "region" | "ept" | "libelle_petr" | "code_pnr" | "libelle_pnr" | "atlas_biodiversite_nom" | "atlas_biodiversite_annee_debut" | "atlas_biodiversite_avancement" | "type_touristique" | "otex_12_postes" | "part_irr_sau_2020" | "agriculture_part_over_55" | "couverture_lcz", ExtArgs["result"]["table_commune"]>

  export type $table_communePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "table_commune"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      index: number
      code_geographique: string
      libelle_geographique: string
      epci: string
      libelle_epci: string
      departement: string
      libelle_departement: string
      region: number
      ept: string | null
      libelle_petr: string | null
      code_pnr: string | null
      libelle_pnr: string | null
      atlas_biodiversite_nom: string | null
      atlas_biodiversite_annee_debut: string | null
      atlas_biodiversite_avancement: string | null
      type_touristique: string | null
      otex_12_postes: string | null
      part_irr_sau_2020: string | null
      agriculture_part_over_55: string | null
      couverture_lcz: string | null
    }, ExtArgs["result"]["table_commune"]>
    composites: {}
  }

  type table_communeGetPayload<S extends boolean | null | undefined | table_communeDefaultArgs> = $Result.GetResult<Prisma.$table_communePayload, S>

  type table_communeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<table_communeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Table_communeCountAggregateInputType | true
    }

  export interface table_communeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['table_commune'], meta: { name: 'table_commune' } }
    /**
     * Find zero or one Table_commune that matches the filter.
     * @param {table_communeFindUniqueArgs} args - Arguments to find a Table_commune
     * @example
     * // Get one Table_commune
     * const table_commune = await prisma.table_commune.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends table_communeFindUniqueArgs>(args: SelectSubset<T, table_communeFindUniqueArgs<ExtArgs>>): Prisma__table_communeClient<$Result.GetResult<Prisma.$table_communePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Table_commune that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {table_communeFindUniqueOrThrowArgs} args - Arguments to find a Table_commune
     * @example
     * // Get one Table_commune
     * const table_commune = await prisma.table_commune.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends table_communeFindUniqueOrThrowArgs>(args: SelectSubset<T, table_communeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__table_communeClient<$Result.GetResult<Prisma.$table_communePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Table_commune that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {table_communeFindFirstArgs} args - Arguments to find a Table_commune
     * @example
     * // Get one Table_commune
     * const table_commune = await prisma.table_commune.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends table_communeFindFirstArgs>(args?: SelectSubset<T, table_communeFindFirstArgs<ExtArgs>>): Prisma__table_communeClient<$Result.GetResult<Prisma.$table_communePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Table_commune that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {table_communeFindFirstOrThrowArgs} args - Arguments to find a Table_commune
     * @example
     * // Get one Table_commune
     * const table_commune = await prisma.table_commune.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends table_communeFindFirstOrThrowArgs>(args?: SelectSubset<T, table_communeFindFirstOrThrowArgs<ExtArgs>>): Prisma__table_communeClient<$Result.GetResult<Prisma.$table_communePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Table_communes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {table_communeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Table_communes
     * const table_communes = await prisma.table_commune.findMany()
     * 
     * // Get first 10 Table_communes
     * const table_communes = await prisma.table_commune.findMany({ take: 10 })
     * 
     * // Only select the `index`
     * const table_communeWithIndexOnly = await prisma.table_commune.findMany({ select: { index: true } })
     * 
     */
    findMany<T extends table_communeFindManyArgs>(args?: SelectSubset<T, table_communeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$table_communePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Table_commune.
     * @param {table_communeCreateArgs} args - Arguments to create a Table_commune.
     * @example
     * // Create one Table_commune
     * const Table_commune = await prisma.table_commune.create({
     *   data: {
     *     // ... data to create a Table_commune
     *   }
     * })
     * 
     */
    create<T extends table_communeCreateArgs>(args: SelectSubset<T, table_communeCreateArgs<ExtArgs>>): Prisma__table_communeClient<$Result.GetResult<Prisma.$table_communePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Table_communes.
     * @param {table_communeCreateManyArgs} args - Arguments to create many Table_communes.
     * @example
     * // Create many Table_communes
     * const table_commune = await prisma.table_commune.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends table_communeCreateManyArgs>(args?: SelectSubset<T, table_communeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Table_communes and returns the data saved in the database.
     * @param {table_communeCreateManyAndReturnArgs} args - Arguments to create many Table_communes.
     * @example
     * // Create many Table_communes
     * const table_commune = await prisma.table_commune.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Table_communes and only return the `index`
     * const table_communeWithIndexOnly = await prisma.table_commune.createManyAndReturn({
     *   select: { index: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends table_communeCreateManyAndReturnArgs>(args?: SelectSubset<T, table_communeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$table_communePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Table_commune.
     * @param {table_communeDeleteArgs} args - Arguments to delete one Table_commune.
     * @example
     * // Delete one Table_commune
     * const Table_commune = await prisma.table_commune.delete({
     *   where: {
     *     // ... filter to delete one Table_commune
     *   }
     * })
     * 
     */
    delete<T extends table_communeDeleteArgs>(args: SelectSubset<T, table_communeDeleteArgs<ExtArgs>>): Prisma__table_communeClient<$Result.GetResult<Prisma.$table_communePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Table_commune.
     * @param {table_communeUpdateArgs} args - Arguments to update one Table_commune.
     * @example
     * // Update one Table_commune
     * const table_commune = await prisma.table_commune.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends table_communeUpdateArgs>(args: SelectSubset<T, table_communeUpdateArgs<ExtArgs>>): Prisma__table_communeClient<$Result.GetResult<Prisma.$table_communePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Table_communes.
     * @param {table_communeDeleteManyArgs} args - Arguments to filter Table_communes to delete.
     * @example
     * // Delete a few Table_communes
     * const { count } = await prisma.table_commune.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends table_communeDeleteManyArgs>(args?: SelectSubset<T, table_communeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Table_communes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {table_communeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Table_communes
     * const table_commune = await prisma.table_commune.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends table_communeUpdateManyArgs>(args: SelectSubset<T, table_communeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Table_communes and returns the data updated in the database.
     * @param {table_communeUpdateManyAndReturnArgs} args - Arguments to update many Table_communes.
     * @example
     * // Update many Table_communes
     * const table_commune = await prisma.table_commune.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Table_communes and only return the `index`
     * const table_communeWithIndexOnly = await prisma.table_commune.updateManyAndReturn({
     *   select: { index: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends table_communeUpdateManyAndReturnArgs>(args: SelectSubset<T, table_communeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$table_communePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Table_commune.
     * @param {table_communeUpsertArgs} args - Arguments to update or create a Table_commune.
     * @example
     * // Update or create a Table_commune
     * const table_commune = await prisma.table_commune.upsert({
     *   create: {
     *     // ... data to create a Table_commune
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Table_commune we want to update
     *   }
     * })
     */
    upsert<T extends table_communeUpsertArgs>(args: SelectSubset<T, table_communeUpsertArgs<ExtArgs>>): Prisma__table_communeClient<$Result.GetResult<Prisma.$table_communePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Table_communes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {table_communeCountArgs} args - Arguments to filter Table_communes to count.
     * @example
     * // Count the number of Table_communes
     * const count = await prisma.table_commune.count({
     *   where: {
     *     // ... the filter for the Table_communes we want to count
     *   }
     * })
    **/
    count<T extends table_communeCountArgs>(
      args?: Subset<T, table_communeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Table_communeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Table_commune.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Table_communeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Table_communeAggregateArgs>(args: Subset<T, Table_communeAggregateArgs>): Prisma.PrismaPromise<GetTable_communeAggregateType<T>>

    /**
     * Group by Table_commune.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {table_communeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends table_communeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: table_communeGroupByArgs['orderBy'] }
        : { orderBy?: table_communeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, table_communeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTable_communeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the table_commune model
   */
  readonly fields: table_communeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for table_commune.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__table_communeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the table_commune model
   */
  interface table_communeFieldRefs {
    readonly index: FieldRef<"table_commune", 'Int'>
    readonly code_geographique: FieldRef<"table_commune", 'String'>
    readonly libelle_geographique: FieldRef<"table_commune", 'String'>
    readonly epci: FieldRef<"table_commune", 'String'>
    readonly libelle_epci: FieldRef<"table_commune", 'String'>
    readonly departement: FieldRef<"table_commune", 'String'>
    readonly libelle_departement: FieldRef<"table_commune", 'String'>
    readonly region: FieldRef<"table_commune", 'Int'>
    readonly ept: FieldRef<"table_commune", 'String'>
    readonly libelle_petr: FieldRef<"table_commune", 'String'>
    readonly code_pnr: FieldRef<"table_commune", 'String'>
    readonly libelle_pnr: FieldRef<"table_commune", 'String'>
    readonly atlas_biodiversite_nom: FieldRef<"table_commune", 'String'>
    readonly atlas_biodiversite_annee_debut: FieldRef<"table_commune", 'String'>
    readonly atlas_biodiversite_avancement: FieldRef<"table_commune", 'String'>
    readonly type_touristique: FieldRef<"table_commune", 'String'>
    readonly otex_12_postes: FieldRef<"table_commune", 'String'>
    readonly part_irr_sau_2020: FieldRef<"table_commune", 'String'>
    readonly agriculture_part_over_55: FieldRef<"table_commune", 'String'>
    readonly couverture_lcz: FieldRef<"table_commune", 'String'>
  }
    

  // Custom InputTypes
  /**
   * table_commune findUnique
   */
  export type table_communeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table_commune
     */
    select?: table_communeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table_commune
     */
    omit?: table_communeOmit<ExtArgs> | null
    /**
     * Filter, which table_commune to fetch.
     */
    where: table_communeWhereUniqueInput
  }

  /**
   * table_commune findUniqueOrThrow
   */
  export type table_communeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table_commune
     */
    select?: table_communeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table_commune
     */
    omit?: table_communeOmit<ExtArgs> | null
    /**
     * Filter, which table_commune to fetch.
     */
    where: table_communeWhereUniqueInput
  }

  /**
   * table_commune findFirst
   */
  export type table_communeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table_commune
     */
    select?: table_communeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table_commune
     */
    omit?: table_communeOmit<ExtArgs> | null
    /**
     * Filter, which table_commune to fetch.
     */
    where?: table_communeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of table_communes to fetch.
     */
    orderBy?: table_communeOrderByWithRelationInput | table_communeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for table_communes.
     */
    cursor?: table_communeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` table_communes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` table_communes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of table_communes.
     */
    distinct?: Table_communeScalarFieldEnum | Table_communeScalarFieldEnum[]
  }

  /**
   * table_commune findFirstOrThrow
   */
  export type table_communeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table_commune
     */
    select?: table_communeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table_commune
     */
    omit?: table_communeOmit<ExtArgs> | null
    /**
     * Filter, which table_commune to fetch.
     */
    where?: table_communeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of table_communes to fetch.
     */
    orderBy?: table_communeOrderByWithRelationInput | table_communeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for table_communes.
     */
    cursor?: table_communeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` table_communes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` table_communes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of table_communes.
     */
    distinct?: Table_communeScalarFieldEnum | Table_communeScalarFieldEnum[]
  }

  /**
   * table_commune findMany
   */
  export type table_communeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table_commune
     */
    select?: table_communeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table_commune
     */
    omit?: table_communeOmit<ExtArgs> | null
    /**
     * Filter, which table_communes to fetch.
     */
    where?: table_communeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of table_communes to fetch.
     */
    orderBy?: table_communeOrderByWithRelationInput | table_communeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing table_communes.
     */
    cursor?: table_communeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` table_communes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` table_communes.
     */
    skip?: number
    distinct?: Table_communeScalarFieldEnum | Table_communeScalarFieldEnum[]
  }

  /**
   * table_commune create
   */
  export type table_communeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table_commune
     */
    select?: table_communeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table_commune
     */
    omit?: table_communeOmit<ExtArgs> | null
    /**
     * The data needed to create a table_commune.
     */
    data: XOR<table_communeCreateInput, table_communeUncheckedCreateInput>
  }

  /**
   * table_commune createMany
   */
  export type table_communeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many table_communes.
     */
    data: table_communeCreateManyInput | table_communeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * table_commune createManyAndReturn
   */
  export type table_communeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table_commune
     */
    select?: table_communeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the table_commune
     */
    omit?: table_communeOmit<ExtArgs> | null
    /**
     * The data used to create many table_communes.
     */
    data: table_communeCreateManyInput | table_communeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * table_commune update
   */
  export type table_communeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table_commune
     */
    select?: table_communeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table_commune
     */
    omit?: table_communeOmit<ExtArgs> | null
    /**
     * The data needed to update a table_commune.
     */
    data: XOR<table_communeUpdateInput, table_communeUncheckedUpdateInput>
    /**
     * Choose, which table_commune to update.
     */
    where: table_communeWhereUniqueInput
  }

  /**
   * table_commune updateMany
   */
  export type table_communeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update table_communes.
     */
    data: XOR<table_communeUpdateManyMutationInput, table_communeUncheckedUpdateManyInput>
    /**
     * Filter which table_communes to update
     */
    where?: table_communeWhereInput
    /**
     * Limit how many table_communes to update.
     */
    limit?: number
  }

  /**
   * table_commune updateManyAndReturn
   */
  export type table_communeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table_commune
     */
    select?: table_communeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the table_commune
     */
    omit?: table_communeOmit<ExtArgs> | null
    /**
     * The data used to update table_communes.
     */
    data: XOR<table_communeUpdateManyMutationInput, table_communeUncheckedUpdateManyInput>
    /**
     * Filter which table_communes to update
     */
    where?: table_communeWhereInput
    /**
     * Limit how many table_communes to update.
     */
    limit?: number
  }

  /**
   * table_commune upsert
   */
  export type table_communeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table_commune
     */
    select?: table_communeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table_commune
     */
    omit?: table_communeOmit<ExtArgs> | null
    /**
     * The filter to search for the table_commune to update in case it exists.
     */
    where: table_communeWhereUniqueInput
    /**
     * In case the table_commune found by the `where` argument doesn't exist, create a new table_commune with this data.
     */
    create: XOR<table_communeCreateInput, table_communeUncheckedCreateInput>
    /**
     * In case the table_commune was found with the provided `where` argument, update it with this data.
     */
    update: XOR<table_communeUpdateInput, table_communeUncheckedUpdateInput>
  }

  /**
   * table_commune delete
   */
  export type table_communeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table_commune
     */
    select?: table_communeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table_commune
     */
    omit?: table_communeOmit<ExtArgs> | null
    /**
     * Filter which table_commune to delete.
     */
    where: table_communeWhereUniqueInput
  }

  /**
   * table_commune deleteMany
   */
  export type table_communeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which table_communes to delete
     */
    where?: table_communeWhereInput
    /**
     * Limit how many table_communes to delete.
     */
    limit?: number
  }

  /**
   * table_commune without action
   */
  export type table_communeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table_commune
     */
    select?: table_communeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table_commune
     */
    omit?: table_communeOmit<ExtArgs> | null
  }


  /**
   * Model table_territoires
   */

  export type AggregateTable_territoires = {
    _count: Table_territoiresCountAggregateOutputType | null
    _avg: Table_territoiresAvgAggregateOutputType | null
    _sum: Table_territoiresSumAggregateOutputType | null
    _min: Table_territoiresMinAggregateOutputType | null
    _max: Table_territoiresMaxAggregateOutputType | null
  }

  export type Table_territoiresAvgAggregateOutputType = {
    index: number | null
    region: number | null
  }

  export type Table_territoiresSumAggregateOutputType = {
    index: number | null
    region: number | null
  }

  export type Table_territoiresMinAggregateOutputType = {
    index: number | null
    code_geographique: string | null
    libelle_geographique: string | null
    epci: string | null
    libelle_epci: string | null
    departement: string | null
    libelle_departement: string | null
    region: number | null
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
  }

  export type Table_territoiresMaxAggregateOutputType = {
    index: number | null
    code_geographique: string | null
    libelle_geographique: string | null
    epci: string | null
    libelle_epci: string | null
    departement: string | null
    libelle_departement: string | null
    region: number | null
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
  }

  export type Table_territoiresCountAggregateOutputType = {
    index: number
    code_geographique: number
    libelle_geographique: number
    epci: number
    libelle_epci: number
    departement: number
    libelle_departement: number
    region: number
    ept: number
    libelle_petr: number
    code_pnr: number
    libelle_pnr: number
    _all: number
  }


  export type Table_territoiresAvgAggregateInputType = {
    index?: true
    region?: true
  }

  export type Table_territoiresSumAggregateInputType = {
    index?: true
    region?: true
  }

  export type Table_territoiresMinAggregateInputType = {
    index?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
  }

  export type Table_territoiresMaxAggregateInputType = {
    index?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
  }

  export type Table_territoiresCountAggregateInputType = {
    index?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
    _all?: true
  }

  export type Table_territoiresAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which table_territoires to aggregate.
     */
    where?: table_territoiresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of table_territoires to fetch.
     */
    orderBy?: table_territoiresOrderByWithRelationInput | table_territoiresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: table_territoiresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` table_territoires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` table_territoires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned table_territoires
    **/
    _count?: true | Table_territoiresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Table_territoiresAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Table_territoiresSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Table_territoiresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Table_territoiresMaxAggregateInputType
  }

  export type GetTable_territoiresAggregateType<T extends Table_territoiresAggregateArgs> = {
        [P in keyof T & keyof AggregateTable_territoires]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTable_territoires[P]>
      : GetScalarType<T[P], AggregateTable_territoires[P]>
  }




  export type table_territoiresGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: table_territoiresWhereInput
    orderBy?: table_territoiresOrderByWithAggregationInput | table_territoiresOrderByWithAggregationInput[]
    by: Table_territoiresScalarFieldEnum[] | Table_territoiresScalarFieldEnum
    having?: table_territoiresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Table_territoiresCountAggregateInputType | true
    _avg?: Table_territoiresAvgAggregateInputType
    _sum?: Table_territoiresSumAggregateInputType
    _min?: Table_territoiresMinAggregateInputType
    _max?: Table_territoiresMaxAggregateInputType
  }

  export type Table_territoiresGroupByOutputType = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
    _count: Table_territoiresCountAggregateOutputType | null
    _avg: Table_territoiresAvgAggregateOutputType | null
    _sum: Table_territoiresSumAggregateOutputType | null
    _min: Table_territoiresMinAggregateOutputType | null
    _max: Table_territoiresMaxAggregateOutputType | null
  }

  type GetTable_territoiresGroupByPayload<T extends table_territoiresGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Table_territoiresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Table_territoiresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Table_territoiresGroupByOutputType[P]>
            : GetScalarType<T[P], Table_territoiresGroupByOutputType[P]>
        }
      >
    >


  export type table_territoiresSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
  }, ExtArgs["result"]["table_territoires"]>

  export type table_territoiresSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
  }, ExtArgs["result"]["table_territoires"]>

  export type table_territoiresSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
  }, ExtArgs["result"]["table_territoires"]>

  export type table_territoiresSelectScalar = {
    index?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
  }

  export type table_territoiresOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"index" | "code_geographique" | "libelle_geographique" | "epci" | "libelle_epci" | "departement" | "libelle_departement" | "region" | "ept" | "libelle_petr" | "code_pnr" | "libelle_pnr", ExtArgs["result"]["table_territoires"]>

  export type $table_territoiresPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "table_territoires"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      index: number
      code_geographique: string
      libelle_geographique: string
      epci: string
      libelle_epci: string
      departement: string
      libelle_departement: string
      region: number
      ept: string | null
      libelle_petr: string | null
      code_pnr: string | null
      libelle_pnr: string | null
    }, ExtArgs["result"]["table_territoires"]>
    composites: {}
  }

  type table_territoiresGetPayload<S extends boolean | null | undefined | table_territoiresDefaultArgs> = $Result.GetResult<Prisma.$table_territoiresPayload, S>

  type table_territoiresCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<table_territoiresFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Table_territoiresCountAggregateInputType | true
    }

  export interface table_territoiresDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['table_territoires'], meta: { name: 'table_territoires' } }
    /**
     * Find zero or one Table_territoires that matches the filter.
     * @param {table_territoiresFindUniqueArgs} args - Arguments to find a Table_territoires
     * @example
     * // Get one Table_territoires
     * const table_territoires = await prisma.table_territoires.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends table_territoiresFindUniqueArgs>(args: SelectSubset<T, table_territoiresFindUniqueArgs<ExtArgs>>): Prisma__table_territoiresClient<$Result.GetResult<Prisma.$table_territoiresPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Table_territoires that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {table_territoiresFindUniqueOrThrowArgs} args - Arguments to find a Table_territoires
     * @example
     * // Get one Table_territoires
     * const table_territoires = await prisma.table_territoires.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends table_territoiresFindUniqueOrThrowArgs>(args: SelectSubset<T, table_territoiresFindUniqueOrThrowArgs<ExtArgs>>): Prisma__table_territoiresClient<$Result.GetResult<Prisma.$table_territoiresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Table_territoires that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {table_territoiresFindFirstArgs} args - Arguments to find a Table_territoires
     * @example
     * // Get one Table_territoires
     * const table_territoires = await prisma.table_territoires.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends table_territoiresFindFirstArgs>(args?: SelectSubset<T, table_territoiresFindFirstArgs<ExtArgs>>): Prisma__table_territoiresClient<$Result.GetResult<Prisma.$table_territoiresPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Table_territoires that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {table_territoiresFindFirstOrThrowArgs} args - Arguments to find a Table_territoires
     * @example
     * // Get one Table_territoires
     * const table_territoires = await prisma.table_territoires.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends table_territoiresFindFirstOrThrowArgs>(args?: SelectSubset<T, table_territoiresFindFirstOrThrowArgs<ExtArgs>>): Prisma__table_territoiresClient<$Result.GetResult<Prisma.$table_territoiresPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Table_territoires that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {table_territoiresFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Table_territoires
     * const table_territoires = await prisma.table_territoires.findMany()
     * 
     * // Get first 10 Table_territoires
     * const table_territoires = await prisma.table_territoires.findMany({ take: 10 })
     * 
     * // Only select the `index`
     * const table_territoiresWithIndexOnly = await prisma.table_territoires.findMany({ select: { index: true } })
     * 
     */
    findMany<T extends table_territoiresFindManyArgs>(args?: SelectSubset<T, table_territoiresFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$table_territoiresPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Table_territoires.
     * @param {table_territoiresCreateArgs} args - Arguments to create a Table_territoires.
     * @example
     * // Create one Table_territoires
     * const Table_territoires = await prisma.table_territoires.create({
     *   data: {
     *     // ... data to create a Table_territoires
     *   }
     * })
     * 
     */
    create<T extends table_territoiresCreateArgs>(args: SelectSubset<T, table_territoiresCreateArgs<ExtArgs>>): Prisma__table_territoiresClient<$Result.GetResult<Prisma.$table_territoiresPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Table_territoires.
     * @param {table_territoiresCreateManyArgs} args - Arguments to create many Table_territoires.
     * @example
     * // Create many Table_territoires
     * const table_territoires = await prisma.table_territoires.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends table_territoiresCreateManyArgs>(args?: SelectSubset<T, table_territoiresCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Table_territoires and returns the data saved in the database.
     * @param {table_territoiresCreateManyAndReturnArgs} args - Arguments to create many Table_territoires.
     * @example
     * // Create many Table_territoires
     * const table_territoires = await prisma.table_territoires.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Table_territoires and only return the `index`
     * const table_territoiresWithIndexOnly = await prisma.table_territoires.createManyAndReturn({
     *   select: { index: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends table_territoiresCreateManyAndReturnArgs>(args?: SelectSubset<T, table_territoiresCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$table_territoiresPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Table_territoires.
     * @param {table_territoiresDeleteArgs} args - Arguments to delete one Table_territoires.
     * @example
     * // Delete one Table_territoires
     * const Table_territoires = await prisma.table_territoires.delete({
     *   where: {
     *     // ... filter to delete one Table_territoires
     *   }
     * })
     * 
     */
    delete<T extends table_territoiresDeleteArgs>(args: SelectSubset<T, table_territoiresDeleteArgs<ExtArgs>>): Prisma__table_territoiresClient<$Result.GetResult<Prisma.$table_territoiresPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Table_territoires.
     * @param {table_territoiresUpdateArgs} args - Arguments to update one Table_territoires.
     * @example
     * // Update one Table_territoires
     * const table_territoires = await prisma.table_territoires.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends table_territoiresUpdateArgs>(args: SelectSubset<T, table_territoiresUpdateArgs<ExtArgs>>): Prisma__table_territoiresClient<$Result.GetResult<Prisma.$table_territoiresPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Table_territoires.
     * @param {table_territoiresDeleteManyArgs} args - Arguments to filter Table_territoires to delete.
     * @example
     * // Delete a few Table_territoires
     * const { count } = await prisma.table_territoires.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends table_territoiresDeleteManyArgs>(args?: SelectSubset<T, table_territoiresDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Table_territoires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {table_territoiresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Table_territoires
     * const table_territoires = await prisma.table_territoires.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends table_territoiresUpdateManyArgs>(args: SelectSubset<T, table_territoiresUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Table_territoires and returns the data updated in the database.
     * @param {table_territoiresUpdateManyAndReturnArgs} args - Arguments to update many Table_territoires.
     * @example
     * // Update many Table_territoires
     * const table_territoires = await prisma.table_territoires.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Table_territoires and only return the `index`
     * const table_territoiresWithIndexOnly = await prisma.table_territoires.updateManyAndReturn({
     *   select: { index: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends table_territoiresUpdateManyAndReturnArgs>(args: SelectSubset<T, table_territoiresUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$table_territoiresPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Table_territoires.
     * @param {table_territoiresUpsertArgs} args - Arguments to update or create a Table_territoires.
     * @example
     * // Update or create a Table_territoires
     * const table_territoires = await prisma.table_territoires.upsert({
     *   create: {
     *     // ... data to create a Table_territoires
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Table_territoires we want to update
     *   }
     * })
     */
    upsert<T extends table_territoiresUpsertArgs>(args: SelectSubset<T, table_territoiresUpsertArgs<ExtArgs>>): Prisma__table_territoiresClient<$Result.GetResult<Prisma.$table_territoiresPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Table_territoires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {table_territoiresCountArgs} args - Arguments to filter Table_territoires to count.
     * @example
     * // Count the number of Table_territoires
     * const count = await prisma.table_territoires.count({
     *   where: {
     *     // ... the filter for the Table_territoires we want to count
     *   }
     * })
    **/
    count<T extends table_territoiresCountArgs>(
      args?: Subset<T, table_territoiresCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Table_territoiresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Table_territoires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Table_territoiresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Table_territoiresAggregateArgs>(args: Subset<T, Table_territoiresAggregateArgs>): Prisma.PrismaPromise<GetTable_territoiresAggregateType<T>>

    /**
     * Group by Table_territoires.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {table_territoiresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends table_territoiresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: table_territoiresGroupByArgs['orderBy'] }
        : { orderBy?: table_territoiresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, table_territoiresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTable_territoiresGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the table_territoires model
   */
  readonly fields: table_territoiresFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for table_territoires.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__table_territoiresClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the table_territoires model
   */
  interface table_territoiresFieldRefs {
    readonly index: FieldRef<"table_territoires", 'Int'>
    readonly code_geographique: FieldRef<"table_territoires", 'String'>
    readonly libelle_geographique: FieldRef<"table_territoires", 'String'>
    readonly epci: FieldRef<"table_territoires", 'String'>
    readonly libelle_epci: FieldRef<"table_territoires", 'String'>
    readonly departement: FieldRef<"table_territoires", 'String'>
    readonly libelle_departement: FieldRef<"table_territoires", 'String'>
    readonly region: FieldRef<"table_territoires", 'Int'>
    readonly ept: FieldRef<"table_territoires", 'String'>
    readonly libelle_petr: FieldRef<"table_territoires", 'String'>
    readonly code_pnr: FieldRef<"table_territoires", 'String'>
    readonly libelle_pnr: FieldRef<"table_territoires", 'String'>
  }
    

  // Custom InputTypes
  /**
   * table_territoires findUnique
   */
  export type table_territoiresFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table_territoires
     */
    select?: table_territoiresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table_territoires
     */
    omit?: table_territoiresOmit<ExtArgs> | null
    /**
     * Filter, which table_territoires to fetch.
     */
    where: table_territoiresWhereUniqueInput
  }

  /**
   * table_territoires findUniqueOrThrow
   */
  export type table_territoiresFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table_territoires
     */
    select?: table_territoiresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table_territoires
     */
    omit?: table_territoiresOmit<ExtArgs> | null
    /**
     * Filter, which table_territoires to fetch.
     */
    where: table_territoiresWhereUniqueInput
  }

  /**
   * table_territoires findFirst
   */
  export type table_territoiresFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table_territoires
     */
    select?: table_territoiresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table_territoires
     */
    omit?: table_territoiresOmit<ExtArgs> | null
    /**
     * Filter, which table_territoires to fetch.
     */
    where?: table_territoiresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of table_territoires to fetch.
     */
    orderBy?: table_territoiresOrderByWithRelationInput | table_territoiresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for table_territoires.
     */
    cursor?: table_territoiresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` table_territoires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` table_territoires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of table_territoires.
     */
    distinct?: Table_territoiresScalarFieldEnum | Table_territoiresScalarFieldEnum[]
  }

  /**
   * table_territoires findFirstOrThrow
   */
  export type table_territoiresFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table_territoires
     */
    select?: table_territoiresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table_territoires
     */
    omit?: table_territoiresOmit<ExtArgs> | null
    /**
     * Filter, which table_territoires to fetch.
     */
    where?: table_territoiresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of table_territoires to fetch.
     */
    orderBy?: table_territoiresOrderByWithRelationInput | table_territoiresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for table_territoires.
     */
    cursor?: table_territoiresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` table_territoires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` table_territoires.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of table_territoires.
     */
    distinct?: Table_territoiresScalarFieldEnum | Table_territoiresScalarFieldEnum[]
  }

  /**
   * table_territoires findMany
   */
  export type table_territoiresFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table_territoires
     */
    select?: table_territoiresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table_territoires
     */
    omit?: table_territoiresOmit<ExtArgs> | null
    /**
     * Filter, which table_territoires to fetch.
     */
    where?: table_territoiresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of table_territoires to fetch.
     */
    orderBy?: table_territoiresOrderByWithRelationInput | table_territoiresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing table_territoires.
     */
    cursor?: table_territoiresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` table_territoires from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` table_territoires.
     */
    skip?: number
    distinct?: Table_territoiresScalarFieldEnum | Table_territoiresScalarFieldEnum[]
  }

  /**
   * table_territoires create
   */
  export type table_territoiresCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table_territoires
     */
    select?: table_territoiresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table_territoires
     */
    omit?: table_territoiresOmit<ExtArgs> | null
    /**
     * The data needed to create a table_territoires.
     */
    data: XOR<table_territoiresCreateInput, table_territoiresUncheckedCreateInput>
  }

  /**
   * table_territoires createMany
   */
  export type table_territoiresCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many table_territoires.
     */
    data: table_territoiresCreateManyInput | table_territoiresCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * table_territoires createManyAndReturn
   */
  export type table_territoiresCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table_territoires
     */
    select?: table_territoiresSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the table_territoires
     */
    omit?: table_territoiresOmit<ExtArgs> | null
    /**
     * The data used to create many table_territoires.
     */
    data: table_territoiresCreateManyInput | table_territoiresCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * table_territoires update
   */
  export type table_territoiresUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table_territoires
     */
    select?: table_territoiresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table_territoires
     */
    omit?: table_territoiresOmit<ExtArgs> | null
    /**
     * The data needed to update a table_territoires.
     */
    data: XOR<table_territoiresUpdateInput, table_territoiresUncheckedUpdateInput>
    /**
     * Choose, which table_territoires to update.
     */
    where: table_territoiresWhereUniqueInput
  }

  /**
   * table_territoires updateMany
   */
  export type table_territoiresUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update table_territoires.
     */
    data: XOR<table_territoiresUpdateManyMutationInput, table_territoiresUncheckedUpdateManyInput>
    /**
     * Filter which table_territoires to update
     */
    where?: table_territoiresWhereInput
    /**
     * Limit how many table_territoires to update.
     */
    limit?: number
  }

  /**
   * table_territoires updateManyAndReturn
   */
  export type table_territoiresUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table_territoires
     */
    select?: table_territoiresSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the table_territoires
     */
    omit?: table_territoiresOmit<ExtArgs> | null
    /**
     * The data used to update table_territoires.
     */
    data: XOR<table_territoiresUpdateManyMutationInput, table_territoiresUncheckedUpdateManyInput>
    /**
     * Filter which table_territoires to update
     */
    where?: table_territoiresWhereInput
    /**
     * Limit how many table_territoires to update.
     */
    limit?: number
  }

  /**
   * table_territoires upsert
   */
  export type table_territoiresUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table_territoires
     */
    select?: table_territoiresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table_territoires
     */
    omit?: table_territoiresOmit<ExtArgs> | null
    /**
     * The filter to search for the table_territoires to update in case it exists.
     */
    where: table_territoiresWhereUniqueInput
    /**
     * In case the table_territoires found by the `where` argument doesn't exist, create a new table_territoires with this data.
     */
    create: XOR<table_territoiresCreateInput, table_territoiresUncheckedCreateInput>
    /**
     * In case the table_territoires was found with the provided `where` argument, update it with this data.
     */
    update: XOR<table_territoiresUpdateInput, table_territoiresUncheckedUpdateInput>
  }

  /**
   * table_territoires delete
   */
  export type table_territoiresDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table_territoires
     */
    select?: table_territoiresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table_territoires
     */
    omit?: table_territoiresOmit<ExtArgs> | null
    /**
     * Filter which table_territoires to delete.
     */
    where: table_territoiresWhereUniqueInput
  }

  /**
   * table_territoires deleteMany
   */
  export type table_territoiresDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which table_territoires to delete
     */
    where?: table_territoiresWhereInput
    /**
     * Limit how many table_territoires to delete.
     */
    limit?: number
  }

  /**
   * table_territoires without action
   */
  export type table_territoiresDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the table_territoires
     */
    select?: table_territoiresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the table_territoires
     */
    omit?: table_territoiresOmit<ExtArgs> | null
  }


  /**
   * Model communes_drom
   */

  export type AggregateCommunes_drom = {
    _count: Communes_dromCountAggregateOutputType | null
    _avg: Communes_dromAvgAggregateOutputType | null
    _sum: Communes_dromSumAggregateOutputType | null
    _min: Communes_dromMinAggregateOutputType | null
    _max: Communes_dromMaxAggregateOutputType | null
  }

  export type Communes_dromAvgAggregateOutputType = {
    pk: number | null
    region: number | null
    precarite_logement: number | null
    surface: number | null
  }

  export type Communes_dromSumAggregateOutputType = {
    pk: number | null
    region: number | null
    precarite_logement: number | null
    surface: number | null
  }

  export type Communes_dromMinAggregateOutputType = {
    pk: number | null
    code_geographique: string | null
    libelle_geographique: string | null
    epci: string | null
    libelle_epci: string | null
    departement: string | null
    libelle_departement: string | null
    region: number | null
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
    coordinates: string | null
    precarite_logement: number | null
    surface: number | null
  }

  export type Communes_dromMaxAggregateOutputType = {
    pk: number | null
    code_geographique: string | null
    libelle_geographique: string | null
    epci: string | null
    libelle_epci: string | null
    departement: string | null
    libelle_departement: string | null
    region: number | null
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
    coordinates: string | null
    precarite_logement: number | null
    surface: number | null
  }

  export type Communes_dromCountAggregateOutputType = {
    pk: number
    code_geographique: number
    libelle_geographique: number
    epci: number
    libelle_epci: number
    departement: number
    libelle_departement: number
    region: number
    ept: number
    libelle_petr: number
    code_pnr: number
    libelle_pnr: number
    coordinates: number
    precarite_logement: number
    surface: number
    _all: number
  }


  export type Communes_dromAvgAggregateInputType = {
    pk?: true
    region?: true
    precarite_logement?: true
    surface?: true
  }

  export type Communes_dromSumAggregateInputType = {
    pk?: true
    region?: true
    precarite_logement?: true
    surface?: true
  }

  export type Communes_dromMinAggregateInputType = {
    pk?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
    coordinates?: true
    precarite_logement?: true
    surface?: true
  }

  export type Communes_dromMaxAggregateInputType = {
    pk?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
    coordinates?: true
    precarite_logement?: true
    surface?: true
  }

  export type Communes_dromCountAggregateInputType = {
    pk?: true
    code_geographique?: true
    libelle_geographique?: true
    epci?: true
    libelle_epci?: true
    departement?: true
    libelle_departement?: true
    region?: true
    ept?: true
    libelle_petr?: true
    code_pnr?: true
    libelle_pnr?: true
    coordinates?: true
    precarite_logement?: true
    surface?: true
    _all?: true
  }

  export type Communes_dromAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which communes_drom to aggregate.
     */
    where?: communes_dromWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of communes_droms to fetch.
     */
    orderBy?: communes_dromOrderByWithRelationInput | communes_dromOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: communes_dromWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` communes_droms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` communes_droms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned communes_droms
    **/
    _count?: true | Communes_dromCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Communes_dromAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Communes_dromSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Communes_dromMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Communes_dromMaxAggregateInputType
  }

  export type GetCommunes_dromAggregateType<T extends Communes_dromAggregateArgs> = {
        [P in keyof T & keyof AggregateCommunes_drom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunes_drom[P]>
      : GetScalarType<T[P], AggregateCommunes_drom[P]>
  }




  export type communes_dromGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: communes_dromWhereInput
    orderBy?: communes_dromOrderByWithAggregationInput | communes_dromOrderByWithAggregationInput[]
    by: Communes_dromScalarFieldEnum[] | Communes_dromScalarFieldEnum
    having?: communes_dromScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Communes_dromCountAggregateInputType | true
    _avg?: Communes_dromAvgAggregateInputType
    _sum?: Communes_dromSumAggregateInputType
    _min?: Communes_dromMinAggregateInputType
    _max?: Communes_dromMaxAggregateInputType
  }

  export type Communes_dromGroupByOutputType = {
    pk: number
    code_geographique: string | null
    libelle_geographique: string | null
    epci: string | null
    libelle_epci: string | null
    departement: string | null
    libelle_departement: string | null
    region: number | null
    ept: string | null
    libelle_petr: string | null
    code_pnr: string | null
    libelle_pnr: string | null
    coordinates: string | null
    precarite_logement: number | null
    surface: number | null
    _count: Communes_dromCountAggregateOutputType | null
    _avg: Communes_dromAvgAggregateOutputType | null
    _sum: Communes_dromSumAggregateOutputType | null
    _min: Communes_dromMinAggregateOutputType | null
    _max: Communes_dromMaxAggregateOutputType | null
  }

  type GetCommunes_dromGroupByPayload<T extends communes_dromGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Communes_dromGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Communes_dromGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Communes_dromGroupByOutputType[P]>
            : GetScalarType<T[P], Communes_dromGroupByOutputType[P]>
        }
      >
    >


  export type communes_dromSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pk?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    coordinates?: boolean
    precarite_logement?: boolean
    surface?: boolean
  }, ExtArgs["result"]["communes_drom"]>

  export type communes_dromSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pk?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    coordinates?: boolean
    precarite_logement?: boolean
    surface?: boolean
  }, ExtArgs["result"]["communes_drom"]>

  export type communes_dromSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pk?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    coordinates?: boolean
    precarite_logement?: boolean
    surface?: boolean
  }, ExtArgs["result"]["communes_drom"]>

  export type communes_dromSelectScalar = {
    pk?: boolean
    code_geographique?: boolean
    libelle_geographique?: boolean
    epci?: boolean
    libelle_epci?: boolean
    departement?: boolean
    libelle_departement?: boolean
    region?: boolean
    ept?: boolean
    libelle_petr?: boolean
    code_pnr?: boolean
    libelle_pnr?: boolean
    coordinates?: boolean
    precarite_logement?: boolean
    surface?: boolean
  }

  export type communes_dromOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"pk" | "code_geographique" | "libelle_geographique" | "epci" | "libelle_epci" | "departement" | "libelle_departement" | "region" | "ept" | "libelle_petr" | "code_pnr" | "libelle_pnr" | "coordinates" | "precarite_logement" | "surface", ExtArgs["result"]["communes_drom"]>

  export type $communes_dromPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "communes_drom"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      pk: number
      code_geographique: string | null
      libelle_geographique: string | null
      epci: string | null
      libelle_epci: string | null
      departement: string | null
      libelle_departement: string | null
      region: number | null
      ept: string | null
      libelle_petr: string | null
      code_pnr: string | null
      libelle_pnr: string | null
      coordinates: string | null
      precarite_logement: number | null
      surface: number | null
    }, ExtArgs["result"]["communes_drom"]>
    composites: {}
  }

  type communes_dromGetPayload<S extends boolean | null | undefined | communes_dromDefaultArgs> = $Result.GetResult<Prisma.$communes_dromPayload, S>

  type communes_dromCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<communes_dromFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Communes_dromCountAggregateInputType | true
    }

  export interface communes_dromDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['communes_drom'], meta: { name: 'communes_drom' } }
    /**
     * Find zero or one Communes_drom that matches the filter.
     * @param {communes_dromFindUniqueArgs} args - Arguments to find a Communes_drom
     * @example
     * // Get one Communes_drom
     * const communes_drom = await prisma.communes_drom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends communes_dromFindUniqueArgs>(args: SelectSubset<T, communes_dromFindUniqueArgs<ExtArgs>>): Prisma__communes_dromClient<$Result.GetResult<Prisma.$communes_dromPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Communes_drom that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {communes_dromFindUniqueOrThrowArgs} args - Arguments to find a Communes_drom
     * @example
     * // Get one Communes_drom
     * const communes_drom = await prisma.communes_drom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends communes_dromFindUniqueOrThrowArgs>(args: SelectSubset<T, communes_dromFindUniqueOrThrowArgs<ExtArgs>>): Prisma__communes_dromClient<$Result.GetResult<Prisma.$communes_dromPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Communes_drom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {communes_dromFindFirstArgs} args - Arguments to find a Communes_drom
     * @example
     * // Get one Communes_drom
     * const communes_drom = await prisma.communes_drom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends communes_dromFindFirstArgs>(args?: SelectSubset<T, communes_dromFindFirstArgs<ExtArgs>>): Prisma__communes_dromClient<$Result.GetResult<Prisma.$communes_dromPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Communes_drom that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {communes_dromFindFirstOrThrowArgs} args - Arguments to find a Communes_drom
     * @example
     * // Get one Communes_drom
     * const communes_drom = await prisma.communes_drom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends communes_dromFindFirstOrThrowArgs>(args?: SelectSubset<T, communes_dromFindFirstOrThrowArgs<ExtArgs>>): Prisma__communes_dromClient<$Result.GetResult<Prisma.$communes_dromPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Communes_droms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {communes_dromFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Communes_droms
     * const communes_droms = await prisma.communes_drom.findMany()
     * 
     * // Get first 10 Communes_droms
     * const communes_droms = await prisma.communes_drom.findMany({ take: 10 })
     * 
     * // Only select the `pk`
     * const communes_dromWithPkOnly = await prisma.communes_drom.findMany({ select: { pk: true } })
     * 
     */
    findMany<T extends communes_dromFindManyArgs>(args?: SelectSubset<T, communes_dromFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$communes_dromPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Communes_drom.
     * @param {communes_dromCreateArgs} args - Arguments to create a Communes_drom.
     * @example
     * // Create one Communes_drom
     * const Communes_drom = await prisma.communes_drom.create({
     *   data: {
     *     // ... data to create a Communes_drom
     *   }
     * })
     * 
     */
    create<T extends communes_dromCreateArgs>(args: SelectSubset<T, communes_dromCreateArgs<ExtArgs>>): Prisma__communes_dromClient<$Result.GetResult<Prisma.$communes_dromPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Communes_droms.
     * @param {communes_dromCreateManyArgs} args - Arguments to create many Communes_droms.
     * @example
     * // Create many Communes_droms
     * const communes_drom = await prisma.communes_drom.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends communes_dromCreateManyArgs>(args?: SelectSubset<T, communes_dromCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Communes_droms and returns the data saved in the database.
     * @param {communes_dromCreateManyAndReturnArgs} args - Arguments to create many Communes_droms.
     * @example
     * // Create many Communes_droms
     * const communes_drom = await prisma.communes_drom.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Communes_droms and only return the `pk`
     * const communes_dromWithPkOnly = await prisma.communes_drom.createManyAndReturn({
     *   select: { pk: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends communes_dromCreateManyAndReturnArgs>(args?: SelectSubset<T, communes_dromCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$communes_dromPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Communes_drom.
     * @param {communes_dromDeleteArgs} args - Arguments to delete one Communes_drom.
     * @example
     * // Delete one Communes_drom
     * const Communes_drom = await prisma.communes_drom.delete({
     *   where: {
     *     // ... filter to delete one Communes_drom
     *   }
     * })
     * 
     */
    delete<T extends communes_dromDeleteArgs>(args: SelectSubset<T, communes_dromDeleteArgs<ExtArgs>>): Prisma__communes_dromClient<$Result.GetResult<Prisma.$communes_dromPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Communes_drom.
     * @param {communes_dromUpdateArgs} args - Arguments to update one Communes_drom.
     * @example
     * // Update one Communes_drom
     * const communes_drom = await prisma.communes_drom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends communes_dromUpdateArgs>(args: SelectSubset<T, communes_dromUpdateArgs<ExtArgs>>): Prisma__communes_dromClient<$Result.GetResult<Prisma.$communes_dromPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Communes_droms.
     * @param {communes_dromDeleteManyArgs} args - Arguments to filter Communes_droms to delete.
     * @example
     * // Delete a few Communes_droms
     * const { count } = await prisma.communes_drom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends communes_dromDeleteManyArgs>(args?: SelectSubset<T, communes_dromDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Communes_droms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {communes_dromUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Communes_droms
     * const communes_drom = await prisma.communes_drom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends communes_dromUpdateManyArgs>(args: SelectSubset<T, communes_dromUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Communes_droms and returns the data updated in the database.
     * @param {communes_dromUpdateManyAndReturnArgs} args - Arguments to update many Communes_droms.
     * @example
     * // Update many Communes_droms
     * const communes_drom = await prisma.communes_drom.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Communes_droms and only return the `pk`
     * const communes_dromWithPkOnly = await prisma.communes_drom.updateManyAndReturn({
     *   select: { pk: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends communes_dromUpdateManyAndReturnArgs>(args: SelectSubset<T, communes_dromUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$communes_dromPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Communes_drom.
     * @param {communes_dromUpsertArgs} args - Arguments to update or create a Communes_drom.
     * @example
     * // Update or create a Communes_drom
     * const communes_drom = await prisma.communes_drom.upsert({
     *   create: {
     *     // ... data to create a Communes_drom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Communes_drom we want to update
     *   }
     * })
     */
    upsert<T extends communes_dromUpsertArgs>(args: SelectSubset<T, communes_dromUpsertArgs<ExtArgs>>): Prisma__communes_dromClient<$Result.GetResult<Prisma.$communes_dromPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Communes_droms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {communes_dromCountArgs} args - Arguments to filter Communes_droms to count.
     * @example
     * // Count the number of Communes_droms
     * const count = await prisma.communes_drom.count({
     *   where: {
     *     // ... the filter for the Communes_droms we want to count
     *   }
     * })
    **/
    count<T extends communes_dromCountArgs>(
      args?: Subset<T, communes_dromCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Communes_dromCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Communes_drom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Communes_dromAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Communes_dromAggregateArgs>(args: Subset<T, Communes_dromAggregateArgs>): Prisma.PrismaPromise<GetCommunes_dromAggregateType<T>>

    /**
     * Group by Communes_drom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {communes_dromGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends communes_dromGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: communes_dromGroupByArgs['orderBy'] }
        : { orderBy?: communes_dromGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, communes_dromGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunes_dromGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the communes_drom model
   */
  readonly fields: communes_dromFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for communes_drom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__communes_dromClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the communes_drom model
   */
  interface communes_dromFieldRefs {
    readonly pk: FieldRef<"communes_drom", 'Int'>
    readonly code_geographique: FieldRef<"communes_drom", 'String'>
    readonly libelle_geographique: FieldRef<"communes_drom", 'String'>
    readonly epci: FieldRef<"communes_drom", 'String'>
    readonly libelle_epci: FieldRef<"communes_drom", 'String'>
    readonly departement: FieldRef<"communes_drom", 'String'>
    readonly libelle_departement: FieldRef<"communes_drom", 'String'>
    readonly region: FieldRef<"communes_drom", 'Int'>
    readonly ept: FieldRef<"communes_drom", 'String'>
    readonly libelle_petr: FieldRef<"communes_drom", 'String'>
    readonly code_pnr: FieldRef<"communes_drom", 'String'>
    readonly libelle_pnr: FieldRef<"communes_drom", 'String'>
    readonly coordinates: FieldRef<"communes_drom", 'String'>
    readonly precarite_logement: FieldRef<"communes_drom", 'Float'>
    readonly surface: FieldRef<"communes_drom", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * communes_drom findUnique
   */
  export type communes_dromFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the communes_drom
     */
    select?: communes_dromSelect<ExtArgs> | null
    /**
     * Omit specific fields from the communes_drom
     */
    omit?: communes_dromOmit<ExtArgs> | null
    /**
     * Filter, which communes_drom to fetch.
     */
    where: communes_dromWhereUniqueInput
  }

  /**
   * communes_drom findUniqueOrThrow
   */
  export type communes_dromFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the communes_drom
     */
    select?: communes_dromSelect<ExtArgs> | null
    /**
     * Omit specific fields from the communes_drom
     */
    omit?: communes_dromOmit<ExtArgs> | null
    /**
     * Filter, which communes_drom to fetch.
     */
    where: communes_dromWhereUniqueInput
  }

  /**
   * communes_drom findFirst
   */
  export type communes_dromFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the communes_drom
     */
    select?: communes_dromSelect<ExtArgs> | null
    /**
     * Omit specific fields from the communes_drom
     */
    omit?: communes_dromOmit<ExtArgs> | null
    /**
     * Filter, which communes_drom to fetch.
     */
    where?: communes_dromWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of communes_droms to fetch.
     */
    orderBy?: communes_dromOrderByWithRelationInput | communes_dromOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for communes_droms.
     */
    cursor?: communes_dromWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` communes_droms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` communes_droms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of communes_droms.
     */
    distinct?: Communes_dromScalarFieldEnum | Communes_dromScalarFieldEnum[]
  }

  /**
   * communes_drom findFirstOrThrow
   */
  export type communes_dromFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the communes_drom
     */
    select?: communes_dromSelect<ExtArgs> | null
    /**
     * Omit specific fields from the communes_drom
     */
    omit?: communes_dromOmit<ExtArgs> | null
    /**
     * Filter, which communes_drom to fetch.
     */
    where?: communes_dromWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of communes_droms to fetch.
     */
    orderBy?: communes_dromOrderByWithRelationInput | communes_dromOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for communes_droms.
     */
    cursor?: communes_dromWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` communes_droms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` communes_droms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of communes_droms.
     */
    distinct?: Communes_dromScalarFieldEnum | Communes_dromScalarFieldEnum[]
  }

  /**
   * communes_drom findMany
   */
  export type communes_dromFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the communes_drom
     */
    select?: communes_dromSelect<ExtArgs> | null
    /**
     * Omit specific fields from the communes_drom
     */
    omit?: communes_dromOmit<ExtArgs> | null
    /**
     * Filter, which communes_droms to fetch.
     */
    where?: communes_dromWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of communes_droms to fetch.
     */
    orderBy?: communes_dromOrderByWithRelationInput | communes_dromOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing communes_droms.
     */
    cursor?: communes_dromWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` communes_droms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` communes_droms.
     */
    skip?: number
    distinct?: Communes_dromScalarFieldEnum | Communes_dromScalarFieldEnum[]
  }

  /**
   * communes_drom create
   */
  export type communes_dromCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the communes_drom
     */
    select?: communes_dromSelect<ExtArgs> | null
    /**
     * Omit specific fields from the communes_drom
     */
    omit?: communes_dromOmit<ExtArgs> | null
    /**
     * The data needed to create a communes_drom.
     */
    data?: XOR<communes_dromCreateInput, communes_dromUncheckedCreateInput>
  }

  /**
   * communes_drom createMany
   */
  export type communes_dromCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many communes_droms.
     */
    data: communes_dromCreateManyInput | communes_dromCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * communes_drom createManyAndReturn
   */
  export type communes_dromCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the communes_drom
     */
    select?: communes_dromSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the communes_drom
     */
    omit?: communes_dromOmit<ExtArgs> | null
    /**
     * The data used to create many communes_droms.
     */
    data: communes_dromCreateManyInput | communes_dromCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * communes_drom update
   */
  export type communes_dromUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the communes_drom
     */
    select?: communes_dromSelect<ExtArgs> | null
    /**
     * Omit specific fields from the communes_drom
     */
    omit?: communes_dromOmit<ExtArgs> | null
    /**
     * The data needed to update a communes_drom.
     */
    data: XOR<communes_dromUpdateInput, communes_dromUncheckedUpdateInput>
    /**
     * Choose, which communes_drom to update.
     */
    where: communes_dromWhereUniqueInput
  }

  /**
   * communes_drom updateMany
   */
  export type communes_dromUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update communes_droms.
     */
    data: XOR<communes_dromUpdateManyMutationInput, communes_dromUncheckedUpdateManyInput>
    /**
     * Filter which communes_droms to update
     */
    where?: communes_dromWhereInput
    /**
     * Limit how many communes_droms to update.
     */
    limit?: number
  }

  /**
   * communes_drom updateManyAndReturn
   */
  export type communes_dromUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the communes_drom
     */
    select?: communes_dromSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the communes_drom
     */
    omit?: communes_dromOmit<ExtArgs> | null
    /**
     * The data used to update communes_droms.
     */
    data: XOR<communes_dromUpdateManyMutationInput, communes_dromUncheckedUpdateManyInput>
    /**
     * Filter which communes_droms to update
     */
    where?: communes_dromWhereInput
    /**
     * Limit how many communes_droms to update.
     */
    limit?: number
  }

  /**
   * communes_drom upsert
   */
  export type communes_dromUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the communes_drom
     */
    select?: communes_dromSelect<ExtArgs> | null
    /**
     * Omit specific fields from the communes_drom
     */
    omit?: communes_dromOmit<ExtArgs> | null
    /**
     * The filter to search for the communes_drom to update in case it exists.
     */
    where: communes_dromWhereUniqueInput
    /**
     * In case the communes_drom found by the `where` argument doesn't exist, create a new communes_drom with this data.
     */
    create: XOR<communes_dromCreateInput, communes_dromUncheckedCreateInput>
    /**
     * In case the communes_drom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<communes_dromUpdateInput, communes_dromUncheckedUpdateInput>
  }

  /**
   * communes_drom delete
   */
  export type communes_dromDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the communes_drom
     */
    select?: communes_dromSelect<ExtArgs> | null
    /**
     * Omit specific fields from the communes_drom
     */
    omit?: communes_dromOmit<ExtArgs> | null
    /**
     * Filter which communes_drom to delete.
     */
    where: communes_dromWhereUniqueInput
  }

  /**
   * communes_drom deleteMany
   */
  export type communes_dromDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which communes_droms to delete
     */
    where?: communes_dromWhereInput
    /**
     * Limit how many communes_droms to delete.
     */
    limit?: number
  }

  /**
   * communes_drom without action
   */
  export type communes_dromDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the communes_drom
     */
    select?: communes_dromSelect<ExtArgs> | null
    /**
     * Omit specific fields from the communes_drom
     */
    omit?: communes_dromOmit<ExtArgs> | null
  }


  /**
   * Model erosion_cotiere
   */

  export type AggregateErosion_cotiere = {
    _count: Erosion_cotiereCountAggregateOutputType | null
    _avg: Erosion_cotiereAvgAggregateOutputType | null
    _sum: Erosion_cotiereSumAggregateOutputType | null
    _min: Erosion_cotiereMinAggregateOutputType | null
    _max: Erosion_cotiereMaxAggregateOutputType | null
  }

  export type Erosion_cotiereAvgAggregateOutputType = {
    pk: number | null
    taux: number | null
    duree: number | null
    tdc_ancien: number | null
    tdc_rec: number | null
  }

  export type Erosion_cotiereSumAggregateOutputType = {
    pk: number | null
    taux: number | null
    duree: number | null
    tdc_ancien: number | null
    tdc_rec: number | null
  }

  export type Erosion_cotiereMinAggregateOutputType = {
    pk: number | null
    taux: number | null
    duree: number | null
    tdc_ancien: number | null
    tdc_rec: number | null
  }

  export type Erosion_cotiereMaxAggregateOutputType = {
    pk: number | null
    taux: number | null
    duree: number | null
    tdc_ancien: number | null
    tdc_rec: number | null
  }

  export type Erosion_cotiereCountAggregateOutputType = {
    pk: number
    taux: number
    duree: number
    tdc_ancien: number
    tdc_rec: number
    _all: number
  }


  export type Erosion_cotiereAvgAggregateInputType = {
    pk?: true
    taux?: true
    duree?: true
    tdc_ancien?: true
    tdc_rec?: true
  }

  export type Erosion_cotiereSumAggregateInputType = {
    pk?: true
    taux?: true
    duree?: true
    tdc_ancien?: true
    tdc_rec?: true
  }

  export type Erosion_cotiereMinAggregateInputType = {
    pk?: true
    taux?: true
    duree?: true
    tdc_ancien?: true
    tdc_rec?: true
  }

  export type Erosion_cotiereMaxAggregateInputType = {
    pk?: true
    taux?: true
    duree?: true
    tdc_ancien?: true
    tdc_rec?: true
  }

  export type Erosion_cotiereCountAggregateInputType = {
    pk?: true
    taux?: true
    duree?: true
    tdc_ancien?: true
    tdc_rec?: true
    _all?: true
  }

  export type Erosion_cotiereAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which erosion_cotiere to aggregate.
     */
    where?: erosion_cotiereWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of erosion_cotieres to fetch.
     */
    orderBy?: erosion_cotiereOrderByWithRelationInput | erosion_cotiereOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: erosion_cotiereWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` erosion_cotieres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` erosion_cotieres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned erosion_cotieres
    **/
    _count?: true | Erosion_cotiereCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Erosion_cotiereAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Erosion_cotiereSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Erosion_cotiereMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Erosion_cotiereMaxAggregateInputType
  }

  export type GetErosion_cotiereAggregateType<T extends Erosion_cotiereAggregateArgs> = {
        [P in keyof T & keyof AggregateErosion_cotiere]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateErosion_cotiere[P]>
      : GetScalarType<T[P], AggregateErosion_cotiere[P]>
  }




  export type erosion_cotiereGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: erosion_cotiereWhereInput
    orderBy?: erosion_cotiereOrderByWithAggregationInput | erosion_cotiereOrderByWithAggregationInput[]
    by: Erosion_cotiereScalarFieldEnum[] | Erosion_cotiereScalarFieldEnum
    having?: erosion_cotiereScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Erosion_cotiereCountAggregateInputType | true
    _avg?: Erosion_cotiereAvgAggregateInputType
    _sum?: Erosion_cotiereSumAggregateInputType
    _min?: Erosion_cotiereMinAggregateInputType
    _max?: Erosion_cotiereMaxAggregateInputType
  }

  export type Erosion_cotiereGroupByOutputType = {
    pk: number
    taux: number
    duree: number
    tdc_ancien: number
    tdc_rec: number
    _count: Erosion_cotiereCountAggregateOutputType | null
    _avg: Erosion_cotiereAvgAggregateOutputType | null
    _sum: Erosion_cotiereSumAggregateOutputType | null
    _min: Erosion_cotiereMinAggregateOutputType | null
    _max: Erosion_cotiereMaxAggregateOutputType | null
  }

  type GetErosion_cotiereGroupByPayload<T extends erosion_cotiereGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Erosion_cotiereGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Erosion_cotiereGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Erosion_cotiereGroupByOutputType[P]>
            : GetScalarType<T[P], Erosion_cotiereGroupByOutputType[P]>
        }
      >
    >


  export type erosion_cotiereSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pk?: boolean
    taux?: boolean
    duree?: boolean
    tdc_ancien?: boolean
    tdc_rec?: boolean
  }, ExtArgs["result"]["erosion_cotiere"]>


  export type erosion_cotiereSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pk?: boolean
    taux?: boolean
    duree?: boolean
    tdc_ancien?: boolean
    tdc_rec?: boolean
  }, ExtArgs["result"]["erosion_cotiere"]>

  export type erosion_cotiereSelectScalar = {
    pk?: boolean
    taux?: boolean
    duree?: boolean
    tdc_ancien?: boolean
    tdc_rec?: boolean
  }

  export type erosion_cotiereOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"pk" | "taux" | "duree" | "tdc_ancien" | "tdc_rec", ExtArgs["result"]["erosion_cotiere"]>

  export type $erosion_cotierePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "erosion_cotiere"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      pk: number
      taux: number
      duree: number
      tdc_ancien: number
      tdc_rec: number
    }, ExtArgs["result"]["erosion_cotiere"]>
    composites: {}
  }

  type erosion_cotiereGetPayload<S extends boolean | null | undefined | erosion_cotiereDefaultArgs> = $Result.GetResult<Prisma.$erosion_cotierePayload, S>

  type erosion_cotiereCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<erosion_cotiereFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Erosion_cotiereCountAggregateInputType | true
    }

  export interface erosion_cotiereDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['erosion_cotiere'], meta: { name: 'erosion_cotiere' } }
    /**
     * Find zero or one Erosion_cotiere that matches the filter.
     * @param {erosion_cotiereFindUniqueArgs} args - Arguments to find a Erosion_cotiere
     * @example
     * // Get one Erosion_cotiere
     * const erosion_cotiere = await prisma.erosion_cotiere.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends erosion_cotiereFindUniqueArgs>(args: SelectSubset<T, erosion_cotiereFindUniqueArgs<ExtArgs>>): Prisma__erosion_cotiereClient<$Result.GetResult<Prisma.$erosion_cotierePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Erosion_cotiere that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {erosion_cotiereFindUniqueOrThrowArgs} args - Arguments to find a Erosion_cotiere
     * @example
     * // Get one Erosion_cotiere
     * const erosion_cotiere = await prisma.erosion_cotiere.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends erosion_cotiereFindUniqueOrThrowArgs>(args: SelectSubset<T, erosion_cotiereFindUniqueOrThrowArgs<ExtArgs>>): Prisma__erosion_cotiereClient<$Result.GetResult<Prisma.$erosion_cotierePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Erosion_cotiere that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {erosion_cotiereFindFirstArgs} args - Arguments to find a Erosion_cotiere
     * @example
     * // Get one Erosion_cotiere
     * const erosion_cotiere = await prisma.erosion_cotiere.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends erosion_cotiereFindFirstArgs>(args?: SelectSubset<T, erosion_cotiereFindFirstArgs<ExtArgs>>): Prisma__erosion_cotiereClient<$Result.GetResult<Prisma.$erosion_cotierePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Erosion_cotiere that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {erosion_cotiereFindFirstOrThrowArgs} args - Arguments to find a Erosion_cotiere
     * @example
     * // Get one Erosion_cotiere
     * const erosion_cotiere = await prisma.erosion_cotiere.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends erosion_cotiereFindFirstOrThrowArgs>(args?: SelectSubset<T, erosion_cotiereFindFirstOrThrowArgs<ExtArgs>>): Prisma__erosion_cotiereClient<$Result.GetResult<Prisma.$erosion_cotierePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Erosion_cotieres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {erosion_cotiereFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Erosion_cotieres
     * const erosion_cotieres = await prisma.erosion_cotiere.findMany()
     * 
     * // Get first 10 Erosion_cotieres
     * const erosion_cotieres = await prisma.erosion_cotiere.findMany({ take: 10 })
     * 
     * // Only select the `pk`
     * const erosion_cotiereWithPkOnly = await prisma.erosion_cotiere.findMany({ select: { pk: true } })
     * 
     */
    findMany<T extends erosion_cotiereFindManyArgs>(args?: SelectSubset<T, erosion_cotiereFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$erosion_cotierePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Delete a Erosion_cotiere.
     * @param {erosion_cotiereDeleteArgs} args - Arguments to delete one Erosion_cotiere.
     * @example
     * // Delete one Erosion_cotiere
     * const Erosion_cotiere = await prisma.erosion_cotiere.delete({
     *   where: {
     *     // ... filter to delete one Erosion_cotiere
     *   }
     * })
     * 
     */
    delete<T extends erosion_cotiereDeleteArgs>(args: SelectSubset<T, erosion_cotiereDeleteArgs<ExtArgs>>): Prisma__erosion_cotiereClient<$Result.GetResult<Prisma.$erosion_cotierePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Erosion_cotiere.
     * @param {erosion_cotiereUpdateArgs} args - Arguments to update one Erosion_cotiere.
     * @example
     * // Update one Erosion_cotiere
     * const erosion_cotiere = await prisma.erosion_cotiere.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends erosion_cotiereUpdateArgs>(args: SelectSubset<T, erosion_cotiereUpdateArgs<ExtArgs>>): Prisma__erosion_cotiereClient<$Result.GetResult<Prisma.$erosion_cotierePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Erosion_cotieres.
     * @param {erosion_cotiereDeleteManyArgs} args - Arguments to filter Erosion_cotieres to delete.
     * @example
     * // Delete a few Erosion_cotieres
     * const { count } = await prisma.erosion_cotiere.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends erosion_cotiereDeleteManyArgs>(args?: SelectSubset<T, erosion_cotiereDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Erosion_cotieres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {erosion_cotiereUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Erosion_cotieres
     * const erosion_cotiere = await prisma.erosion_cotiere.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends erosion_cotiereUpdateManyArgs>(args: SelectSubset<T, erosion_cotiereUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Erosion_cotieres and returns the data updated in the database.
     * @param {erosion_cotiereUpdateManyAndReturnArgs} args - Arguments to update many Erosion_cotieres.
     * @example
     * // Update many Erosion_cotieres
     * const erosion_cotiere = await prisma.erosion_cotiere.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Erosion_cotieres and only return the `pk`
     * const erosion_cotiereWithPkOnly = await prisma.erosion_cotiere.updateManyAndReturn({
     *   select: { pk: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends erosion_cotiereUpdateManyAndReturnArgs>(args: SelectSubset<T, erosion_cotiereUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$erosion_cotierePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>


    /**
     * Count the number of Erosion_cotieres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {erosion_cotiereCountArgs} args - Arguments to filter Erosion_cotieres to count.
     * @example
     * // Count the number of Erosion_cotieres
     * const count = await prisma.erosion_cotiere.count({
     *   where: {
     *     // ... the filter for the Erosion_cotieres we want to count
     *   }
     * })
    **/
    count<T extends erosion_cotiereCountArgs>(
      args?: Subset<T, erosion_cotiereCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Erosion_cotiereCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Erosion_cotiere.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Erosion_cotiereAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Erosion_cotiereAggregateArgs>(args: Subset<T, Erosion_cotiereAggregateArgs>): Prisma.PrismaPromise<GetErosion_cotiereAggregateType<T>>

    /**
     * Group by Erosion_cotiere.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {erosion_cotiereGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends erosion_cotiereGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: erosion_cotiereGroupByArgs['orderBy'] }
        : { orderBy?: erosion_cotiereGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, erosion_cotiereGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetErosion_cotiereGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the erosion_cotiere model
   */
  readonly fields: erosion_cotiereFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for erosion_cotiere.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__erosion_cotiereClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the erosion_cotiere model
   */
  interface erosion_cotiereFieldRefs {
    readonly pk: FieldRef<"erosion_cotiere", 'Int'>
    readonly taux: FieldRef<"erosion_cotiere", 'Float'>
    readonly duree: FieldRef<"erosion_cotiere", 'Float'>
    readonly tdc_ancien: FieldRef<"erosion_cotiere", 'Int'>
    readonly tdc_rec: FieldRef<"erosion_cotiere", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * erosion_cotiere findUnique
   */
  export type erosion_cotiereFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the erosion_cotiere
     */
    select?: erosion_cotiereSelect<ExtArgs> | null
    /**
     * Omit specific fields from the erosion_cotiere
     */
    omit?: erosion_cotiereOmit<ExtArgs> | null
    /**
     * Filter, which erosion_cotiere to fetch.
     */
    where: erosion_cotiereWhereUniqueInput
  }

  /**
   * erosion_cotiere findUniqueOrThrow
   */
  export type erosion_cotiereFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the erosion_cotiere
     */
    select?: erosion_cotiereSelect<ExtArgs> | null
    /**
     * Omit specific fields from the erosion_cotiere
     */
    omit?: erosion_cotiereOmit<ExtArgs> | null
    /**
     * Filter, which erosion_cotiere to fetch.
     */
    where: erosion_cotiereWhereUniqueInput
  }

  /**
   * erosion_cotiere findFirst
   */
  export type erosion_cotiereFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the erosion_cotiere
     */
    select?: erosion_cotiereSelect<ExtArgs> | null
    /**
     * Omit specific fields from the erosion_cotiere
     */
    omit?: erosion_cotiereOmit<ExtArgs> | null
    /**
     * Filter, which erosion_cotiere to fetch.
     */
    where?: erosion_cotiereWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of erosion_cotieres to fetch.
     */
    orderBy?: erosion_cotiereOrderByWithRelationInput | erosion_cotiereOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for erosion_cotieres.
     */
    cursor?: erosion_cotiereWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` erosion_cotieres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` erosion_cotieres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of erosion_cotieres.
     */
    distinct?: Erosion_cotiereScalarFieldEnum | Erosion_cotiereScalarFieldEnum[]
  }

  /**
   * erosion_cotiere findFirstOrThrow
   */
  export type erosion_cotiereFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the erosion_cotiere
     */
    select?: erosion_cotiereSelect<ExtArgs> | null
    /**
     * Omit specific fields from the erosion_cotiere
     */
    omit?: erosion_cotiereOmit<ExtArgs> | null
    /**
     * Filter, which erosion_cotiere to fetch.
     */
    where?: erosion_cotiereWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of erosion_cotieres to fetch.
     */
    orderBy?: erosion_cotiereOrderByWithRelationInput | erosion_cotiereOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for erosion_cotieres.
     */
    cursor?: erosion_cotiereWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` erosion_cotieres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` erosion_cotieres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of erosion_cotieres.
     */
    distinct?: Erosion_cotiereScalarFieldEnum | Erosion_cotiereScalarFieldEnum[]
  }

  /**
   * erosion_cotiere findMany
   */
  export type erosion_cotiereFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the erosion_cotiere
     */
    select?: erosion_cotiereSelect<ExtArgs> | null
    /**
     * Omit specific fields from the erosion_cotiere
     */
    omit?: erosion_cotiereOmit<ExtArgs> | null
    /**
     * Filter, which erosion_cotieres to fetch.
     */
    where?: erosion_cotiereWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of erosion_cotieres to fetch.
     */
    orderBy?: erosion_cotiereOrderByWithRelationInput | erosion_cotiereOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing erosion_cotieres.
     */
    cursor?: erosion_cotiereWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` erosion_cotieres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` erosion_cotieres.
     */
    skip?: number
    distinct?: Erosion_cotiereScalarFieldEnum | Erosion_cotiereScalarFieldEnum[]
  }

  /**
   * erosion_cotiere update
   */
  export type erosion_cotiereUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the erosion_cotiere
     */
    select?: erosion_cotiereSelect<ExtArgs> | null
    /**
     * Omit specific fields from the erosion_cotiere
     */
    omit?: erosion_cotiereOmit<ExtArgs> | null
    /**
     * The data needed to update a erosion_cotiere.
     */
    data: XOR<erosion_cotiereUpdateInput, erosion_cotiereUncheckedUpdateInput>
    /**
     * Choose, which erosion_cotiere to update.
     */
    where: erosion_cotiereWhereUniqueInput
  }

  /**
   * erosion_cotiere updateMany
   */
  export type erosion_cotiereUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update erosion_cotieres.
     */
    data: XOR<erosion_cotiereUpdateManyMutationInput, erosion_cotiereUncheckedUpdateManyInput>
    /**
     * Filter which erosion_cotieres to update
     */
    where?: erosion_cotiereWhereInput
    /**
     * Limit how many erosion_cotieres to update.
     */
    limit?: number
  }

  /**
   * erosion_cotiere updateManyAndReturn
   */
  export type erosion_cotiereUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the erosion_cotiere
     */
    select?: erosion_cotiereSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the erosion_cotiere
     */
    omit?: erosion_cotiereOmit<ExtArgs> | null
    /**
     * The data used to update erosion_cotieres.
     */
    data: XOR<erosion_cotiereUpdateManyMutationInput, erosion_cotiereUncheckedUpdateManyInput>
    /**
     * Filter which erosion_cotieres to update
     */
    where?: erosion_cotiereWhereInput
    /**
     * Limit how many erosion_cotieres to update.
     */
    limit?: number
  }

  /**
   * erosion_cotiere delete
   */
  export type erosion_cotiereDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the erosion_cotiere
     */
    select?: erosion_cotiereSelect<ExtArgs> | null
    /**
     * Omit specific fields from the erosion_cotiere
     */
    omit?: erosion_cotiereOmit<ExtArgs> | null
    /**
     * Filter which erosion_cotiere to delete.
     */
    where: erosion_cotiereWhereUniqueInput
  }

  /**
   * erosion_cotiere deleteMany
   */
  export type erosion_cotiereDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which erosion_cotieres to delete
     */
    where?: erosion_cotiereWhereInput
    /**
     * Limit how many erosion_cotieres to delete.
     */
    limit?: number
  }

  /**
   * erosion_cotiere without action
   */
  export type erosion_cotiereDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the erosion_cotiere
     */
    select?: erosion_cotiereSelect<ExtArgs> | null
    /**
     * Omit specific fields from the erosion_cotiere
     */
    omit?: erosion_cotiereOmit<ExtArgs> | null
  }


  /**
   * Model etat_cours_d_eau
   */

  export type AggregateEtat_cours_d_eau = {
    _count: Etat_cours_d_eauCountAggregateOutputType | null
    _avg: Etat_cours_d_eauAvgAggregateOutputType | null
    _sum: Etat_cours_d_eauSumAggregateOutputType | null
    _min: Etat_cours_d_eauMinAggregateOutputType | null
    _max: Etat_cours_d_eauMaxAggregateOutputType | null
  }

  export type Etat_cours_d_eauAvgAggregateOutputType = {
    pk: number | null
    longueur: number | null
  }

  export type Etat_cours_d_eauSumAggregateOutputType = {
    pk: number | null
    longueur: number | null
  }

  export type Etat_cours_d_eauMinAggregateOutputType = {
    pk: number | null
    name: string | null
    longueur: number | null
    etateco: string | null
  }

  export type Etat_cours_d_eauMaxAggregateOutputType = {
    pk: number | null
    name: string | null
    longueur: number | null
    etateco: string | null
  }

  export type Etat_cours_d_eauCountAggregateOutputType = {
    pk: number
    name: number
    longueur: number
    etateco: number
    _all: number
  }


  export type Etat_cours_d_eauAvgAggregateInputType = {
    pk?: true
    longueur?: true
  }

  export type Etat_cours_d_eauSumAggregateInputType = {
    pk?: true
    longueur?: true
  }

  export type Etat_cours_d_eauMinAggregateInputType = {
    pk?: true
    name?: true
    longueur?: true
    etateco?: true
  }

  export type Etat_cours_d_eauMaxAggregateInputType = {
    pk?: true
    name?: true
    longueur?: true
    etateco?: true
  }

  export type Etat_cours_d_eauCountAggregateInputType = {
    pk?: true
    name?: true
    longueur?: true
    etateco?: true
    _all?: true
  }

  export type Etat_cours_d_eauAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which etat_cours_d_eau to aggregate.
     */
    where?: etat_cours_d_eauWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of etat_cours_d_eaus to fetch.
     */
    orderBy?: etat_cours_d_eauOrderByWithRelationInput | etat_cours_d_eauOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: etat_cours_d_eauWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` etat_cours_d_eaus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` etat_cours_d_eaus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned etat_cours_d_eaus
    **/
    _count?: true | Etat_cours_d_eauCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Etat_cours_d_eauAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Etat_cours_d_eauSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Etat_cours_d_eauMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Etat_cours_d_eauMaxAggregateInputType
  }

  export type GetEtat_cours_d_eauAggregateType<T extends Etat_cours_d_eauAggregateArgs> = {
        [P in keyof T & keyof AggregateEtat_cours_d_eau]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEtat_cours_d_eau[P]>
      : GetScalarType<T[P], AggregateEtat_cours_d_eau[P]>
  }




  export type etat_cours_d_eauGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: etat_cours_d_eauWhereInput
    orderBy?: etat_cours_d_eauOrderByWithAggregationInput | etat_cours_d_eauOrderByWithAggregationInput[]
    by: Etat_cours_d_eauScalarFieldEnum[] | Etat_cours_d_eauScalarFieldEnum
    having?: etat_cours_d_eauScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Etat_cours_d_eauCountAggregateInputType | true
    _avg?: Etat_cours_d_eauAvgAggregateInputType
    _sum?: Etat_cours_d_eauSumAggregateInputType
    _min?: Etat_cours_d_eauMinAggregateInputType
    _max?: Etat_cours_d_eauMaxAggregateInputType
  }

  export type Etat_cours_d_eauGroupByOutputType = {
    pk: number
    name: string
    longueur: number
    etateco: string | null
    _count: Etat_cours_d_eauCountAggregateOutputType | null
    _avg: Etat_cours_d_eauAvgAggregateOutputType | null
    _sum: Etat_cours_d_eauSumAggregateOutputType | null
    _min: Etat_cours_d_eauMinAggregateOutputType | null
    _max: Etat_cours_d_eauMaxAggregateOutputType | null
  }

  type GetEtat_cours_d_eauGroupByPayload<T extends etat_cours_d_eauGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Etat_cours_d_eauGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Etat_cours_d_eauGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Etat_cours_d_eauGroupByOutputType[P]>
            : GetScalarType<T[P], Etat_cours_d_eauGroupByOutputType[P]>
        }
      >
    >


  export type etat_cours_d_eauSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pk?: boolean
    name?: boolean
    longueur?: boolean
    etateco?: boolean
  }, ExtArgs["result"]["etat_cours_d_eau"]>


  export type etat_cours_d_eauSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pk?: boolean
    name?: boolean
    longueur?: boolean
    etateco?: boolean
  }, ExtArgs["result"]["etat_cours_d_eau"]>

  export type etat_cours_d_eauSelectScalar = {
    pk?: boolean
    name?: boolean
    longueur?: boolean
    etateco?: boolean
  }

  export type etat_cours_d_eauOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"pk" | "name" | "longueur" | "etateco", ExtArgs["result"]["etat_cours_d_eau"]>

  export type $etat_cours_d_eauPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "etat_cours_d_eau"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      pk: number
      name: string
      longueur: number
      etateco: string | null
    }, ExtArgs["result"]["etat_cours_d_eau"]>
    composites: {}
  }

  type etat_cours_d_eauGetPayload<S extends boolean | null | undefined | etat_cours_d_eauDefaultArgs> = $Result.GetResult<Prisma.$etat_cours_d_eauPayload, S>

  type etat_cours_d_eauCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<etat_cours_d_eauFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Etat_cours_d_eauCountAggregateInputType | true
    }

  export interface etat_cours_d_eauDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['etat_cours_d_eau'], meta: { name: 'etat_cours_d_eau' } }
    /**
     * Find zero or one Etat_cours_d_eau that matches the filter.
     * @param {etat_cours_d_eauFindUniqueArgs} args - Arguments to find a Etat_cours_d_eau
     * @example
     * // Get one Etat_cours_d_eau
     * const etat_cours_d_eau = await prisma.etat_cours_d_eau.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends etat_cours_d_eauFindUniqueArgs>(args: SelectSubset<T, etat_cours_d_eauFindUniqueArgs<ExtArgs>>): Prisma__etat_cours_d_eauClient<$Result.GetResult<Prisma.$etat_cours_d_eauPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Etat_cours_d_eau that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {etat_cours_d_eauFindUniqueOrThrowArgs} args - Arguments to find a Etat_cours_d_eau
     * @example
     * // Get one Etat_cours_d_eau
     * const etat_cours_d_eau = await prisma.etat_cours_d_eau.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends etat_cours_d_eauFindUniqueOrThrowArgs>(args: SelectSubset<T, etat_cours_d_eauFindUniqueOrThrowArgs<ExtArgs>>): Prisma__etat_cours_d_eauClient<$Result.GetResult<Prisma.$etat_cours_d_eauPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Etat_cours_d_eau that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {etat_cours_d_eauFindFirstArgs} args - Arguments to find a Etat_cours_d_eau
     * @example
     * // Get one Etat_cours_d_eau
     * const etat_cours_d_eau = await prisma.etat_cours_d_eau.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends etat_cours_d_eauFindFirstArgs>(args?: SelectSubset<T, etat_cours_d_eauFindFirstArgs<ExtArgs>>): Prisma__etat_cours_d_eauClient<$Result.GetResult<Prisma.$etat_cours_d_eauPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Etat_cours_d_eau that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {etat_cours_d_eauFindFirstOrThrowArgs} args - Arguments to find a Etat_cours_d_eau
     * @example
     * // Get one Etat_cours_d_eau
     * const etat_cours_d_eau = await prisma.etat_cours_d_eau.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends etat_cours_d_eauFindFirstOrThrowArgs>(args?: SelectSubset<T, etat_cours_d_eauFindFirstOrThrowArgs<ExtArgs>>): Prisma__etat_cours_d_eauClient<$Result.GetResult<Prisma.$etat_cours_d_eauPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Etat_cours_d_eaus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {etat_cours_d_eauFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Etat_cours_d_eaus
     * const etat_cours_d_eaus = await prisma.etat_cours_d_eau.findMany()
     * 
     * // Get first 10 Etat_cours_d_eaus
     * const etat_cours_d_eaus = await prisma.etat_cours_d_eau.findMany({ take: 10 })
     * 
     * // Only select the `pk`
     * const etat_cours_d_eauWithPkOnly = await prisma.etat_cours_d_eau.findMany({ select: { pk: true } })
     * 
     */
    findMany<T extends etat_cours_d_eauFindManyArgs>(args?: SelectSubset<T, etat_cours_d_eauFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$etat_cours_d_eauPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Delete a Etat_cours_d_eau.
     * @param {etat_cours_d_eauDeleteArgs} args - Arguments to delete one Etat_cours_d_eau.
     * @example
     * // Delete one Etat_cours_d_eau
     * const Etat_cours_d_eau = await prisma.etat_cours_d_eau.delete({
     *   where: {
     *     // ... filter to delete one Etat_cours_d_eau
     *   }
     * })
     * 
     */
    delete<T extends etat_cours_d_eauDeleteArgs>(args: SelectSubset<T, etat_cours_d_eauDeleteArgs<ExtArgs>>): Prisma__etat_cours_d_eauClient<$Result.GetResult<Prisma.$etat_cours_d_eauPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Etat_cours_d_eau.
     * @param {etat_cours_d_eauUpdateArgs} args - Arguments to update one Etat_cours_d_eau.
     * @example
     * // Update one Etat_cours_d_eau
     * const etat_cours_d_eau = await prisma.etat_cours_d_eau.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends etat_cours_d_eauUpdateArgs>(args: SelectSubset<T, etat_cours_d_eauUpdateArgs<ExtArgs>>): Prisma__etat_cours_d_eauClient<$Result.GetResult<Prisma.$etat_cours_d_eauPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Etat_cours_d_eaus.
     * @param {etat_cours_d_eauDeleteManyArgs} args - Arguments to filter Etat_cours_d_eaus to delete.
     * @example
     * // Delete a few Etat_cours_d_eaus
     * const { count } = await prisma.etat_cours_d_eau.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends etat_cours_d_eauDeleteManyArgs>(args?: SelectSubset<T, etat_cours_d_eauDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Etat_cours_d_eaus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {etat_cours_d_eauUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Etat_cours_d_eaus
     * const etat_cours_d_eau = await prisma.etat_cours_d_eau.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends etat_cours_d_eauUpdateManyArgs>(args: SelectSubset<T, etat_cours_d_eauUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Etat_cours_d_eaus and returns the data updated in the database.
     * @param {etat_cours_d_eauUpdateManyAndReturnArgs} args - Arguments to update many Etat_cours_d_eaus.
     * @example
     * // Update many Etat_cours_d_eaus
     * const etat_cours_d_eau = await prisma.etat_cours_d_eau.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Etat_cours_d_eaus and only return the `pk`
     * const etat_cours_d_eauWithPkOnly = await prisma.etat_cours_d_eau.updateManyAndReturn({
     *   select: { pk: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends etat_cours_d_eauUpdateManyAndReturnArgs>(args: SelectSubset<T, etat_cours_d_eauUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$etat_cours_d_eauPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>


    /**
     * Count the number of Etat_cours_d_eaus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {etat_cours_d_eauCountArgs} args - Arguments to filter Etat_cours_d_eaus to count.
     * @example
     * // Count the number of Etat_cours_d_eaus
     * const count = await prisma.etat_cours_d_eau.count({
     *   where: {
     *     // ... the filter for the Etat_cours_d_eaus we want to count
     *   }
     * })
    **/
    count<T extends etat_cours_d_eauCountArgs>(
      args?: Subset<T, etat_cours_d_eauCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Etat_cours_d_eauCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Etat_cours_d_eau.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Etat_cours_d_eauAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Etat_cours_d_eauAggregateArgs>(args: Subset<T, Etat_cours_d_eauAggregateArgs>): Prisma.PrismaPromise<GetEtat_cours_d_eauAggregateType<T>>

    /**
     * Group by Etat_cours_d_eau.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {etat_cours_d_eauGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends etat_cours_d_eauGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: etat_cours_d_eauGroupByArgs['orderBy'] }
        : { orderBy?: etat_cours_d_eauGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, etat_cours_d_eauGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEtat_cours_d_eauGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the etat_cours_d_eau model
   */
  readonly fields: etat_cours_d_eauFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for etat_cours_d_eau.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__etat_cours_d_eauClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the etat_cours_d_eau model
   */
  interface etat_cours_d_eauFieldRefs {
    readonly pk: FieldRef<"etat_cours_d_eau", 'Int'>
    readonly name: FieldRef<"etat_cours_d_eau", 'String'>
    readonly longueur: FieldRef<"etat_cours_d_eau", 'Float'>
    readonly etateco: FieldRef<"etat_cours_d_eau", 'String'>
  }
    

  // Custom InputTypes
  /**
   * etat_cours_d_eau findUnique
   */
  export type etat_cours_d_eauFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the etat_cours_d_eau
     */
    select?: etat_cours_d_eauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the etat_cours_d_eau
     */
    omit?: etat_cours_d_eauOmit<ExtArgs> | null
    /**
     * Filter, which etat_cours_d_eau to fetch.
     */
    where: etat_cours_d_eauWhereUniqueInput
  }

  /**
   * etat_cours_d_eau findUniqueOrThrow
   */
  export type etat_cours_d_eauFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the etat_cours_d_eau
     */
    select?: etat_cours_d_eauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the etat_cours_d_eau
     */
    omit?: etat_cours_d_eauOmit<ExtArgs> | null
    /**
     * Filter, which etat_cours_d_eau to fetch.
     */
    where: etat_cours_d_eauWhereUniqueInput
  }

  /**
   * etat_cours_d_eau findFirst
   */
  export type etat_cours_d_eauFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the etat_cours_d_eau
     */
    select?: etat_cours_d_eauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the etat_cours_d_eau
     */
    omit?: etat_cours_d_eauOmit<ExtArgs> | null
    /**
     * Filter, which etat_cours_d_eau to fetch.
     */
    where?: etat_cours_d_eauWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of etat_cours_d_eaus to fetch.
     */
    orderBy?: etat_cours_d_eauOrderByWithRelationInput | etat_cours_d_eauOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for etat_cours_d_eaus.
     */
    cursor?: etat_cours_d_eauWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` etat_cours_d_eaus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` etat_cours_d_eaus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of etat_cours_d_eaus.
     */
    distinct?: Etat_cours_d_eauScalarFieldEnum | Etat_cours_d_eauScalarFieldEnum[]
  }

  /**
   * etat_cours_d_eau findFirstOrThrow
   */
  export type etat_cours_d_eauFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the etat_cours_d_eau
     */
    select?: etat_cours_d_eauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the etat_cours_d_eau
     */
    omit?: etat_cours_d_eauOmit<ExtArgs> | null
    /**
     * Filter, which etat_cours_d_eau to fetch.
     */
    where?: etat_cours_d_eauWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of etat_cours_d_eaus to fetch.
     */
    orderBy?: etat_cours_d_eauOrderByWithRelationInput | etat_cours_d_eauOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for etat_cours_d_eaus.
     */
    cursor?: etat_cours_d_eauWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` etat_cours_d_eaus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` etat_cours_d_eaus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of etat_cours_d_eaus.
     */
    distinct?: Etat_cours_d_eauScalarFieldEnum | Etat_cours_d_eauScalarFieldEnum[]
  }

  /**
   * etat_cours_d_eau findMany
   */
  export type etat_cours_d_eauFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the etat_cours_d_eau
     */
    select?: etat_cours_d_eauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the etat_cours_d_eau
     */
    omit?: etat_cours_d_eauOmit<ExtArgs> | null
    /**
     * Filter, which etat_cours_d_eaus to fetch.
     */
    where?: etat_cours_d_eauWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of etat_cours_d_eaus to fetch.
     */
    orderBy?: etat_cours_d_eauOrderByWithRelationInput | etat_cours_d_eauOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing etat_cours_d_eaus.
     */
    cursor?: etat_cours_d_eauWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` etat_cours_d_eaus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` etat_cours_d_eaus.
     */
    skip?: number
    distinct?: Etat_cours_d_eauScalarFieldEnum | Etat_cours_d_eauScalarFieldEnum[]
  }

  /**
   * etat_cours_d_eau update
   */
  export type etat_cours_d_eauUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the etat_cours_d_eau
     */
    select?: etat_cours_d_eauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the etat_cours_d_eau
     */
    omit?: etat_cours_d_eauOmit<ExtArgs> | null
    /**
     * The data needed to update a etat_cours_d_eau.
     */
    data: XOR<etat_cours_d_eauUpdateInput, etat_cours_d_eauUncheckedUpdateInput>
    /**
     * Choose, which etat_cours_d_eau to update.
     */
    where: etat_cours_d_eauWhereUniqueInput
  }

  /**
   * etat_cours_d_eau updateMany
   */
  export type etat_cours_d_eauUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update etat_cours_d_eaus.
     */
    data: XOR<etat_cours_d_eauUpdateManyMutationInput, etat_cours_d_eauUncheckedUpdateManyInput>
    /**
     * Filter which etat_cours_d_eaus to update
     */
    where?: etat_cours_d_eauWhereInput
    /**
     * Limit how many etat_cours_d_eaus to update.
     */
    limit?: number
  }

  /**
   * etat_cours_d_eau updateManyAndReturn
   */
  export type etat_cours_d_eauUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the etat_cours_d_eau
     */
    select?: etat_cours_d_eauSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the etat_cours_d_eau
     */
    omit?: etat_cours_d_eauOmit<ExtArgs> | null
    /**
     * The data used to update etat_cours_d_eaus.
     */
    data: XOR<etat_cours_d_eauUpdateManyMutationInput, etat_cours_d_eauUncheckedUpdateManyInput>
    /**
     * Filter which etat_cours_d_eaus to update
     */
    where?: etat_cours_d_eauWhereInput
    /**
     * Limit how many etat_cours_d_eaus to update.
     */
    limit?: number
  }

  /**
   * etat_cours_d_eau delete
   */
  export type etat_cours_d_eauDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the etat_cours_d_eau
     */
    select?: etat_cours_d_eauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the etat_cours_d_eau
     */
    omit?: etat_cours_d_eauOmit<ExtArgs> | null
    /**
     * Filter which etat_cours_d_eau to delete.
     */
    where: etat_cours_d_eauWhereUniqueInput
  }

  /**
   * etat_cours_d_eau deleteMany
   */
  export type etat_cours_d_eauDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which etat_cours_d_eaus to delete
     */
    where?: etat_cours_d_eauWhereInput
    /**
     * Limit how many etat_cours_d_eaus to delete.
     */
    limit?: number
  }

  /**
   * etat_cours_d_eau without action
   */
  export type etat_cours_d_eauDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the etat_cours_d_eau
     */
    select?: etat_cours_d_eauSelect<ExtArgs> | null
    /**
     * Omit specific fields from the etat_cours_d_eau
     */
    omit?: etat_cours_d_eauOmit<ExtArgs> | null
  }


  /**
   * Model spatial_ref_sys
   */

  export type AggregateSpatial_ref_sys = {
    _count: Spatial_ref_sysCountAggregateOutputType | null
    _avg: Spatial_ref_sysAvgAggregateOutputType | null
    _sum: Spatial_ref_sysSumAggregateOutputType | null
    _min: Spatial_ref_sysMinAggregateOutputType | null
    _max: Spatial_ref_sysMaxAggregateOutputType | null
  }

  export type Spatial_ref_sysAvgAggregateOutputType = {
    srid: number | null
    auth_srid: number | null
  }

  export type Spatial_ref_sysSumAggregateOutputType = {
    srid: number | null
    auth_srid: number | null
  }

  export type Spatial_ref_sysMinAggregateOutputType = {
    srid: number | null
    auth_name: string | null
    auth_srid: number | null
    srtext: string | null
    proj4text: string | null
  }

  export type Spatial_ref_sysMaxAggregateOutputType = {
    srid: number | null
    auth_name: string | null
    auth_srid: number | null
    srtext: string | null
    proj4text: string | null
  }

  export type Spatial_ref_sysCountAggregateOutputType = {
    srid: number
    auth_name: number
    auth_srid: number
    srtext: number
    proj4text: number
    _all: number
  }


  export type Spatial_ref_sysAvgAggregateInputType = {
    srid?: true
    auth_srid?: true
  }

  export type Spatial_ref_sysSumAggregateInputType = {
    srid?: true
    auth_srid?: true
  }

  export type Spatial_ref_sysMinAggregateInputType = {
    srid?: true
    auth_name?: true
    auth_srid?: true
    srtext?: true
    proj4text?: true
  }

  export type Spatial_ref_sysMaxAggregateInputType = {
    srid?: true
    auth_name?: true
    auth_srid?: true
    srtext?: true
    proj4text?: true
  }

  export type Spatial_ref_sysCountAggregateInputType = {
    srid?: true
    auth_name?: true
    auth_srid?: true
    srtext?: true
    proj4text?: true
    _all?: true
  }

  export type Spatial_ref_sysAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which spatial_ref_sys to aggregate.
     */
    where?: spatial_ref_sysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of spatial_ref_sys to fetch.
     */
    orderBy?: spatial_ref_sysOrderByWithRelationInput | spatial_ref_sysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: spatial_ref_sysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` spatial_ref_sys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` spatial_ref_sys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned spatial_ref_sys
    **/
    _count?: true | Spatial_ref_sysCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Spatial_ref_sysAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Spatial_ref_sysSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Spatial_ref_sysMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Spatial_ref_sysMaxAggregateInputType
  }

  export type GetSpatial_ref_sysAggregateType<T extends Spatial_ref_sysAggregateArgs> = {
        [P in keyof T & keyof AggregateSpatial_ref_sys]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpatial_ref_sys[P]>
      : GetScalarType<T[P], AggregateSpatial_ref_sys[P]>
  }




  export type spatial_ref_sysGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: spatial_ref_sysWhereInput
    orderBy?: spatial_ref_sysOrderByWithAggregationInput | spatial_ref_sysOrderByWithAggregationInput[]
    by: Spatial_ref_sysScalarFieldEnum[] | Spatial_ref_sysScalarFieldEnum
    having?: spatial_ref_sysScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Spatial_ref_sysCountAggregateInputType | true
    _avg?: Spatial_ref_sysAvgAggregateInputType
    _sum?: Spatial_ref_sysSumAggregateInputType
    _min?: Spatial_ref_sysMinAggregateInputType
    _max?: Spatial_ref_sysMaxAggregateInputType
  }

  export type Spatial_ref_sysGroupByOutputType = {
    srid: number
    auth_name: string | null
    auth_srid: number | null
    srtext: string | null
    proj4text: string | null
    _count: Spatial_ref_sysCountAggregateOutputType | null
    _avg: Spatial_ref_sysAvgAggregateOutputType | null
    _sum: Spatial_ref_sysSumAggregateOutputType | null
    _min: Spatial_ref_sysMinAggregateOutputType | null
    _max: Spatial_ref_sysMaxAggregateOutputType | null
  }

  type GetSpatial_ref_sysGroupByPayload<T extends spatial_ref_sysGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Spatial_ref_sysGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Spatial_ref_sysGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Spatial_ref_sysGroupByOutputType[P]>
            : GetScalarType<T[P], Spatial_ref_sysGroupByOutputType[P]>
        }
      >
    >


  export type spatial_ref_sysSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    srid?: boolean
    auth_name?: boolean
    auth_srid?: boolean
    srtext?: boolean
    proj4text?: boolean
  }, ExtArgs["result"]["spatial_ref_sys"]>

  export type spatial_ref_sysSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    srid?: boolean
    auth_name?: boolean
    auth_srid?: boolean
    srtext?: boolean
    proj4text?: boolean
  }, ExtArgs["result"]["spatial_ref_sys"]>

  export type spatial_ref_sysSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    srid?: boolean
    auth_name?: boolean
    auth_srid?: boolean
    srtext?: boolean
    proj4text?: boolean
  }, ExtArgs["result"]["spatial_ref_sys"]>

  export type spatial_ref_sysSelectScalar = {
    srid?: boolean
    auth_name?: boolean
    auth_srid?: boolean
    srtext?: boolean
    proj4text?: boolean
  }

  export type spatial_ref_sysOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"srid" | "auth_name" | "auth_srid" | "srtext" | "proj4text", ExtArgs["result"]["spatial_ref_sys"]>

  export type $spatial_ref_sysPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "spatial_ref_sys"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      srid: number
      auth_name: string | null
      auth_srid: number | null
      srtext: string | null
      proj4text: string | null
    }, ExtArgs["result"]["spatial_ref_sys"]>
    composites: {}
  }

  type spatial_ref_sysGetPayload<S extends boolean | null | undefined | spatial_ref_sysDefaultArgs> = $Result.GetResult<Prisma.$spatial_ref_sysPayload, S>

  type spatial_ref_sysCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<spatial_ref_sysFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Spatial_ref_sysCountAggregateInputType | true
    }

  export interface spatial_ref_sysDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['spatial_ref_sys'], meta: { name: 'spatial_ref_sys' } }
    /**
     * Find zero or one Spatial_ref_sys that matches the filter.
     * @param {spatial_ref_sysFindUniqueArgs} args - Arguments to find a Spatial_ref_sys
     * @example
     * // Get one Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends spatial_ref_sysFindUniqueArgs>(args: SelectSubset<T, spatial_ref_sysFindUniqueArgs<ExtArgs>>): Prisma__spatial_ref_sysClient<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Spatial_ref_sys that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {spatial_ref_sysFindUniqueOrThrowArgs} args - Arguments to find a Spatial_ref_sys
     * @example
     * // Get one Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends spatial_ref_sysFindUniqueOrThrowArgs>(args: SelectSubset<T, spatial_ref_sysFindUniqueOrThrowArgs<ExtArgs>>): Prisma__spatial_ref_sysClient<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Spatial_ref_sys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {spatial_ref_sysFindFirstArgs} args - Arguments to find a Spatial_ref_sys
     * @example
     * // Get one Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends spatial_ref_sysFindFirstArgs>(args?: SelectSubset<T, spatial_ref_sysFindFirstArgs<ExtArgs>>): Prisma__spatial_ref_sysClient<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Spatial_ref_sys that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {spatial_ref_sysFindFirstOrThrowArgs} args - Arguments to find a Spatial_ref_sys
     * @example
     * // Get one Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends spatial_ref_sysFindFirstOrThrowArgs>(args?: SelectSubset<T, spatial_ref_sysFindFirstOrThrowArgs<ExtArgs>>): Prisma__spatial_ref_sysClient<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Spatial_ref_sys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {spatial_ref_sysFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.findMany()
     * 
     * // Get first 10 Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.findMany({ take: 10 })
     * 
     * // Only select the `srid`
     * const spatial_ref_sysWithSridOnly = await prisma.spatial_ref_sys.findMany({ select: { srid: true } })
     * 
     */
    findMany<T extends spatial_ref_sysFindManyArgs>(args?: SelectSubset<T, spatial_ref_sysFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Spatial_ref_sys.
     * @param {spatial_ref_sysCreateArgs} args - Arguments to create a Spatial_ref_sys.
     * @example
     * // Create one Spatial_ref_sys
     * const Spatial_ref_sys = await prisma.spatial_ref_sys.create({
     *   data: {
     *     // ... data to create a Spatial_ref_sys
     *   }
     * })
     * 
     */
    create<T extends spatial_ref_sysCreateArgs>(args: SelectSubset<T, spatial_ref_sysCreateArgs<ExtArgs>>): Prisma__spatial_ref_sysClient<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Spatial_ref_sys.
     * @param {spatial_ref_sysCreateManyArgs} args - Arguments to create many Spatial_ref_sys.
     * @example
     * // Create many Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends spatial_ref_sysCreateManyArgs>(args?: SelectSubset<T, spatial_ref_sysCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Spatial_ref_sys and returns the data saved in the database.
     * @param {spatial_ref_sysCreateManyAndReturnArgs} args - Arguments to create many Spatial_ref_sys.
     * @example
     * // Create many Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Spatial_ref_sys and only return the `srid`
     * const spatial_ref_sysWithSridOnly = await prisma.spatial_ref_sys.createManyAndReturn({
     *   select: { srid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends spatial_ref_sysCreateManyAndReturnArgs>(args?: SelectSubset<T, spatial_ref_sysCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Spatial_ref_sys.
     * @param {spatial_ref_sysDeleteArgs} args - Arguments to delete one Spatial_ref_sys.
     * @example
     * // Delete one Spatial_ref_sys
     * const Spatial_ref_sys = await prisma.spatial_ref_sys.delete({
     *   where: {
     *     // ... filter to delete one Spatial_ref_sys
     *   }
     * })
     * 
     */
    delete<T extends spatial_ref_sysDeleteArgs>(args: SelectSubset<T, spatial_ref_sysDeleteArgs<ExtArgs>>): Prisma__spatial_ref_sysClient<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Spatial_ref_sys.
     * @param {spatial_ref_sysUpdateArgs} args - Arguments to update one Spatial_ref_sys.
     * @example
     * // Update one Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends spatial_ref_sysUpdateArgs>(args: SelectSubset<T, spatial_ref_sysUpdateArgs<ExtArgs>>): Prisma__spatial_ref_sysClient<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Spatial_ref_sys.
     * @param {spatial_ref_sysDeleteManyArgs} args - Arguments to filter Spatial_ref_sys to delete.
     * @example
     * // Delete a few Spatial_ref_sys
     * const { count } = await prisma.spatial_ref_sys.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends spatial_ref_sysDeleteManyArgs>(args?: SelectSubset<T, spatial_ref_sysDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Spatial_ref_sys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {spatial_ref_sysUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends spatial_ref_sysUpdateManyArgs>(args: SelectSubset<T, spatial_ref_sysUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Spatial_ref_sys and returns the data updated in the database.
     * @param {spatial_ref_sysUpdateManyAndReturnArgs} args - Arguments to update many Spatial_ref_sys.
     * @example
     * // Update many Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Spatial_ref_sys and only return the `srid`
     * const spatial_ref_sysWithSridOnly = await prisma.spatial_ref_sys.updateManyAndReturn({
     *   select: { srid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends spatial_ref_sysUpdateManyAndReturnArgs>(args: SelectSubset<T, spatial_ref_sysUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Spatial_ref_sys.
     * @param {spatial_ref_sysUpsertArgs} args - Arguments to update or create a Spatial_ref_sys.
     * @example
     * // Update or create a Spatial_ref_sys
     * const spatial_ref_sys = await prisma.spatial_ref_sys.upsert({
     *   create: {
     *     // ... data to create a Spatial_ref_sys
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Spatial_ref_sys we want to update
     *   }
     * })
     */
    upsert<T extends spatial_ref_sysUpsertArgs>(args: SelectSubset<T, spatial_ref_sysUpsertArgs<ExtArgs>>): Prisma__spatial_ref_sysClient<$Result.GetResult<Prisma.$spatial_ref_sysPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Spatial_ref_sys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {spatial_ref_sysCountArgs} args - Arguments to filter Spatial_ref_sys to count.
     * @example
     * // Count the number of Spatial_ref_sys
     * const count = await prisma.spatial_ref_sys.count({
     *   where: {
     *     // ... the filter for the Spatial_ref_sys we want to count
     *   }
     * })
    **/
    count<T extends spatial_ref_sysCountArgs>(
      args?: Subset<T, spatial_ref_sysCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Spatial_ref_sysCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Spatial_ref_sys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Spatial_ref_sysAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Spatial_ref_sysAggregateArgs>(args: Subset<T, Spatial_ref_sysAggregateArgs>): Prisma.PrismaPromise<GetSpatial_ref_sysAggregateType<T>>

    /**
     * Group by Spatial_ref_sys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {spatial_ref_sysGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends spatial_ref_sysGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: spatial_ref_sysGroupByArgs['orderBy'] }
        : { orderBy?: spatial_ref_sysGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, spatial_ref_sysGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpatial_ref_sysGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the spatial_ref_sys model
   */
  readonly fields: spatial_ref_sysFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for spatial_ref_sys.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__spatial_ref_sysClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the spatial_ref_sys model
   */
  interface spatial_ref_sysFieldRefs {
    readonly srid: FieldRef<"spatial_ref_sys", 'Int'>
    readonly auth_name: FieldRef<"spatial_ref_sys", 'String'>
    readonly auth_srid: FieldRef<"spatial_ref_sys", 'Int'>
    readonly srtext: FieldRef<"spatial_ref_sys", 'String'>
    readonly proj4text: FieldRef<"spatial_ref_sys", 'String'>
  }
    

  // Custom InputTypes
  /**
   * spatial_ref_sys findUnique
   */
  export type spatial_ref_sysFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the spatial_ref_sys
     */
    omit?: spatial_ref_sysOmit<ExtArgs> | null
    /**
     * Filter, which spatial_ref_sys to fetch.
     */
    where: spatial_ref_sysWhereUniqueInput
  }

  /**
   * spatial_ref_sys findUniqueOrThrow
   */
  export type spatial_ref_sysFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the spatial_ref_sys
     */
    omit?: spatial_ref_sysOmit<ExtArgs> | null
    /**
     * Filter, which spatial_ref_sys to fetch.
     */
    where: spatial_ref_sysWhereUniqueInput
  }

  /**
   * spatial_ref_sys findFirst
   */
  export type spatial_ref_sysFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the spatial_ref_sys
     */
    omit?: spatial_ref_sysOmit<ExtArgs> | null
    /**
     * Filter, which spatial_ref_sys to fetch.
     */
    where?: spatial_ref_sysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of spatial_ref_sys to fetch.
     */
    orderBy?: spatial_ref_sysOrderByWithRelationInput | spatial_ref_sysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for spatial_ref_sys.
     */
    cursor?: spatial_ref_sysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` spatial_ref_sys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` spatial_ref_sys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of spatial_ref_sys.
     */
    distinct?: Spatial_ref_sysScalarFieldEnum | Spatial_ref_sysScalarFieldEnum[]
  }

  /**
   * spatial_ref_sys findFirstOrThrow
   */
  export type spatial_ref_sysFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the spatial_ref_sys
     */
    omit?: spatial_ref_sysOmit<ExtArgs> | null
    /**
     * Filter, which spatial_ref_sys to fetch.
     */
    where?: spatial_ref_sysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of spatial_ref_sys to fetch.
     */
    orderBy?: spatial_ref_sysOrderByWithRelationInput | spatial_ref_sysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for spatial_ref_sys.
     */
    cursor?: spatial_ref_sysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` spatial_ref_sys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` spatial_ref_sys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of spatial_ref_sys.
     */
    distinct?: Spatial_ref_sysScalarFieldEnum | Spatial_ref_sysScalarFieldEnum[]
  }

  /**
   * spatial_ref_sys findMany
   */
  export type spatial_ref_sysFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the spatial_ref_sys
     */
    omit?: spatial_ref_sysOmit<ExtArgs> | null
    /**
     * Filter, which spatial_ref_sys to fetch.
     */
    where?: spatial_ref_sysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of spatial_ref_sys to fetch.
     */
    orderBy?: spatial_ref_sysOrderByWithRelationInput | spatial_ref_sysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing spatial_ref_sys.
     */
    cursor?: spatial_ref_sysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` spatial_ref_sys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` spatial_ref_sys.
     */
    skip?: number
    distinct?: Spatial_ref_sysScalarFieldEnum | Spatial_ref_sysScalarFieldEnum[]
  }

  /**
   * spatial_ref_sys create
   */
  export type spatial_ref_sysCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the spatial_ref_sys
     */
    omit?: spatial_ref_sysOmit<ExtArgs> | null
    /**
     * The data needed to create a spatial_ref_sys.
     */
    data: XOR<spatial_ref_sysCreateInput, spatial_ref_sysUncheckedCreateInput>
  }

  /**
   * spatial_ref_sys createMany
   */
  export type spatial_ref_sysCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many spatial_ref_sys.
     */
    data: spatial_ref_sysCreateManyInput | spatial_ref_sysCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * spatial_ref_sys createManyAndReturn
   */
  export type spatial_ref_sysCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the spatial_ref_sys
     */
    omit?: spatial_ref_sysOmit<ExtArgs> | null
    /**
     * The data used to create many spatial_ref_sys.
     */
    data: spatial_ref_sysCreateManyInput | spatial_ref_sysCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * spatial_ref_sys update
   */
  export type spatial_ref_sysUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the spatial_ref_sys
     */
    omit?: spatial_ref_sysOmit<ExtArgs> | null
    /**
     * The data needed to update a spatial_ref_sys.
     */
    data: XOR<spatial_ref_sysUpdateInput, spatial_ref_sysUncheckedUpdateInput>
    /**
     * Choose, which spatial_ref_sys to update.
     */
    where: spatial_ref_sysWhereUniqueInput
  }

  /**
   * spatial_ref_sys updateMany
   */
  export type spatial_ref_sysUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update spatial_ref_sys.
     */
    data: XOR<spatial_ref_sysUpdateManyMutationInput, spatial_ref_sysUncheckedUpdateManyInput>
    /**
     * Filter which spatial_ref_sys to update
     */
    where?: spatial_ref_sysWhereInput
    /**
     * Limit how many spatial_ref_sys to update.
     */
    limit?: number
  }

  /**
   * spatial_ref_sys updateManyAndReturn
   */
  export type spatial_ref_sysUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the spatial_ref_sys
     */
    omit?: spatial_ref_sysOmit<ExtArgs> | null
    /**
     * The data used to update spatial_ref_sys.
     */
    data: XOR<spatial_ref_sysUpdateManyMutationInput, spatial_ref_sysUncheckedUpdateManyInput>
    /**
     * Filter which spatial_ref_sys to update
     */
    where?: spatial_ref_sysWhereInput
    /**
     * Limit how many spatial_ref_sys to update.
     */
    limit?: number
  }

  /**
   * spatial_ref_sys upsert
   */
  export type spatial_ref_sysUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the spatial_ref_sys
     */
    omit?: spatial_ref_sysOmit<ExtArgs> | null
    /**
     * The filter to search for the spatial_ref_sys to update in case it exists.
     */
    where: spatial_ref_sysWhereUniqueInput
    /**
     * In case the spatial_ref_sys found by the `where` argument doesn't exist, create a new spatial_ref_sys with this data.
     */
    create: XOR<spatial_ref_sysCreateInput, spatial_ref_sysUncheckedCreateInput>
    /**
     * In case the spatial_ref_sys was found with the provided `where` argument, update it with this data.
     */
    update: XOR<spatial_ref_sysUpdateInput, spatial_ref_sysUncheckedUpdateInput>
  }

  /**
   * spatial_ref_sys delete
   */
  export type spatial_ref_sysDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the spatial_ref_sys
     */
    omit?: spatial_ref_sysOmit<ExtArgs> | null
    /**
     * Filter which spatial_ref_sys to delete.
     */
    where: spatial_ref_sysWhereUniqueInput
  }

  /**
   * spatial_ref_sys deleteMany
   */
  export type spatial_ref_sysDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which spatial_ref_sys to delete
     */
    where?: spatial_ref_sysWhereInput
    /**
     * Limit how many spatial_ref_sys to delete.
     */
    limit?: number
  }

  /**
   * spatial_ref_sys without action
   */
  export type spatial_ref_sysDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the spatial_ref_sys
     */
    select?: spatial_ref_sysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the spatial_ref_sys
     */
    omit?: spatial_ref_sysOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const North_star_metricScalarFieldEnum: {
    value: 'value',
    date: 'date',
    pk: 'pk'
  };

  export type North_star_metricScalarFieldEnum = (typeof North_star_metricScalarFieldEnum)[keyof typeof North_star_metricScalarFieldEnum]


  export const Sandbox_usersScalarFieldEnum: {
    username: 'username',
    pk: 'pk',
    password: 'password',
    created_at: 'created_at'
  };

  export type Sandbox_usersScalarFieldEnum = (typeof Sandbox_usersScalarFieldEnum)[keyof typeof Sandbox_usersScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    pk: 'pk',
    email: 'email',
    username: 'username',
    password: 'password',
    created_at: 'created_at',
    last_connection: 'last_connection',
    role: 'role'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const All_autocapture_rawScalarFieldEnum: {
    id: 'id',
    event_timestamp: 'event_timestamp',
    properties: 'properties',
    distinct_id: 'distinct_id',
    session_id: 'session_id',
    current_url: 'current_url',
    person_id: 'person_id',
    ingested_at: 'ingested_at'
  };

  export type All_autocapture_rawScalarFieldEnum = (typeof All_autocapture_rawScalarFieldEnum)[keyof typeof All_autocapture_rawScalarFieldEnum]


  export const All_pageview_rawScalarFieldEnum: {
    id: 'id',
    event_timestamp: 'event_timestamp',
    properties: 'properties',
    distinct_id: 'distinct_id',
    session_id: 'session_id',
    current_url: 'current_url',
    person_id: 'person_id',
    ingested_at: 'ingested_at'
  };

  export type All_pageview_rawScalarFieldEnum = (typeof All_pageview_rawScalarFieldEnum)[keyof typeof All_pageview_rawScalarFieldEnum]


  export const Baserow_evenementsScalarFieldEnum: {
    id: 'id',
    ordre: 'ordre',
    nom: 'nom',
    date: 'date',
    type: 'type',
    qui_anime_evenement: 'qui_anime_evenement',
    compte_rendu: 'compte_rendu',
    nom_participants: 'nom_participants',
    nom_territoires: 'nom_territoires',
    propos_nom_evenement: 'propos_nom_evenement',
    campagne_test_utilisateur: 'campagne_test_utilisateur',
    champs_rapporte: 'champs_rapporte',
    fichier: 'fichier',
    ingested_at: 'ingested_at'
  };

  export type Baserow_evenementsScalarFieldEnum = (typeof Baserow_evenementsScalarFieldEnum)[keyof typeof Baserow_evenementsScalarFieldEnum]


  export const Baserow_territoiresScalarFieldEnum: {
    id: 'id',
    ordre: 'ordre',
    nom_territoire: 'nom_territoire',
    notes_ouvertes: 'notes_ouvertes',
    typologie_territoire: 'typologie_territoire',
    thematique_prioritaire: 'thematique_prioritaire',
    be: 'be',
    soumis_a_pcaet: 'soumis_a_pcaet',
    demarches_et_programmes: 'demarches_et_programmes',
    documents_de_planification: 'documents_de_planification',
    avancee_sur_le_ddv: 'avancee_sur_le_ddv',
    avancee_sur_la_strategie: 'avancee_sur_la_strategie',
    suivi_evaluation: 'suivi_evaluation',
    date_validation: 'date_validation',
    date_revision_estimee: 'date_revision_estimee',
    propos: 'propos',
    attente_session_accueil: 'attente_session_accueil',
    role_be: 'role_be',
    cdm: 'cdm',
    siren: 'siren',
    ingested_at: 'ingested_at'
  };

  export type Baserow_territoiresScalarFieldEnum = (typeof Baserow_territoiresScalarFieldEnum)[keyof typeof Baserow_territoiresScalarFieldEnum]


  export const Boutons_export_rawScalarFieldEnum: {
    id: 'id',
    event: 'event',
    event_timestamp: 'event_timestamp',
    session_id: 'session_id',
    person_id: 'person_id',
    code_geographique: 'code_geographique',
    libelle_geographique: 'libelle_geographique',
    thematique: 'thematique',
    ingested_at: 'ingested_at'
  };

  export type Boutons_export_rawScalarFieldEnum = (typeof Boutons_export_rawScalarFieldEnum)[keyof typeof Boutons_export_rawScalarFieldEnum]


  export const Boutons_homepageScalarFieldEnum: {
    id: 'id',
    event: 'event',
    event_timestamp: 'event_timestamp',
    properties: 'properties',
    distinct_id: 'distinct_id',
    session_id: 'session_id',
    person_id: 'person_id',
    ingested_at: 'ingested_at'
  };

  export type Boutons_homepageScalarFieldEnum = (typeof Boutons_homepageScalarFieldEnum)[keyof typeof Boutons_homepageScalarFieldEnum]


  export const Couverture_populationScalarFieldEnum: {
    id: 'id',
    date: 'date',
    population: 'population'
  };

  export type Couverture_populationScalarFieldEnum = (typeof Couverture_populationScalarFieldEnum)[keyof typeof Couverture_populationScalarFieldEnum]


  export const Ressources_consulteesScalarFieldEnum: {
    id: 'id',
    event_timestamp: 'event_timestamp',
    distinct_id: 'distinct_id',
    session_id: 'session_id',
    person_id: 'person_id',
    ressource: 'ressource',
    ingested_at: 'ingested_at'
  };

  export type Ressources_consulteesScalarFieldEnum = (typeof Ressources_consulteesScalarFieldEnum)[keyof typeof Ressources_consulteesScalarFieldEnum]


  export const ThematiqueScalarFieldEnum: {
    id: 'id',
    event_timestamp: 'event_timestamp',
    properties: 'properties',
    distinct_id: 'distinct_id',
    session_id: 'session_id',
    person_id: 'person_id',
    thematique: 'thematique',
    ingested_at: 'ingested_at'
  };

  export type ThematiqueScalarFieldEnum = (typeof ThematiqueScalarFieldEnum)[keyof typeof ThematiqueScalarFieldEnum]


  export const AgricultureScalarFieldEnum: {
    index: 'index',
    code_geographique: 'code_geographique',
    libelle_geographique: 'libelle_geographique',
    epci: 'epci',
    libelle_epci: 'libelle_epci',
    departement: 'departement',
    libelle_departement: 'libelle_departement',
    region: 'region',
    ept: 'ept',
    libelle_petr: 'libelle_petr',
    code_pnr: 'code_pnr',
    libelle_pnr: 'libelle_pnr',
    part_irr_SAU_2020: 'part_irr_SAU_2020',
    otex_12_postes: 'otex_12_postes'
  };

  export type AgricultureScalarFieldEnum = (typeof AgricultureScalarFieldEnum)[keyof typeof AgricultureScalarFieldEnum]


  export const Agriculture_bioScalarFieldEnum: {
    index: 'index',
    epci: 'epci',
    libelle_epci: 'libelle_epci',
    VARIABLE: 'VARIABLE',
    LIBELLE_SOUS_CHAMP: 'LIBELLE_SOUS_CHAMP',
    surface_2023: 'surface_2023',
    surface_2022: 'surface_2022',
    surface_2021: 'surface_2021',
    surface_2020: 'surface_2020',
    surface_2019: 'surface_2019',
    surface_2018: 'surface_2018',
    surface_2017: 'surface_2017',
    surface_2016: 'surface_2016',
    surface_2015: 'surface_2015',
    surface_2014: 'surface_2014',
    surface_2013: 'surface_2013',
    surface_2012: 'surface_2012',
    surface_2011: 'surface_2011',
    surface_2010: 'surface_2010',
    surface_2009: 'surface_2009',
    surface_2008: 'surface_2008',
    nombre_2023: 'nombre_2023',
    nombre_2022: 'nombre_2022',
    nombre_2021: 'nombre_2021',
    nombre_2020: 'nombre_2020',
    nombre_2019: 'nombre_2019',
    nombre_2018: 'nombre_2018',
    nombre_2017: 'nombre_2017',
    nombre_2016: 'nombre_2016',
    nombre_2015: 'nombre_2015',
    nombre_2014: 'nombre_2014',
    nombre_2013: 'nombre_2013',
    nombre_2012: 'nombre_2012',
    nombre_2011: 'nombre_2011',
    nombre_2010: 'nombre_2010',
    nombre_2009: 'nombre_2009',
    nombre_2008: 'nombre_2008'
  };

  export type Agriculture_bioScalarFieldEnum = (typeof Agriculture_bioScalarFieldEnum)[keyof typeof Agriculture_bioScalarFieldEnum]


  export const Aot_40ScalarFieldEnum: {
    index: 'index',
    nom_site: 'nom_site',
    type_d_implantation: 'type_d_implantation',
    valeur_brute: 'valeur_brute',
    Latitude: 'Latitude',
    Longitude: 'Longitude'
  };

  export type Aot_40ScalarFieldEnum = (typeof Aot_40ScalarFieldEnum)[keyof typeof Aot_40ScalarFieldEnum]


  export const Arretes_catnatScalarFieldEnum: {
    index: 'index',
    code_geographique: 'code_geographique',
    libelle_geographique: 'libelle_geographique',
    epci: 'epci',
    libelle_epci: 'libelle_epci',
    departement: 'departement',
    libelle_departement: 'libelle_departement',
    region: 'region',
    ept: 'ept',
    libelle_petr: 'libelle_petr',
    code_pnr: 'code_pnr',
    libelle_pnr: 'libelle_pnr',
    lib_risque_jo: 'lib_risque_jo',
    dat_deb: 'dat_deb',
    dat_fin: 'dat_fin',
    dat_pub_arrete: 'dat_pub_arrete'
  };

  export type Arretes_catnatScalarFieldEnum = (typeof Arretes_catnatScalarFieldEnum)[keyof typeof Arretes_catnatScalarFieldEnum]


  export const Atlas_biodiversiteScalarFieldEnum: {
    index: 'index',
    code_geographique: 'code_geographique',
    libelle_geographique: 'libelle_geographique',
    epci: 'epci',
    libelle_epci: 'libelle_epci',
    departement: 'departement',
    libelle_departement: 'libelle_departement',
    region: 'region',
    ept: 'ept',
    libelle_petr: 'libelle_petr',
    code_pnr: 'code_pnr',
    libelle_pnr: 'libelle_pnr',
    nom: 'nom',
    structure_porteuse: 'structure_porteuse',
    type_de_structure_porteuse: 'type_de_structure_porteuse',
    annee_debut: 'annee_debut',
    avancement: 'avancement'
  };

  export type Atlas_biodiversiteScalarFieldEnum = (typeof Atlas_biodiversiteScalarFieldEnum)[keyof typeof Atlas_biodiversiteScalarFieldEnum]


  export const Collectivites_searchbarScalarFieldEnum: {
    index: 'index',
    code_geographique: 'code_geographique',
    libelle_geographique: 'libelle_geographique',
    epci: 'epci',
    libelle_epci: 'libelle_epci',
    departement: 'departement',
    libelle_departement: 'libelle_departement',
    region: 'region',
    ept: 'ept',
    libelle_petr: 'libelle_petr',
    code_pnr: 'code_pnr',
    libelle_pnr: 'libelle_pnr',
    search_code: 'search_code',
    search_libelle: 'search_libelle'
  };

  export type Collectivites_searchbarScalarFieldEnum = (typeof Collectivites_searchbarScalarFieldEnum)[keyof typeof Collectivites_searchbarScalarFieldEnum]


  export const Confort_thermiqueScalarFieldEnum: {
    index: 'index',
    code_geographique: 'code_geographique',
    libelle_geographique: 'libelle_geographique',
    epci: 'epci',
    libelle_epci: 'libelle_epci',
    departement: 'departement',
    libelle_departement: 'libelle_departement',
    region: 'region',
    ept: 'ept',
    libelle_petr: 'libelle_petr',
    code_pnr: 'code_pnr',
    libelle_pnr: 'libelle_pnr',
    age_bati_post06: 'age_bati_post06',
    age_bati_91_05: 'age_bati_91_05',
    age_bati_46_90: 'age_bati_46_90',
    age_bati_19_45: 'age_bati_19_45',
    age_bati_pre_19: 'age_bati_pre_19',
    under_4_sum_1968: 'under_4_sum_1968',
    to_75_sum_1968: 'to_75_sum_1968',
    over_75_sum_1968: 'over_75_sum_1968',
    under_4_sum_1975: 'under_4_sum_1975',
    to_75_sum_1975: 'to_75_sum_1975',
    over_75_sum_1975: 'over_75_sum_1975',
    under_4_sum_1982: 'under_4_sum_1982',
    to_75_sum_1982: 'to_75_sum_1982',
    over_75_sum_1982: 'over_75_sum_1982',
    under_4_sum_1990: 'under_4_sum_1990',
    to_75_sum_1990: 'to_75_sum_1990',
    over_75_sum_1990: 'over_75_sum_1990',
    under_4_sum_1999: 'under_4_sum_1999',
    to_75_sum_1999: 'to_75_sum_1999',
    over_75_sum_1999: 'over_75_sum_1999',
    under_4_sum_2009: 'under_4_sum_2009',
    to_75_sum_2009: 'to_75_sum_2009',
    over_75_sum_2009: 'over_75_sum_2009',
    under_4_sum_2014: 'under_4_sum_2014',
    to_75_sum_2014: 'to_75_sum_2014',
    over_75_sum_2014: 'over_75_sum_2014',
    under_4_sum_2020: 'under_4_sum_2020',
    to_75_sum_2020: 'to_75_sum_2020',
    over_75_sum_2020: 'over_75_sum_2020',
    tee_log: 'tee_log',
    tee_mob: 'tee_mob',
    precarite_logement: 'precarite_logement',
    NA5AZ_sum: 'NA5AZ_sum',
    NA5BE_sum: 'NA5BE_sum',
    NA5FZ_sum: 'NA5FZ_sum',
    NA5GU_sum: 'NA5GU_sum',
    NA5OQ_sum: 'NA5OQ_sum',
    clc_1_artificialise: 'clc_1_artificialise',
    clc_2_agricole: 'clc_2_agricole',
    clc_3_foret_semiNaturel: 'clc_3_foret_semiNaturel',
    clc_4_humide: 'clc_4_humide',
    clc_5_eau: 'clc_5_eau',
    superf_choro: 'superf_choro'
  };

  export type Confort_thermiqueScalarFieldEnum = (typeof Confort_thermiqueScalarFieldEnum)[keyof typeof Confort_thermiqueScalarFieldEnum]


  export const Consommation_espaces_nafScalarFieldEnum: {
    index: 'index',
    code_geographique: 'code_geographique',
    libelle_geographique: 'libelle_geographique',
    epci: 'epci',
    libelle_epci: 'libelle_epci',
    departement: 'departement',
    libelle_departement: 'libelle_departement',
    region: 'region',
    ept: 'ept',
    libelle_petr: 'libelle_petr',
    code_pnr: 'code_pnr',
    libelle_pnr: 'libelle_pnr',
    naf09art10: 'naf09art10',
    art09act10: 'art09act10',
    art09hab10: 'art09hab10',
    art09mix10: 'art09mix10',
    art09rou10: 'art09rou10',
    art09fer10: 'art09fer10',
    art09inc10: 'art09inc10',
    naf10art11: 'naf10art11',
    art10act11: 'art10act11',
    art10hab11: 'art10hab11',
    art10mix11: 'art10mix11',
    art10rou11: 'art10rou11',
    art10fer11: 'art10fer11',
    art10inc11: 'art10inc11',
    naf11art12: 'naf11art12',
    art11act12: 'art11act12',
    art11hab12: 'art11hab12',
    art11mix12: 'art11mix12',
    art11rou12: 'art11rou12',
    art11fer12: 'art11fer12',
    art11inc12: 'art11inc12',
    naf12art13: 'naf12art13',
    art12act13: 'art12act13',
    art12hab13: 'art12hab13',
    art12mix13: 'art12mix13',
    art12rou13: 'art12rou13',
    art12fer13: 'art12fer13',
    art12inc13: 'art12inc13',
    naf13art14: 'naf13art14',
    art13act14: 'art13act14',
    art13hab14: 'art13hab14',
    art13mix14: 'art13mix14',
    art13rou14: 'art13rou14',
    art13fer14: 'art13fer14',
    art13inc14: 'art13inc14',
    naf14art15: 'naf14art15',
    art14act15: 'art14act15',
    art14hab15: 'art14hab15',
    art14mix15: 'art14mix15',
    art14rou15: 'art14rou15',
    art14fer15: 'art14fer15',
    art14inc15: 'art14inc15',
    naf15art16: 'naf15art16',
    art15act16: 'art15act16',
    art15hab16: 'art15hab16',
    art15mix16: 'art15mix16',
    art15rou16: 'art15rou16',
    art15fer16: 'art15fer16',
    art15inc16: 'art15inc16',
    naf16art17: 'naf16art17',
    art16act17: 'art16act17',
    art16hab17: 'art16hab17',
    art16mix17: 'art16mix17',
    art16rou17: 'art16rou17',
    art16fer17: 'art16fer17',
    art16inc17: 'art16inc17',
    naf17art18: 'naf17art18',
    art17act18: 'art17act18',
    art17hab18: 'art17hab18',
    art17mix18: 'art17mix18',
    art17rou18: 'art17rou18',
    art17fer18: 'art17fer18',
    art17inc18: 'art17inc18',
    naf18art19: 'naf18art19',
    art18act19: 'art18act19',
    art18hab19: 'art18hab19',
    art18mix19: 'art18mix19',
    art18rou19: 'art18rou19',
    art18fer19: 'art18fer19',
    art18inc19: 'art18inc19',
    naf19art20: 'naf19art20',
    art19act20: 'art19act20',
    art19hab20: 'art19hab20',
    art19mix20: 'art19mix20',
    art19rou20: 'art19rou20',
    art19fer20: 'art19fer20',
    art19inc20: 'art19inc20',
    naf20art21: 'naf20art21',
    art20act21: 'art20act21',
    art20hab21: 'art20hab21',
    art20mix21: 'art20mix21',
    art20rou21: 'art20rou21',
    art20fer21: 'art20fer21',
    art20inc21: 'art20inc21',
    naf21art22: 'naf21art22',
    art21act22: 'art21act22',
    art21hab22: 'art21hab22',
    art21mix22: 'art21mix22',
    art21rou22: 'art21rou22',
    art21fer22: 'art21fer22',
    art21inc22: 'art21inc22',
    naf22art23: 'naf22art23',
    art22act23: 'art22act23',
    art22hab23: 'art22hab23',
    art22mix23: 'art22mix23',
    art22rou23: 'art22rou23',
    art22fer23: 'art22fer23',
    art22inc23: 'art22inc23',
    naf09art23: 'naf09art23',
    art09act23: 'art09act23',
    art09hab23: 'art09hab23',
    art09mix23: 'art09mix23',
    art09inc23: 'art09inc23',
    art09rou23: 'art09rou23',
    art09fer23: 'art09fer23',
    artcom0923: 'artcom0923'
  };

  export type Consommation_espaces_nafScalarFieldEnum = (typeof Consommation_espaces_nafScalarFieldEnum)[keyof typeof Consommation_espaces_nafScalarFieldEnum]


  export const Export_cours_d_eauScalarFieldEnum: {
    index: 'index',
    code_geographique: 'code_geographique',
    libelle_geographique: 'libelle_geographique',
    epci: 'epci',
    libelle_epci: 'libelle_epci',
    departement: 'departement',
    libelle_departement: 'libelle_departement',
    region: 'region',
    ept: 'ept',
    libelle_petr: 'libelle_petr',
    code_pnr: 'code_pnr',
    libelle_pnr: 'libelle_pnr',
    cours_d_eau: 'cours_d_eau',
    etat_ecologique: 'etat_ecologique',
    longueur: 'longueur'
  };

  export type Export_cours_d_eauScalarFieldEnum = (typeof Export_cours_d_eauScalarFieldEnum)[keyof typeof Export_cours_d_eauScalarFieldEnum]


  export const Feux_foretScalarFieldEnum: {
    index: 'index',
    code_geographique: 'code_geographique',
    libelle_geographique: 'libelle_geographique',
    epci: 'epci',
    libelle_epci: 'libelle_epci',
    departement: 'departement',
    libelle_departement: 'libelle_departement',
    region: 'region',
    ept: 'ept',
    libelle_petr: 'libelle_petr',
    code_pnr: 'code_pnr',
    libelle_pnr: 'libelle_pnr',
    annee: 'annee',
    nature: 'nature',
    surface_parcourue: 'surface_parcourue',
    surface_foret: 'surface_foret',
    surface_maquis_garrigues: 'surface_maquis_garrigues',
    autres_surfaces_naturelles_hors_foret: 'autres_surfaces_naturelles_hors_foret',
    surfaces_agricoles: 'surfaces_agricoles',
    surfaces_non_boisees: 'surfaces_non_boisees',
    surfaces_non_boisees_artificialisees: 'surfaces_non_boisees_artificialisees',
    surfaces_non_boisees_naturelles: 'surfaces_non_boisees_naturelles',
    surface_autres_terres_boisees: 'surface_autres_terres_boisees',
    autres_surfaces: 'autres_surfaces'
  };

  export type Feux_foretScalarFieldEnum = (typeof Feux_foretScalarFieldEnum)[keyof typeof Feux_foretScalarFieldEnum]


  export const Lcz_couvertureScalarFieldEnum: {
    index: 'index',
    code_geographique: 'code_geographique',
    libelle_geographique: 'libelle_geographique',
    epci: 'epci',
    libelle_epci: 'libelle_epci',
    departement: 'departement',
    libelle_departement: 'libelle_departement',
    region: 'region',
    ept: 'ept',
    libelle_petr: 'libelle_petr',
    code_pnr: 'code_pnr',
    libelle_pnr: 'libelle_pnr',
    couverture_lcz: 'couverture_lcz'
  };

  export type Lcz_couvertureScalarFieldEnum = (typeof Lcz_couvertureScalarFieldEnum)[keyof typeof Lcz_couvertureScalarFieldEnum]


  export const Patch4cScalarFieldEnum: {
    index: 'index',
    code_geographique: 'code_geographique',
    niveaux_marins: 'niveaux_marins',
    feux_foret: 'feux_foret',
    secheresse_sols: 'secheresse_sols',
    fortes_precipitations: 'fortes_precipitations',
    fortes_chaleurs: 'fortes_chaleurs'
  };

  export type Patch4cScalarFieldEnum = (typeof Patch4cScalarFieldEnum)[keyof typeof Patch4cScalarFieldEnum]


  export const Prelevements_eauScalarFieldEnum: {
    index: 'index',
    code_geographique: 'code_geographique',
    libelle_geographique: 'libelle_geographique',
    epci: 'epci',
    libelle_epci: 'libelle_epci',
    departement: 'departement',
    libelle_departement: 'libelle_departement',
    region: 'region',
    ept: 'ept',
    libelle_petr: 'libelle_petr',
    code_pnr: 'code_pnr',
    libelle_pnr: 'libelle_pnr',
    libelle_sous_champ: 'libelle_sous_champ',
    A2020: 'A2020',
    A2019: 'A2019',
    A2018: 'A2018',
    A2017: 'A2017',
    A2016: 'A2016',
    A2015: 'A2015',
    A2014: 'A2014',
    A2013: 'A2013',
    A2012: 'A2012',
    A2011: 'A2011',
    A2010: 'A2010',
    A2009: 'A2009',
    A2008: 'A2008',
    sous_champ: 'sous_champ'
  };

  export type Prelevements_eauScalarFieldEnum = (typeof Prelevements_eauScalarFieldEnum)[keyof typeof Prelevements_eauScalarFieldEnum]


  export const Qualite_sites_baignadeScalarFieldEnum: {
    index: 'index',
    DEP_NOM: 'DEP_NOM',
    DEP_NUM: 'DEP_NUM',
    TYPE: 'TYPE',
    COMMUNE: 'COMMUNE',
    POINT: 'POINT',
    LONG: 'LONG',
    LAT: 'LAT',
    QEB_2013: 'QEB_2013',
    QEB_2014: 'QEB_2014',
    QEB_2015: 'QEB_2015',
    QEB_2016: 'QEB_2016',
    QEB_2017: 'QEB_2017',
    QEB_2018: 'QEB_2018',
    QEB_2019: 'QEB_2019',
    QEB_2020: 'QEB_2020'
  };

  export type Qualite_sites_baignadeScalarFieldEnum = (typeof Qualite_sites_baignadeScalarFieldEnum)[keyof typeof Qualite_sites_baignadeScalarFieldEnum]


  export const Ressources_eauScalarFieldEnum: {
    index: 'index',
    code_geographique: 'code_geographique',
    LIBELLE_SOUS_CHAMP: 'LIBELLE_SOUS_CHAMP',
    A2020: 'A2020',
    A2019: 'A2019',
    A2018: 'A2018',
    A2017: 'A2017',
    A2016: 'A2016',
    A2015: 'A2015',
    A2014: 'A2014',
    A2013: 'A2013',
    A2012: 'A2012',
    A2011: 'A2011',
    A2010: 'A2010',
    A2009: 'A2009',
    A2008: 'A2008',
    SOUS_CHAMP: 'SOUS_CHAMP',
    libelle_geographique: 'libelle_geographique',
    epci: 'epci',
    libelle_epci: 'libelle_epci',
    departement: 'departement',
    libelle_departement: 'libelle_departement',
    region: 'region',
    ept: 'ept',
    libelle_petr: 'libelle_petr',
    code_pnr: 'code_pnr',
    libelle_pnr: 'libelle_pnr'
  };

  export type Ressources_eauScalarFieldEnum = (typeof Ressources_eauScalarFieldEnum)[keyof typeof Ressources_eauScalarFieldEnum]


  export const RgaScalarFieldEnum: {
    index: 'index',
    code_geographique: 'code_geographique',
    libelle_geographique: 'libelle_geographique',
    epci: 'epci',
    libelle_epci: 'libelle_epci',
    departement: 'departement',
    libelle_departement: 'libelle_departement',
    region: 'region',
    ept: 'ept',
    libelle_petr: 'libelle_petr',
    code_pnr: 'code_pnr',
    libelle_pnr: 'libelle_pnr',
    nb_logement: 'nb_logement',
    nb_logement_alea_moyen_fort: 'nb_logement_alea_moyen_fort',
    nb_logement_alea_faible: 'nb_logement_alea_faible',
    nb_logement_sans_alea: 'nb_logement_sans_alea',
    nb_logement_alea_moyen_fort_avant_1920: 'nb_logement_alea_moyen_fort_avant_1920',
    nb_logement_alea_moyen_fort_1920_1945: 'nb_logement_alea_moyen_fort_1920_1945',
    nb_logement_alea_moyen_fort_1945_1975: 'nb_logement_alea_moyen_fort_1945_1975',
    nb_logement_alea_moyen_fort_apres_1975: 'nb_logement_alea_moyen_fort_apres_1975',
    nb_logement_alea_faible_avant_1920: 'nb_logement_alea_faible_avant_1920',
    nb_logement_alea_faible_1920_1945: 'nb_logement_alea_faible_1920_1945',
    nb_logement_alea_faible_1945_1975: 'nb_logement_alea_faible_1945_1975',
    nb_logement_alea_faible_apres_1975: 'nb_logement_alea_faible_apres_1975',
    surface_commune: 'surface_commune',
    surface_alea_faible_commune: 'surface_alea_faible_commune',
    surface_alea_moyen_fort_commune: 'surface_alea_moyen_fort_commune',
    part_logement_alea_moyen_fort_avant_1920: 'part_logement_alea_moyen_fort_avant_1920',
    part_logement_alea_moyen_fort_1920_1945: 'part_logement_alea_moyen_fort_1920_1945',
    part_logement_alea_moyen_fort_1945_1975: 'part_logement_alea_moyen_fort_1945_1975',
    part_logement_alea_moyen_fort_apres_1975: 'part_logement_alea_moyen_fort_apres_1975',
    part_logement_alea_faible_avant_1920: 'part_logement_alea_faible_avant_1920',
    part_logement_alea_faible_1920_1945: 'part_logement_alea_faible_1920_1945',
    part_logement_alea_faible_1945_1975: 'part_logement_alea_faible_1945_1975',
    part_logement_alea_faible_apres_1975: 'part_logement_alea_faible_apres_1975',
    part_alea_faible_commune: 'part_alea_faible_commune',
    part_alea_moyen_fort_commune: 'part_alea_moyen_fort_commune'
  };

  export type RgaScalarFieldEnum = (typeof RgaScalarFieldEnum)[keyof typeof RgaScalarFieldEnum]


  export const Surfaces_agricolesScalarFieldEnum: {
    index: 'index',
    epci: 'epci',
    exploitation_sau: 'exploitation_sau',
    exploitation_sau_terres_arables: 'exploitation_sau_terres_arables',
    exploitation_sau_terres_arables_cereales: 'exploitation_sau_terres_arables_cereales',
    exploitation_sau_terres_arables_oleagineux: 'exploitation_sau_terres_arables_oleagineux',
    exploitation_sau_terres_arables_fourrageres: 'exploitation_sau_terres_arables_fourrageres',
    exploitation_sau_terres_arables_tubercules: 'exploitation_sau_terres_arables_tubercules',
    exploitation_sau_terres_arables_legumes_melons_fraises: 'exploitation_sau_terres_arables_legumes_melons_fraises',
    exploitation_sau_terres_arables_fleurs: 'exploitation_sau_terres_arables_fleurs',
    exploitation_sau_terres_arables_autres: 'exploitation_sau_terres_arables_autres',
    exploitation_sau_cultures_permanentes: 'exploitation_sau_cultures_permanentes',
    exploitation_sau_cultures_permanentes_vigne: 'exploitation_sau_cultures_permanentes_vigne',
    exploitation_sau_cultures_permanentes_fruits: 'exploitation_sau_cultures_permanentes_fruits',
    exploitation_sau_cultures_permanentes_autres: 'exploitation_sau_cultures_permanentes_autres',
    exploitation_sau_herbe: 'exploitation_sau_herbe',
    exploitation_sau_herbe_prairies_productives: 'exploitation_sau_herbe_prairies_productives',
    exploitation_sau_herbe_prairies_peu_productives: 'exploitation_sau_herbe_prairies_peu_productives',
    exploitation_sau_herbe_subventions: 'exploitation_sau_herbe_subventions',
    exploitation_sau_herbe_bois_patures: 'exploitation_sau_herbe_bois_patures',
    exploitation_sau_jardins: 'exploitation_sau_jardins',
    superficie_sau: 'superficie_sau',
    superficie_sau_terres_arables: 'superficie_sau_terres_arables',
    superficie_sau_terres_arables_cereales: 'superficie_sau_terres_arables_cereales',
    superficie_sau_terres_arables_oleagineux: 'superficie_sau_terres_arables_oleagineux',
    superficie_sau_terres_arables_fourrageres: 'superficie_sau_terres_arables_fourrageres',
    superficie_sau_terres_arables_tubercules: 'superficie_sau_terres_arables_tubercules',
    superficie_sau_terres_arables_legumes_melons_fraises: 'superficie_sau_terres_arables_legumes_melons_fraises',
    superficie_sau_terres_arables_fleurs: 'superficie_sau_terres_arables_fleurs',
    superficie_sau_terres_arables_autres: 'superficie_sau_terres_arables_autres',
    superficie_sau_cultures_permanentes: 'superficie_sau_cultures_permanentes',
    superficie_sau_cultures_permanentes_vigne: 'superficie_sau_cultures_permanentes_vigne',
    superficie_sau_cultures_permanentes_fruits: 'superficie_sau_cultures_permanentes_fruits',
    superficie_sau_cultures_permanentes_autres: 'superficie_sau_cultures_permanentes_autres',
    superficie_sau_herbe: 'superficie_sau_herbe',
    superficie_sau_herbe_prairies_productives: 'superficie_sau_herbe_prairies_productives',
    superficie_sau_herbe_prairies_peu_productives: 'superficie_sau_herbe_prairies_peu_productives',
    superficie_sau_herbe_subventions: 'superficie_sau_herbe_subventions',
    superficie_sau_herbe_bois_patures: 'superficie_sau_herbe_bois_patures',
    superficie_sau_jardins: 'superficie_sau_jardins'
  };

  export type Surfaces_agricolesScalarFieldEnum = (typeof Surfaces_agricolesScalarFieldEnum)[keyof typeof Surfaces_agricolesScalarFieldEnum]


  export const Surfaces_protegeesScalarFieldEnum: {
    index: 'index',
    code_geographique: 'code_geographique',
    PNC: 'PNC',
    RAMSAR: 'RAMSAR',
    PNR: 'PNR',
    PNP: 'PNP',
    FOR_PRO: 'FOR_PRO',
    ZZZ: 'ZZZ',
    ZNIEFF2: 'ZNIEFF2',
    ZNIEFF1: 'ZNIEFF1',
    RNR: 'RNR',
    TOU_PRO: 'TOU_PRO',
    NATURA: 'NATURA',
    ZPS: 'ZPS',
    SIC: 'SIC',
    CELRL: 'CELRL',
    BIO: 'BIO',
    APB: 'APB',
    RN: 'RN',
    RBFD: 'RBFD',
    RNCFS: 'RNCFS',
    libelle_geographique: 'libelle_geographique',
    epci: 'epci',
    libelle_epci: 'libelle_epci',
    departement: 'departement',
    region: 'region'
  };

  export type Surfaces_protegeesScalarFieldEnum = (typeof Surfaces_protegeesScalarFieldEnum)[keyof typeof Surfaces_protegeesScalarFieldEnum]


  export const Table_communeScalarFieldEnum: {
    index: 'index',
    code_geographique: 'code_geographique',
    libelle_geographique: 'libelle_geographique',
    epci: 'epci',
    libelle_epci: 'libelle_epci',
    departement: 'departement',
    libelle_departement: 'libelle_departement',
    region: 'region',
    ept: 'ept',
    libelle_petr: 'libelle_petr',
    code_pnr: 'code_pnr',
    libelle_pnr: 'libelle_pnr',
    atlas_biodiversite_nom: 'atlas_biodiversite_nom',
    atlas_biodiversite_annee_debut: 'atlas_biodiversite_annee_debut',
    atlas_biodiversite_avancement: 'atlas_biodiversite_avancement',
    type_touristique: 'type_touristique',
    otex_12_postes: 'otex_12_postes',
    part_irr_sau_2020: 'part_irr_sau_2020',
    agriculture_part_over_55: 'agriculture_part_over_55',
    couverture_lcz: 'couverture_lcz'
  };

  export type Table_communeScalarFieldEnum = (typeof Table_communeScalarFieldEnum)[keyof typeof Table_communeScalarFieldEnum]


  export const Table_territoiresScalarFieldEnum: {
    index: 'index',
    code_geographique: 'code_geographique',
    libelle_geographique: 'libelle_geographique',
    epci: 'epci',
    libelle_epci: 'libelle_epci',
    departement: 'departement',
    libelle_departement: 'libelle_departement',
    region: 'region',
    ept: 'ept',
    libelle_petr: 'libelle_petr',
    code_pnr: 'code_pnr',
    libelle_pnr: 'libelle_pnr'
  };

  export type Table_territoiresScalarFieldEnum = (typeof Table_territoiresScalarFieldEnum)[keyof typeof Table_territoiresScalarFieldEnum]


  export const Communes_dromScalarFieldEnum: {
    pk: 'pk',
    code_geographique: 'code_geographique',
    libelle_geographique: 'libelle_geographique',
    epci: 'epci',
    libelle_epci: 'libelle_epci',
    departement: 'departement',
    libelle_departement: 'libelle_departement',
    region: 'region',
    ept: 'ept',
    libelle_petr: 'libelle_petr',
    code_pnr: 'code_pnr',
    libelle_pnr: 'libelle_pnr',
    coordinates: 'coordinates',
    precarite_logement: 'precarite_logement',
    surface: 'surface'
  };

  export type Communes_dromScalarFieldEnum = (typeof Communes_dromScalarFieldEnum)[keyof typeof Communes_dromScalarFieldEnum]


  export const Erosion_cotiereScalarFieldEnum: {
    pk: 'pk',
    taux: 'taux',
    duree: 'duree',
    tdc_ancien: 'tdc_ancien',
    tdc_rec: 'tdc_rec'
  };

  export type Erosion_cotiereScalarFieldEnum = (typeof Erosion_cotiereScalarFieldEnum)[keyof typeof Erosion_cotiereScalarFieldEnum]


  export const Etat_cours_d_eauScalarFieldEnum: {
    pk: 'pk',
    name: 'name',
    longueur: 'longueur',
    etateco: 'etateco'
  };

  export type Etat_cours_d_eauScalarFieldEnum = (typeof Etat_cours_d_eauScalarFieldEnum)[keyof typeof Etat_cours_d_eauScalarFieldEnum]


  export const Spatial_ref_sysScalarFieldEnum: {
    srid: 'srid',
    auth_name: 'auth_name',
    auth_srid: 'auth_srid',
    srtext: 'srtext',
    proj4text: 'proj4text'
  };

  export type Spatial_ref_sysScalarFieldEnum = (typeof Spatial_ref_sysScalarFieldEnum)[keyof typeof Spatial_ref_sysScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type north_star_metricWhereInput = {
    AND?: north_star_metricWhereInput | north_star_metricWhereInput[]
    OR?: north_star_metricWhereInput[]
    NOT?: north_star_metricWhereInput | north_star_metricWhereInput[]
    value?: StringFilter<"north_star_metric"> | string
    date?: DateTimeFilter<"north_star_metric"> | Date | string
    pk?: IntFilter<"north_star_metric"> | number
  }

  export type north_star_metricOrderByWithRelationInput = {
    value?: SortOrder
    date?: SortOrder
    pk?: SortOrder
  }

  export type north_star_metricWhereUniqueInput = Prisma.AtLeast<{
    pk?: number
    AND?: north_star_metricWhereInput | north_star_metricWhereInput[]
    OR?: north_star_metricWhereInput[]
    NOT?: north_star_metricWhereInput | north_star_metricWhereInput[]
    value?: StringFilter<"north_star_metric"> | string
    date?: DateTimeFilter<"north_star_metric"> | Date | string
  }, "pk">

  export type north_star_metricOrderByWithAggregationInput = {
    value?: SortOrder
    date?: SortOrder
    pk?: SortOrder
    _count?: north_star_metricCountOrderByAggregateInput
    _avg?: north_star_metricAvgOrderByAggregateInput
    _max?: north_star_metricMaxOrderByAggregateInput
    _min?: north_star_metricMinOrderByAggregateInput
    _sum?: north_star_metricSumOrderByAggregateInput
  }

  export type north_star_metricScalarWhereWithAggregatesInput = {
    AND?: north_star_metricScalarWhereWithAggregatesInput | north_star_metricScalarWhereWithAggregatesInput[]
    OR?: north_star_metricScalarWhereWithAggregatesInput[]
    NOT?: north_star_metricScalarWhereWithAggregatesInput | north_star_metricScalarWhereWithAggregatesInput[]
    value?: StringWithAggregatesFilter<"north_star_metric"> | string
    date?: DateTimeWithAggregatesFilter<"north_star_metric"> | Date | string
    pk?: IntWithAggregatesFilter<"north_star_metric"> | number
  }

  export type sandbox_usersWhereInput = {
    AND?: sandbox_usersWhereInput | sandbox_usersWhereInput[]
    OR?: sandbox_usersWhereInput[]
    NOT?: sandbox_usersWhereInput | sandbox_usersWhereInput[]
    username?: StringFilter<"sandbox_users"> | string
    pk?: IntFilter<"sandbox_users"> | number
    password?: StringFilter<"sandbox_users"> | string
    created_at?: DateTimeFilter<"sandbox_users"> | Date | string
  }

  export type sandbox_usersOrderByWithRelationInput = {
    username?: SortOrder
    pk?: SortOrder
    password?: SortOrder
    created_at?: SortOrder
  }

  export type sandbox_usersWhereUniqueInput = Prisma.AtLeast<{
    username?: string
    pk?: number
    AND?: sandbox_usersWhereInput | sandbox_usersWhereInput[]
    OR?: sandbox_usersWhereInput[]
    NOT?: sandbox_usersWhereInput | sandbox_usersWhereInput[]
    password?: StringFilter<"sandbox_users"> | string
    created_at?: DateTimeFilter<"sandbox_users"> | Date | string
  }, "pk" | "username">

  export type sandbox_usersOrderByWithAggregationInput = {
    username?: SortOrder
    pk?: SortOrder
    password?: SortOrder
    created_at?: SortOrder
    _count?: sandbox_usersCountOrderByAggregateInput
    _avg?: sandbox_usersAvgOrderByAggregateInput
    _max?: sandbox_usersMaxOrderByAggregateInput
    _min?: sandbox_usersMinOrderByAggregateInput
    _sum?: sandbox_usersSumOrderByAggregateInput
  }

  export type sandbox_usersScalarWhereWithAggregatesInput = {
    AND?: sandbox_usersScalarWhereWithAggregatesInput | sandbox_usersScalarWhereWithAggregatesInput[]
    OR?: sandbox_usersScalarWhereWithAggregatesInput[]
    NOT?: sandbox_usersScalarWhereWithAggregatesInput | sandbox_usersScalarWhereWithAggregatesInput[]
    username?: StringWithAggregatesFilter<"sandbox_users"> | string
    pk?: IntWithAggregatesFilter<"sandbox_users"> | number
    password?: StringWithAggregatesFilter<"sandbox_users"> | string
    created_at?: DateTimeWithAggregatesFilter<"sandbox_users"> | Date | string
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    pk?: IntFilter<"users"> | number
    email?: StringFilter<"users"> | string
    username?: StringFilter<"users"> | string
    password?: StringFilter<"users"> | string
    created_at?: DateTimeFilter<"users"> | Date | string
    last_connection?: DateTimeNullableFilter<"users"> | Date | string | null
    role?: StringFilter<"users"> | string
  }

  export type usersOrderByWithRelationInput = {
    pk?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    created_at?: SortOrder
    last_connection?: SortOrderInput | SortOrder
    role?: SortOrder
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    pk?: number
    email?: string
    username?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    password?: StringFilter<"users"> | string
    created_at?: DateTimeFilter<"users"> | Date | string
    last_connection?: DateTimeNullableFilter<"users"> | Date | string | null
    role?: StringFilter<"users"> | string
  }, "pk" | "email" | "username">

  export type usersOrderByWithAggregationInput = {
    pk?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    created_at?: SortOrder
    last_connection?: SortOrderInput | SortOrder
    role?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    pk?: IntWithAggregatesFilter<"users"> | number
    email?: StringWithAggregatesFilter<"users"> | string
    username?: StringWithAggregatesFilter<"users"> | string
    password?: StringWithAggregatesFilter<"users"> | string
    created_at?: DateTimeWithAggregatesFilter<"users"> | Date | string
    last_connection?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    role?: StringWithAggregatesFilter<"users"> | string
  }

  export type all_autocapture_rawWhereInput = {
    AND?: all_autocapture_rawWhereInput | all_autocapture_rawWhereInput[]
    OR?: all_autocapture_rawWhereInput[]
    NOT?: all_autocapture_rawWhereInput | all_autocapture_rawWhereInput[]
    id?: BigIntFilter<"all_autocapture_raw"> | bigint | number
    event_timestamp?: DateTimeFilter<"all_autocapture_raw"> | Date | string
    properties?: JsonNullableFilter<"all_autocapture_raw">
    distinct_id?: StringNullableFilter<"all_autocapture_raw"> | string | null
    session_id?: StringNullableFilter<"all_autocapture_raw"> | string | null
    current_url?: StringNullableFilter<"all_autocapture_raw"> | string | null
    person_id?: StringNullableFilter<"all_autocapture_raw"> | string | null
    ingested_at?: DateTimeFilter<"all_autocapture_raw"> | Date | string
  }

  export type all_autocapture_rawOrderByWithRelationInput = {
    id?: SortOrder
    event_timestamp?: SortOrder
    properties?: SortOrderInput | SortOrder
    distinct_id?: SortOrderInput | SortOrder
    session_id?: SortOrderInput | SortOrder
    current_url?: SortOrderInput | SortOrder
    person_id?: SortOrderInput | SortOrder
    ingested_at?: SortOrder
  }

  export type all_autocapture_rawWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    event_timestamp_distinct_id_session_id_current_url_person_id?: all_autocapture_rawEvent_timestampDistinct_idSession_idCurrent_urlPerson_idCompoundUniqueInput
    AND?: all_autocapture_rawWhereInput | all_autocapture_rawWhereInput[]
    OR?: all_autocapture_rawWhereInput[]
    NOT?: all_autocapture_rawWhereInput | all_autocapture_rawWhereInput[]
    event_timestamp?: DateTimeFilter<"all_autocapture_raw"> | Date | string
    properties?: JsonNullableFilter<"all_autocapture_raw">
    distinct_id?: StringNullableFilter<"all_autocapture_raw"> | string | null
    session_id?: StringNullableFilter<"all_autocapture_raw"> | string | null
    current_url?: StringNullableFilter<"all_autocapture_raw"> | string | null
    person_id?: StringNullableFilter<"all_autocapture_raw"> | string | null
    ingested_at?: DateTimeFilter<"all_autocapture_raw"> | Date | string
  }, "id" | "event_timestamp_distinct_id_session_id_current_url_person_id">

  export type all_autocapture_rawOrderByWithAggregationInput = {
    id?: SortOrder
    event_timestamp?: SortOrder
    properties?: SortOrderInput | SortOrder
    distinct_id?: SortOrderInput | SortOrder
    session_id?: SortOrderInput | SortOrder
    current_url?: SortOrderInput | SortOrder
    person_id?: SortOrderInput | SortOrder
    ingested_at?: SortOrder
    _count?: all_autocapture_rawCountOrderByAggregateInput
    _avg?: all_autocapture_rawAvgOrderByAggregateInput
    _max?: all_autocapture_rawMaxOrderByAggregateInput
    _min?: all_autocapture_rawMinOrderByAggregateInput
    _sum?: all_autocapture_rawSumOrderByAggregateInput
  }

  export type all_autocapture_rawScalarWhereWithAggregatesInput = {
    AND?: all_autocapture_rawScalarWhereWithAggregatesInput | all_autocapture_rawScalarWhereWithAggregatesInput[]
    OR?: all_autocapture_rawScalarWhereWithAggregatesInput[]
    NOT?: all_autocapture_rawScalarWhereWithAggregatesInput | all_autocapture_rawScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"all_autocapture_raw"> | bigint | number
    event_timestamp?: DateTimeWithAggregatesFilter<"all_autocapture_raw"> | Date | string
    properties?: JsonNullableWithAggregatesFilter<"all_autocapture_raw">
    distinct_id?: StringNullableWithAggregatesFilter<"all_autocapture_raw"> | string | null
    session_id?: StringNullableWithAggregatesFilter<"all_autocapture_raw"> | string | null
    current_url?: StringNullableWithAggregatesFilter<"all_autocapture_raw"> | string | null
    person_id?: StringNullableWithAggregatesFilter<"all_autocapture_raw"> | string | null
    ingested_at?: DateTimeWithAggregatesFilter<"all_autocapture_raw"> | Date | string
  }

  export type all_pageview_rawWhereInput = {
    AND?: all_pageview_rawWhereInput | all_pageview_rawWhereInput[]
    OR?: all_pageview_rawWhereInput[]
    NOT?: all_pageview_rawWhereInput | all_pageview_rawWhereInput[]
    id?: BigIntFilter<"all_pageview_raw"> | bigint | number
    event_timestamp?: DateTimeFilter<"all_pageview_raw"> | Date | string
    properties?: JsonNullableFilter<"all_pageview_raw">
    distinct_id?: StringNullableFilter<"all_pageview_raw"> | string | null
    session_id?: StringNullableFilter<"all_pageview_raw"> | string | null
    current_url?: StringNullableFilter<"all_pageview_raw"> | string | null
    person_id?: StringNullableFilter<"all_pageview_raw"> | string | null
    ingested_at?: DateTimeFilter<"all_pageview_raw"> | Date | string
  }

  export type all_pageview_rawOrderByWithRelationInput = {
    id?: SortOrder
    event_timestamp?: SortOrder
    properties?: SortOrderInput | SortOrder
    distinct_id?: SortOrderInput | SortOrder
    session_id?: SortOrderInput | SortOrder
    current_url?: SortOrderInput | SortOrder
    person_id?: SortOrderInput | SortOrder
    ingested_at?: SortOrder
  }

  export type all_pageview_rawWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    event_timestamp_distinct_id_session_id_current_url_person_id?: all_pageview_rawEvent_timestampDistinct_idSession_idCurrent_urlPerson_idCompoundUniqueInput
    AND?: all_pageview_rawWhereInput | all_pageview_rawWhereInput[]
    OR?: all_pageview_rawWhereInput[]
    NOT?: all_pageview_rawWhereInput | all_pageview_rawWhereInput[]
    event_timestamp?: DateTimeFilter<"all_pageview_raw"> | Date | string
    properties?: JsonNullableFilter<"all_pageview_raw">
    distinct_id?: StringNullableFilter<"all_pageview_raw"> | string | null
    session_id?: StringNullableFilter<"all_pageview_raw"> | string | null
    current_url?: StringNullableFilter<"all_pageview_raw"> | string | null
    person_id?: StringNullableFilter<"all_pageview_raw"> | string | null
    ingested_at?: DateTimeFilter<"all_pageview_raw"> | Date | string
  }, "id" | "event_timestamp_distinct_id_session_id_current_url_person_id">

  export type all_pageview_rawOrderByWithAggregationInput = {
    id?: SortOrder
    event_timestamp?: SortOrder
    properties?: SortOrderInput | SortOrder
    distinct_id?: SortOrderInput | SortOrder
    session_id?: SortOrderInput | SortOrder
    current_url?: SortOrderInput | SortOrder
    person_id?: SortOrderInput | SortOrder
    ingested_at?: SortOrder
    _count?: all_pageview_rawCountOrderByAggregateInput
    _avg?: all_pageview_rawAvgOrderByAggregateInput
    _max?: all_pageview_rawMaxOrderByAggregateInput
    _min?: all_pageview_rawMinOrderByAggregateInput
    _sum?: all_pageview_rawSumOrderByAggregateInput
  }

  export type all_pageview_rawScalarWhereWithAggregatesInput = {
    AND?: all_pageview_rawScalarWhereWithAggregatesInput | all_pageview_rawScalarWhereWithAggregatesInput[]
    OR?: all_pageview_rawScalarWhereWithAggregatesInput[]
    NOT?: all_pageview_rawScalarWhereWithAggregatesInput | all_pageview_rawScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"all_pageview_raw"> | bigint | number
    event_timestamp?: DateTimeWithAggregatesFilter<"all_pageview_raw"> | Date | string
    properties?: JsonNullableWithAggregatesFilter<"all_pageview_raw">
    distinct_id?: StringNullableWithAggregatesFilter<"all_pageview_raw"> | string | null
    session_id?: StringNullableWithAggregatesFilter<"all_pageview_raw"> | string | null
    current_url?: StringNullableWithAggregatesFilter<"all_pageview_raw"> | string | null
    person_id?: StringNullableWithAggregatesFilter<"all_pageview_raw"> | string | null
    ingested_at?: DateTimeWithAggregatesFilter<"all_pageview_raw"> | Date | string
  }

  export type baserow_evenementsWhereInput = {
    AND?: baserow_evenementsWhereInput | baserow_evenementsWhereInput[]
    OR?: baserow_evenementsWhereInput[]
    NOT?: baserow_evenementsWhereInput | baserow_evenementsWhereInput[]
    id?: BigIntFilter<"baserow_evenements"> | bigint | number
    ordre?: StringNullableFilter<"baserow_evenements"> | string | null
    nom?: StringNullableFilter<"baserow_evenements"> | string | null
    date?: StringNullableFilter<"baserow_evenements"> | string | null
    type?: JsonNullableFilter<"baserow_evenements">
    qui_anime_evenement?: StringNullableListFilter<"baserow_evenements">
    compte_rendu?: StringNullableFilter<"baserow_evenements"> | string | null
    nom_participants?: StringNullableListFilter<"baserow_evenements">
    nom_territoires?: StringNullableListFilter<"baserow_evenements">
    propos_nom_evenement?: StringNullableListFilter<"baserow_evenements">
    campagne_test_utilisateur?: JsonNullableFilter<"baserow_evenements">
    champs_rapporte?: StringNullableListFilter<"baserow_evenements">
    fichier?: StringNullableListFilter<"baserow_evenements">
    ingested_at?: DateTimeFilter<"baserow_evenements"> | Date | string
  }

  export type baserow_evenementsOrderByWithRelationInput = {
    id?: SortOrder
    ordre?: SortOrderInput | SortOrder
    nom?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    qui_anime_evenement?: SortOrder
    compte_rendu?: SortOrderInput | SortOrder
    nom_participants?: SortOrder
    nom_territoires?: SortOrder
    propos_nom_evenement?: SortOrder
    campagne_test_utilisateur?: SortOrderInput | SortOrder
    champs_rapporte?: SortOrder
    fichier?: SortOrder
    ingested_at?: SortOrder
  }

  export type baserow_evenementsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    ordre?: string
    AND?: baserow_evenementsWhereInput | baserow_evenementsWhereInput[]
    OR?: baserow_evenementsWhereInput[]
    NOT?: baserow_evenementsWhereInput | baserow_evenementsWhereInput[]
    nom?: StringNullableFilter<"baserow_evenements"> | string | null
    date?: StringNullableFilter<"baserow_evenements"> | string | null
    type?: JsonNullableFilter<"baserow_evenements">
    qui_anime_evenement?: StringNullableListFilter<"baserow_evenements">
    compte_rendu?: StringNullableFilter<"baserow_evenements"> | string | null
    nom_participants?: StringNullableListFilter<"baserow_evenements">
    nom_territoires?: StringNullableListFilter<"baserow_evenements">
    propos_nom_evenement?: StringNullableListFilter<"baserow_evenements">
    campagne_test_utilisateur?: JsonNullableFilter<"baserow_evenements">
    champs_rapporte?: StringNullableListFilter<"baserow_evenements">
    fichier?: StringNullableListFilter<"baserow_evenements">
    ingested_at?: DateTimeFilter<"baserow_evenements"> | Date | string
  }, "id" | "ordre">

  export type baserow_evenementsOrderByWithAggregationInput = {
    id?: SortOrder
    ordre?: SortOrderInput | SortOrder
    nom?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    qui_anime_evenement?: SortOrder
    compte_rendu?: SortOrderInput | SortOrder
    nom_participants?: SortOrder
    nom_territoires?: SortOrder
    propos_nom_evenement?: SortOrder
    campagne_test_utilisateur?: SortOrderInput | SortOrder
    champs_rapporte?: SortOrder
    fichier?: SortOrder
    ingested_at?: SortOrder
    _count?: baserow_evenementsCountOrderByAggregateInput
    _avg?: baserow_evenementsAvgOrderByAggregateInput
    _max?: baserow_evenementsMaxOrderByAggregateInput
    _min?: baserow_evenementsMinOrderByAggregateInput
    _sum?: baserow_evenementsSumOrderByAggregateInput
  }

  export type baserow_evenementsScalarWhereWithAggregatesInput = {
    AND?: baserow_evenementsScalarWhereWithAggregatesInput | baserow_evenementsScalarWhereWithAggregatesInput[]
    OR?: baserow_evenementsScalarWhereWithAggregatesInput[]
    NOT?: baserow_evenementsScalarWhereWithAggregatesInput | baserow_evenementsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"baserow_evenements"> | bigint | number
    ordre?: StringNullableWithAggregatesFilter<"baserow_evenements"> | string | null
    nom?: StringNullableWithAggregatesFilter<"baserow_evenements"> | string | null
    date?: StringNullableWithAggregatesFilter<"baserow_evenements"> | string | null
    type?: JsonNullableWithAggregatesFilter<"baserow_evenements">
    qui_anime_evenement?: StringNullableListFilter<"baserow_evenements">
    compte_rendu?: StringNullableWithAggregatesFilter<"baserow_evenements"> | string | null
    nom_participants?: StringNullableListFilter<"baserow_evenements">
    nom_territoires?: StringNullableListFilter<"baserow_evenements">
    propos_nom_evenement?: StringNullableListFilter<"baserow_evenements">
    campagne_test_utilisateur?: JsonNullableWithAggregatesFilter<"baserow_evenements">
    champs_rapporte?: StringNullableListFilter<"baserow_evenements">
    fichier?: StringNullableListFilter<"baserow_evenements">
    ingested_at?: DateTimeWithAggregatesFilter<"baserow_evenements"> | Date | string
  }

  export type baserow_territoiresWhereInput = {
    AND?: baserow_territoiresWhereInput | baserow_territoiresWhereInput[]
    OR?: baserow_territoiresWhereInput[]
    NOT?: baserow_territoiresWhereInput | baserow_territoiresWhereInput[]
    id?: BigIntFilter<"baserow_territoires"> | bigint | number
    ordre?: StringNullableFilter<"baserow_territoires"> | string | null
    nom_territoire?: StringNullableFilter<"baserow_territoires"> | string | null
    notes_ouvertes?: StringNullableFilter<"baserow_territoires"> | string | null
    typologie_territoire?: StringNullableListFilter<"baserow_territoires">
    thematique_prioritaire?: StringNullableListFilter<"baserow_territoires">
    be?: BoolNullableFilter<"baserow_territoires"> | boolean | null
    soumis_a_pcaet?: BoolNullableFilter<"baserow_territoires"> | boolean | null
    demarches_et_programmes?: StringNullableListFilter<"baserow_territoires">
    documents_de_planification?: StringNullableListFilter<"baserow_territoires">
    avancee_sur_le_ddv?: StringNullableListFilter<"baserow_territoires">
    avancee_sur_la_strategie?: StringNullableListFilter<"baserow_territoires">
    suivi_evaluation?: BoolNullableFilter<"baserow_territoires"> | boolean | null
    date_validation?: StringNullableFilter<"baserow_territoires"> | string | null
    date_revision_estimee?: StringNullableFilter<"baserow_territoires"> | string | null
    propos?: StringNullableListFilter<"baserow_territoires">
    attente_session_accueil?: StringNullableListFilter<"baserow_territoires">
    role_be?: StringNullableListFilter<"baserow_territoires">
    cdm?: StringNullableListFilter<"baserow_territoires">
    siren?: StringNullableFilter<"baserow_territoires"> | string | null
    ingested_at?: DateTimeFilter<"baserow_territoires"> | Date | string
  }

  export type baserow_territoiresOrderByWithRelationInput = {
    id?: SortOrder
    ordre?: SortOrderInput | SortOrder
    nom_territoire?: SortOrderInput | SortOrder
    notes_ouvertes?: SortOrderInput | SortOrder
    typologie_territoire?: SortOrder
    thematique_prioritaire?: SortOrder
    be?: SortOrderInput | SortOrder
    soumis_a_pcaet?: SortOrderInput | SortOrder
    demarches_et_programmes?: SortOrder
    documents_de_planification?: SortOrder
    avancee_sur_le_ddv?: SortOrder
    avancee_sur_la_strategie?: SortOrder
    suivi_evaluation?: SortOrderInput | SortOrder
    date_validation?: SortOrderInput | SortOrder
    date_revision_estimee?: SortOrderInput | SortOrder
    propos?: SortOrder
    attente_session_accueil?: SortOrder
    role_be?: SortOrder
    cdm?: SortOrder
    siren?: SortOrderInput | SortOrder
    ingested_at?: SortOrder
  }

  export type baserow_territoiresWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    ordre?: string
    AND?: baserow_territoiresWhereInput | baserow_territoiresWhereInput[]
    OR?: baserow_territoiresWhereInput[]
    NOT?: baserow_territoiresWhereInput | baserow_territoiresWhereInput[]
    nom_territoire?: StringNullableFilter<"baserow_territoires"> | string | null
    notes_ouvertes?: StringNullableFilter<"baserow_territoires"> | string | null
    typologie_territoire?: StringNullableListFilter<"baserow_territoires">
    thematique_prioritaire?: StringNullableListFilter<"baserow_territoires">
    be?: BoolNullableFilter<"baserow_territoires"> | boolean | null
    soumis_a_pcaet?: BoolNullableFilter<"baserow_territoires"> | boolean | null
    demarches_et_programmes?: StringNullableListFilter<"baserow_territoires">
    documents_de_planification?: StringNullableListFilter<"baserow_territoires">
    avancee_sur_le_ddv?: StringNullableListFilter<"baserow_territoires">
    avancee_sur_la_strategie?: StringNullableListFilter<"baserow_territoires">
    suivi_evaluation?: BoolNullableFilter<"baserow_territoires"> | boolean | null
    date_validation?: StringNullableFilter<"baserow_territoires"> | string | null
    date_revision_estimee?: StringNullableFilter<"baserow_territoires"> | string | null
    propos?: StringNullableListFilter<"baserow_territoires">
    attente_session_accueil?: StringNullableListFilter<"baserow_territoires">
    role_be?: StringNullableListFilter<"baserow_territoires">
    cdm?: StringNullableListFilter<"baserow_territoires">
    siren?: StringNullableFilter<"baserow_territoires"> | string | null
    ingested_at?: DateTimeFilter<"baserow_territoires"> | Date | string
  }, "id" | "ordre">

  export type baserow_territoiresOrderByWithAggregationInput = {
    id?: SortOrder
    ordre?: SortOrderInput | SortOrder
    nom_territoire?: SortOrderInput | SortOrder
    notes_ouvertes?: SortOrderInput | SortOrder
    typologie_territoire?: SortOrder
    thematique_prioritaire?: SortOrder
    be?: SortOrderInput | SortOrder
    soumis_a_pcaet?: SortOrderInput | SortOrder
    demarches_et_programmes?: SortOrder
    documents_de_planification?: SortOrder
    avancee_sur_le_ddv?: SortOrder
    avancee_sur_la_strategie?: SortOrder
    suivi_evaluation?: SortOrderInput | SortOrder
    date_validation?: SortOrderInput | SortOrder
    date_revision_estimee?: SortOrderInput | SortOrder
    propos?: SortOrder
    attente_session_accueil?: SortOrder
    role_be?: SortOrder
    cdm?: SortOrder
    siren?: SortOrderInput | SortOrder
    ingested_at?: SortOrder
    _count?: baserow_territoiresCountOrderByAggregateInput
    _avg?: baserow_territoiresAvgOrderByAggregateInput
    _max?: baserow_territoiresMaxOrderByAggregateInput
    _min?: baserow_territoiresMinOrderByAggregateInput
    _sum?: baserow_territoiresSumOrderByAggregateInput
  }

  export type baserow_territoiresScalarWhereWithAggregatesInput = {
    AND?: baserow_territoiresScalarWhereWithAggregatesInput | baserow_territoiresScalarWhereWithAggregatesInput[]
    OR?: baserow_territoiresScalarWhereWithAggregatesInput[]
    NOT?: baserow_territoiresScalarWhereWithAggregatesInput | baserow_territoiresScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"baserow_territoires"> | bigint | number
    ordre?: StringNullableWithAggregatesFilter<"baserow_territoires"> | string | null
    nom_territoire?: StringNullableWithAggregatesFilter<"baserow_territoires"> | string | null
    notes_ouvertes?: StringNullableWithAggregatesFilter<"baserow_territoires"> | string | null
    typologie_territoire?: StringNullableListFilter<"baserow_territoires">
    thematique_prioritaire?: StringNullableListFilter<"baserow_territoires">
    be?: BoolNullableWithAggregatesFilter<"baserow_territoires"> | boolean | null
    soumis_a_pcaet?: BoolNullableWithAggregatesFilter<"baserow_territoires"> | boolean | null
    demarches_et_programmes?: StringNullableListFilter<"baserow_territoires">
    documents_de_planification?: StringNullableListFilter<"baserow_territoires">
    avancee_sur_le_ddv?: StringNullableListFilter<"baserow_territoires">
    avancee_sur_la_strategie?: StringNullableListFilter<"baserow_territoires">
    suivi_evaluation?: BoolNullableWithAggregatesFilter<"baserow_territoires"> | boolean | null
    date_validation?: StringNullableWithAggregatesFilter<"baserow_territoires"> | string | null
    date_revision_estimee?: StringNullableWithAggregatesFilter<"baserow_territoires"> | string | null
    propos?: StringNullableListFilter<"baserow_territoires">
    attente_session_accueil?: StringNullableListFilter<"baserow_territoires">
    role_be?: StringNullableListFilter<"baserow_territoires">
    cdm?: StringNullableListFilter<"baserow_territoires">
    siren?: StringNullableWithAggregatesFilter<"baserow_territoires"> | string | null
    ingested_at?: DateTimeWithAggregatesFilter<"baserow_territoires"> | Date | string
  }

  export type boutons_export_rawWhereInput = {
    AND?: boutons_export_rawWhereInput | boutons_export_rawWhereInput[]
    OR?: boutons_export_rawWhereInput[]
    NOT?: boutons_export_rawWhereInput | boutons_export_rawWhereInput[]
    id?: BigIntFilter<"boutons_export_raw"> | bigint | number
    event?: StringFilter<"boutons_export_raw"> | string
    event_timestamp?: DateTimeFilter<"boutons_export_raw"> | Date | string
    session_id?: StringNullableFilter<"boutons_export_raw"> | string | null
    person_id?: StringNullableFilter<"boutons_export_raw"> | string | null
    code_geographique?: StringNullableFilter<"boutons_export_raw"> | string | null
    libelle_geographique?: StringNullableFilter<"boutons_export_raw"> | string | null
    thematique?: StringNullableFilter<"boutons_export_raw"> | string | null
    ingested_at?: DateTimeFilter<"boutons_export_raw"> | Date | string
  }

  export type boutons_export_rawOrderByWithRelationInput = {
    id?: SortOrder
    event?: SortOrder
    event_timestamp?: SortOrder
    session_id?: SortOrderInput | SortOrder
    person_id?: SortOrderInput | SortOrder
    code_geographique?: SortOrderInput | SortOrder
    libelle_geographique?: SortOrderInput | SortOrder
    thematique?: SortOrderInput | SortOrder
    ingested_at?: SortOrder
  }

  export type boutons_export_rawWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    event_event_timestamp_session_id_person_id_code_geographique_libelle_geographique_thematique?: boutons_export_rawEventEvent_timestampSession_idPerson_idCode_geographiqueLibelle_geographiqueThematiqueCompoundUniqueInput
    AND?: boutons_export_rawWhereInput | boutons_export_rawWhereInput[]
    OR?: boutons_export_rawWhereInput[]
    NOT?: boutons_export_rawWhereInput | boutons_export_rawWhereInput[]
    event?: StringFilter<"boutons_export_raw"> | string
    event_timestamp?: DateTimeFilter<"boutons_export_raw"> | Date | string
    session_id?: StringNullableFilter<"boutons_export_raw"> | string | null
    person_id?: StringNullableFilter<"boutons_export_raw"> | string | null
    code_geographique?: StringNullableFilter<"boutons_export_raw"> | string | null
    libelle_geographique?: StringNullableFilter<"boutons_export_raw"> | string | null
    thematique?: StringNullableFilter<"boutons_export_raw"> | string | null
    ingested_at?: DateTimeFilter<"boutons_export_raw"> | Date | string
  }, "id" | "event_event_timestamp_session_id_person_id_code_geographique_libelle_geographique_thematique">

  export type boutons_export_rawOrderByWithAggregationInput = {
    id?: SortOrder
    event?: SortOrder
    event_timestamp?: SortOrder
    session_id?: SortOrderInput | SortOrder
    person_id?: SortOrderInput | SortOrder
    code_geographique?: SortOrderInput | SortOrder
    libelle_geographique?: SortOrderInput | SortOrder
    thematique?: SortOrderInput | SortOrder
    ingested_at?: SortOrder
    _count?: boutons_export_rawCountOrderByAggregateInput
    _avg?: boutons_export_rawAvgOrderByAggregateInput
    _max?: boutons_export_rawMaxOrderByAggregateInput
    _min?: boutons_export_rawMinOrderByAggregateInput
    _sum?: boutons_export_rawSumOrderByAggregateInput
  }

  export type boutons_export_rawScalarWhereWithAggregatesInput = {
    AND?: boutons_export_rawScalarWhereWithAggregatesInput | boutons_export_rawScalarWhereWithAggregatesInput[]
    OR?: boutons_export_rawScalarWhereWithAggregatesInput[]
    NOT?: boutons_export_rawScalarWhereWithAggregatesInput | boutons_export_rawScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"boutons_export_raw"> | bigint | number
    event?: StringWithAggregatesFilter<"boutons_export_raw"> | string
    event_timestamp?: DateTimeWithAggregatesFilter<"boutons_export_raw"> | Date | string
    session_id?: StringNullableWithAggregatesFilter<"boutons_export_raw"> | string | null
    person_id?: StringNullableWithAggregatesFilter<"boutons_export_raw"> | string | null
    code_geographique?: StringNullableWithAggregatesFilter<"boutons_export_raw"> | string | null
    libelle_geographique?: StringNullableWithAggregatesFilter<"boutons_export_raw"> | string | null
    thematique?: StringNullableWithAggregatesFilter<"boutons_export_raw"> | string | null
    ingested_at?: DateTimeWithAggregatesFilter<"boutons_export_raw"> | Date | string
  }

  export type boutons_homepageWhereInput = {
    AND?: boutons_homepageWhereInput | boutons_homepageWhereInput[]
    OR?: boutons_homepageWhereInput[]
    NOT?: boutons_homepageWhereInput | boutons_homepageWhereInput[]
    id?: BigIntFilter<"boutons_homepage"> | bigint | number
    event?: StringNullableFilter<"boutons_homepage"> | string | null
    event_timestamp?: DateTimeFilter<"boutons_homepage"> | Date | string
    properties?: JsonNullableFilter<"boutons_homepage">
    distinct_id?: StringNullableFilter<"boutons_homepage"> | string | null
    session_id?: StringNullableFilter<"boutons_homepage"> | string | null
    person_id?: StringNullableFilter<"boutons_homepage"> | string | null
    ingested_at?: DateTimeFilter<"boutons_homepage"> | Date | string
  }

  export type boutons_homepageOrderByWithRelationInput = {
    id?: SortOrder
    event?: SortOrderInput | SortOrder
    event_timestamp?: SortOrder
    properties?: SortOrderInput | SortOrder
    distinct_id?: SortOrderInput | SortOrder
    session_id?: SortOrderInput | SortOrder
    person_id?: SortOrderInput | SortOrder
    ingested_at?: SortOrder
  }

  export type boutons_homepageWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    event_timestamp_distinct_id_session_id_person_id?: boutons_homepageEvent_timestampDistinct_idSession_idPerson_idCompoundUniqueInput
    AND?: boutons_homepageWhereInput | boutons_homepageWhereInput[]
    OR?: boutons_homepageWhereInput[]
    NOT?: boutons_homepageWhereInput | boutons_homepageWhereInput[]
    event?: StringNullableFilter<"boutons_homepage"> | string | null
    event_timestamp?: DateTimeFilter<"boutons_homepage"> | Date | string
    properties?: JsonNullableFilter<"boutons_homepage">
    distinct_id?: StringNullableFilter<"boutons_homepage"> | string | null
    session_id?: StringNullableFilter<"boutons_homepage"> | string | null
    person_id?: StringNullableFilter<"boutons_homepage"> | string | null
    ingested_at?: DateTimeFilter<"boutons_homepage"> | Date | string
  }, "id" | "event_timestamp_distinct_id_session_id_person_id">

  export type boutons_homepageOrderByWithAggregationInput = {
    id?: SortOrder
    event?: SortOrderInput | SortOrder
    event_timestamp?: SortOrder
    properties?: SortOrderInput | SortOrder
    distinct_id?: SortOrderInput | SortOrder
    session_id?: SortOrderInput | SortOrder
    person_id?: SortOrderInput | SortOrder
    ingested_at?: SortOrder
    _count?: boutons_homepageCountOrderByAggregateInput
    _avg?: boutons_homepageAvgOrderByAggregateInput
    _max?: boutons_homepageMaxOrderByAggregateInput
    _min?: boutons_homepageMinOrderByAggregateInput
    _sum?: boutons_homepageSumOrderByAggregateInput
  }

  export type boutons_homepageScalarWhereWithAggregatesInput = {
    AND?: boutons_homepageScalarWhereWithAggregatesInput | boutons_homepageScalarWhereWithAggregatesInput[]
    OR?: boutons_homepageScalarWhereWithAggregatesInput[]
    NOT?: boutons_homepageScalarWhereWithAggregatesInput | boutons_homepageScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"boutons_homepage"> | bigint | number
    event?: StringNullableWithAggregatesFilter<"boutons_homepage"> | string | null
    event_timestamp?: DateTimeWithAggregatesFilter<"boutons_homepage"> | Date | string
    properties?: JsonNullableWithAggregatesFilter<"boutons_homepage">
    distinct_id?: StringNullableWithAggregatesFilter<"boutons_homepage"> | string | null
    session_id?: StringNullableWithAggregatesFilter<"boutons_homepage"> | string | null
    person_id?: StringNullableWithAggregatesFilter<"boutons_homepage"> | string | null
    ingested_at?: DateTimeWithAggregatesFilter<"boutons_homepage"> | Date | string
  }

  export type couverture_populationWhereInput = {
    AND?: couverture_populationWhereInput | couverture_populationWhereInput[]
    OR?: couverture_populationWhereInput[]
    NOT?: couverture_populationWhereInput | couverture_populationWhereInput[]
    id?: BigIntFilter<"couverture_population"> | bigint | number
    date?: DateTimeFilter<"couverture_population"> | Date | string
    population?: IntFilter<"couverture_population"> | number
  }

  export type couverture_populationOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    population?: SortOrder
  }

  export type couverture_populationWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: couverture_populationWhereInput | couverture_populationWhereInput[]
    OR?: couverture_populationWhereInput[]
    NOT?: couverture_populationWhereInput | couverture_populationWhereInput[]
    date?: DateTimeFilter<"couverture_population"> | Date | string
    population?: IntFilter<"couverture_population"> | number
  }, "id">

  export type couverture_populationOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    population?: SortOrder
    _count?: couverture_populationCountOrderByAggregateInput
    _avg?: couverture_populationAvgOrderByAggregateInput
    _max?: couverture_populationMaxOrderByAggregateInput
    _min?: couverture_populationMinOrderByAggregateInput
    _sum?: couverture_populationSumOrderByAggregateInput
  }

  export type couverture_populationScalarWhereWithAggregatesInput = {
    AND?: couverture_populationScalarWhereWithAggregatesInput | couverture_populationScalarWhereWithAggregatesInput[]
    OR?: couverture_populationScalarWhereWithAggregatesInput[]
    NOT?: couverture_populationScalarWhereWithAggregatesInput | couverture_populationScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"couverture_population"> | bigint | number
    date?: DateTimeWithAggregatesFilter<"couverture_population"> | Date | string
    population?: IntWithAggregatesFilter<"couverture_population"> | number
  }

  export type ressources_consulteesWhereInput = {
    AND?: ressources_consulteesWhereInput | ressources_consulteesWhereInput[]
    OR?: ressources_consulteesWhereInput[]
    NOT?: ressources_consulteesWhereInput | ressources_consulteesWhereInput[]
    id?: BigIntFilter<"ressources_consultees"> | bigint | number
    event_timestamp?: DateTimeFilter<"ressources_consultees"> | Date | string
    distinct_id?: StringNullableFilter<"ressources_consultees"> | string | null
    session_id?: StringNullableFilter<"ressources_consultees"> | string | null
    person_id?: StringNullableFilter<"ressources_consultees"> | string | null
    ressource?: StringNullableFilter<"ressources_consultees"> | string | null
    ingested_at?: DateTimeFilter<"ressources_consultees"> | Date | string
  }

  export type ressources_consulteesOrderByWithRelationInput = {
    id?: SortOrder
    event_timestamp?: SortOrder
    distinct_id?: SortOrderInput | SortOrder
    session_id?: SortOrderInput | SortOrder
    person_id?: SortOrderInput | SortOrder
    ressource?: SortOrderInput | SortOrder
    ingested_at?: SortOrder
  }

  export type ressources_consulteesWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    event_timestamp_distinct_id_session_id_person_id?: ressources_consulteesEvent_timestampDistinct_idSession_idPerson_idCompoundUniqueInput
    AND?: ressources_consulteesWhereInput | ressources_consulteesWhereInput[]
    OR?: ressources_consulteesWhereInput[]
    NOT?: ressources_consulteesWhereInput | ressources_consulteesWhereInput[]
    event_timestamp?: DateTimeFilter<"ressources_consultees"> | Date | string
    distinct_id?: StringNullableFilter<"ressources_consultees"> | string | null
    session_id?: StringNullableFilter<"ressources_consultees"> | string | null
    person_id?: StringNullableFilter<"ressources_consultees"> | string | null
    ressource?: StringNullableFilter<"ressources_consultees"> | string | null
    ingested_at?: DateTimeFilter<"ressources_consultees"> | Date | string
  }, "id" | "event_timestamp_distinct_id_session_id_person_id">

  export type ressources_consulteesOrderByWithAggregationInput = {
    id?: SortOrder
    event_timestamp?: SortOrder
    distinct_id?: SortOrderInput | SortOrder
    session_id?: SortOrderInput | SortOrder
    person_id?: SortOrderInput | SortOrder
    ressource?: SortOrderInput | SortOrder
    ingested_at?: SortOrder
    _count?: ressources_consulteesCountOrderByAggregateInput
    _avg?: ressources_consulteesAvgOrderByAggregateInput
    _max?: ressources_consulteesMaxOrderByAggregateInput
    _min?: ressources_consulteesMinOrderByAggregateInput
    _sum?: ressources_consulteesSumOrderByAggregateInput
  }

  export type ressources_consulteesScalarWhereWithAggregatesInput = {
    AND?: ressources_consulteesScalarWhereWithAggregatesInput | ressources_consulteesScalarWhereWithAggregatesInput[]
    OR?: ressources_consulteesScalarWhereWithAggregatesInput[]
    NOT?: ressources_consulteesScalarWhereWithAggregatesInput | ressources_consulteesScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"ressources_consultees"> | bigint | number
    event_timestamp?: DateTimeWithAggregatesFilter<"ressources_consultees"> | Date | string
    distinct_id?: StringNullableWithAggregatesFilter<"ressources_consultees"> | string | null
    session_id?: StringNullableWithAggregatesFilter<"ressources_consultees"> | string | null
    person_id?: StringNullableWithAggregatesFilter<"ressources_consultees"> | string | null
    ressource?: StringNullableWithAggregatesFilter<"ressources_consultees"> | string | null
    ingested_at?: DateTimeWithAggregatesFilter<"ressources_consultees"> | Date | string
  }

  export type thematiqueWhereInput = {
    AND?: thematiqueWhereInput | thematiqueWhereInput[]
    OR?: thematiqueWhereInput[]
    NOT?: thematiqueWhereInput | thematiqueWhereInput[]
    id?: BigIntFilter<"thematique"> | bigint | number
    event_timestamp?: DateTimeFilter<"thematique"> | Date | string
    properties?: JsonNullableFilter<"thematique">
    distinct_id?: StringNullableFilter<"thematique"> | string | null
    session_id?: StringNullableFilter<"thematique"> | string | null
    person_id?: StringNullableFilter<"thematique"> | string | null
    thematique?: StringNullableFilter<"thematique"> | string | null
    ingested_at?: DateTimeFilter<"thematique"> | Date | string
  }

  export type thematiqueOrderByWithRelationInput = {
    id?: SortOrder
    event_timestamp?: SortOrder
    properties?: SortOrderInput | SortOrder
    distinct_id?: SortOrderInput | SortOrder
    session_id?: SortOrderInput | SortOrder
    person_id?: SortOrderInput | SortOrder
    thematique?: SortOrderInput | SortOrder
    ingested_at?: SortOrder
  }

  export type thematiqueWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    event_timestamp_distinct_id_session_id_person_id?: thematiqueEvent_timestampDistinct_idSession_idPerson_idCompoundUniqueInput
    AND?: thematiqueWhereInput | thematiqueWhereInput[]
    OR?: thematiqueWhereInput[]
    NOT?: thematiqueWhereInput | thematiqueWhereInput[]
    event_timestamp?: DateTimeFilter<"thematique"> | Date | string
    properties?: JsonNullableFilter<"thematique">
    distinct_id?: StringNullableFilter<"thematique"> | string | null
    session_id?: StringNullableFilter<"thematique"> | string | null
    person_id?: StringNullableFilter<"thematique"> | string | null
    thematique?: StringNullableFilter<"thematique"> | string | null
    ingested_at?: DateTimeFilter<"thematique"> | Date | string
  }, "id" | "event_timestamp_distinct_id_session_id_person_id">

  export type thematiqueOrderByWithAggregationInput = {
    id?: SortOrder
    event_timestamp?: SortOrder
    properties?: SortOrderInput | SortOrder
    distinct_id?: SortOrderInput | SortOrder
    session_id?: SortOrderInput | SortOrder
    person_id?: SortOrderInput | SortOrder
    thematique?: SortOrderInput | SortOrder
    ingested_at?: SortOrder
    _count?: thematiqueCountOrderByAggregateInput
    _avg?: thematiqueAvgOrderByAggregateInput
    _max?: thematiqueMaxOrderByAggregateInput
    _min?: thematiqueMinOrderByAggregateInput
    _sum?: thematiqueSumOrderByAggregateInput
  }

  export type thematiqueScalarWhereWithAggregatesInput = {
    AND?: thematiqueScalarWhereWithAggregatesInput | thematiqueScalarWhereWithAggregatesInput[]
    OR?: thematiqueScalarWhereWithAggregatesInput[]
    NOT?: thematiqueScalarWhereWithAggregatesInput | thematiqueScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"thematique"> | bigint | number
    event_timestamp?: DateTimeWithAggregatesFilter<"thematique"> | Date | string
    properties?: JsonNullableWithAggregatesFilter<"thematique">
    distinct_id?: StringNullableWithAggregatesFilter<"thematique"> | string | null
    session_id?: StringNullableWithAggregatesFilter<"thematique"> | string | null
    person_id?: StringNullableWithAggregatesFilter<"thematique"> | string | null
    thematique?: StringNullableWithAggregatesFilter<"thematique"> | string | null
    ingested_at?: DateTimeWithAggregatesFilter<"thematique"> | Date | string
  }

  export type agricultureWhereInput = {
    AND?: agricultureWhereInput | agricultureWhereInput[]
    OR?: agricultureWhereInput[]
    NOT?: agricultureWhereInput | agricultureWhereInput[]
    index?: IntFilter<"agriculture"> | number
    code_geographique?: StringFilter<"agriculture"> | string
    libelle_geographique?: StringFilter<"agriculture"> | string
    epci?: StringFilter<"agriculture"> | string
    libelle_epci?: StringFilter<"agriculture"> | string
    departement?: StringFilter<"agriculture"> | string
    libelle_departement?: StringFilter<"agriculture"> | string
    region?: FloatFilter<"agriculture"> | number
    ept?: StringNullableFilter<"agriculture"> | string | null
    libelle_petr?: StringNullableFilter<"agriculture"> | string | null
    code_pnr?: StringNullableFilter<"agriculture"> | string | null
    libelle_pnr?: StringNullableFilter<"agriculture"> | string | null
    part_irr_SAU_2020?: FloatNullableFilter<"agriculture"> | number | null
    otex_12_postes?: StringFilter<"agriculture"> | string
  }

  export type agricultureOrderByWithRelationInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrderInput | SortOrder
    libelle_petr?: SortOrderInput | SortOrder
    code_pnr?: SortOrderInput | SortOrder
    libelle_pnr?: SortOrderInput | SortOrder
    part_irr_SAU_2020?: SortOrderInput | SortOrder
    otex_12_postes?: SortOrder
  }

  export type agricultureWhereUniqueInput = Prisma.AtLeast<{
    index?: number
    AND?: agricultureWhereInput | agricultureWhereInput[]
    OR?: agricultureWhereInput[]
    NOT?: agricultureWhereInput | agricultureWhereInput[]
    code_geographique?: StringFilter<"agriculture"> | string
    libelle_geographique?: StringFilter<"agriculture"> | string
    epci?: StringFilter<"agriculture"> | string
    libelle_epci?: StringFilter<"agriculture"> | string
    departement?: StringFilter<"agriculture"> | string
    libelle_departement?: StringFilter<"agriculture"> | string
    region?: FloatFilter<"agriculture"> | number
    ept?: StringNullableFilter<"agriculture"> | string | null
    libelle_petr?: StringNullableFilter<"agriculture"> | string | null
    code_pnr?: StringNullableFilter<"agriculture"> | string | null
    libelle_pnr?: StringNullableFilter<"agriculture"> | string | null
    part_irr_SAU_2020?: FloatNullableFilter<"agriculture"> | number | null
    otex_12_postes?: StringFilter<"agriculture"> | string
  }, "index">

  export type agricultureOrderByWithAggregationInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrderInput | SortOrder
    libelle_petr?: SortOrderInput | SortOrder
    code_pnr?: SortOrderInput | SortOrder
    libelle_pnr?: SortOrderInput | SortOrder
    part_irr_SAU_2020?: SortOrderInput | SortOrder
    otex_12_postes?: SortOrder
    _count?: agricultureCountOrderByAggregateInput
    _avg?: agricultureAvgOrderByAggregateInput
    _max?: agricultureMaxOrderByAggregateInput
    _min?: agricultureMinOrderByAggregateInput
    _sum?: agricultureSumOrderByAggregateInput
  }

  export type agricultureScalarWhereWithAggregatesInput = {
    AND?: agricultureScalarWhereWithAggregatesInput | agricultureScalarWhereWithAggregatesInput[]
    OR?: agricultureScalarWhereWithAggregatesInput[]
    NOT?: agricultureScalarWhereWithAggregatesInput | agricultureScalarWhereWithAggregatesInput[]
    index?: IntWithAggregatesFilter<"agriculture"> | number
    code_geographique?: StringWithAggregatesFilter<"agriculture"> | string
    libelle_geographique?: StringWithAggregatesFilter<"agriculture"> | string
    epci?: StringWithAggregatesFilter<"agriculture"> | string
    libelle_epci?: StringWithAggregatesFilter<"agriculture"> | string
    departement?: StringWithAggregatesFilter<"agriculture"> | string
    libelle_departement?: StringWithAggregatesFilter<"agriculture"> | string
    region?: FloatWithAggregatesFilter<"agriculture"> | number
    ept?: StringNullableWithAggregatesFilter<"agriculture"> | string | null
    libelle_petr?: StringNullableWithAggregatesFilter<"agriculture"> | string | null
    code_pnr?: StringNullableWithAggregatesFilter<"agriculture"> | string | null
    libelle_pnr?: StringNullableWithAggregatesFilter<"agriculture"> | string | null
    part_irr_SAU_2020?: FloatNullableWithAggregatesFilter<"agriculture"> | number | null
    otex_12_postes?: StringWithAggregatesFilter<"agriculture"> | string
  }

  export type agriculture_bioWhereInput = {
    AND?: agriculture_bioWhereInput | agriculture_bioWhereInput[]
    OR?: agriculture_bioWhereInput[]
    NOT?: agriculture_bioWhereInput | agriculture_bioWhereInput[]
    index?: IntFilter<"agriculture_bio"> | number
    epci?: StringFilter<"agriculture_bio"> | string
    libelle_epci?: StringFilter<"agriculture_bio"> | string
    VARIABLE?: StringFilter<"agriculture_bio"> | string
    LIBELLE_SOUS_CHAMP?: StringNullableFilter<"agriculture_bio"> | string | null
    surface_2023?: FloatNullableFilter<"agriculture_bio"> | number | null
    surface_2022?: FloatNullableFilter<"agriculture_bio"> | number | null
    surface_2021?: FloatNullableFilter<"agriculture_bio"> | number | null
    surface_2020?: FloatNullableFilter<"agriculture_bio"> | number | null
    surface_2019?: FloatNullableFilter<"agriculture_bio"> | number | null
    surface_2018?: FloatNullableFilter<"agriculture_bio"> | number | null
    surface_2017?: FloatNullableFilter<"agriculture_bio"> | number | null
    surface_2016?: FloatNullableFilter<"agriculture_bio"> | number | null
    surface_2015?: FloatNullableFilter<"agriculture_bio"> | number | null
    surface_2014?: FloatNullableFilter<"agriculture_bio"> | number | null
    surface_2013?: FloatNullableFilter<"agriculture_bio"> | number | null
    surface_2012?: FloatNullableFilter<"agriculture_bio"> | number | null
    surface_2011?: FloatNullableFilter<"agriculture_bio"> | number | null
    surface_2010?: FloatNullableFilter<"agriculture_bio"> | number | null
    surface_2009?: FloatNullableFilter<"agriculture_bio"> | number | null
    surface_2008?: FloatNullableFilter<"agriculture_bio"> | number | null
    nombre_2023?: FloatNullableFilter<"agriculture_bio"> | number | null
    nombre_2022?: FloatNullableFilter<"agriculture_bio"> | number | null
    nombre_2021?: FloatNullableFilter<"agriculture_bio"> | number | null
    nombre_2020?: FloatNullableFilter<"agriculture_bio"> | number | null
    nombre_2019?: FloatNullableFilter<"agriculture_bio"> | number | null
    nombre_2018?: FloatNullableFilter<"agriculture_bio"> | number | null
    nombre_2017?: FloatNullableFilter<"agriculture_bio"> | number | null
    nombre_2016?: FloatNullableFilter<"agriculture_bio"> | number | null
    nombre_2015?: FloatNullableFilter<"agriculture_bio"> | number | null
    nombre_2014?: FloatNullableFilter<"agriculture_bio"> | number | null
    nombre_2013?: FloatNullableFilter<"agriculture_bio"> | number | null
    nombre_2012?: FloatNullableFilter<"agriculture_bio"> | number | null
    nombre_2011?: FloatNullableFilter<"agriculture_bio"> | number | null
    nombre_2010?: FloatNullableFilter<"agriculture_bio"> | number | null
    nombre_2009?: FloatNullableFilter<"agriculture_bio"> | number | null
    nombre_2008?: FloatNullableFilter<"agriculture_bio"> | number | null
  }

  export type agriculture_bioOrderByWithRelationInput = {
    index?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    VARIABLE?: SortOrder
    LIBELLE_SOUS_CHAMP?: SortOrderInput | SortOrder
    surface_2023?: SortOrderInput | SortOrder
    surface_2022?: SortOrderInput | SortOrder
    surface_2021?: SortOrderInput | SortOrder
    surface_2020?: SortOrderInput | SortOrder
    surface_2019?: SortOrderInput | SortOrder
    surface_2018?: SortOrderInput | SortOrder
    surface_2017?: SortOrderInput | SortOrder
    surface_2016?: SortOrderInput | SortOrder
    surface_2015?: SortOrderInput | SortOrder
    surface_2014?: SortOrderInput | SortOrder
    surface_2013?: SortOrderInput | SortOrder
    surface_2012?: SortOrderInput | SortOrder
    surface_2011?: SortOrderInput | SortOrder
    surface_2010?: SortOrderInput | SortOrder
    surface_2009?: SortOrderInput | SortOrder
    surface_2008?: SortOrderInput | SortOrder
    nombre_2023?: SortOrderInput | SortOrder
    nombre_2022?: SortOrderInput | SortOrder
    nombre_2021?: SortOrderInput | SortOrder
    nombre_2020?: SortOrderInput | SortOrder
    nombre_2019?: SortOrderInput | SortOrder
    nombre_2018?: SortOrderInput | SortOrder
    nombre_2017?: SortOrderInput | SortOrder
    nombre_2016?: SortOrderInput | SortOrder
    nombre_2015?: SortOrderInput | SortOrder
    nombre_2014?: SortOrderInput | SortOrder
    nombre_2013?: SortOrderInput | SortOrder
    nombre_2012?: SortOrderInput | SortOrder
    nombre_2011?: SortOrderInput | SortOrder
    nombre_2010?: SortOrderInput | SortOrder
    nombre_2009?: SortOrderInput | SortOrder
    nombre_2008?: SortOrderInput | SortOrder
  }

  export type agriculture_bioWhereUniqueInput = Prisma.AtLeast<{
    index?: number
    AND?: agriculture_bioWhereInput | agriculture_bioWhereInput[]
    OR?: agriculture_bioWhereInput[]
    NOT?: agriculture_bioWhereInput | agriculture_bioWhereInput[]
    epci?: StringFilter<"agriculture_bio"> | string
    libelle_epci?: StringFilter<"agriculture_bio"> | string
    VARIABLE?: StringFilter<"agriculture_bio"> | string
    LIBELLE_SOUS_CHAMP?: StringNullableFilter<"agriculture_bio"> | string | null
    surface_2023?: FloatNullableFilter<"agriculture_bio"> | number | null
    surface_2022?: FloatNullableFilter<"agriculture_bio"> | number | null
    surface_2021?: FloatNullableFilter<"agriculture_bio"> | number | null
    surface_2020?: FloatNullableFilter<"agriculture_bio"> | number | null
    surface_2019?: FloatNullableFilter<"agriculture_bio"> | number | null
    surface_2018?: FloatNullableFilter<"agriculture_bio"> | number | null
    surface_2017?: FloatNullableFilter<"agriculture_bio"> | number | null
    surface_2016?: FloatNullableFilter<"agriculture_bio"> | number | null
    surface_2015?: FloatNullableFilter<"agriculture_bio"> | number | null
    surface_2014?: FloatNullableFilter<"agriculture_bio"> | number | null
    surface_2013?: FloatNullableFilter<"agriculture_bio"> | number | null
    surface_2012?: FloatNullableFilter<"agriculture_bio"> | number | null
    surface_2011?: FloatNullableFilter<"agriculture_bio"> | number | null
    surface_2010?: FloatNullableFilter<"agriculture_bio"> | number | null
    surface_2009?: FloatNullableFilter<"agriculture_bio"> | number | null
    surface_2008?: FloatNullableFilter<"agriculture_bio"> | number | null
    nombre_2023?: FloatNullableFilter<"agriculture_bio"> | number | null
    nombre_2022?: FloatNullableFilter<"agriculture_bio"> | number | null
    nombre_2021?: FloatNullableFilter<"agriculture_bio"> | number | null
    nombre_2020?: FloatNullableFilter<"agriculture_bio"> | number | null
    nombre_2019?: FloatNullableFilter<"agriculture_bio"> | number | null
    nombre_2018?: FloatNullableFilter<"agriculture_bio"> | number | null
    nombre_2017?: FloatNullableFilter<"agriculture_bio"> | number | null
    nombre_2016?: FloatNullableFilter<"agriculture_bio"> | number | null
    nombre_2015?: FloatNullableFilter<"agriculture_bio"> | number | null
    nombre_2014?: FloatNullableFilter<"agriculture_bio"> | number | null
    nombre_2013?: FloatNullableFilter<"agriculture_bio"> | number | null
    nombre_2012?: FloatNullableFilter<"agriculture_bio"> | number | null
    nombre_2011?: FloatNullableFilter<"agriculture_bio"> | number | null
    nombre_2010?: FloatNullableFilter<"agriculture_bio"> | number | null
    nombre_2009?: FloatNullableFilter<"agriculture_bio"> | number | null
    nombre_2008?: FloatNullableFilter<"agriculture_bio"> | number | null
  }, "index">

  export type agriculture_bioOrderByWithAggregationInput = {
    index?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    VARIABLE?: SortOrder
    LIBELLE_SOUS_CHAMP?: SortOrderInput | SortOrder
    surface_2023?: SortOrderInput | SortOrder
    surface_2022?: SortOrderInput | SortOrder
    surface_2021?: SortOrderInput | SortOrder
    surface_2020?: SortOrderInput | SortOrder
    surface_2019?: SortOrderInput | SortOrder
    surface_2018?: SortOrderInput | SortOrder
    surface_2017?: SortOrderInput | SortOrder
    surface_2016?: SortOrderInput | SortOrder
    surface_2015?: SortOrderInput | SortOrder
    surface_2014?: SortOrderInput | SortOrder
    surface_2013?: SortOrderInput | SortOrder
    surface_2012?: SortOrderInput | SortOrder
    surface_2011?: SortOrderInput | SortOrder
    surface_2010?: SortOrderInput | SortOrder
    surface_2009?: SortOrderInput | SortOrder
    surface_2008?: SortOrderInput | SortOrder
    nombre_2023?: SortOrderInput | SortOrder
    nombre_2022?: SortOrderInput | SortOrder
    nombre_2021?: SortOrderInput | SortOrder
    nombre_2020?: SortOrderInput | SortOrder
    nombre_2019?: SortOrderInput | SortOrder
    nombre_2018?: SortOrderInput | SortOrder
    nombre_2017?: SortOrderInput | SortOrder
    nombre_2016?: SortOrderInput | SortOrder
    nombre_2015?: SortOrderInput | SortOrder
    nombre_2014?: SortOrderInput | SortOrder
    nombre_2013?: SortOrderInput | SortOrder
    nombre_2012?: SortOrderInput | SortOrder
    nombre_2011?: SortOrderInput | SortOrder
    nombre_2010?: SortOrderInput | SortOrder
    nombre_2009?: SortOrderInput | SortOrder
    nombre_2008?: SortOrderInput | SortOrder
    _count?: agriculture_bioCountOrderByAggregateInput
    _avg?: agriculture_bioAvgOrderByAggregateInput
    _max?: agriculture_bioMaxOrderByAggregateInput
    _min?: agriculture_bioMinOrderByAggregateInput
    _sum?: agriculture_bioSumOrderByAggregateInput
  }

  export type agriculture_bioScalarWhereWithAggregatesInput = {
    AND?: agriculture_bioScalarWhereWithAggregatesInput | agriculture_bioScalarWhereWithAggregatesInput[]
    OR?: agriculture_bioScalarWhereWithAggregatesInput[]
    NOT?: agriculture_bioScalarWhereWithAggregatesInput | agriculture_bioScalarWhereWithAggregatesInput[]
    index?: IntWithAggregatesFilter<"agriculture_bio"> | number
    epci?: StringWithAggregatesFilter<"agriculture_bio"> | string
    libelle_epci?: StringWithAggregatesFilter<"agriculture_bio"> | string
    VARIABLE?: StringWithAggregatesFilter<"agriculture_bio"> | string
    LIBELLE_SOUS_CHAMP?: StringNullableWithAggregatesFilter<"agriculture_bio"> | string | null
    surface_2023?: FloatNullableWithAggregatesFilter<"agriculture_bio"> | number | null
    surface_2022?: FloatNullableWithAggregatesFilter<"agriculture_bio"> | number | null
    surface_2021?: FloatNullableWithAggregatesFilter<"agriculture_bio"> | number | null
    surface_2020?: FloatNullableWithAggregatesFilter<"agriculture_bio"> | number | null
    surface_2019?: FloatNullableWithAggregatesFilter<"agriculture_bio"> | number | null
    surface_2018?: FloatNullableWithAggregatesFilter<"agriculture_bio"> | number | null
    surface_2017?: FloatNullableWithAggregatesFilter<"agriculture_bio"> | number | null
    surface_2016?: FloatNullableWithAggregatesFilter<"agriculture_bio"> | number | null
    surface_2015?: FloatNullableWithAggregatesFilter<"agriculture_bio"> | number | null
    surface_2014?: FloatNullableWithAggregatesFilter<"agriculture_bio"> | number | null
    surface_2013?: FloatNullableWithAggregatesFilter<"agriculture_bio"> | number | null
    surface_2012?: FloatNullableWithAggregatesFilter<"agriculture_bio"> | number | null
    surface_2011?: FloatNullableWithAggregatesFilter<"agriculture_bio"> | number | null
    surface_2010?: FloatNullableWithAggregatesFilter<"agriculture_bio"> | number | null
    surface_2009?: FloatNullableWithAggregatesFilter<"agriculture_bio"> | number | null
    surface_2008?: FloatNullableWithAggregatesFilter<"agriculture_bio"> | number | null
    nombre_2023?: FloatNullableWithAggregatesFilter<"agriculture_bio"> | number | null
    nombre_2022?: FloatNullableWithAggregatesFilter<"agriculture_bio"> | number | null
    nombre_2021?: FloatNullableWithAggregatesFilter<"agriculture_bio"> | number | null
    nombre_2020?: FloatNullableWithAggregatesFilter<"agriculture_bio"> | number | null
    nombre_2019?: FloatNullableWithAggregatesFilter<"agriculture_bio"> | number | null
    nombre_2018?: FloatNullableWithAggregatesFilter<"agriculture_bio"> | number | null
    nombre_2017?: FloatNullableWithAggregatesFilter<"agriculture_bio"> | number | null
    nombre_2016?: FloatNullableWithAggregatesFilter<"agriculture_bio"> | number | null
    nombre_2015?: FloatNullableWithAggregatesFilter<"agriculture_bio"> | number | null
    nombre_2014?: FloatNullableWithAggregatesFilter<"agriculture_bio"> | number | null
    nombre_2013?: FloatNullableWithAggregatesFilter<"agriculture_bio"> | number | null
    nombre_2012?: FloatNullableWithAggregatesFilter<"agriculture_bio"> | number | null
    nombre_2011?: FloatNullableWithAggregatesFilter<"agriculture_bio"> | number | null
    nombre_2010?: FloatNullableWithAggregatesFilter<"agriculture_bio"> | number | null
    nombre_2009?: FloatNullableWithAggregatesFilter<"agriculture_bio"> | number | null
    nombre_2008?: FloatNullableWithAggregatesFilter<"agriculture_bio"> | number | null
  }

  export type aot_40WhereInput = {
    AND?: aot_40WhereInput | aot_40WhereInput[]
    OR?: aot_40WhereInput[]
    NOT?: aot_40WhereInput | aot_40WhereInput[]
    index?: IntFilter<"aot_40"> | number
    nom_site?: StringFilter<"aot_40"> | string
    type_d_implantation?: StringFilter<"aot_40"> | string
    valeur_brute?: FloatFilter<"aot_40"> | number
    Latitude?: FloatFilter<"aot_40"> | number
    Longitude?: FloatFilter<"aot_40"> | number
  }

  export type aot_40OrderByWithRelationInput = {
    index?: SortOrder
    nom_site?: SortOrder
    type_d_implantation?: SortOrder
    valeur_brute?: SortOrder
    Latitude?: SortOrder
    Longitude?: SortOrder
  }

  export type aot_40WhereUniqueInput = Prisma.AtLeast<{
    index?: number
    AND?: aot_40WhereInput | aot_40WhereInput[]
    OR?: aot_40WhereInput[]
    NOT?: aot_40WhereInput | aot_40WhereInput[]
    nom_site?: StringFilter<"aot_40"> | string
    type_d_implantation?: StringFilter<"aot_40"> | string
    valeur_brute?: FloatFilter<"aot_40"> | number
    Latitude?: FloatFilter<"aot_40"> | number
    Longitude?: FloatFilter<"aot_40"> | number
  }, "index">

  export type aot_40OrderByWithAggregationInput = {
    index?: SortOrder
    nom_site?: SortOrder
    type_d_implantation?: SortOrder
    valeur_brute?: SortOrder
    Latitude?: SortOrder
    Longitude?: SortOrder
    _count?: aot_40CountOrderByAggregateInput
    _avg?: aot_40AvgOrderByAggregateInput
    _max?: aot_40MaxOrderByAggregateInput
    _min?: aot_40MinOrderByAggregateInput
    _sum?: aot_40SumOrderByAggregateInput
  }

  export type aot_40ScalarWhereWithAggregatesInput = {
    AND?: aot_40ScalarWhereWithAggregatesInput | aot_40ScalarWhereWithAggregatesInput[]
    OR?: aot_40ScalarWhereWithAggregatesInput[]
    NOT?: aot_40ScalarWhereWithAggregatesInput | aot_40ScalarWhereWithAggregatesInput[]
    index?: IntWithAggregatesFilter<"aot_40"> | number
    nom_site?: StringWithAggregatesFilter<"aot_40"> | string
    type_d_implantation?: StringWithAggregatesFilter<"aot_40"> | string
    valeur_brute?: FloatWithAggregatesFilter<"aot_40"> | number
    Latitude?: FloatWithAggregatesFilter<"aot_40"> | number
    Longitude?: FloatWithAggregatesFilter<"aot_40"> | number
  }

  export type arretes_catnatWhereInput = {
    AND?: arretes_catnatWhereInput | arretes_catnatWhereInput[]
    OR?: arretes_catnatWhereInput[]
    NOT?: arretes_catnatWhereInput | arretes_catnatWhereInput[]
    index?: IntFilter<"arretes_catnat"> | number
    code_geographique?: StringFilter<"arretes_catnat"> | string
    libelle_geographique?: StringFilter<"arretes_catnat"> | string
    epci?: StringFilter<"arretes_catnat"> | string
    libelle_epci?: StringFilter<"arretes_catnat"> | string
    departement?: StringFilter<"arretes_catnat"> | string
    libelle_departement?: StringFilter<"arretes_catnat"> | string
    region?: FloatFilter<"arretes_catnat"> | number
    ept?: StringNullableFilter<"arretes_catnat"> | string | null
    libelle_petr?: StringNullableFilter<"arretes_catnat"> | string | null
    code_pnr?: StringNullableFilter<"arretes_catnat"> | string | null
    libelle_pnr?: StringNullableFilter<"arretes_catnat"> | string | null
    lib_risque_jo?: StringFilter<"arretes_catnat"> | string
    dat_deb?: StringFilter<"arretes_catnat"> | string
    dat_fin?: StringFilter<"arretes_catnat"> | string
    dat_pub_arrete?: StringFilter<"arretes_catnat"> | string
  }

  export type arretes_catnatOrderByWithRelationInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrderInput | SortOrder
    libelle_petr?: SortOrderInput | SortOrder
    code_pnr?: SortOrderInput | SortOrder
    libelle_pnr?: SortOrderInput | SortOrder
    lib_risque_jo?: SortOrder
    dat_deb?: SortOrder
    dat_fin?: SortOrder
    dat_pub_arrete?: SortOrder
  }

  export type arretes_catnatWhereUniqueInput = Prisma.AtLeast<{
    index?: number
    AND?: arretes_catnatWhereInput | arretes_catnatWhereInput[]
    OR?: arretes_catnatWhereInput[]
    NOT?: arretes_catnatWhereInput | arretes_catnatWhereInput[]
    code_geographique?: StringFilter<"arretes_catnat"> | string
    libelle_geographique?: StringFilter<"arretes_catnat"> | string
    epci?: StringFilter<"arretes_catnat"> | string
    libelle_epci?: StringFilter<"arretes_catnat"> | string
    departement?: StringFilter<"arretes_catnat"> | string
    libelle_departement?: StringFilter<"arretes_catnat"> | string
    region?: FloatFilter<"arretes_catnat"> | number
    ept?: StringNullableFilter<"arretes_catnat"> | string | null
    libelle_petr?: StringNullableFilter<"arretes_catnat"> | string | null
    code_pnr?: StringNullableFilter<"arretes_catnat"> | string | null
    libelle_pnr?: StringNullableFilter<"arretes_catnat"> | string | null
    lib_risque_jo?: StringFilter<"arretes_catnat"> | string
    dat_deb?: StringFilter<"arretes_catnat"> | string
    dat_fin?: StringFilter<"arretes_catnat"> | string
    dat_pub_arrete?: StringFilter<"arretes_catnat"> | string
  }, "index">

  export type arretes_catnatOrderByWithAggregationInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrderInput | SortOrder
    libelle_petr?: SortOrderInput | SortOrder
    code_pnr?: SortOrderInput | SortOrder
    libelle_pnr?: SortOrderInput | SortOrder
    lib_risque_jo?: SortOrder
    dat_deb?: SortOrder
    dat_fin?: SortOrder
    dat_pub_arrete?: SortOrder
    _count?: arretes_catnatCountOrderByAggregateInput
    _avg?: arretes_catnatAvgOrderByAggregateInput
    _max?: arretes_catnatMaxOrderByAggregateInput
    _min?: arretes_catnatMinOrderByAggregateInput
    _sum?: arretes_catnatSumOrderByAggregateInput
  }

  export type arretes_catnatScalarWhereWithAggregatesInput = {
    AND?: arretes_catnatScalarWhereWithAggregatesInput | arretes_catnatScalarWhereWithAggregatesInput[]
    OR?: arretes_catnatScalarWhereWithAggregatesInput[]
    NOT?: arretes_catnatScalarWhereWithAggregatesInput | arretes_catnatScalarWhereWithAggregatesInput[]
    index?: IntWithAggregatesFilter<"arretes_catnat"> | number
    code_geographique?: StringWithAggregatesFilter<"arretes_catnat"> | string
    libelle_geographique?: StringWithAggregatesFilter<"arretes_catnat"> | string
    epci?: StringWithAggregatesFilter<"arretes_catnat"> | string
    libelle_epci?: StringWithAggregatesFilter<"arretes_catnat"> | string
    departement?: StringWithAggregatesFilter<"arretes_catnat"> | string
    libelle_departement?: StringWithAggregatesFilter<"arretes_catnat"> | string
    region?: FloatWithAggregatesFilter<"arretes_catnat"> | number
    ept?: StringNullableWithAggregatesFilter<"arretes_catnat"> | string | null
    libelle_petr?: StringNullableWithAggregatesFilter<"arretes_catnat"> | string | null
    code_pnr?: StringNullableWithAggregatesFilter<"arretes_catnat"> | string | null
    libelle_pnr?: StringNullableWithAggregatesFilter<"arretes_catnat"> | string | null
    lib_risque_jo?: StringWithAggregatesFilter<"arretes_catnat"> | string
    dat_deb?: StringWithAggregatesFilter<"arretes_catnat"> | string
    dat_fin?: StringWithAggregatesFilter<"arretes_catnat"> | string
    dat_pub_arrete?: StringWithAggregatesFilter<"arretes_catnat"> | string
  }

  export type atlas_biodiversiteWhereInput = {
    AND?: atlas_biodiversiteWhereInput | atlas_biodiversiteWhereInput[]
    OR?: atlas_biodiversiteWhereInput[]
    NOT?: atlas_biodiversiteWhereInput | atlas_biodiversiteWhereInput[]
    index?: IntFilter<"atlas_biodiversite"> | number
    code_geographique?: StringFilter<"atlas_biodiversite"> | string
    libelle_geographique?: StringFilter<"atlas_biodiversite"> | string
    epci?: StringFilter<"atlas_biodiversite"> | string
    libelle_epci?: StringFilter<"atlas_biodiversite"> | string
    departement?: StringFilter<"atlas_biodiversite"> | string
    libelle_departement?: StringFilter<"atlas_biodiversite"> | string
    region?: FloatFilter<"atlas_biodiversite"> | number
    ept?: StringNullableFilter<"atlas_biodiversite"> | string | null
    libelle_petr?: StringNullableFilter<"atlas_biodiversite"> | string | null
    code_pnr?: StringNullableFilter<"atlas_biodiversite"> | string | null
    libelle_pnr?: StringNullableFilter<"atlas_biodiversite"> | string | null
    nom?: StringNullableFilter<"atlas_biodiversite"> | string | null
    structure_porteuse?: StringNullableFilter<"atlas_biodiversite"> | string | null
    type_de_structure_porteuse?: StringNullableFilter<"atlas_biodiversite"> | string | null
    annee_debut?: FloatNullableFilter<"atlas_biodiversite"> | number | null
    avancement?: StringNullableFilter<"atlas_biodiversite"> | string | null
  }

  export type atlas_biodiversiteOrderByWithRelationInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrderInput | SortOrder
    libelle_petr?: SortOrderInput | SortOrder
    code_pnr?: SortOrderInput | SortOrder
    libelle_pnr?: SortOrderInput | SortOrder
    nom?: SortOrderInput | SortOrder
    structure_porteuse?: SortOrderInput | SortOrder
    type_de_structure_porteuse?: SortOrderInput | SortOrder
    annee_debut?: SortOrderInput | SortOrder
    avancement?: SortOrderInput | SortOrder
  }

  export type atlas_biodiversiteWhereUniqueInput = Prisma.AtLeast<{
    index?: number
    AND?: atlas_biodiversiteWhereInput | atlas_biodiversiteWhereInput[]
    OR?: atlas_biodiversiteWhereInput[]
    NOT?: atlas_biodiversiteWhereInput | atlas_biodiversiteWhereInput[]
    code_geographique?: StringFilter<"atlas_biodiversite"> | string
    libelle_geographique?: StringFilter<"atlas_biodiversite"> | string
    epci?: StringFilter<"atlas_biodiversite"> | string
    libelle_epci?: StringFilter<"atlas_biodiversite"> | string
    departement?: StringFilter<"atlas_biodiversite"> | string
    libelle_departement?: StringFilter<"atlas_biodiversite"> | string
    region?: FloatFilter<"atlas_biodiversite"> | number
    ept?: StringNullableFilter<"atlas_biodiversite"> | string | null
    libelle_petr?: StringNullableFilter<"atlas_biodiversite"> | string | null
    code_pnr?: StringNullableFilter<"atlas_biodiversite"> | string | null
    libelle_pnr?: StringNullableFilter<"atlas_biodiversite"> | string | null
    nom?: StringNullableFilter<"atlas_biodiversite"> | string | null
    structure_porteuse?: StringNullableFilter<"atlas_biodiversite"> | string | null
    type_de_structure_porteuse?: StringNullableFilter<"atlas_biodiversite"> | string | null
    annee_debut?: FloatNullableFilter<"atlas_biodiversite"> | number | null
    avancement?: StringNullableFilter<"atlas_biodiversite"> | string | null
  }, "index">

  export type atlas_biodiversiteOrderByWithAggregationInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrderInput | SortOrder
    libelle_petr?: SortOrderInput | SortOrder
    code_pnr?: SortOrderInput | SortOrder
    libelle_pnr?: SortOrderInput | SortOrder
    nom?: SortOrderInput | SortOrder
    structure_porteuse?: SortOrderInput | SortOrder
    type_de_structure_porteuse?: SortOrderInput | SortOrder
    annee_debut?: SortOrderInput | SortOrder
    avancement?: SortOrderInput | SortOrder
    _count?: atlas_biodiversiteCountOrderByAggregateInput
    _avg?: atlas_biodiversiteAvgOrderByAggregateInput
    _max?: atlas_biodiversiteMaxOrderByAggregateInput
    _min?: atlas_biodiversiteMinOrderByAggregateInput
    _sum?: atlas_biodiversiteSumOrderByAggregateInput
  }

  export type atlas_biodiversiteScalarWhereWithAggregatesInput = {
    AND?: atlas_biodiversiteScalarWhereWithAggregatesInput | atlas_biodiversiteScalarWhereWithAggregatesInput[]
    OR?: atlas_biodiversiteScalarWhereWithAggregatesInput[]
    NOT?: atlas_biodiversiteScalarWhereWithAggregatesInput | atlas_biodiversiteScalarWhereWithAggregatesInput[]
    index?: IntWithAggregatesFilter<"atlas_biodiversite"> | number
    code_geographique?: StringWithAggregatesFilter<"atlas_biodiversite"> | string
    libelle_geographique?: StringWithAggregatesFilter<"atlas_biodiversite"> | string
    epci?: StringWithAggregatesFilter<"atlas_biodiversite"> | string
    libelle_epci?: StringWithAggregatesFilter<"atlas_biodiversite"> | string
    departement?: StringWithAggregatesFilter<"atlas_biodiversite"> | string
    libelle_departement?: StringWithAggregatesFilter<"atlas_biodiversite"> | string
    region?: FloatWithAggregatesFilter<"atlas_biodiversite"> | number
    ept?: StringNullableWithAggregatesFilter<"atlas_biodiversite"> | string | null
    libelle_petr?: StringNullableWithAggregatesFilter<"atlas_biodiversite"> | string | null
    code_pnr?: StringNullableWithAggregatesFilter<"atlas_biodiversite"> | string | null
    libelle_pnr?: StringNullableWithAggregatesFilter<"atlas_biodiversite"> | string | null
    nom?: StringNullableWithAggregatesFilter<"atlas_biodiversite"> | string | null
    structure_porteuse?: StringNullableWithAggregatesFilter<"atlas_biodiversite"> | string | null
    type_de_structure_porteuse?: StringNullableWithAggregatesFilter<"atlas_biodiversite"> | string | null
    annee_debut?: FloatNullableWithAggregatesFilter<"atlas_biodiversite"> | number | null
    avancement?: StringNullableWithAggregatesFilter<"atlas_biodiversite"> | string | null
  }

  export type collectivites_searchbarWhereInput = {
    AND?: collectivites_searchbarWhereInput | collectivites_searchbarWhereInput[]
    OR?: collectivites_searchbarWhereInput[]
    NOT?: collectivites_searchbarWhereInput | collectivites_searchbarWhereInput[]
    index?: IntFilter<"collectivites_searchbar"> | number
    code_geographique?: StringNullableFilter<"collectivites_searchbar"> | string | null
    libelle_geographique?: StringNullableFilter<"collectivites_searchbar"> | string | null
    epci?: StringNullableFilter<"collectivites_searchbar"> | string | null
    libelle_epci?: StringNullableFilter<"collectivites_searchbar"> | string | null
    departement?: StringNullableFilter<"collectivites_searchbar"> | string | null
    libelle_departement?: StringNullableFilter<"collectivites_searchbar"> | string | null
    region?: StringNullableFilter<"collectivites_searchbar"> | string | null
    ept?: StringNullableFilter<"collectivites_searchbar"> | string | null
    libelle_petr?: StringNullableFilter<"collectivites_searchbar"> | string | null
    code_pnr?: StringNullableFilter<"collectivites_searchbar"> | string | null
    libelle_pnr?: StringNullableFilter<"collectivites_searchbar"> | string | null
    search_code?: StringNullableFilter<"collectivites_searchbar"> | string | null
    search_libelle?: StringFilter<"collectivites_searchbar"> | string
  }

  export type collectivites_searchbarOrderByWithRelationInput = {
    index?: SortOrder
    code_geographique?: SortOrderInput | SortOrder
    libelle_geographique?: SortOrderInput | SortOrder
    epci?: SortOrderInput | SortOrder
    libelle_epci?: SortOrderInput | SortOrder
    departement?: SortOrderInput | SortOrder
    libelle_departement?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    ept?: SortOrderInput | SortOrder
    libelle_petr?: SortOrderInput | SortOrder
    code_pnr?: SortOrderInput | SortOrder
    libelle_pnr?: SortOrderInput | SortOrder
    search_code?: SortOrderInput | SortOrder
    search_libelle?: SortOrder
  }

  export type collectivites_searchbarWhereUniqueInput = Prisma.AtLeast<{
    index?: number
    AND?: collectivites_searchbarWhereInput | collectivites_searchbarWhereInput[]
    OR?: collectivites_searchbarWhereInput[]
    NOT?: collectivites_searchbarWhereInput | collectivites_searchbarWhereInput[]
    code_geographique?: StringNullableFilter<"collectivites_searchbar"> | string | null
    libelle_geographique?: StringNullableFilter<"collectivites_searchbar"> | string | null
    epci?: StringNullableFilter<"collectivites_searchbar"> | string | null
    libelle_epci?: StringNullableFilter<"collectivites_searchbar"> | string | null
    departement?: StringNullableFilter<"collectivites_searchbar"> | string | null
    libelle_departement?: StringNullableFilter<"collectivites_searchbar"> | string | null
    region?: StringNullableFilter<"collectivites_searchbar"> | string | null
    ept?: StringNullableFilter<"collectivites_searchbar"> | string | null
    libelle_petr?: StringNullableFilter<"collectivites_searchbar"> | string | null
    code_pnr?: StringNullableFilter<"collectivites_searchbar"> | string | null
    libelle_pnr?: StringNullableFilter<"collectivites_searchbar"> | string | null
    search_code?: StringNullableFilter<"collectivites_searchbar"> | string | null
    search_libelle?: StringFilter<"collectivites_searchbar"> | string
  }, "index">

  export type collectivites_searchbarOrderByWithAggregationInput = {
    index?: SortOrder
    code_geographique?: SortOrderInput | SortOrder
    libelle_geographique?: SortOrderInput | SortOrder
    epci?: SortOrderInput | SortOrder
    libelle_epci?: SortOrderInput | SortOrder
    departement?: SortOrderInput | SortOrder
    libelle_departement?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    ept?: SortOrderInput | SortOrder
    libelle_petr?: SortOrderInput | SortOrder
    code_pnr?: SortOrderInput | SortOrder
    libelle_pnr?: SortOrderInput | SortOrder
    search_code?: SortOrderInput | SortOrder
    search_libelle?: SortOrder
    _count?: collectivites_searchbarCountOrderByAggregateInput
    _avg?: collectivites_searchbarAvgOrderByAggregateInput
    _max?: collectivites_searchbarMaxOrderByAggregateInput
    _min?: collectivites_searchbarMinOrderByAggregateInput
    _sum?: collectivites_searchbarSumOrderByAggregateInput
  }

  export type collectivites_searchbarScalarWhereWithAggregatesInput = {
    AND?: collectivites_searchbarScalarWhereWithAggregatesInput | collectivites_searchbarScalarWhereWithAggregatesInput[]
    OR?: collectivites_searchbarScalarWhereWithAggregatesInput[]
    NOT?: collectivites_searchbarScalarWhereWithAggregatesInput | collectivites_searchbarScalarWhereWithAggregatesInput[]
    index?: IntWithAggregatesFilter<"collectivites_searchbar"> | number
    code_geographique?: StringNullableWithAggregatesFilter<"collectivites_searchbar"> | string | null
    libelle_geographique?: StringNullableWithAggregatesFilter<"collectivites_searchbar"> | string | null
    epci?: StringNullableWithAggregatesFilter<"collectivites_searchbar"> | string | null
    libelle_epci?: StringNullableWithAggregatesFilter<"collectivites_searchbar"> | string | null
    departement?: StringNullableWithAggregatesFilter<"collectivites_searchbar"> | string | null
    libelle_departement?: StringNullableWithAggregatesFilter<"collectivites_searchbar"> | string | null
    region?: StringNullableWithAggregatesFilter<"collectivites_searchbar"> | string | null
    ept?: StringNullableWithAggregatesFilter<"collectivites_searchbar"> | string | null
    libelle_petr?: StringNullableWithAggregatesFilter<"collectivites_searchbar"> | string | null
    code_pnr?: StringNullableWithAggregatesFilter<"collectivites_searchbar"> | string | null
    libelle_pnr?: StringNullableWithAggregatesFilter<"collectivites_searchbar"> | string | null
    search_code?: StringNullableWithAggregatesFilter<"collectivites_searchbar"> | string | null
    search_libelle?: StringWithAggregatesFilter<"collectivites_searchbar"> | string
  }

  export type confort_thermiqueWhereInput = {
    AND?: confort_thermiqueWhereInput | confort_thermiqueWhereInput[]
    OR?: confort_thermiqueWhereInput[]
    NOT?: confort_thermiqueWhereInput | confort_thermiqueWhereInput[]
    index?: IntFilter<"confort_thermique"> | number
    code_geographique?: StringFilter<"confort_thermique"> | string
    libelle_geographique?: StringFilter<"confort_thermique"> | string
    epci?: StringFilter<"confort_thermique"> | string
    libelle_epci?: StringFilter<"confort_thermique"> | string
    departement?: StringFilter<"confort_thermique"> | string
    libelle_departement?: StringFilter<"confort_thermique"> | string
    region?: IntFilter<"confort_thermique"> | number
    ept?: StringNullableFilter<"confort_thermique"> | string | null
    libelle_petr?: StringNullableFilter<"confort_thermique"> | string | null
    code_pnr?: StringNullableFilter<"confort_thermique"> | string | null
    libelle_pnr?: StringNullableFilter<"confort_thermique"> | string | null
    age_bati_post06?: FloatNullableFilter<"confort_thermique"> | number | null
    age_bati_91_05?: FloatNullableFilter<"confort_thermique"> | number | null
    age_bati_46_90?: FloatNullableFilter<"confort_thermique"> | number | null
    age_bati_19_45?: FloatNullableFilter<"confort_thermique"> | number | null
    age_bati_pre_19?: FloatNullableFilter<"confort_thermique"> | number | null
    under_4_sum_1968?: FloatNullableFilter<"confort_thermique"> | number | null
    to_75_sum_1968?: FloatNullableFilter<"confort_thermique"> | number | null
    over_75_sum_1968?: FloatNullableFilter<"confort_thermique"> | number | null
    under_4_sum_1975?: FloatNullableFilter<"confort_thermique"> | number | null
    to_75_sum_1975?: FloatNullableFilter<"confort_thermique"> | number | null
    over_75_sum_1975?: FloatNullableFilter<"confort_thermique"> | number | null
    under_4_sum_1982?: FloatNullableFilter<"confort_thermique"> | number | null
    to_75_sum_1982?: FloatNullableFilter<"confort_thermique"> | number | null
    over_75_sum_1982?: FloatNullableFilter<"confort_thermique"> | number | null
    under_4_sum_1990?: FloatNullableFilter<"confort_thermique"> | number | null
    to_75_sum_1990?: FloatNullableFilter<"confort_thermique"> | number | null
    over_75_sum_1990?: FloatNullableFilter<"confort_thermique"> | number | null
    under_4_sum_1999?: FloatNullableFilter<"confort_thermique"> | number | null
    to_75_sum_1999?: FloatNullableFilter<"confort_thermique"> | number | null
    over_75_sum_1999?: FloatNullableFilter<"confort_thermique"> | number | null
    under_4_sum_2009?: FloatNullableFilter<"confort_thermique"> | number | null
    to_75_sum_2009?: FloatNullableFilter<"confort_thermique"> | number | null
    over_75_sum_2009?: FloatNullableFilter<"confort_thermique"> | number | null
    under_4_sum_2014?: FloatNullableFilter<"confort_thermique"> | number | null
    to_75_sum_2014?: FloatNullableFilter<"confort_thermique"> | number | null
    over_75_sum_2014?: FloatNullableFilter<"confort_thermique"> | number | null
    under_4_sum_2020?: FloatNullableFilter<"confort_thermique"> | number | null
    to_75_sum_2020?: FloatNullableFilter<"confort_thermique"> | number | null
    over_75_sum_2020?: FloatNullableFilter<"confort_thermique"> | number | null
    tee_log?: FloatNullableFilter<"confort_thermique"> | number | null
    tee_mob?: FloatNullableFilter<"confort_thermique"> | number | null
    precarite_logement?: FloatNullableFilter<"confort_thermique"> | number | null
    NA5AZ_sum?: FloatNullableFilter<"confort_thermique"> | number | null
    NA5BE_sum?: FloatNullableFilter<"confort_thermique"> | number | null
    NA5FZ_sum?: FloatNullableFilter<"confort_thermique"> | number | null
    NA5GU_sum?: FloatNullableFilter<"confort_thermique"> | number | null
    NA5OQ_sum?: FloatNullableFilter<"confort_thermique"> | number | null
    clc_1_artificialise?: FloatNullableFilter<"confort_thermique"> | number | null
    clc_2_agricole?: FloatNullableFilter<"confort_thermique"> | number | null
    clc_3_foret_semiNaturel?: FloatNullableFilter<"confort_thermique"> | number | null
    clc_4_humide?: FloatNullableFilter<"confort_thermique"> | number | null
    clc_5_eau?: FloatNullableFilter<"confort_thermique"> | number | null
    superf_choro?: FloatNullableFilter<"confort_thermique"> | number | null
  }

  export type confort_thermiqueOrderByWithRelationInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrderInput | SortOrder
    libelle_petr?: SortOrderInput | SortOrder
    code_pnr?: SortOrderInput | SortOrder
    libelle_pnr?: SortOrderInput | SortOrder
    age_bati_post06?: SortOrderInput | SortOrder
    age_bati_91_05?: SortOrderInput | SortOrder
    age_bati_46_90?: SortOrderInput | SortOrder
    age_bati_19_45?: SortOrderInput | SortOrder
    age_bati_pre_19?: SortOrderInput | SortOrder
    under_4_sum_1968?: SortOrderInput | SortOrder
    to_75_sum_1968?: SortOrderInput | SortOrder
    over_75_sum_1968?: SortOrderInput | SortOrder
    under_4_sum_1975?: SortOrderInput | SortOrder
    to_75_sum_1975?: SortOrderInput | SortOrder
    over_75_sum_1975?: SortOrderInput | SortOrder
    under_4_sum_1982?: SortOrderInput | SortOrder
    to_75_sum_1982?: SortOrderInput | SortOrder
    over_75_sum_1982?: SortOrderInput | SortOrder
    under_4_sum_1990?: SortOrderInput | SortOrder
    to_75_sum_1990?: SortOrderInput | SortOrder
    over_75_sum_1990?: SortOrderInput | SortOrder
    under_4_sum_1999?: SortOrderInput | SortOrder
    to_75_sum_1999?: SortOrderInput | SortOrder
    over_75_sum_1999?: SortOrderInput | SortOrder
    under_4_sum_2009?: SortOrderInput | SortOrder
    to_75_sum_2009?: SortOrderInput | SortOrder
    over_75_sum_2009?: SortOrderInput | SortOrder
    under_4_sum_2014?: SortOrderInput | SortOrder
    to_75_sum_2014?: SortOrderInput | SortOrder
    over_75_sum_2014?: SortOrderInput | SortOrder
    under_4_sum_2020?: SortOrderInput | SortOrder
    to_75_sum_2020?: SortOrderInput | SortOrder
    over_75_sum_2020?: SortOrderInput | SortOrder
    tee_log?: SortOrderInput | SortOrder
    tee_mob?: SortOrderInput | SortOrder
    precarite_logement?: SortOrderInput | SortOrder
    NA5AZ_sum?: SortOrderInput | SortOrder
    NA5BE_sum?: SortOrderInput | SortOrder
    NA5FZ_sum?: SortOrderInput | SortOrder
    NA5GU_sum?: SortOrderInput | SortOrder
    NA5OQ_sum?: SortOrderInput | SortOrder
    clc_1_artificialise?: SortOrderInput | SortOrder
    clc_2_agricole?: SortOrderInput | SortOrder
    clc_3_foret_semiNaturel?: SortOrderInput | SortOrder
    clc_4_humide?: SortOrderInput | SortOrder
    clc_5_eau?: SortOrderInput | SortOrder
    superf_choro?: SortOrderInput | SortOrder
  }

  export type confort_thermiqueWhereUniqueInput = Prisma.AtLeast<{
    index?: number
    AND?: confort_thermiqueWhereInput | confort_thermiqueWhereInput[]
    OR?: confort_thermiqueWhereInput[]
    NOT?: confort_thermiqueWhereInput | confort_thermiqueWhereInput[]
    code_geographique?: StringFilter<"confort_thermique"> | string
    libelle_geographique?: StringFilter<"confort_thermique"> | string
    epci?: StringFilter<"confort_thermique"> | string
    libelle_epci?: StringFilter<"confort_thermique"> | string
    departement?: StringFilter<"confort_thermique"> | string
    libelle_departement?: StringFilter<"confort_thermique"> | string
    region?: IntFilter<"confort_thermique"> | number
    ept?: StringNullableFilter<"confort_thermique"> | string | null
    libelle_petr?: StringNullableFilter<"confort_thermique"> | string | null
    code_pnr?: StringNullableFilter<"confort_thermique"> | string | null
    libelle_pnr?: StringNullableFilter<"confort_thermique"> | string | null
    age_bati_post06?: FloatNullableFilter<"confort_thermique"> | number | null
    age_bati_91_05?: FloatNullableFilter<"confort_thermique"> | number | null
    age_bati_46_90?: FloatNullableFilter<"confort_thermique"> | number | null
    age_bati_19_45?: FloatNullableFilter<"confort_thermique"> | number | null
    age_bati_pre_19?: FloatNullableFilter<"confort_thermique"> | number | null
    under_4_sum_1968?: FloatNullableFilter<"confort_thermique"> | number | null
    to_75_sum_1968?: FloatNullableFilter<"confort_thermique"> | number | null
    over_75_sum_1968?: FloatNullableFilter<"confort_thermique"> | number | null
    under_4_sum_1975?: FloatNullableFilter<"confort_thermique"> | number | null
    to_75_sum_1975?: FloatNullableFilter<"confort_thermique"> | number | null
    over_75_sum_1975?: FloatNullableFilter<"confort_thermique"> | number | null
    under_4_sum_1982?: FloatNullableFilter<"confort_thermique"> | number | null
    to_75_sum_1982?: FloatNullableFilter<"confort_thermique"> | number | null
    over_75_sum_1982?: FloatNullableFilter<"confort_thermique"> | number | null
    under_4_sum_1990?: FloatNullableFilter<"confort_thermique"> | number | null
    to_75_sum_1990?: FloatNullableFilter<"confort_thermique"> | number | null
    over_75_sum_1990?: FloatNullableFilter<"confort_thermique"> | number | null
    under_4_sum_1999?: FloatNullableFilter<"confort_thermique"> | number | null
    to_75_sum_1999?: FloatNullableFilter<"confort_thermique"> | number | null
    over_75_sum_1999?: FloatNullableFilter<"confort_thermique"> | number | null
    under_4_sum_2009?: FloatNullableFilter<"confort_thermique"> | number | null
    to_75_sum_2009?: FloatNullableFilter<"confort_thermique"> | number | null
    over_75_sum_2009?: FloatNullableFilter<"confort_thermique"> | number | null
    under_4_sum_2014?: FloatNullableFilter<"confort_thermique"> | number | null
    to_75_sum_2014?: FloatNullableFilter<"confort_thermique"> | number | null
    over_75_sum_2014?: FloatNullableFilter<"confort_thermique"> | number | null
    under_4_sum_2020?: FloatNullableFilter<"confort_thermique"> | number | null
    to_75_sum_2020?: FloatNullableFilter<"confort_thermique"> | number | null
    over_75_sum_2020?: FloatNullableFilter<"confort_thermique"> | number | null
    tee_log?: FloatNullableFilter<"confort_thermique"> | number | null
    tee_mob?: FloatNullableFilter<"confort_thermique"> | number | null
    precarite_logement?: FloatNullableFilter<"confort_thermique"> | number | null
    NA5AZ_sum?: FloatNullableFilter<"confort_thermique"> | number | null
    NA5BE_sum?: FloatNullableFilter<"confort_thermique"> | number | null
    NA5FZ_sum?: FloatNullableFilter<"confort_thermique"> | number | null
    NA5GU_sum?: FloatNullableFilter<"confort_thermique"> | number | null
    NA5OQ_sum?: FloatNullableFilter<"confort_thermique"> | number | null
    clc_1_artificialise?: FloatNullableFilter<"confort_thermique"> | number | null
    clc_2_agricole?: FloatNullableFilter<"confort_thermique"> | number | null
    clc_3_foret_semiNaturel?: FloatNullableFilter<"confort_thermique"> | number | null
    clc_4_humide?: FloatNullableFilter<"confort_thermique"> | number | null
    clc_5_eau?: FloatNullableFilter<"confort_thermique"> | number | null
    superf_choro?: FloatNullableFilter<"confort_thermique"> | number | null
  }, "index">

  export type confort_thermiqueOrderByWithAggregationInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrderInput | SortOrder
    libelle_petr?: SortOrderInput | SortOrder
    code_pnr?: SortOrderInput | SortOrder
    libelle_pnr?: SortOrderInput | SortOrder
    age_bati_post06?: SortOrderInput | SortOrder
    age_bati_91_05?: SortOrderInput | SortOrder
    age_bati_46_90?: SortOrderInput | SortOrder
    age_bati_19_45?: SortOrderInput | SortOrder
    age_bati_pre_19?: SortOrderInput | SortOrder
    under_4_sum_1968?: SortOrderInput | SortOrder
    to_75_sum_1968?: SortOrderInput | SortOrder
    over_75_sum_1968?: SortOrderInput | SortOrder
    under_4_sum_1975?: SortOrderInput | SortOrder
    to_75_sum_1975?: SortOrderInput | SortOrder
    over_75_sum_1975?: SortOrderInput | SortOrder
    under_4_sum_1982?: SortOrderInput | SortOrder
    to_75_sum_1982?: SortOrderInput | SortOrder
    over_75_sum_1982?: SortOrderInput | SortOrder
    under_4_sum_1990?: SortOrderInput | SortOrder
    to_75_sum_1990?: SortOrderInput | SortOrder
    over_75_sum_1990?: SortOrderInput | SortOrder
    under_4_sum_1999?: SortOrderInput | SortOrder
    to_75_sum_1999?: SortOrderInput | SortOrder
    over_75_sum_1999?: SortOrderInput | SortOrder
    under_4_sum_2009?: SortOrderInput | SortOrder
    to_75_sum_2009?: SortOrderInput | SortOrder
    over_75_sum_2009?: SortOrderInput | SortOrder
    under_4_sum_2014?: SortOrderInput | SortOrder
    to_75_sum_2014?: SortOrderInput | SortOrder
    over_75_sum_2014?: SortOrderInput | SortOrder
    under_4_sum_2020?: SortOrderInput | SortOrder
    to_75_sum_2020?: SortOrderInput | SortOrder
    over_75_sum_2020?: SortOrderInput | SortOrder
    tee_log?: SortOrderInput | SortOrder
    tee_mob?: SortOrderInput | SortOrder
    precarite_logement?: SortOrderInput | SortOrder
    NA5AZ_sum?: SortOrderInput | SortOrder
    NA5BE_sum?: SortOrderInput | SortOrder
    NA5FZ_sum?: SortOrderInput | SortOrder
    NA5GU_sum?: SortOrderInput | SortOrder
    NA5OQ_sum?: SortOrderInput | SortOrder
    clc_1_artificialise?: SortOrderInput | SortOrder
    clc_2_agricole?: SortOrderInput | SortOrder
    clc_3_foret_semiNaturel?: SortOrderInput | SortOrder
    clc_4_humide?: SortOrderInput | SortOrder
    clc_5_eau?: SortOrderInput | SortOrder
    superf_choro?: SortOrderInput | SortOrder
    _count?: confort_thermiqueCountOrderByAggregateInput
    _avg?: confort_thermiqueAvgOrderByAggregateInput
    _max?: confort_thermiqueMaxOrderByAggregateInput
    _min?: confort_thermiqueMinOrderByAggregateInput
    _sum?: confort_thermiqueSumOrderByAggregateInput
  }

  export type confort_thermiqueScalarWhereWithAggregatesInput = {
    AND?: confort_thermiqueScalarWhereWithAggregatesInput | confort_thermiqueScalarWhereWithAggregatesInput[]
    OR?: confort_thermiqueScalarWhereWithAggregatesInput[]
    NOT?: confort_thermiqueScalarWhereWithAggregatesInput | confort_thermiqueScalarWhereWithAggregatesInput[]
    index?: IntWithAggregatesFilter<"confort_thermique"> | number
    code_geographique?: StringWithAggregatesFilter<"confort_thermique"> | string
    libelle_geographique?: StringWithAggregatesFilter<"confort_thermique"> | string
    epci?: StringWithAggregatesFilter<"confort_thermique"> | string
    libelle_epci?: StringWithAggregatesFilter<"confort_thermique"> | string
    departement?: StringWithAggregatesFilter<"confort_thermique"> | string
    libelle_departement?: StringWithAggregatesFilter<"confort_thermique"> | string
    region?: IntWithAggregatesFilter<"confort_thermique"> | number
    ept?: StringNullableWithAggregatesFilter<"confort_thermique"> | string | null
    libelle_petr?: StringNullableWithAggregatesFilter<"confort_thermique"> | string | null
    code_pnr?: StringNullableWithAggregatesFilter<"confort_thermique"> | string | null
    libelle_pnr?: StringNullableWithAggregatesFilter<"confort_thermique"> | string | null
    age_bati_post06?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    age_bati_91_05?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    age_bati_46_90?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    age_bati_19_45?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    age_bati_pre_19?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    under_4_sum_1968?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    to_75_sum_1968?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    over_75_sum_1968?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    under_4_sum_1975?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    to_75_sum_1975?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    over_75_sum_1975?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    under_4_sum_1982?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    to_75_sum_1982?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    over_75_sum_1982?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    under_4_sum_1990?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    to_75_sum_1990?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    over_75_sum_1990?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    under_4_sum_1999?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    to_75_sum_1999?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    over_75_sum_1999?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    under_4_sum_2009?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    to_75_sum_2009?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    over_75_sum_2009?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    under_4_sum_2014?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    to_75_sum_2014?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    over_75_sum_2014?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    under_4_sum_2020?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    to_75_sum_2020?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    over_75_sum_2020?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    tee_log?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    tee_mob?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    precarite_logement?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    NA5AZ_sum?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    NA5BE_sum?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    NA5FZ_sum?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    NA5GU_sum?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    NA5OQ_sum?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    clc_1_artificialise?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    clc_2_agricole?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    clc_3_foret_semiNaturel?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    clc_4_humide?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    clc_5_eau?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
    superf_choro?: FloatNullableWithAggregatesFilter<"confort_thermique"> | number | null
  }

  export type consommation_espaces_nafWhereInput = {
    AND?: consommation_espaces_nafWhereInput | consommation_espaces_nafWhereInput[]
    OR?: consommation_espaces_nafWhereInput[]
    NOT?: consommation_espaces_nafWhereInput | consommation_espaces_nafWhereInput[]
    index?: IntFilter<"consommation_espaces_naf"> | number
    code_geographique?: StringFilter<"consommation_espaces_naf"> | string
    libelle_geographique?: StringFilter<"consommation_espaces_naf"> | string
    epci?: StringFilter<"consommation_espaces_naf"> | string
    libelle_epci?: StringFilter<"consommation_espaces_naf"> | string
    departement?: StringFilter<"consommation_espaces_naf"> | string
    libelle_departement?: StringFilter<"consommation_espaces_naf"> | string
    region?: FloatFilter<"consommation_espaces_naf"> | number
    ept?: StringNullableFilter<"consommation_espaces_naf"> | string | null
    libelle_petr?: StringNullableFilter<"consommation_espaces_naf"> | string | null
    code_pnr?: StringNullableFilter<"consommation_espaces_naf"> | string | null
    libelle_pnr?: StringNullableFilter<"consommation_espaces_naf"> | string | null
    naf09art10?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art09act10?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art09hab10?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art09mix10?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art09rou10?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art09fer10?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art09inc10?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    naf10art11?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art10act11?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art10hab11?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art10mix11?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art10rou11?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art10fer11?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art10inc11?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    naf11art12?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art11act12?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art11hab12?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art11mix12?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art11rou12?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art11fer12?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art11inc12?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    naf12art13?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art12act13?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art12hab13?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art12mix13?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art12rou13?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art12fer13?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art12inc13?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    naf13art14?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art13act14?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art13hab14?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art13mix14?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art13rou14?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art13fer14?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art13inc14?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    naf14art15?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art14act15?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art14hab15?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art14mix15?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art14rou15?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art14fer15?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art14inc15?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    naf15art16?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art15act16?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art15hab16?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art15mix16?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art15rou16?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art15fer16?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art15inc16?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    naf16art17?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art16act17?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art16hab17?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art16mix17?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art16rou17?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art16fer17?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art16inc17?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    naf17art18?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art17act18?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art17hab18?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art17mix18?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art17rou18?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art17fer18?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art17inc18?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    naf18art19?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art18act19?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art18hab19?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art18mix19?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art18rou19?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art18fer19?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art18inc19?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    naf19art20?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art19act20?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art19hab20?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art19mix20?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art19rou20?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art19fer20?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art19inc20?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    naf20art21?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art20act21?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art20hab21?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art20mix21?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art20rou21?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art20fer21?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art20inc21?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    naf21art22?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art21act22?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art21hab22?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art21mix22?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art21rou22?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art21fer22?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art21inc22?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    naf22art23?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art22act23?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art22hab23?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art22mix23?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art22rou23?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art22fer23?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art22inc23?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    naf09art23?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art09act23?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art09hab23?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art09mix23?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art09inc23?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art09rou23?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art09fer23?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    artcom0923?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
  }

  export type consommation_espaces_nafOrderByWithRelationInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrderInput | SortOrder
    libelle_petr?: SortOrderInput | SortOrder
    code_pnr?: SortOrderInput | SortOrder
    libelle_pnr?: SortOrderInput | SortOrder
    naf09art10?: SortOrderInput | SortOrder
    art09act10?: SortOrderInput | SortOrder
    art09hab10?: SortOrderInput | SortOrder
    art09mix10?: SortOrderInput | SortOrder
    art09rou10?: SortOrderInput | SortOrder
    art09fer10?: SortOrderInput | SortOrder
    art09inc10?: SortOrderInput | SortOrder
    naf10art11?: SortOrderInput | SortOrder
    art10act11?: SortOrderInput | SortOrder
    art10hab11?: SortOrderInput | SortOrder
    art10mix11?: SortOrderInput | SortOrder
    art10rou11?: SortOrderInput | SortOrder
    art10fer11?: SortOrderInput | SortOrder
    art10inc11?: SortOrderInput | SortOrder
    naf11art12?: SortOrderInput | SortOrder
    art11act12?: SortOrderInput | SortOrder
    art11hab12?: SortOrderInput | SortOrder
    art11mix12?: SortOrderInput | SortOrder
    art11rou12?: SortOrderInput | SortOrder
    art11fer12?: SortOrderInput | SortOrder
    art11inc12?: SortOrderInput | SortOrder
    naf12art13?: SortOrderInput | SortOrder
    art12act13?: SortOrderInput | SortOrder
    art12hab13?: SortOrderInput | SortOrder
    art12mix13?: SortOrderInput | SortOrder
    art12rou13?: SortOrderInput | SortOrder
    art12fer13?: SortOrderInput | SortOrder
    art12inc13?: SortOrderInput | SortOrder
    naf13art14?: SortOrderInput | SortOrder
    art13act14?: SortOrderInput | SortOrder
    art13hab14?: SortOrderInput | SortOrder
    art13mix14?: SortOrderInput | SortOrder
    art13rou14?: SortOrderInput | SortOrder
    art13fer14?: SortOrderInput | SortOrder
    art13inc14?: SortOrderInput | SortOrder
    naf14art15?: SortOrderInput | SortOrder
    art14act15?: SortOrderInput | SortOrder
    art14hab15?: SortOrderInput | SortOrder
    art14mix15?: SortOrderInput | SortOrder
    art14rou15?: SortOrderInput | SortOrder
    art14fer15?: SortOrderInput | SortOrder
    art14inc15?: SortOrderInput | SortOrder
    naf15art16?: SortOrderInput | SortOrder
    art15act16?: SortOrderInput | SortOrder
    art15hab16?: SortOrderInput | SortOrder
    art15mix16?: SortOrderInput | SortOrder
    art15rou16?: SortOrderInput | SortOrder
    art15fer16?: SortOrderInput | SortOrder
    art15inc16?: SortOrderInput | SortOrder
    naf16art17?: SortOrderInput | SortOrder
    art16act17?: SortOrderInput | SortOrder
    art16hab17?: SortOrderInput | SortOrder
    art16mix17?: SortOrderInput | SortOrder
    art16rou17?: SortOrderInput | SortOrder
    art16fer17?: SortOrderInput | SortOrder
    art16inc17?: SortOrderInput | SortOrder
    naf17art18?: SortOrderInput | SortOrder
    art17act18?: SortOrderInput | SortOrder
    art17hab18?: SortOrderInput | SortOrder
    art17mix18?: SortOrderInput | SortOrder
    art17rou18?: SortOrderInput | SortOrder
    art17fer18?: SortOrderInput | SortOrder
    art17inc18?: SortOrderInput | SortOrder
    naf18art19?: SortOrderInput | SortOrder
    art18act19?: SortOrderInput | SortOrder
    art18hab19?: SortOrderInput | SortOrder
    art18mix19?: SortOrderInput | SortOrder
    art18rou19?: SortOrderInput | SortOrder
    art18fer19?: SortOrderInput | SortOrder
    art18inc19?: SortOrderInput | SortOrder
    naf19art20?: SortOrderInput | SortOrder
    art19act20?: SortOrderInput | SortOrder
    art19hab20?: SortOrderInput | SortOrder
    art19mix20?: SortOrderInput | SortOrder
    art19rou20?: SortOrderInput | SortOrder
    art19fer20?: SortOrderInput | SortOrder
    art19inc20?: SortOrderInput | SortOrder
    naf20art21?: SortOrderInput | SortOrder
    art20act21?: SortOrderInput | SortOrder
    art20hab21?: SortOrderInput | SortOrder
    art20mix21?: SortOrderInput | SortOrder
    art20rou21?: SortOrderInput | SortOrder
    art20fer21?: SortOrderInput | SortOrder
    art20inc21?: SortOrderInput | SortOrder
    naf21art22?: SortOrderInput | SortOrder
    art21act22?: SortOrderInput | SortOrder
    art21hab22?: SortOrderInput | SortOrder
    art21mix22?: SortOrderInput | SortOrder
    art21rou22?: SortOrderInput | SortOrder
    art21fer22?: SortOrderInput | SortOrder
    art21inc22?: SortOrderInput | SortOrder
    naf22art23?: SortOrderInput | SortOrder
    art22act23?: SortOrderInput | SortOrder
    art22hab23?: SortOrderInput | SortOrder
    art22mix23?: SortOrderInput | SortOrder
    art22rou23?: SortOrderInput | SortOrder
    art22fer23?: SortOrderInput | SortOrder
    art22inc23?: SortOrderInput | SortOrder
    naf09art23?: SortOrderInput | SortOrder
    art09act23?: SortOrderInput | SortOrder
    art09hab23?: SortOrderInput | SortOrder
    art09mix23?: SortOrderInput | SortOrder
    art09inc23?: SortOrderInput | SortOrder
    art09rou23?: SortOrderInput | SortOrder
    art09fer23?: SortOrderInput | SortOrder
    artcom0923?: SortOrderInput | SortOrder
  }

  export type consommation_espaces_nafWhereUniqueInput = Prisma.AtLeast<{
    index?: number
    AND?: consommation_espaces_nafWhereInput | consommation_espaces_nafWhereInput[]
    OR?: consommation_espaces_nafWhereInput[]
    NOT?: consommation_espaces_nafWhereInput | consommation_espaces_nafWhereInput[]
    code_geographique?: StringFilter<"consommation_espaces_naf"> | string
    libelle_geographique?: StringFilter<"consommation_espaces_naf"> | string
    epci?: StringFilter<"consommation_espaces_naf"> | string
    libelle_epci?: StringFilter<"consommation_espaces_naf"> | string
    departement?: StringFilter<"consommation_espaces_naf"> | string
    libelle_departement?: StringFilter<"consommation_espaces_naf"> | string
    region?: FloatFilter<"consommation_espaces_naf"> | number
    ept?: StringNullableFilter<"consommation_espaces_naf"> | string | null
    libelle_petr?: StringNullableFilter<"consommation_espaces_naf"> | string | null
    code_pnr?: StringNullableFilter<"consommation_espaces_naf"> | string | null
    libelle_pnr?: StringNullableFilter<"consommation_espaces_naf"> | string | null
    naf09art10?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art09act10?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art09hab10?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art09mix10?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art09rou10?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art09fer10?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art09inc10?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    naf10art11?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art10act11?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art10hab11?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art10mix11?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art10rou11?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art10fer11?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art10inc11?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    naf11art12?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art11act12?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art11hab12?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art11mix12?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art11rou12?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art11fer12?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art11inc12?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    naf12art13?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art12act13?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art12hab13?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art12mix13?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art12rou13?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art12fer13?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art12inc13?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    naf13art14?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art13act14?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art13hab14?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art13mix14?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art13rou14?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art13fer14?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art13inc14?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    naf14art15?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art14act15?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art14hab15?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art14mix15?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art14rou15?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art14fer15?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art14inc15?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    naf15art16?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art15act16?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art15hab16?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art15mix16?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art15rou16?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art15fer16?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art15inc16?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    naf16art17?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art16act17?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art16hab17?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art16mix17?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art16rou17?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art16fer17?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art16inc17?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    naf17art18?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art17act18?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art17hab18?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art17mix18?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art17rou18?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art17fer18?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art17inc18?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    naf18art19?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art18act19?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art18hab19?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art18mix19?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art18rou19?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art18fer19?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art18inc19?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    naf19art20?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art19act20?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art19hab20?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art19mix20?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art19rou20?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art19fer20?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art19inc20?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    naf20art21?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art20act21?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art20hab21?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art20mix21?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art20rou21?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art20fer21?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art20inc21?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    naf21art22?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art21act22?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art21hab22?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art21mix22?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art21rou22?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art21fer22?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art21inc22?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    naf22art23?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art22act23?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art22hab23?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art22mix23?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art22rou23?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art22fer23?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art22inc23?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    naf09art23?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art09act23?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art09hab23?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art09mix23?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art09inc23?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art09rou23?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    art09fer23?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
    artcom0923?: FloatNullableFilter<"consommation_espaces_naf"> | number | null
  }, "index">

  export type consommation_espaces_nafOrderByWithAggregationInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrderInput | SortOrder
    libelle_petr?: SortOrderInput | SortOrder
    code_pnr?: SortOrderInput | SortOrder
    libelle_pnr?: SortOrderInput | SortOrder
    naf09art10?: SortOrderInput | SortOrder
    art09act10?: SortOrderInput | SortOrder
    art09hab10?: SortOrderInput | SortOrder
    art09mix10?: SortOrderInput | SortOrder
    art09rou10?: SortOrderInput | SortOrder
    art09fer10?: SortOrderInput | SortOrder
    art09inc10?: SortOrderInput | SortOrder
    naf10art11?: SortOrderInput | SortOrder
    art10act11?: SortOrderInput | SortOrder
    art10hab11?: SortOrderInput | SortOrder
    art10mix11?: SortOrderInput | SortOrder
    art10rou11?: SortOrderInput | SortOrder
    art10fer11?: SortOrderInput | SortOrder
    art10inc11?: SortOrderInput | SortOrder
    naf11art12?: SortOrderInput | SortOrder
    art11act12?: SortOrderInput | SortOrder
    art11hab12?: SortOrderInput | SortOrder
    art11mix12?: SortOrderInput | SortOrder
    art11rou12?: SortOrderInput | SortOrder
    art11fer12?: SortOrderInput | SortOrder
    art11inc12?: SortOrderInput | SortOrder
    naf12art13?: SortOrderInput | SortOrder
    art12act13?: SortOrderInput | SortOrder
    art12hab13?: SortOrderInput | SortOrder
    art12mix13?: SortOrderInput | SortOrder
    art12rou13?: SortOrderInput | SortOrder
    art12fer13?: SortOrderInput | SortOrder
    art12inc13?: SortOrderInput | SortOrder
    naf13art14?: SortOrderInput | SortOrder
    art13act14?: SortOrderInput | SortOrder
    art13hab14?: SortOrderInput | SortOrder
    art13mix14?: SortOrderInput | SortOrder
    art13rou14?: SortOrderInput | SortOrder
    art13fer14?: SortOrderInput | SortOrder
    art13inc14?: SortOrderInput | SortOrder
    naf14art15?: SortOrderInput | SortOrder
    art14act15?: SortOrderInput | SortOrder
    art14hab15?: SortOrderInput | SortOrder
    art14mix15?: SortOrderInput | SortOrder
    art14rou15?: SortOrderInput | SortOrder
    art14fer15?: SortOrderInput | SortOrder
    art14inc15?: SortOrderInput | SortOrder
    naf15art16?: SortOrderInput | SortOrder
    art15act16?: SortOrderInput | SortOrder
    art15hab16?: SortOrderInput | SortOrder
    art15mix16?: SortOrderInput | SortOrder
    art15rou16?: SortOrderInput | SortOrder
    art15fer16?: SortOrderInput | SortOrder
    art15inc16?: SortOrderInput | SortOrder
    naf16art17?: SortOrderInput | SortOrder
    art16act17?: SortOrderInput | SortOrder
    art16hab17?: SortOrderInput | SortOrder
    art16mix17?: SortOrderInput | SortOrder
    art16rou17?: SortOrderInput | SortOrder
    art16fer17?: SortOrderInput | SortOrder
    art16inc17?: SortOrderInput | SortOrder
    naf17art18?: SortOrderInput | SortOrder
    art17act18?: SortOrderInput | SortOrder
    art17hab18?: SortOrderInput | SortOrder
    art17mix18?: SortOrderInput | SortOrder
    art17rou18?: SortOrderInput | SortOrder
    art17fer18?: SortOrderInput | SortOrder
    art17inc18?: SortOrderInput | SortOrder
    naf18art19?: SortOrderInput | SortOrder
    art18act19?: SortOrderInput | SortOrder
    art18hab19?: SortOrderInput | SortOrder
    art18mix19?: SortOrderInput | SortOrder
    art18rou19?: SortOrderInput | SortOrder
    art18fer19?: SortOrderInput | SortOrder
    art18inc19?: SortOrderInput | SortOrder
    naf19art20?: SortOrderInput | SortOrder
    art19act20?: SortOrderInput | SortOrder
    art19hab20?: SortOrderInput | SortOrder
    art19mix20?: SortOrderInput | SortOrder
    art19rou20?: SortOrderInput | SortOrder
    art19fer20?: SortOrderInput | SortOrder
    art19inc20?: SortOrderInput | SortOrder
    naf20art21?: SortOrderInput | SortOrder
    art20act21?: SortOrderInput | SortOrder
    art20hab21?: SortOrderInput | SortOrder
    art20mix21?: SortOrderInput | SortOrder
    art20rou21?: SortOrderInput | SortOrder
    art20fer21?: SortOrderInput | SortOrder
    art20inc21?: SortOrderInput | SortOrder
    naf21art22?: SortOrderInput | SortOrder
    art21act22?: SortOrderInput | SortOrder
    art21hab22?: SortOrderInput | SortOrder
    art21mix22?: SortOrderInput | SortOrder
    art21rou22?: SortOrderInput | SortOrder
    art21fer22?: SortOrderInput | SortOrder
    art21inc22?: SortOrderInput | SortOrder
    naf22art23?: SortOrderInput | SortOrder
    art22act23?: SortOrderInput | SortOrder
    art22hab23?: SortOrderInput | SortOrder
    art22mix23?: SortOrderInput | SortOrder
    art22rou23?: SortOrderInput | SortOrder
    art22fer23?: SortOrderInput | SortOrder
    art22inc23?: SortOrderInput | SortOrder
    naf09art23?: SortOrderInput | SortOrder
    art09act23?: SortOrderInput | SortOrder
    art09hab23?: SortOrderInput | SortOrder
    art09mix23?: SortOrderInput | SortOrder
    art09inc23?: SortOrderInput | SortOrder
    art09rou23?: SortOrderInput | SortOrder
    art09fer23?: SortOrderInput | SortOrder
    artcom0923?: SortOrderInput | SortOrder
    _count?: consommation_espaces_nafCountOrderByAggregateInput
    _avg?: consommation_espaces_nafAvgOrderByAggregateInput
    _max?: consommation_espaces_nafMaxOrderByAggregateInput
    _min?: consommation_espaces_nafMinOrderByAggregateInput
    _sum?: consommation_espaces_nafSumOrderByAggregateInput
  }

  export type consommation_espaces_nafScalarWhereWithAggregatesInput = {
    AND?: consommation_espaces_nafScalarWhereWithAggregatesInput | consommation_espaces_nafScalarWhereWithAggregatesInput[]
    OR?: consommation_espaces_nafScalarWhereWithAggregatesInput[]
    NOT?: consommation_espaces_nafScalarWhereWithAggregatesInput | consommation_espaces_nafScalarWhereWithAggregatesInput[]
    index?: IntWithAggregatesFilter<"consommation_espaces_naf"> | number
    code_geographique?: StringWithAggregatesFilter<"consommation_espaces_naf"> | string
    libelle_geographique?: StringWithAggregatesFilter<"consommation_espaces_naf"> | string
    epci?: StringWithAggregatesFilter<"consommation_espaces_naf"> | string
    libelle_epci?: StringWithAggregatesFilter<"consommation_espaces_naf"> | string
    departement?: StringWithAggregatesFilter<"consommation_espaces_naf"> | string
    libelle_departement?: StringWithAggregatesFilter<"consommation_espaces_naf"> | string
    region?: FloatWithAggregatesFilter<"consommation_espaces_naf"> | number
    ept?: StringNullableWithAggregatesFilter<"consommation_espaces_naf"> | string | null
    libelle_petr?: StringNullableWithAggregatesFilter<"consommation_espaces_naf"> | string | null
    code_pnr?: StringNullableWithAggregatesFilter<"consommation_espaces_naf"> | string | null
    libelle_pnr?: StringNullableWithAggregatesFilter<"consommation_espaces_naf"> | string | null
    naf09art10?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art09act10?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art09hab10?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art09mix10?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art09rou10?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art09fer10?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art09inc10?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    naf10art11?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art10act11?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art10hab11?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art10mix11?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art10rou11?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art10fer11?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art10inc11?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    naf11art12?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art11act12?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art11hab12?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art11mix12?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art11rou12?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art11fer12?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art11inc12?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    naf12art13?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art12act13?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art12hab13?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art12mix13?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art12rou13?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art12fer13?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art12inc13?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    naf13art14?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art13act14?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art13hab14?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art13mix14?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art13rou14?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art13fer14?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art13inc14?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    naf14art15?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art14act15?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art14hab15?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art14mix15?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art14rou15?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art14fer15?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art14inc15?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    naf15art16?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art15act16?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art15hab16?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art15mix16?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art15rou16?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art15fer16?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art15inc16?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    naf16art17?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art16act17?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art16hab17?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art16mix17?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art16rou17?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art16fer17?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art16inc17?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    naf17art18?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art17act18?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art17hab18?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art17mix18?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art17rou18?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art17fer18?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art17inc18?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    naf18art19?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art18act19?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art18hab19?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art18mix19?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art18rou19?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art18fer19?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art18inc19?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    naf19art20?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art19act20?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art19hab20?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art19mix20?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art19rou20?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art19fer20?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art19inc20?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    naf20art21?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art20act21?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art20hab21?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art20mix21?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art20rou21?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art20fer21?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art20inc21?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    naf21art22?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art21act22?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art21hab22?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art21mix22?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art21rou22?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art21fer22?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art21inc22?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    naf22art23?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art22act23?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art22hab23?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art22mix23?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art22rou23?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art22fer23?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art22inc23?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    naf09art23?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art09act23?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art09hab23?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art09mix23?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art09inc23?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art09rou23?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    art09fer23?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
    artcom0923?: FloatNullableWithAggregatesFilter<"consommation_espaces_naf"> | number | null
  }

  export type export_cours_d_eauWhereInput = {
    AND?: export_cours_d_eauWhereInput | export_cours_d_eauWhereInput[]
    OR?: export_cours_d_eauWhereInput[]
    NOT?: export_cours_d_eauWhereInput | export_cours_d_eauWhereInput[]
    index?: IntFilter<"export_cours_d_eau"> | number
    code_geographique?: StringFilter<"export_cours_d_eau"> | string
    libelle_geographique?: StringFilter<"export_cours_d_eau"> | string
    epci?: StringFilter<"export_cours_d_eau"> | string
    libelle_epci?: StringFilter<"export_cours_d_eau"> | string
    departement?: StringFilter<"export_cours_d_eau"> | string
    libelle_departement?: StringFilter<"export_cours_d_eau"> | string
    region?: FloatFilter<"export_cours_d_eau"> | number
    ept?: StringNullableFilter<"export_cours_d_eau"> | string | null
    libelle_petr?: StringNullableFilter<"export_cours_d_eau"> | string | null
    code_pnr?: StringNullableFilter<"export_cours_d_eau"> | string | null
    libelle_pnr?: StringNullableFilter<"export_cours_d_eau"> | string | null
    cours_d_eau?: StringFilter<"export_cours_d_eau"> | string
    etat_ecologique?: StringNullableFilter<"export_cours_d_eau"> | string | null
    longueur?: FloatFilter<"export_cours_d_eau"> | number
  }

  export type export_cours_d_eauOrderByWithRelationInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrderInput | SortOrder
    libelle_petr?: SortOrderInput | SortOrder
    code_pnr?: SortOrderInput | SortOrder
    libelle_pnr?: SortOrderInput | SortOrder
    cours_d_eau?: SortOrder
    etat_ecologique?: SortOrderInput | SortOrder
    longueur?: SortOrder
  }

  export type export_cours_d_eauWhereUniqueInput = Prisma.AtLeast<{
    index?: number
    AND?: export_cours_d_eauWhereInput | export_cours_d_eauWhereInput[]
    OR?: export_cours_d_eauWhereInput[]
    NOT?: export_cours_d_eauWhereInput | export_cours_d_eauWhereInput[]
    code_geographique?: StringFilter<"export_cours_d_eau"> | string
    libelle_geographique?: StringFilter<"export_cours_d_eau"> | string
    epci?: StringFilter<"export_cours_d_eau"> | string
    libelle_epci?: StringFilter<"export_cours_d_eau"> | string
    departement?: StringFilter<"export_cours_d_eau"> | string
    libelle_departement?: StringFilter<"export_cours_d_eau"> | string
    region?: FloatFilter<"export_cours_d_eau"> | number
    ept?: StringNullableFilter<"export_cours_d_eau"> | string | null
    libelle_petr?: StringNullableFilter<"export_cours_d_eau"> | string | null
    code_pnr?: StringNullableFilter<"export_cours_d_eau"> | string | null
    libelle_pnr?: StringNullableFilter<"export_cours_d_eau"> | string | null
    cours_d_eau?: StringFilter<"export_cours_d_eau"> | string
    etat_ecologique?: StringNullableFilter<"export_cours_d_eau"> | string | null
    longueur?: FloatFilter<"export_cours_d_eau"> | number
  }, "index">

  export type export_cours_d_eauOrderByWithAggregationInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrderInput | SortOrder
    libelle_petr?: SortOrderInput | SortOrder
    code_pnr?: SortOrderInput | SortOrder
    libelle_pnr?: SortOrderInput | SortOrder
    cours_d_eau?: SortOrder
    etat_ecologique?: SortOrderInput | SortOrder
    longueur?: SortOrder
    _count?: export_cours_d_eauCountOrderByAggregateInput
    _avg?: export_cours_d_eauAvgOrderByAggregateInput
    _max?: export_cours_d_eauMaxOrderByAggregateInput
    _min?: export_cours_d_eauMinOrderByAggregateInput
    _sum?: export_cours_d_eauSumOrderByAggregateInput
  }

  export type export_cours_d_eauScalarWhereWithAggregatesInput = {
    AND?: export_cours_d_eauScalarWhereWithAggregatesInput | export_cours_d_eauScalarWhereWithAggregatesInput[]
    OR?: export_cours_d_eauScalarWhereWithAggregatesInput[]
    NOT?: export_cours_d_eauScalarWhereWithAggregatesInput | export_cours_d_eauScalarWhereWithAggregatesInput[]
    index?: IntWithAggregatesFilter<"export_cours_d_eau"> | number
    code_geographique?: StringWithAggregatesFilter<"export_cours_d_eau"> | string
    libelle_geographique?: StringWithAggregatesFilter<"export_cours_d_eau"> | string
    epci?: StringWithAggregatesFilter<"export_cours_d_eau"> | string
    libelle_epci?: StringWithAggregatesFilter<"export_cours_d_eau"> | string
    departement?: StringWithAggregatesFilter<"export_cours_d_eau"> | string
    libelle_departement?: StringWithAggregatesFilter<"export_cours_d_eau"> | string
    region?: FloatWithAggregatesFilter<"export_cours_d_eau"> | number
    ept?: StringNullableWithAggregatesFilter<"export_cours_d_eau"> | string | null
    libelle_petr?: StringNullableWithAggregatesFilter<"export_cours_d_eau"> | string | null
    code_pnr?: StringNullableWithAggregatesFilter<"export_cours_d_eau"> | string | null
    libelle_pnr?: StringNullableWithAggregatesFilter<"export_cours_d_eau"> | string | null
    cours_d_eau?: StringWithAggregatesFilter<"export_cours_d_eau"> | string
    etat_ecologique?: StringNullableWithAggregatesFilter<"export_cours_d_eau"> | string | null
    longueur?: FloatWithAggregatesFilter<"export_cours_d_eau"> | number
  }

  export type feux_foretWhereInput = {
    AND?: feux_foretWhereInput | feux_foretWhereInput[]
    OR?: feux_foretWhereInput[]
    NOT?: feux_foretWhereInput | feux_foretWhereInput[]
    index?: IntFilter<"feux_foret"> | number
    code_geographique?: StringFilter<"feux_foret"> | string
    libelle_geographique?: StringFilter<"feux_foret"> | string
    epci?: StringFilter<"feux_foret"> | string
    libelle_epci?: StringFilter<"feux_foret"> | string
    departement?: StringFilter<"feux_foret"> | string
    libelle_departement?: StringFilter<"feux_foret"> | string
    region?: FloatFilter<"feux_foret"> | number
    ept?: StringNullableFilter<"feux_foret"> | string | null
    libelle_petr?: StringNullableFilter<"feux_foret"> | string | null
    code_pnr?: StringNullableFilter<"feux_foret"> | string | null
    libelle_pnr?: StringNullableFilter<"feux_foret"> | string | null
    annee?: FloatFilter<"feux_foret"> | number
    nature?: StringNullableFilter<"feux_foret"> | string | null
    surface_parcourue?: FloatFilter<"feux_foret"> | number
    surface_foret?: FloatNullableFilter<"feux_foret"> | number | null
    surface_maquis_garrigues?: FloatNullableFilter<"feux_foret"> | number | null
    autres_surfaces_naturelles_hors_foret?: FloatNullableFilter<"feux_foret"> | number | null
    surfaces_agricoles?: FloatNullableFilter<"feux_foret"> | number | null
    surfaces_non_boisees?: FloatNullableFilter<"feux_foret"> | number | null
    surfaces_non_boisees_artificialisees?: FloatNullableFilter<"feux_foret"> | number | null
    surfaces_non_boisees_naturelles?: FloatNullableFilter<"feux_foret"> | number | null
    surface_autres_terres_boisees?: FloatNullableFilter<"feux_foret"> | number | null
    autres_surfaces?: FloatNullableFilter<"feux_foret"> | number | null
  }

  export type feux_foretOrderByWithRelationInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrderInput | SortOrder
    libelle_petr?: SortOrderInput | SortOrder
    code_pnr?: SortOrderInput | SortOrder
    libelle_pnr?: SortOrderInput | SortOrder
    annee?: SortOrder
    nature?: SortOrderInput | SortOrder
    surface_parcourue?: SortOrder
    surface_foret?: SortOrderInput | SortOrder
    surface_maquis_garrigues?: SortOrderInput | SortOrder
    autres_surfaces_naturelles_hors_foret?: SortOrderInput | SortOrder
    surfaces_agricoles?: SortOrderInput | SortOrder
    surfaces_non_boisees?: SortOrderInput | SortOrder
    surfaces_non_boisees_artificialisees?: SortOrderInput | SortOrder
    surfaces_non_boisees_naturelles?: SortOrderInput | SortOrder
    surface_autres_terres_boisees?: SortOrderInput | SortOrder
    autres_surfaces?: SortOrderInput | SortOrder
  }

  export type feux_foretWhereUniqueInput = Prisma.AtLeast<{
    index?: number
    AND?: feux_foretWhereInput | feux_foretWhereInput[]
    OR?: feux_foretWhereInput[]
    NOT?: feux_foretWhereInput | feux_foretWhereInput[]
    code_geographique?: StringFilter<"feux_foret"> | string
    libelle_geographique?: StringFilter<"feux_foret"> | string
    epci?: StringFilter<"feux_foret"> | string
    libelle_epci?: StringFilter<"feux_foret"> | string
    departement?: StringFilter<"feux_foret"> | string
    libelle_departement?: StringFilter<"feux_foret"> | string
    region?: FloatFilter<"feux_foret"> | number
    ept?: StringNullableFilter<"feux_foret"> | string | null
    libelle_petr?: StringNullableFilter<"feux_foret"> | string | null
    code_pnr?: StringNullableFilter<"feux_foret"> | string | null
    libelle_pnr?: StringNullableFilter<"feux_foret"> | string | null
    annee?: FloatFilter<"feux_foret"> | number
    nature?: StringNullableFilter<"feux_foret"> | string | null
    surface_parcourue?: FloatFilter<"feux_foret"> | number
    surface_foret?: FloatNullableFilter<"feux_foret"> | number | null
    surface_maquis_garrigues?: FloatNullableFilter<"feux_foret"> | number | null
    autres_surfaces_naturelles_hors_foret?: FloatNullableFilter<"feux_foret"> | number | null
    surfaces_agricoles?: FloatNullableFilter<"feux_foret"> | number | null
    surfaces_non_boisees?: FloatNullableFilter<"feux_foret"> | number | null
    surfaces_non_boisees_artificialisees?: FloatNullableFilter<"feux_foret"> | number | null
    surfaces_non_boisees_naturelles?: FloatNullableFilter<"feux_foret"> | number | null
    surface_autres_terres_boisees?: FloatNullableFilter<"feux_foret"> | number | null
    autres_surfaces?: FloatNullableFilter<"feux_foret"> | number | null
  }, "index">

  export type feux_foretOrderByWithAggregationInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrderInput | SortOrder
    libelle_petr?: SortOrderInput | SortOrder
    code_pnr?: SortOrderInput | SortOrder
    libelle_pnr?: SortOrderInput | SortOrder
    annee?: SortOrder
    nature?: SortOrderInput | SortOrder
    surface_parcourue?: SortOrder
    surface_foret?: SortOrderInput | SortOrder
    surface_maquis_garrigues?: SortOrderInput | SortOrder
    autres_surfaces_naturelles_hors_foret?: SortOrderInput | SortOrder
    surfaces_agricoles?: SortOrderInput | SortOrder
    surfaces_non_boisees?: SortOrderInput | SortOrder
    surfaces_non_boisees_artificialisees?: SortOrderInput | SortOrder
    surfaces_non_boisees_naturelles?: SortOrderInput | SortOrder
    surface_autres_terres_boisees?: SortOrderInput | SortOrder
    autres_surfaces?: SortOrderInput | SortOrder
    _count?: feux_foretCountOrderByAggregateInput
    _avg?: feux_foretAvgOrderByAggregateInput
    _max?: feux_foretMaxOrderByAggregateInput
    _min?: feux_foretMinOrderByAggregateInput
    _sum?: feux_foretSumOrderByAggregateInput
  }

  export type feux_foretScalarWhereWithAggregatesInput = {
    AND?: feux_foretScalarWhereWithAggregatesInput | feux_foretScalarWhereWithAggregatesInput[]
    OR?: feux_foretScalarWhereWithAggregatesInput[]
    NOT?: feux_foretScalarWhereWithAggregatesInput | feux_foretScalarWhereWithAggregatesInput[]
    index?: IntWithAggregatesFilter<"feux_foret"> | number
    code_geographique?: StringWithAggregatesFilter<"feux_foret"> | string
    libelle_geographique?: StringWithAggregatesFilter<"feux_foret"> | string
    epci?: StringWithAggregatesFilter<"feux_foret"> | string
    libelle_epci?: StringWithAggregatesFilter<"feux_foret"> | string
    departement?: StringWithAggregatesFilter<"feux_foret"> | string
    libelle_departement?: StringWithAggregatesFilter<"feux_foret"> | string
    region?: FloatWithAggregatesFilter<"feux_foret"> | number
    ept?: StringNullableWithAggregatesFilter<"feux_foret"> | string | null
    libelle_petr?: StringNullableWithAggregatesFilter<"feux_foret"> | string | null
    code_pnr?: StringNullableWithAggregatesFilter<"feux_foret"> | string | null
    libelle_pnr?: StringNullableWithAggregatesFilter<"feux_foret"> | string | null
    annee?: FloatWithAggregatesFilter<"feux_foret"> | number
    nature?: StringNullableWithAggregatesFilter<"feux_foret"> | string | null
    surface_parcourue?: FloatWithAggregatesFilter<"feux_foret"> | number
    surface_foret?: FloatNullableWithAggregatesFilter<"feux_foret"> | number | null
    surface_maquis_garrigues?: FloatNullableWithAggregatesFilter<"feux_foret"> | number | null
    autres_surfaces_naturelles_hors_foret?: FloatNullableWithAggregatesFilter<"feux_foret"> | number | null
    surfaces_agricoles?: FloatNullableWithAggregatesFilter<"feux_foret"> | number | null
    surfaces_non_boisees?: FloatNullableWithAggregatesFilter<"feux_foret"> | number | null
    surfaces_non_boisees_artificialisees?: FloatNullableWithAggregatesFilter<"feux_foret"> | number | null
    surfaces_non_boisees_naturelles?: FloatNullableWithAggregatesFilter<"feux_foret"> | number | null
    surface_autres_terres_boisees?: FloatNullableWithAggregatesFilter<"feux_foret"> | number | null
    autres_surfaces?: FloatNullableWithAggregatesFilter<"feux_foret"> | number | null
  }

  export type lcz_couvertureWhereInput = {
    AND?: lcz_couvertureWhereInput | lcz_couvertureWhereInput[]
    OR?: lcz_couvertureWhereInput[]
    NOT?: lcz_couvertureWhereInput | lcz_couvertureWhereInput[]
    index?: IntFilter<"lcz_couverture"> | number
    code_geographique?: StringFilter<"lcz_couverture"> | string
    libelle_geographique?: StringNullableFilter<"lcz_couverture"> | string | null
    epci?: StringNullableFilter<"lcz_couverture"> | string | null
    libelle_epci?: StringNullableFilter<"lcz_couverture"> | string | null
    departement?: StringNullableFilter<"lcz_couverture"> | string | null
    libelle_departement?: StringNullableFilter<"lcz_couverture"> | string | null
    region?: FloatNullableFilter<"lcz_couverture"> | number | null
    ept?: StringNullableFilter<"lcz_couverture"> | string | null
    libelle_petr?: StringNullableFilter<"lcz_couverture"> | string | null
    code_pnr?: StringNullableFilter<"lcz_couverture"> | string | null
    libelle_pnr?: StringNullableFilter<"lcz_couverture"> | string | null
    couverture_lcz?: FloatFilter<"lcz_couverture"> | number
  }

  export type lcz_couvertureOrderByWithRelationInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrderInput | SortOrder
    epci?: SortOrderInput | SortOrder
    libelle_epci?: SortOrderInput | SortOrder
    departement?: SortOrderInput | SortOrder
    libelle_departement?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    ept?: SortOrderInput | SortOrder
    libelle_petr?: SortOrderInput | SortOrder
    code_pnr?: SortOrderInput | SortOrder
    libelle_pnr?: SortOrderInput | SortOrder
    couverture_lcz?: SortOrder
  }

  export type lcz_couvertureWhereUniqueInput = Prisma.AtLeast<{
    index?: number
    AND?: lcz_couvertureWhereInput | lcz_couvertureWhereInput[]
    OR?: lcz_couvertureWhereInput[]
    NOT?: lcz_couvertureWhereInput | lcz_couvertureWhereInput[]
    code_geographique?: StringFilter<"lcz_couverture"> | string
    libelle_geographique?: StringNullableFilter<"lcz_couverture"> | string | null
    epci?: StringNullableFilter<"lcz_couverture"> | string | null
    libelle_epci?: StringNullableFilter<"lcz_couverture"> | string | null
    departement?: StringNullableFilter<"lcz_couverture"> | string | null
    libelle_departement?: StringNullableFilter<"lcz_couverture"> | string | null
    region?: FloatNullableFilter<"lcz_couverture"> | number | null
    ept?: StringNullableFilter<"lcz_couverture"> | string | null
    libelle_petr?: StringNullableFilter<"lcz_couverture"> | string | null
    code_pnr?: StringNullableFilter<"lcz_couverture"> | string | null
    libelle_pnr?: StringNullableFilter<"lcz_couverture"> | string | null
    couverture_lcz?: FloatFilter<"lcz_couverture"> | number
  }, "index">

  export type lcz_couvertureOrderByWithAggregationInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrderInput | SortOrder
    epci?: SortOrderInput | SortOrder
    libelle_epci?: SortOrderInput | SortOrder
    departement?: SortOrderInput | SortOrder
    libelle_departement?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    ept?: SortOrderInput | SortOrder
    libelle_petr?: SortOrderInput | SortOrder
    code_pnr?: SortOrderInput | SortOrder
    libelle_pnr?: SortOrderInput | SortOrder
    couverture_lcz?: SortOrder
    _count?: lcz_couvertureCountOrderByAggregateInput
    _avg?: lcz_couvertureAvgOrderByAggregateInput
    _max?: lcz_couvertureMaxOrderByAggregateInput
    _min?: lcz_couvertureMinOrderByAggregateInput
    _sum?: lcz_couvertureSumOrderByAggregateInput
  }

  export type lcz_couvertureScalarWhereWithAggregatesInput = {
    AND?: lcz_couvertureScalarWhereWithAggregatesInput | lcz_couvertureScalarWhereWithAggregatesInput[]
    OR?: lcz_couvertureScalarWhereWithAggregatesInput[]
    NOT?: lcz_couvertureScalarWhereWithAggregatesInput | lcz_couvertureScalarWhereWithAggregatesInput[]
    index?: IntWithAggregatesFilter<"lcz_couverture"> | number
    code_geographique?: StringWithAggregatesFilter<"lcz_couverture"> | string
    libelle_geographique?: StringNullableWithAggregatesFilter<"lcz_couverture"> | string | null
    epci?: StringNullableWithAggregatesFilter<"lcz_couverture"> | string | null
    libelle_epci?: StringNullableWithAggregatesFilter<"lcz_couverture"> | string | null
    departement?: StringNullableWithAggregatesFilter<"lcz_couverture"> | string | null
    libelle_departement?: StringNullableWithAggregatesFilter<"lcz_couverture"> | string | null
    region?: FloatNullableWithAggregatesFilter<"lcz_couverture"> | number | null
    ept?: StringNullableWithAggregatesFilter<"lcz_couverture"> | string | null
    libelle_petr?: StringNullableWithAggregatesFilter<"lcz_couverture"> | string | null
    code_pnr?: StringNullableWithAggregatesFilter<"lcz_couverture"> | string | null
    libelle_pnr?: StringNullableWithAggregatesFilter<"lcz_couverture"> | string | null
    couverture_lcz?: FloatWithAggregatesFilter<"lcz_couverture"> | number
  }

  export type patch4cWhereInput = {
    AND?: patch4cWhereInput | patch4cWhereInput[]
    OR?: patch4cWhereInput[]
    NOT?: patch4cWhereInput | patch4cWhereInput[]
    index?: IntFilter<"patch4c"> | number
    code_geographique?: StringFilter<"patch4c"> | string
    niveaux_marins?: FloatNullableFilter<"patch4c"> | number | null
    feux_foret?: FloatFilter<"patch4c"> | number
    secheresse_sols?: FloatFilter<"patch4c"> | number
    fortes_precipitations?: FloatFilter<"patch4c"> | number
    fortes_chaleurs?: FloatFilter<"patch4c"> | number
  }

  export type patch4cOrderByWithRelationInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    niveaux_marins?: SortOrderInput | SortOrder
    feux_foret?: SortOrder
    secheresse_sols?: SortOrder
    fortes_precipitations?: SortOrder
    fortes_chaleurs?: SortOrder
  }

  export type patch4cWhereUniqueInput = Prisma.AtLeast<{
    index?: number
    AND?: patch4cWhereInput | patch4cWhereInput[]
    OR?: patch4cWhereInput[]
    NOT?: patch4cWhereInput | patch4cWhereInput[]
    code_geographique?: StringFilter<"patch4c"> | string
    niveaux_marins?: FloatNullableFilter<"patch4c"> | number | null
    feux_foret?: FloatFilter<"patch4c"> | number
    secheresse_sols?: FloatFilter<"patch4c"> | number
    fortes_precipitations?: FloatFilter<"patch4c"> | number
    fortes_chaleurs?: FloatFilter<"patch4c"> | number
  }, "index">

  export type patch4cOrderByWithAggregationInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    niveaux_marins?: SortOrderInput | SortOrder
    feux_foret?: SortOrder
    secheresse_sols?: SortOrder
    fortes_precipitations?: SortOrder
    fortes_chaleurs?: SortOrder
    _count?: patch4cCountOrderByAggregateInput
    _avg?: patch4cAvgOrderByAggregateInput
    _max?: patch4cMaxOrderByAggregateInput
    _min?: patch4cMinOrderByAggregateInput
    _sum?: patch4cSumOrderByAggregateInput
  }

  export type patch4cScalarWhereWithAggregatesInput = {
    AND?: patch4cScalarWhereWithAggregatesInput | patch4cScalarWhereWithAggregatesInput[]
    OR?: patch4cScalarWhereWithAggregatesInput[]
    NOT?: patch4cScalarWhereWithAggregatesInput | patch4cScalarWhereWithAggregatesInput[]
    index?: IntWithAggregatesFilter<"patch4c"> | number
    code_geographique?: StringWithAggregatesFilter<"patch4c"> | string
    niveaux_marins?: FloatNullableWithAggregatesFilter<"patch4c"> | number | null
    feux_foret?: FloatWithAggregatesFilter<"patch4c"> | number
    secheresse_sols?: FloatWithAggregatesFilter<"patch4c"> | number
    fortes_precipitations?: FloatWithAggregatesFilter<"patch4c"> | number
    fortes_chaleurs?: FloatWithAggregatesFilter<"patch4c"> | number
  }

  export type prelevements_eauWhereInput = {
    AND?: prelevements_eauWhereInput | prelevements_eauWhereInput[]
    OR?: prelevements_eauWhereInput[]
    NOT?: prelevements_eauWhereInput | prelevements_eauWhereInput[]
    index?: IntFilter<"prelevements_eau"> | number
    code_geographique?: StringFilter<"prelevements_eau"> | string
    libelle_geographique?: StringFilter<"prelevements_eau"> | string
    epci?: StringFilter<"prelevements_eau"> | string
    libelle_epci?: StringFilter<"prelevements_eau"> | string
    departement?: StringFilter<"prelevements_eau"> | string
    libelle_departement?: StringFilter<"prelevements_eau"> | string
    region?: IntFilter<"prelevements_eau"> | number
    ept?: StringNullableFilter<"prelevements_eau"> | string | null
    libelle_petr?: StringNullableFilter<"prelevements_eau"> | string | null
    code_pnr?: StringNullableFilter<"prelevements_eau"> | string | null
    libelle_pnr?: StringNullableFilter<"prelevements_eau"> | string | null
    libelle_sous_champ?: StringNullableFilter<"prelevements_eau"> | string | null
    A2020?: StringNullableFilter<"prelevements_eau"> | string | null
    A2019?: StringNullableFilter<"prelevements_eau"> | string | null
    A2018?: StringNullableFilter<"prelevements_eau"> | string | null
    A2017?: StringNullableFilter<"prelevements_eau"> | string | null
    A2016?: StringNullableFilter<"prelevements_eau"> | string | null
    A2015?: StringNullableFilter<"prelevements_eau"> | string | null
    A2014?: StringNullableFilter<"prelevements_eau"> | string | null
    A2013?: StringNullableFilter<"prelevements_eau"> | string | null
    A2012?: StringNullableFilter<"prelevements_eau"> | string | null
    A2011?: StringNullableFilter<"prelevements_eau"> | string | null
    A2010?: StringNullableFilter<"prelevements_eau"> | string | null
    A2009?: StringNullableFilter<"prelevements_eau"> | string | null
    A2008?: StringNullableFilter<"prelevements_eau"> | string | null
    sous_champ?: StringNullableFilter<"prelevements_eau"> | string | null
  }

  export type prelevements_eauOrderByWithRelationInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrderInput | SortOrder
    libelle_petr?: SortOrderInput | SortOrder
    code_pnr?: SortOrderInput | SortOrder
    libelle_pnr?: SortOrderInput | SortOrder
    libelle_sous_champ?: SortOrderInput | SortOrder
    A2020?: SortOrderInput | SortOrder
    A2019?: SortOrderInput | SortOrder
    A2018?: SortOrderInput | SortOrder
    A2017?: SortOrderInput | SortOrder
    A2016?: SortOrderInput | SortOrder
    A2015?: SortOrderInput | SortOrder
    A2014?: SortOrderInput | SortOrder
    A2013?: SortOrderInput | SortOrder
    A2012?: SortOrderInput | SortOrder
    A2011?: SortOrderInput | SortOrder
    A2010?: SortOrderInput | SortOrder
    A2009?: SortOrderInput | SortOrder
    A2008?: SortOrderInput | SortOrder
    sous_champ?: SortOrderInput | SortOrder
  }

  export type prelevements_eauWhereUniqueInput = Prisma.AtLeast<{
    index?: number
    AND?: prelevements_eauWhereInput | prelevements_eauWhereInput[]
    OR?: prelevements_eauWhereInput[]
    NOT?: prelevements_eauWhereInput | prelevements_eauWhereInput[]
    code_geographique?: StringFilter<"prelevements_eau"> | string
    libelle_geographique?: StringFilter<"prelevements_eau"> | string
    epci?: StringFilter<"prelevements_eau"> | string
    libelle_epci?: StringFilter<"prelevements_eau"> | string
    departement?: StringFilter<"prelevements_eau"> | string
    libelle_departement?: StringFilter<"prelevements_eau"> | string
    region?: IntFilter<"prelevements_eau"> | number
    ept?: StringNullableFilter<"prelevements_eau"> | string | null
    libelle_petr?: StringNullableFilter<"prelevements_eau"> | string | null
    code_pnr?: StringNullableFilter<"prelevements_eau"> | string | null
    libelle_pnr?: StringNullableFilter<"prelevements_eau"> | string | null
    libelle_sous_champ?: StringNullableFilter<"prelevements_eau"> | string | null
    A2020?: StringNullableFilter<"prelevements_eau"> | string | null
    A2019?: StringNullableFilter<"prelevements_eau"> | string | null
    A2018?: StringNullableFilter<"prelevements_eau"> | string | null
    A2017?: StringNullableFilter<"prelevements_eau"> | string | null
    A2016?: StringNullableFilter<"prelevements_eau"> | string | null
    A2015?: StringNullableFilter<"prelevements_eau"> | string | null
    A2014?: StringNullableFilter<"prelevements_eau"> | string | null
    A2013?: StringNullableFilter<"prelevements_eau"> | string | null
    A2012?: StringNullableFilter<"prelevements_eau"> | string | null
    A2011?: StringNullableFilter<"prelevements_eau"> | string | null
    A2010?: StringNullableFilter<"prelevements_eau"> | string | null
    A2009?: StringNullableFilter<"prelevements_eau"> | string | null
    A2008?: StringNullableFilter<"prelevements_eau"> | string | null
    sous_champ?: StringNullableFilter<"prelevements_eau"> | string | null
  }, "index">

  export type prelevements_eauOrderByWithAggregationInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrderInput | SortOrder
    libelle_petr?: SortOrderInput | SortOrder
    code_pnr?: SortOrderInput | SortOrder
    libelle_pnr?: SortOrderInput | SortOrder
    libelle_sous_champ?: SortOrderInput | SortOrder
    A2020?: SortOrderInput | SortOrder
    A2019?: SortOrderInput | SortOrder
    A2018?: SortOrderInput | SortOrder
    A2017?: SortOrderInput | SortOrder
    A2016?: SortOrderInput | SortOrder
    A2015?: SortOrderInput | SortOrder
    A2014?: SortOrderInput | SortOrder
    A2013?: SortOrderInput | SortOrder
    A2012?: SortOrderInput | SortOrder
    A2011?: SortOrderInput | SortOrder
    A2010?: SortOrderInput | SortOrder
    A2009?: SortOrderInput | SortOrder
    A2008?: SortOrderInput | SortOrder
    sous_champ?: SortOrderInput | SortOrder
    _count?: prelevements_eauCountOrderByAggregateInput
    _avg?: prelevements_eauAvgOrderByAggregateInput
    _max?: prelevements_eauMaxOrderByAggregateInput
    _min?: prelevements_eauMinOrderByAggregateInput
    _sum?: prelevements_eauSumOrderByAggregateInput
  }

  export type prelevements_eauScalarWhereWithAggregatesInput = {
    AND?: prelevements_eauScalarWhereWithAggregatesInput | prelevements_eauScalarWhereWithAggregatesInput[]
    OR?: prelevements_eauScalarWhereWithAggregatesInput[]
    NOT?: prelevements_eauScalarWhereWithAggregatesInput | prelevements_eauScalarWhereWithAggregatesInput[]
    index?: IntWithAggregatesFilter<"prelevements_eau"> | number
    code_geographique?: StringWithAggregatesFilter<"prelevements_eau"> | string
    libelle_geographique?: StringWithAggregatesFilter<"prelevements_eau"> | string
    epci?: StringWithAggregatesFilter<"prelevements_eau"> | string
    libelle_epci?: StringWithAggregatesFilter<"prelevements_eau"> | string
    departement?: StringWithAggregatesFilter<"prelevements_eau"> | string
    libelle_departement?: StringWithAggregatesFilter<"prelevements_eau"> | string
    region?: IntWithAggregatesFilter<"prelevements_eau"> | number
    ept?: StringNullableWithAggregatesFilter<"prelevements_eau"> | string | null
    libelle_petr?: StringNullableWithAggregatesFilter<"prelevements_eau"> | string | null
    code_pnr?: StringNullableWithAggregatesFilter<"prelevements_eau"> | string | null
    libelle_pnr?: StringNullableWithAggregatesFilter<"prelevements_eau"> | string | null
    libelle_sous_champ?: StringNullableWithAggregatesFilter<"prelevements_eau"> | string | null
    A2020?: StringNullableWithAggregatesFilter<"prelevements_eau"> | string | null
    A2019?: StringNullableWithAggregatesFilter<"prelevements_eau"> | string | null
    A2018?: StringNullableWithAggregatesFilter<"prelevements_eau"> | string | null
    A2017?: StringNullableWithAggregatesFilter<"prelevements_eau"> | string | null
    A2016?: StringNullableWithAggregatesFilter<"prelevements_eau"> | string | null
    A2015?: StringNullableWithAggregatesFilter<"prelevements_eau"> | string | null
    A2014?: StringNullableWithAggregatesFilter<"prelevements_eau"> | string | null
    A2013?: StringNullableWithAggregatesFilter<"prelevements_eau"> | string | null
    A2012?: StringNullableWithAggregatesFilter<"prelevements_eau"> | string | null
    A2011?: StringNullableWithAggregatesFilter<"prelevements_eau"> | string | null
    A2010?: StringNullableWithAggregatesFilter<"prelevements_eau"> | string | null
    A2009?: StringNullableWithAggregatesFilter<"prelevements_eau"> | string | null
    A2008?: StringNullableWithAggregatesFilter<"prelevements_eau"> | string | null
    sous_champ?: StringNullableWithAggregatesFilter<"prelevements_eau"> | string | null
  }

  export type qualite_sites_baignadeWhereInput = {
    AND?: qualite_sites_baignadeWhereInput | qualite_sites_baignadeWhereInput[]
    OR?: qualite_sites_baignadeWhereInput[]
    NOT?: qualite_sites_baignadeWhereInput | qualite_sites_baignadeWhereInput[]
    index?: IntFilter<"qualite_sites_baignade"> | number
    DEP_NOM?: StringFilter<"qualite_sites_baignade"> | string
    DEP_NUM?: StringFilter<"qualite_sites_baignade"> | string
    TYPE?: StringFilter<"qualite_sites_baignade"> | string
    COMMUNE?: StringFilter<"qualite_sites_baignade"> | string
    POINT?: StringFilter<"qualite_sites_baignade"> | string
    LONG?: FloatFilter<"qualite_sites_baignade"> | number
    LAT?: FloatFilter<"qualite_sites_baignade"> | number
    QEB_2013?: StringNullableFilter<"qualite_sites_baignade"> | string | null
    QEB_2014?: StringNullableFilter<"qualite_sites_baignade"> | string | null
    QEB_2015?: StringNullableFilter<"qualite_sites_baignade"> | string | null
    QEB_2016?: StringNullableFilter<"qualite_sites_baignade"> | string | null
    QEB_2017?: StringNullableFilter<"qualite_sites_baignade"> | string | null
    QEB_2018?: StringNullableFilter<"qualite_sites_baignade"> | string | null
    QEB_2019?: StringNullableFilter<"qualite_sites_baignade"> | string | null
    QEB_2020?: StringNullableFilter<"qualite_sites_baignade"> | string | null
  }

  export type qualite_sites_baignadeOrderByWithRelationInput = {
    index?: SortOrder
    DEP_NOM?: SortOrder
    DEP_NUM?: SortOrder
    TYPE?: SortOrder
    COMMUNE?: SortOrder
    POINT?: SortOrder
    LONG?: SortOrder
    LAT?: SortOrder
    QEB_2013?: SortOrderInput | SortOrder
    QEB_2014?: SortOrderInput | SortOrder
    QEB_2015?: SortOrderInput | SortOrder
    QEB_2016?: SortOrderInput | SortOrder
    QEB_2017?: SortOrderInput | SortOrder
    QEB_2018?: SortOrderInput | SortOrder
    QEB_2019?: SortOrderInput | SortOrder
    QEB_2020?: SortOrderInput | SortOrder
  }

  export type qualite_sites_baignadeWhereUniqueInput = Prisma.AtLeast<{
    index?: number
    AND?: qualite_sites_baignadeWhereInput | qualite_sites_baignadeWhereInput[]
    OR?: qualite_sites_baignadeWhereInput[]
    NOT?: qualite_sites_baignadeWhereInput | qualite_sites_baignadeWhereInput[]
    DEP_NOM?: StringFilter<"qualite_sites_baignade"> | string
    DEP_NUM?: StringFilter<"qualite_sites_baignade"> | string
    TYPE?: StringFilter<"qualite_sites_baignade"> | string
    COMMUNE?: StringFilter<"qualite_sites_baignade"> | string
    POINT?: StringFilter<"qualite_sites_baignade"> | string
    LONG?: FloatFilter<"qualite_sites_baignade"> | number
    LAT?: FloatFilter<"qualite_sites_baignade"> | number
    QEB_2013?: StringNullableFilter<"qualite_sites_baignade"> | string | null
    QEB_2014?: StringNullableFilter<"qualite_sites_baignade"> | string | null
    QEB_2015?: StringNullableFilter<"qualite_sites_baignade"> | string | null
    QEB_2016?: StringNullableFilter<"qualite_sites_baignade"> | string | null
    QEB_2017?: StringNullableFilter<"qualite_sites_baignade"> | string | null
    QEB_2018?: StringNullableFilter<"qualite_sites_baignade"> | string | null
    QEB_2019?: StringNullableFilter<"qualite_sites_baignade"> | string | null
    QEB_2020?: StringNullableFilter<"qualite_sites_baignade"> | string | null
  }, "index">

  export type qualite_sites_baignadeOrderByWithAggregationInput = {
    index?: SortOrder
    DEP_NOM?: SortOrder
    DEP_NUM?: SortOrder
    TYPE?: SortOrder
    COMMUNE?: SortOrder
    POINT?: SortOrder
    LONG?: SortOrder
    LAT?: SortOrder
    QEB_2013?: SortOrderInput | SortOrder
    QEB_2014?: SortOrderInput | SortOrder
    QEB_2015?: SortOrderInput | SortOrder
    QEB_2016?: SortOrderInput | SortOrder
    QEB_2017?: SortOrderInput | SortOrder
    QEB_2018?: SortOrderInput | SortOrder
    QEB_2019?: SortOrderInput | SortOrder
    QEB_2020?: SortOrderInput | SortOrder
    _count?: qualite_sites_baignadeCountOrderByAggregateInput
    _avg?: qualite_sites_baignadeAvgOrderByAggregateInput
    _max?: qualite_sites_baignadeMaxOrderByAggregateInput
    _min?: qualite_sites_baignadeMinOrderByAggregateInput
    _sum?: qualite_sites_baignadeSumOrderByAggregateInput
  }

  export type qualite_sites_baignadeScalarWhereWithAggregatesInput = {
    AND?: qualite_sites_baignadeScalarWhereWithAggregatesInput | qualite_sites_baignadeScalarWhereWithAggregatesInput[]
    OR?: qualite_sites_baignadeScalarWhereWithAggregatesInput[]
    NOT?: qualite_sites_baignadeScalarWhereWithAggregatesInput | qualite_sites_baignadeScalarWhereWithAggregatesInput[]
    index?: IntWithAggregatesFilter<"qualite_sites_baignade"> | number
    DEP_NOM?: StringWithAggregatesFilter<"qualite_sites_baignade"> | string
    DEP_NUM?: StringWithAggregatesFilter<"qualite_sites_baignade"> | string
    TYPE?: StringWithAggregatesFilter<"qualite_sites_baignade"> | string
    COMMUNE?: StringWithAggregatesFilter<"qualite_sites_baignade"> | string
    POINT?: StringWithAggregatesFilter<"qualite_sites_baignade"> | string
    LONG?: FloatWithAggregatesFilter<"qualite_sites_baignade"> | number
    LAT?: FloatWithAggregatesFilter<"qualite_sites_baignade"> | number
    QEB_2013?: StringNullableWithAggregatesFilter<"qualite_sites_baignade"> | string | null
    QEB_2014?: StringNullableWithAggregatesFilter<"qualite_sites_baignade"> | string | null
    QEB_2015?: StringNullableWithAggregatesFilter<"qualite_sites_baignade"> | string | null
    QEB_2016?: StringNullableWithAggregatesFilter<"qualite_sites_baignade"> | string | null
    QEB_2017?: StringNullableWithAggregatesFilter<"qualite_sites_baignade"> | string | null
    QEB_2018?: StringNullableWithAggregatesFilter<"qualite_sites_baignade"> | string | null
    QEB_2019?: StringNullableWithAggregatesFilter<"qualite_sites_baignade"> | string | null
    QEB_2020?: StringNullableWithAggregatesFilter<"qualite_sites_baignade"> | string | null
  }

  export type ressources_eauWhereInput = {
    AND?: ressources_eauWhereInput | ressources_eauWhereInput[]
    OR?: ressources_eauWhereInput[]
    NOT?: ressources_eauWhereInput | ressources_eauWhereInput[]
    index?: IntFilter<"ressources_eau"> | number
    code_geographique?: StringFilter<"ressources_eau"> | string
    LIBELLE_SOUS_CHAMP?: StringFilter<"ressources_eau"> | string
    A2020?: FloatFilter<"ressources_eau"> | number
    A2019?: FloatFilter<"ressources_eau"> | number
    A2018?: FloatFilter<"ressources_eau"> | number
    A2017?: FloatFilter<"ressources_eau"> | number
    A2016?: FloatFilter<"ressources_eau"> | number
    A2015?: FloatFilter<"ressources_eau"> | number
    A2014?: FloatFilter<"ressources_eau"> | number
    A2013?: FloatFilter<"ressources_eau"> | number
    A2012?: FloatFilter<"ressources_eau"> | number
    A2011?: FloatFilter<"ressources_eau"> | number
    A2010?: FloatFilter<"ressources_eau"> | number
    A2009?: FloatFilter<"ressources_eau"> | number
    A2008?: FloatFilter<"ressources_eau"> | number
    SOUS_CHAMP?: StringFilter<"ressources_eau"> | string
    libelle_geographique?: StringFilter<"ressources_eau"> | string
    epci?: StringFilter<"ressources_eau"> | string
    libelle_epci?: StringFilter<"ressources_eau"> | string
    departement?: StringFilter<"ressources_eau"> | string
    libelle_departement?: StringFilter<"ressources_eau"> | string
    region?: FloatFilter<"ressources_eau"> | number
    ept?: StringNullableFilter<"ressources_eau"> | string | null
    libelle_petr?: StringNullableFilter<"ressources_eau"> | string | null
    code_pnr?: StringNullableFilter<"ressources_eau"> | string | null
    libelle_pnr?: StringNullableFilter<"ressources_eau"> | string | null
  }

  export type ressources_eauOrderByWithRelationInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    LIBELLE_SOUS_CHAMP?: SortOrder
    A2020?: SortOrder
    A2019?: SortOrder
    A2018?: SortOrder
    A2017?: SortOrder
    A2016?: SortOrder
    A2015?: SortOrder
    A2014?: SortOrder
    A2013?: SortOrder
    A2012?: SortOrder
    A2011?: SortOrder
    A2010?: SortOrder
    A2009?: SortOrder
    A2008?: SortOrder
    SOUS_CHAMP?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrderInput | SortOrder
    libelle_petr?: SortOrderInput | SortOrder
    code_pnr?: SortOrderInput | SortOrder
    libelle_pnr?: SortOrderInput | SortOrder
  }

  export type ressources_eauWhereUniqueInput = Prisma.AtLeast<{
    index?: number
    AND?: ressources_eauWhereInput | ressources_eauWhereInput[]
    OR?: ressources_eauWhereInput[]
    NOT?: ressources_eauWhereInput | ressources_eauWhereInput[]
    code_geographique?: StringFilter<"ressources_eau"> | string
    LIBELLE_SOUS_CHAMP?: StringFilter<"ressources_eau"> | string
    A2020?: FloatFilter<"ressources_eau"> | number
    A2019?: FloatFilter<"ressources_eau"> | number
    A2018?: FloatFilter<"ressources_eau"> | number
    A2017?: FloatFilter<"ressources_eau"> | number
    A2016?: FloatFilter<"ressources_eau"> | number
    A2015?: FloatFilter<"ressources_eau"> | number
    A2014?: FloatFilter<"ressources_eau"> | number
    A2013?: FloatFilter<"ressources_eau"> | number
    A2012?: FloatFilter<"ressources_eau"> | number
    A2011?: FloatFilter<"ressources_eau"> | number
    A2010?: FloatFilter<"ressources_eau"> | number
    A2009?: FloatFilter<"ressources_eau"> | number
    A2008?: FloatFilter<"ressources_eau"> | number
    SOUS_CHAMP?: StringFilter<"ressources_eau"> | string
    libelle_geographique?: StringFilter<"ressources_eau"> | string
    epci?: StringFilter<"ressources_eau"> | string
    libelle_epci?: StringFilter<"ressources_eau"> | string
    departement?: StringFilter<"ressources_eau"> | string
    libelle_departement?: StringFilter<"ressources_eau"> | string
    region?: FloatFilter<"ressources_eau"> | number
    ept?: StringNullableFilter<"ressources_eau"> | string | null
    libelle_petr?: StringNullableFilter<"ressources_eau"> | string | null
    code_pnr?: StringNullableFilter<"ressources_eau"> | string | null
    libelle_pnr?: StringNullableFilter<"ressources_eau"> | string | null
  }, "index">

  export type ressources_eauOrderByWithAggregationInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    LIBELLE_SOUS_CHAMP?: SortOrder
    A2020?: SortOrder
    A2019?: SortOrder
    A2018?: SortOrder
    A2017?: SortOrder
    A2016?: SortOrder
    A2015?: SortOrder
    A2014?: SortOrder
    A2013?: SortOrder
    A2012?: SortOrder
    A2011?: SortOrder
    A2010?: SortOrder
    A2009?: SortOrder
    A2008?: SortOrder
    SOUS_CHAMP?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrderInput | SortOrder
    libelle_petr?: SortOrderInput | SortOrder
    code_pnr?: SortOrderInput | SortOrder
    libelle_pnr?: SortOrderInput | SortOrder
    _count?: ressources_eauCountOrderByAggregateInput
    _avg?: ressources_eauAvgOrderByAggregateInput
    _max?: ressources_eauMaxOrderByAggregateInput
    _min?: ressources_eauMinOrderByAggregateInput
    _sum?: ressources_eauSumOrderByAggregateInput
  }

  export type ressources_eauScalarWhereWithAggregatesInput = {
    AND?: ressources_eauScalarWhereWithAggregatesInput | ressources_eauScalarWhereWithAggregatesInput[]
    OR?: ressources_eauScalarWhereWithAggregatesInput[]
    NOT?: ressources_eauScalarWhereWithAggregatesInput | ressources_eauScalarWhereWithAggregatesInput[]
    index?: IntWithAggregatesFilter<"ressources_eau"> | number
    code_geographique?: StringWithAggregatesFilter<"ressources_eau"> | string
    LIBELLE_SOUS_CHAMP?: StringWithAggregatesFilter<"ressources_eau"> | string
    A2020?: FloatWithAggregatesFilter<"ressources_eau"> | number
    A2019?: FloatWithAggregatesFilter<"ressources_eau"> | number
    A2018?: FloatWithAggregatesFilter<"ressources_eau"> | number
    A2017?: FloatWithAggregatesFilter<"ressources_eau"> | number
    A2016?: FloatWithAggregatesFilter<"ressources_eau"> | number
    A2015?: FloatWithAggregatesFilter<"ressources_eau"> | number
    A2014?: FloatWithAggregatesFilter<"ressources_eau"> | number
    A2013?: FloatWithAggregatesFilter<"ressources_eau"> | number
    A2012?: FloatWithAggregatesFilter<"ressources_eau"> | number
    A2011?: FloatWithAggregatesFilter<"ressources_eau"> | number
    A2010?: FloatWithAggregatesFilter<"ressources_eau"> | number
    A2009?: FloatWithAggregatesFilter<"ressources_eau"> | number
    A2008?: FloatWithAggregatesFilter<"ressources_eau"> | number
    SOUS_CHAMP?: StringWithAggregatesFilter<"ressources_eau"> | string
    libelle_geographique?: StringWithAggregatesFilter<"ressources_eau"> | string
    epci?: StringWithAggregatesFilter<"ressources_eau"> | string
    libelle_epci?: StringWithAggregatesFilter<"ressources_eau"> | string
    departement?: StringWithAggregatesFilter<"ressources_eau"> | string
    libelle_departement?: StringWithAggregatesFilter<"ressources_eau"> | string
    region?: FloatWithAggregatesFilter<"ressources_eau"> | number
    ept?: StringNullableWithAggregatesFilter<"ressources_eau"> | string | null
    libelle_petr?: StringNullableWithAggregatesFilter<"ressources_eau"> | string | null
    code_pnr?: StringNullableWithAggregatesFilter<"ressources_eau"> | string | null
    libelle_pnr?: StringNullableWithAggregatesFilter<"ressources_eau"> | string | null
  }

  export type rgaWhereInput = {
    AND?: rgaWhereInput | rgaWhereInput[]
    OR?: rgaWhereInput[]
    NOT?: rgaWhereInput | rgaWhereInput[]
    index?: IntFilter<"rga"> | number
    code_geographique?: StringFilter<"rga"> | string
    libelle_geographique?: StringFilter<"rga"> | string
    epci?: StringFilter<"rga"> | string
    libelle_epci?: StringFilter<"rga"> | string
    departement?: StringFilter<"rga"> | string
    libelle_departement?: StringFilter<"rga"> | string
    region?: FloatFilter<"rga"> | number
    ept?: StringNullableFilter<"rga"> | string | null
    libelle_petr?: StringNullableFilter<"rga"> | string | null
    code_pnr?: StringNullableFilter<"rga"> | string | null
    libelle_pnr?: StringNullableFilter<"rga"> | string | null
    nb_logement?: IntFilter<"rga"> | number
    nb_logement_alea_moyen_fort?: IntFilter<"rga"> | number
    nb_logement_alea_faible?: IntFilter<"rga"> | number
    nb_logement_sans_alea?: IntFilter<"rga"> | number
    nb_logement_alea_moyen_fort_avant_1920?: IntFilter<"rga"> | number
    nb_logement_alea_moyen_fort_1920_1945?: IntFilter<"rga"> | number
    nb_logement_alea_moyen_fort_1945_1975?: IntFilter<"rga"> | number
    nb_logement_alea_moyen_fort_apres_1975?: IntFilter<"rga"> | number
    nb_logement_alea_faible_avant_1920?: IntFilter<"rga"> | number
    nb_logement_alea_faible_1920_1945?: IntFilter<"rga"> | number
    nb_logement_alea_faible_1945_1975?: IntFilter<"rga"> | number
    nb_logement_alea_faible_apres_1975?: IntFilter<"rga"> | number
    surface_commune?: IntFilter<"rga"> | number
    surface_alea_faible_commune?: IntFilter<"rga"> | number
    surface_alea_moyen_fort_commune?: IntFilter<"rga"> | number
    part_logement_alea_moyen_fort_avant_1920?: IntFilter<"rga"> | number
    part_logement_alea_moyen_fort_1920_1945?: IntFilter<"rga"> | number
    part_logement_alea_moyen_fort_1945_1975?: IntFilter<"rga"> | number
    part_logement_alea_moyen_fort_apres_1975?: IntFilter<"rga"> | number
    part_logement_alea_faible_avant_1920?: IntFilter<"rga"> | number
    part_logement_alea_faible_1920_1945?: IntFilter<"rga"> | number
    part_logement_alea_faible_1945_1975?: IntFilter<"rga"> | number
    part_logement_alea_faible_apres_1975?: IntFilter<"rga"> | number
    part_alea_faible_commune?: IntFilter<"rga"> | number
    part_alea_moyen_fort_commune?: IntFilter<"rga"> | number
  }

  export type rgaOrderByWithRelationInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrderInput | SortOrder
    libelle_petr?: SortOrderInput | SortOrder
    code_pnr?: SortOrderInput | SortOrder
    libelle_pnr?: SortOrderInput | SortOrder
    nb_logement?: SortOrder
    nb_logement_alea_moyen_fort?: SortOrder
    nb_logement_alea_faible?: SortOrder
    nb_logement_sans_alea?: SortOrder
    nb_logement_alea_moyen_fort_avant_1920?: SortOrder
    nb_logement_alea_moyen_fort_1920_1945?: SortOrder
    nb_logement_alea_moyen_fort_1945_1975?: SortOrder
    nb_logement_alea_moyen_fort_apres_1975?: SortOrder
    nb_logement_alea_faible_avant_1920?: SortOrder
    nb_logement_alea_faible_1920_1945?: SortOrder
    nb_logement_alea_faible_1945_1975?: SortOrder
    nb_logement_alea_faible_apres_1975?: SortOrder
    surface_commune?: SortOrder
    surface_alea_faible_commune?: SortOrder
    surface_alea_moyen_fort_commune?: SortOrder
    part_logement_alea_moyen_fort_avant_1920?: SortOrder
    part_logement_alea_moyen_fort_1920_1945?: SortOrder
    part_logement_alea_moyen_fort_1945_1975?: SortOrder
    part_logement_alea_moyen_fort_apres_1975?: SortOrder
    part_logement_alea_faible_avant_1920?: SortOrder
    part_logement_alea_faible_1920_1945?: SortOrder
    part_logement_alea_faible_1945_1975?: SortOrder
    part_logement_alea_faible_apres_1975?: SortOrder
    part_alea_faible_commune?: SortOrder
    part_alea_moyen_fort_commune?: SortOrder
  }

  export type rgaWhereUniqueInput = Prisma.AtLeast<{
    index?: number
    AND?: rgaWhereInput | rgaWhereInput[]
    OR?: rgaWhereInput[]
    NOT?: rgaWhereInput | rgaWhereInput[]
    code_geographique?: StringFilter<"rga"> | string
    libelle_geographique?: StringFilter<"rga"> | string
    epci?: StringFilter<"rga"> | string
    libelle_epci?: StringFilter<"rga"> | string
    departement?: StringFilter<"rga"> | string
    libelle_departement?: StringFilter<"rga"> | string
    region?: FloatFilter<"rga"> | number
    ept?: StringNullableFilter<"rga"> | string | null
    libelle_petr?: StringNullableFilter<"rga"> | string | null
    code_pnr?: StringNullableFilter<"rga"> | string | null
    libelle_pnr?: StringNullableFilter<"rga"> | string | null
    nb_logement?: IntFilter<"rga"> | number
    nb_logement_alea_moyen_fort?: IntFilter<"rga"> | number
    nb_logement_alea_faible?: IntFilter<"rga"> | number
    nb_logement_sans_alea?: IntFilter<"rga"> | number
    nb_logement_alea_moyen_fort_avant_1920?: IntFilter<"rga"> | number
    nb_logement_alea_moyen_fort_1920_1945?: IntFilter<"rga"> | number
    nb_logement_alea_moyen_fort_1945_1975?: IntFilter<"rga"> | number
    nb_logement_alea_moyen_fort_apres_1975?: IntFilter<"rga"> | number
    nb_logement_alea_faible_avant_1920?: IntFilter<"rga"> | number
    nb_logement_alea_faible_1920_1945?: IntFilter<"rga"> | number
    nb_logement_alea_faible_1945_1975?: IntFilter<"rga"> | number
    nb_logement_alea_faible_apres_1975?: IntFilter<"rga"> | number
    surface_commune?: IntFilter<"rga"> | number
    surface_alea_faible_commune?: IntFilter<"rga"> | number
    surface_alea_moyen_fort_commune?: IntFilter<"rga"> | number
    part_logement_alea_moyen_fort_avant_1920?: IntFilter<"rga"> | number
    part_logement_alea_moyen_fort_1920_1945?: IntFilter<"rga"> | number
    part_logement_alea_moyen_fort_1945_1975?: IntFilter<"rga"> | number
    part_logement_alea_moyen_fort_apres_1975?: IntFilter<"rga"> | number
    part_logement_alea_faible_avant_1920?: IntFilter<"rga"> | number
    part_logement_alea_faible_1920_1945?: IntFilter<"rga"> | number
    part_logement_alea_faible_1945_1975?: IntFilter<"rga"> | number
    part_logement_alea_faible_apres_1975?: IntFilter<"rga"> | number
    part_alea_faible_commune?: IntFilter<"rga"> | number
    part_alea_moyen_fort_commune?: IntFilter<"rga"> | number
  }, "index">

  export type rgaOrderByWithAggregationInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrderInput | SortOrder
    libelle_petr?: SortOrderInput | SortOrder
    code_pnr?: SortOrderInput | SortOrder
    libelle_pnr?: SortOrderInput | SortOrder
    nb_logement?: SortOrder
    nb_logement_alea_moyen_fort?: SortOrder
    nb_logement_alea_faible?: SortOrder
    nb_logement_sans_alea?: SortOrder
    nb_logement_alea_moyen_fort_avant_1920?: SortOrder
    nb_logement_alea_moyen_fort_1920_1945?: SortOrder
    nb_logement_alea_moyen_fort_1945_1975?: SortOrder
    nb_logement_alea_moyen_fort_apres_1975?: SortOrder
    nb_logement_alea_faible_avant_1920?: SortOrder
    nb_logement_alea_faible_1920_1945?: SortOrder
    nb_logement_alea_faible_1945_1975?: SortOrder
    nb_logement_alea_faible_apres_1975?: SortOrder
    surface_commune?: SortOrder
    surface_alea_faible_commune?: SortOrder
    surface_alea_moyen_fort_commune?: SortOrder
    part_logement_alea_moyen_fort_avant_1920?: SortOrder
    part_logement_alea_moyen_fort_1920_1945?: SortOrder
    part_logement_alea_moyen_fort_1945_1975?: SortOrder
    part_logement_alea_moyen_fort_apres_1975?: SortOrder
    part_logement_alea_faible_avant_1920?: SortOrder
    part_logement_alea_faible_1920_1945?: SortOrder
    part_logement_alea_faible_1945_1975?: SortOrder
    part_logement_alea_faible_apres_1975?: SortOrder
    part_alea_faible_commune?: SortOrder
    part_alea_moyen_fort_commune?: SortOrder
    _count?: rgaCountOrderByAggregateInput
    _avg?: rgaAvgOrderByAggregateInput
    _max?: rgaMaxOrderByAggregateInput
    _min?: rgaMinOrderByAggregateInput
    _sum?: rgaSumOrderByAggregateInput
  }

  export type rgaScalarWhereWithAggregatesInput = {
    AND?: rgaScalarWhereWithAggregatesInput | rgaScalarWhereWithAggregatesInput[]
    OR?: rgaScalarWhereWithAggregatesInput[]
    NOT?: rgaScalarWhereWithAggregatesInput | rgaScalarWhereWithAggregatesInput[]
    index?: IntWithAggregatesFilter<"rga"> | number
    code_geographique?: StringWithAggregatesFilter<"rga"> | string
    libelle_geographique?: StringWithAggregatesFilter<"rga"> | string
    epci?: StringWithAggregatesFilter<"rga"> | string
    libelle_epci?: StringWithAggregatesFilter<"rga"> | string
    departement?: StringWithAggregatesFilter<"rga"> | string
    libelle_departement?: StringWithAggregatesFilter<"rga"> | string
    region?: FloatWithAggregatesFilter<"rga"> | number
    ept?: StringNullableWithAggregatesFilter<"rga"> | string | null
    libelle_petr?: StringNullableWithAggregatesFilter<"rga"> | string | null
    code_pnr?: StringNullableWithAggregatesFilter<"rga"> | string | null
    libelle_pnr?: StringNullableWithAggregatesFilter<"rga"> | string | null
    nb_logement?: IntWithAggregatesFilter<"rga"> | number
    nb_logement_alea_moyen_fort?: IntWithAggregatesFilter<"rga"> | number
    nb_logement_alea_faible?: IntWithAggregatesFilter<"rga"> | number
    nb_logement_sans_alea?: IntWithAggregatesFilter<"rga"> | number
    nb_logement_alea_moyen_fort_avant_1920?: IntWithAggregatesFilter<"rga"> | number
    nb_logement_alea_moyen_fort_1920_1945?: IntWithAggregatesFilter<"rga"> | number
    nb_logement_alea_moyen_fort_1945_1975?: IntWithAggregatesFilter<"rga"> | number
    nb_logement_alea_moyen_fort_apres_1975?: IntWithAggregatesFilter<"rga"> | number
    nb_logement_alea_faible_avant_1920?: IntWithAggregatesFilter<"rga"> | number
    nb_logement_alea_faible_1920_1945?: IntWithAggregatesFilter<"rga"> | number
    nb_logement_alea_faible_1945_1975?: IntWithAggregatesFilter<"rga"> | number
    nb_logement_alea_faible_apres_1975?: IntWithAggregatesFilter<"rga"> | number
    surface_commune?: IntWithAggregatesFilter<"rga"> | number
    surface_alea_faible_commune?: IntWithAggregatesFilter<"rga"> | number
    surface_alea_moyen_fort_commune?: IntWithAggregatesFilter<"rga"> | number
    part_logement_alea_moyen_fort_avant_1920?: IntWithAggregatesFilter<"rga"> | number
    part_logement_alea_moyen_fort_1920_1945?: IntWithAggregatesFilter<"rga"> | number
    part_logement_alea_moyen_fort_1945_1975?: IntWithAggregatesFilter<"rga"> | number
    part_logement_alea_moyen_fort_apres_1975?: IntWithAggregatesFilter<"rga"> | number
    part_logement_alea_faible_avant_1920?: IntWithAggregatesFilter<"rga"> | number
    part_logement_alea_faible_1920_1945?: IntWithAggregatesFilter<"rga"> | number
    part_logement_alea_faible_1945_1975?: IntWithAggregatesFilter<"rga"> | number
    part_logement_alea_faible_apres_1975?: IntWithAggregatesFilter<"rga"> | number
    part_alea_faible_commune?: IntWithAggregatesFilter<"rga"> | number
    part_alea_moyen_fort_commune?: IntWithAggregatesFilter<"rga"> | number
  }

  export type surfaces_agricolesWhereInput = {
    AND?: surfaces_agricolesWhereInput | surfaces_agricolesWhereInput[]
    OR?: surfaces_agricolesWhereInput[]
    NOT?: surfaces_agricolesWhereInput | surfaces_agricolesWhereInput[]
    index?: IntFilter<"surfaces_agricoles"> | number
    epci?: StringFilter<"surfaces_agricoles"> | string
    exploitation_sau?: FloatFilter<"surfaces_agricoles"> | number
    exploitation_sau_terres_arables?: FloatFilter<"surfaces_agricoles"> | number
    exploitation_sau_terres_arables_cereales?: FloatFilter<"surfaces_agricoles"> | number
    exploitation_sau_terres_arables_oleagineux?: FloatFilter<"surfaces_agricoles"> | number
    exploitation_sau_terres_arables_fourrageres?: FloatFilter<"surfaces_agricoles"> | number
    exploitation_sau_terres_arables_tubercules?: FloatFilter<"surfaces_agricoles"> | number
    exploitation_sau_terres_arables_legumes_melons_fraises?: FloatFilter<"surfaces_agricoles"> | number
    exploitation_sau_terres_arables_fleurs?: FloatFilter<"surfaces_agricoles"> | number
    exploitation_sau_terres_arables_autres?: FloatFilter<"surfaces_agricoles"> | number
    exploitation_sau_cultures_permanentes?: FloatFilter<"surfaces_agricoles"> | number
    exploitation_sau_cultures_permanentes_vigne?: FloatFilter<"surfaces_agricoles"> | number
    exploitation_sau_cultures_permanentes_fruits?: FloatFilter<"surfaces_agricoles"> | number
    exploitation_sau_cultures_permanentes_autres?: FloatFilter<"surfaces_agricoles"> | number
    exploitation_sau_herbe?: FloatFilter<"surfaces_agricoles"> | number
    exploitation_sau_herbe_prairies_productives?: FloatFilter<"surfaces_agricoles"> | number
    exploitation_sau_herbe_prairies_peu_productives?: FloatFilter<"surfaces_agricoles"> | number
    exploitation_sau_herbe_subventions?: FloatFilter<"surfaces_agricoles"> | number
    exploitation_sau_herbe_bois_patures?: FloatFilter<"surfaces_agricoles"> | number
    exploitation_sau_jardins?: FloatFilter<"surfaces_agricoles"> | number
    superficie_sau?: FloatFilter<"surfaces_agricoles"> | number
    superficie_sau_terres_arables?: FloatFilter<"surfaces_agricoles"> | number
    superficie_sau_terres_arables_cereales?: FloatFilter<"surfaces_agricoles"> | number
    superficie_sau_terres_arables_oleagineux?: FloatFilter<"surfaces_agricoles"> | number
    superficie_sau_terres_arables_fourrageres?: FloatFilter<"surfaces_agricoles"> | number
    superficie_sau_terres_arables_tubercules?: FloatFilter<"surfaces_agricoles"> | number
    superficie_sau_terres_arables_legumes_melons_fraises?: FloatFilter<"surfaces_agricoles"> | number
    superficie_sau_terres_arables_fleurs?: FloatFilter<"surfaces_agricoles"> | number
    superficie_sau_terres_arables_autres?: FloatFilter<"surfaces_agricoles"> | number
    superficie_sau_cultures_permanentes?: FloatFilter<"surfaces_agricoles"> | number
    superficie_sau_cultures_permanentes_vigne?: FloatFilter<"surfaces_agricoles"> | number
    superficie_sau_cultures_permanentes_fruits?: FloatFilter<"surfaces_agricoles"> | number
    superficie_sau_cultures_permanentes_autres?: FloatFilter<"surfaces_agricoles"> | number
    superficie_sau_herbe?: FloatFilter<"surfaces_agricoles"> | number
    superficie_sau_herbe_prairies_productives?: FloatFilter<"surfaces_agricoles"> | number
    superficie_sau_herbe_prairies_peu_productives?: FloatFilter<"surfaces_agricoles"> | number
    superficie_sau_herbe_subventions?: FloatFilter<"surfaces_agricoles"> | number
    superficie_sau_herbe_bois_patures?: FloatFilter<"surfaces_agricoles"> | number
    superficie_sau_jardins?: FloatFilter<"surfaces_agricoles"> | number
  }

  export type surfaces_agricolesOrderByWithRelationInput = {
    index?: SortOrder
    epci?: SortOrder
    exploitation_sau?: SortOrder
    exploitation_sau_terres_arables?: SortOrder
    exploitation_sau_terres_arables_cereales?: SortOrder
    exploitation_sau_terres_arables_oleagineux?: SortOrder
    exploitation_sau_terres_arables_fourrageres?: SortOrder
    exploitation_sau_terres_arables_tubercules?: SortOrder
    exploitation_sau_terres_arables_legumes_melons_fraises?: SortOrder
    exploitation_sau_terres_arables_fleurs?: SortOrder
    exploitation_sau_terres_arables_autres?: SortOrder
    exploitation_sau_cultures_permanentes?: SortOrder
    exploitation_sau_cultures_permanentes_vigne?: SortOrder
    exploitation_sau_cultures_permanentes_fruits?: SortOrder
    exploitation_sau_cultures_permanentes_autres?: SortOrder
    exploitation_sau_herbe?: SortOrder
    exploitation_sau_herbe_prairies_productives?: SortOrder
    exploitation_sau_herbe_prairies_peu_productives?: SortOrder
    exploitation_sau_herbe_subventions?: SortOrder
    exploitation_sau_herbe_bois_patures?: SortOrder
    exploitation_sau_jardins?: SortOrder
    superficie_sau?: SortOrder
    superficie_sau_terres_arables?: SortOrder
    superficie_sau_terres_arables_cereales?: SortOrder
    superficie_sau_terres_arables_oleagineux?: SortOrder
    superficie_sau_terres_arables_fourrageres?: SortOrder
    superficie_sau_terres_arables_tubercules?: SortOrder
    superficie_sau_terres_arables_legumes_melons_fraises?: SortOrder
    superficie_sau_terres_arables_fleurs?: SortOrder
    superficie_sau_terres_arables_autres?: SortOrder
    superficie_sau_cultures_permanentes?: SortOrder
    superficie_sau_cultures_permanentes_vigne?: SortOrder
    superficie_sau_cultures_permanentes_fruits?: SortOrder
    superficie_sau_cultures_permanentes_autres?: SortOrder
    superficie_sau_herbe?: SortOrder
    superficie_sau_herbe_prairies_productives?: SortOrder
    superficie_sau_herbe_prairies_peu_productives?: SortOrder
    superficie_sau_herbe_subventions?: SortOrder
    superficie_sau_herbe_bois_patures?: SortOrder
    superficie_sau_jardins?: SortOrder
  }

  export type surfaces_agricolesWhereUniqueInput = Prisma.AtLeast<{
    index?: number
    AND?: surfaces_agricolesWhereInput | surfaces_agricolesWhereInput[]
    OR?: surfaces_agricolesWhereInput[]
    NOT?: surfaces_agricolesWhereInput | surfaces_agricolesWhereInput[]
    epci?: StringFilter<"surfaces_agricoles"> | string
    exploitation_sau?: FloatFilter<"surfaces_agricoles"> | number
    exploitation_sau_terres_arables?: FloatFilter<"surfaces_agricoles"> | number
    exploitation_sau_terres_arables_cereales?: FloatFilter<"surfaces_agricoles"> | number
    exploitation_sau_terres_arables_oleagineux?: FloatFilter<"surfaces_agricoles"> | number
    exploitation_sau_terres_arables_fourrageres?: FloatFilter<"surfaces_agricoles"> | number
    exploitation_sau_terres_arables_tubercules?: FloatFilter<"surfaces_agricoles"> | number
    exploitation_sau_terres_arables_legumes_melons_fraises?: FloatFilter<"surfaces_agricoles"> | number
    exploitation_sau_terres_arables_fleurs?: FloatFilter<"surfaces_agricoles"> | number
    exploitation_sau_terres_arables_autres?: FloatFilter<"surfaces_agricoles"> | number
    exploitation_sau_cultures_permanentes?: FloatFilter<"surfaces_agricoles"> | number
    exploitation_sau_cultures_permanentes_vigne?: FloatFilter<"surfaces_agricoles"> | number
    exploitation_sau_cultures_permanentes_fruits?: FloatFilter<"surfaces_agricoles"> | number
    exploitation_sau_cultures_permanentes_autres?: FloatFilter<"surfaces_agricoles"> | number
    exploitation_sau_herbe?: FloatFilter<"surfaces_agricoles"> | number
    exploitation_sau_herbe_prairies_productives?: FloatFilter<"surfaces_agricoles"> | number
    exploitation_sau_herbe_prairies_peu_productives?: FloatFilter<"surfaces_agricoles"> | number
    exploitation_sau_herbe_subventions?: FloatFilter<"surfaces_agricoles"> | number
    exploitation_sau_herbe_bois_patures?: FloatFilter<"surfaces_agricoles"> | number
    exploitation_sau_jardins?: FloatFilter<"surfaces_agricoles"> | number
    superficie_sau?: FloatFilter<"surfaces_agricoles"> | number
    superficie_sau_terres_arables?: FloatFilter<"surfaces_agricoles"> | number
    superficie_sau_terres_arables_cereales?: FloatFilter<"surfaces_agricoles"> | number
    superficie_sau_terres_arables_oleagineux?: FloatFilter<"surfaces_agricoles"> | number
    superficie_sau_terres_arables_fourrageres?: FloatFilter<"surfaces_agricoles"> | number
    superficie_sau_terres_arables_tubercules?: FloatFilter<"surfaces_agricoles"> | number
    superficie_sau_terres_arables_legumes_melons_fraises?: FloatFilter<"surfaces_agricoles"> | number
    superficie_sau_terres_arables_fleurs?: FloatFilter<"surfaces_agricoles"> | number
    superficie_sau_terres_arables_autres?: FloatFilter<"surfaces_agricoles"> | number
    superficie_sau_cultures_permanentes?: FloatFilter<"surfaces_agricoles"> | number
    superficie_sau_cultures_permanentes_vigne?: FloatFilter<"surfaces_agricoles"> | number
    superficie_sau_cultures_permanentes_fruits?: FloatFilter<"surfaces_agricoles"> | number
    superficie_sau_cultures_permanentes_autres?: FloatFilter<"surfaces_agricoles"> | number
    superficie_sau_herbe?: FloatFilter<"surfaces_agricoles"> | number
    superficie_sau_herbe_prairies_productives?: FloatFilter<"surfaces_agricoles"> | number
    superficie_sau_herbe_prairies_peu_productives?: FloatFilter<"surfaces_agricoles"> | number
    superficie_sau_herbe_subventions?: FloatFilter<"surfaces_agricoles"> | number
    superficie_sau_herbe_bois_patures?: FloatFilter<"surfaces_agricoles"> | number
    superficie_sau_jardins?: FloatFilter<"surfaces_agricoles"> | number
  }, "index">

  export type surfaces_agricolesOrderByWithAggregationInput = {
    index?: SortOrder
    epci?: SortOrder
    exploitation_sau?: SortOrder
    exploitation_sau_terres_arables?: SortOrder
    exploitation_sau_terres_arables_cereales?: SortOrder
    exploitation_sau_terres_arables_oleagineux?: SortOrder
    exploitation_sau_terres_arables_fourrageres?: SortOrder
    exploitation_sau_terres_arables_tubercules?: SortOrder
    exploitation_sau_terres_arables_legumes_melons_fraises?: SortOrder
    exploitation_sau_terres_arables_fleurs?: SortOrder
    exploitation_sau_terres_arables_autres?: SortOrder
    exploitation_sau_cultures_permanentes?: SortOrder
    exploitation_sau_cultures_permanentes_vigne?: SortOrder
    exploitation_sau_cultures_permanentes_fruits?: SortOrder
    exploitation_sau_cultures_permanentes_autres?: SortOrder
    exploitation_sau_herbe?: SortOrder
    exploitation_sau_herbe_prairies_productives?: SortOrder
    exploitation_sau_herbe_prairies_peu_productives?: SortOrder
    exploitation_sau_herbe_subventions?: SortOrder
    exploitation_sau_herbe_bois_patures?: SortOrder
    exploitation_sau_jardins?: SortOrder
    superficie_sau?: SortOrder
    superficie_sau_terres_arables?: SortOrder
    superficie_sau_terres_arables_cereales?: SortOrder
    superficie_sau_terres_arables_oleagineux?: SortOrder
    superficie_sau_terres_arables_fourrageres?: SortOrder
    superficie_sau_terres_arables_tubercules?: SortOrder
    superficie_sau_terres_arables_legumes_melons_fraises?: SortOrder
    superficie_sau_terres_arables_fleurs?: SortOrder
    superficie_sau_terres_arables_autres?: SortOrder
    superficie_sau_cultures_permanentes?: SortOrder
    superficie_sau_cultures_permanentes_vigne?: SortOrder
    superficie_sau_cultures_permanentes_fruits?: SortOrder
    superficie_sau_cultures_permanentes_autres?: SortOrder
    superficie_sau_herbe?: SortOrder
    superficie_sau_herbe_prairies_productives?: SortOrder
    superficie_sau_herbe_prairies_peu_productives?: SortOrder
    superficie_sau_herbe_subventions?: SortOrder
    superficie_sau_herbe_bois_patures?: SortOrder
    superficie_sau_jardins?: SortOrder
    _count?: surfaces_agricolesCountOrderByAggregateInput
    _avg?: surfaces_agricolesAvgOrderByAggregateInput
    _max?: surfaces_agricolesMaxOrderByAggregateInput
    _min?: surfaces_agricolesMinOrderByAggregateInput
    _sum?: surfaces_agricolesSumOrderByAggregateInput
  }

  export type surfaces_agricolesScalarWhereWithAggregatesInput = {
    AND?: surfaces_agricolesScalarWhereWithAggregatesInput | surfaces_agricolesScalarWhereWithAggregatesInput[]
    OR?: surfaces_agricolesScalarWhereWithAggregatesInput[]
    NOT?: surfaces_agricolesScalarWhereWithAggregatesInput | surfaces_agricolesScalarWhereWithAggregatesInput[]
    index?: IntWithAggregatesFilter<"surfaces_agricoles"> | number
    epci?: StringWithAggregatesFilter<"surfaces_agricoles"> | string
    exploitation_sau?: FloatWithAggregatesFilter<"surfaces_agricoles"> | number
    exploitation_sau_terres_arables?: FloatWithAggregatesFilter<"surfaces_agricoles"> | number
    exploitation_sau_terres_arables_cereales?: FloatWithAggregatesFilter<"surfaces_agricoles"> | number
    exploitation_sau_terres_arables_oleagineux?: FloatWithAggregatesFilter<"surfaces_agricoles"> | number
    exploitation_sau_terres_arables_fourrageres?: FloatWithAggregatesFilter<"surfaces_agricoles"> | number
    exploitation_sau_terres_arables_tubercules?: FloatWithAggregatesFilter<"surfaces_agricoles"> | number
    exploitation_sau_terres_arables_legumes_melons_fraises?: FloatWithAggregatesFilter<"surfaces_agricoles"> | number
    exploitation_sau_terres_arables_fleurs?: FloatWithAggregatesFilter<"surfaces_agricoles"> | number
    exploitation_sau_terres_arables_autres?: FloatWithAggregatesFilter<"surfaces_agricoles"> | number
    exploitation_sau_cultures_permanentes?: FloatWithAggregatesFilter<"surfaces_agricoles"> | number
    exploitation_sau_cultures_permanentes_vigne?: FloatWithAggregatesFilter<"surfaces_agricoles"> | number
    exploitation_sau_cultures_permanentes_fruits?: FloatWithAggregatesFilter<"surfaces_agricoles"> | number
    exploitation_sau_cultures_permanentes_autres?: FloatWithAggregatesFilter<"surfaces_agricoles"> | number
    exploitation_sau_herbe?: FloatWithAggregatesFilter<"surfaces_agricoles"> | number
    exploitation_sau_herbe_prairies_productives?: FloatWithAggregatesFilter<"surfaces_agricoles"> | number
    exploitation_sau_herbe_prairies_peu_productives?: FloatWithAggregatesFilter<"surfaces_agricoles"> | number
    exploitation_sau_herbe_subventions?: FloatWithAggregatesFilter<"surfaces_agricoles"> | number
    exploitation_sau_herbe_bois_patures?: FloatWithAggregatesFilter<"surfaces_agricoles"> | number
    exploitation_sau_jardins?: FloatWithAggregatesFilter<"surfaces_agricoles"> | number
    superficie_sau?: FloatWithAggregatesFilter<"surfaces_agricoles"> | number
    superficie_sau_terres_arables?: FloatWithAggregatesFilter<"surfaces_agricoles"> | number
    superficie_sau_terres_arables_cereales?: FloatWithAggregatesFilter<"surfaces_agricoles"> | number
    superficie_sau_terres_arables_oleagineux?: FloatWithAggregatesFilter<"surfaces_agricoles"> | number
    superficie_sau_terres_arables_fourrageres?: FloatWithAggregatesFilter<"surfaces_agricoles"> | number
    superficie_sau_terres_arables_tubercules?: FloatWithAggregatesFilter<"surfaces_agricoles"> | number
    superficie_sau_terres_arables_legumes_melons_fraises?: FloatWithAggregatesFilter<"surfaces_agricoles"> | number
    superficie_sau_terres_arables_fleurs?: FloatWithAggregatesFilter<"surfaces_agricoles"> | number
    superficie_sau_terres_arables_autres?: FloatWithAggregatesFilter<"surfaces_agricoles"> | number
    superficie_sau_cultures_permanentes?: FloatWithAggregatesFilter<"surfaces_agricoles"> | number
    superficie_sau_cultures_permanentes_vigne?: FloatWithAggregatesFilter<"surfaces_agricoles"> | number
    superficie_sau_cultures_permanentes_fruits?: FloatWithAggregatesFilter<"surfaces_agricoles"> | number
    superficie_sau_cultures_permanentes_autres?: FloatWithAggregatesFilter<"surfaces_agricoles"> | number
    superficie_sau_herbe?: FloatWithAggregatesFilter<"surfaces_agricoles"> | number
    superficie_sau_herbe_prairies_productives?: FloatWithAggregatesFilter<"surfaces_agricoles"> | number
    superficie_sau_herbe_prairies_peu_productives?: FloatWithAggregatesFilter<"surfaces_agricoles"> | number
    superficie_sau_herbe_subventions?: FloatWithAggregatesFilter<"surfaces_agricoles"> | number
    superficie_sau_herbe_bois_patures?: FloatWithAggregatesFilter<"surfaces_agricoles"> | number
    superficie_sau_jardins?: FloatWithAggregatesFilter<"surfaces_agricoles"> | number
  }

  export type surfaces_protegeesWhereInput = {
    AND?: surfaces_protegeesWhereInput | surfaces_protegeesWhereInput[]
    OR?: surfaces_protegeesWhereInput[]
    NOT?: surfaces_protegeesWhereInput | surfaces_protegeesWhereInput[]
    index?: IntFilter<"surfaces_protegees"> | number
    code_geographique?: StringFilter<"surfaces_protegees"> | string
    PNC?: StringNullableFilter<"surfaces_protegees"> | string | null
    RAMSAR?: StringNullableFilter<"surfaces_protegees"> | string | null
    PNR?: StringNullableFilter<"surfaces_protegees"> | string | null
    PNP?: StringNullableFilter<"surfaces_protegees"> | string | null
    FOR_PRO?: StringNullableFilter<"surfaces_protegees"> | string | null
    ZZZ?: StringNullableFilter<"surfaces_protegees"> | string | null
    ZNIEFF2?: StringNullableFilter<"surfaces_protegees"> | string | null
    ZNIEFF1?: StringNullableFilter<"surfaces_protegees"> | string | null
    RNR?: StringNullableFilter<"surfaces_protegees"> | string | null
    TOU_PRO?: StringNullableFilter<"surfaces_protegees"> | string | null
    NATURA?: StringNullableFilter<"surfaces_protegees"> | string | null
    ZPS?: StringNullableFilter<"surfaces_protegees"> | string | null
    SIC?: StringNullableFilter<"surfaces_protegees"> | string | null
    CELRL?: StringNullableFilter<"surfaces_protegees"> | string | null
    BIO?: StringNullableFilter<"surfaces_protegees"> | string | null
    APB?: StringNullableFilter<"surfaces_protegees"> | string | null
    RN?: StringNullableFilter<"surfaces_protegees"> | string | null
    RBFD?: StringNullableFilter<"surfaces_protegees"> | string | null
    RNCFS?: StringNullableFilter<"surfaces_protegees"> | string | null
    libelle_geographique?: StringFilter<"surfaces_protegees"> | string
    epci?: StringFilter<"surfaces_protegees"> | string
    libelle_epci?: StringFilter<"surfaces_protegees"> | string
    departement?: StringFilter<"surfaces_protegees"> | string
    region?: FloatFilter<"surfaces_protegees"> | number
  }

  export type surfaces_protegeesOrderByWithRelationInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    PNC?: SortOrderInput | SortOrder
    RAMSAR?: SortOrderInput | SortOrder
    PNR?: SortOrderInput | SortOrder
    PNP?: SortOrderInput | SortOrder
    FOR_PRO?: SortOrderInput | SortOrder
    ZZZ?: SortOrderInput | SortOrder
    ZNIEFF2?: SortOrderInput | SortOrder
    ZNIEFF1?: SortOrderInput | SortOrder
    RNR?: SortOrderInput | SortOrder
    TOU_PRO?: SortOrderInput | SortOrder
    NATURA?: SortOrderInput | SortOrder
    ZPS?: SortOrderInput | SortOrder
    SIC?: SortOrderInput | SortOrder
    CELRL?: SortOrderInput | SortOrder
    BIO?: SortOrderInput | SortOrder
    APB?: SortOrderInput | SortOrder
    RN?: SortOrderInput | SortOrder
    RBFD?: SortOrderInput | SortOrder
    RNCFS?: SortOrderInput | SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    region?: SortOrder
  }

  export type surfaces_protegeesWhereUniqueInput = Prisma.AtLeast<{
    index?: number
    AND?: surfaces_protegeesWhereInput | surfaces_protegeesWhereInput[]
    OR?: surfaces_protegeesWhereInput[]
    NOT?: surfaces_protegeesWhereInput | surfaces_protegeesWhereInput[]
    code_geographique?: StringFilter<"surfaces_protegees"> | string
    PNC?: StringNullableFilter<"surfaces_protegees"> | string | null
    RAMSAR?: StringNullableFilter<"surfaces_protegees"> | string | null
    PNR?: StringNullableFilter<"surfaces_protegees"> | string | null
    PNP?: StringNullableFilter<"surfaces_protegees"> | string | null
    FOR_PRO?: StringNullableFilter<"surfaces_protegees"> | string | null
    ZZZ?: StringNullableFilter<"surfaces_protegees"> | string | null
    ZNIEFF2?: StringNullableFilter<"surfaces_protegees"> | string | null
    ZNIEFF1?: StringNullableFilter<"surfaces_protegees"> | string | null
    RNR?: StringNullableFilter<"surfaces_protegees"> | string | null
    TOU_PRO?: StringNullableFilter<"surfaces_protegees"> | string | null
    NATURA?: StringNullableFilter<"surfaces_protegees"> | string | null
    ZPS?: StringNullableFilter<"surfaces_protegees"> | string | null
    SIC?: StringNullableFilter<"surfaces_protegees"> | string | null
    CELRL?: StringNullableFilter<"surfaces_protegees"> | string | null
    BIO?: StringNullableFilter<"surfaces_protegees"> | string | null
    APB?: StringNullableFilter<"surfaces_protegees"> | string | null
    RN?: StringNullableFilter<"surfaces_protegees"> | string | null
    RBFD?: StringNullableFilter<"surfaces_protegees"> | string | null
    RNCFS?: StringNullableFilter<"surfaces_protegees"> | string | null
    libelle_geographique?: StringFilter<"surfaces_protegees"> | string
    epci?: StringFilter<"surfaces_protegees"> | string
    libelle_epci?: StringFilter<"surfaces_protegees"> | string
    departement?: StringFilter<"surfaces_protegees"> | string
    region?: FloatFilter<"surfaces_protegees"> | number
  }, "index">

  export type surfaces_protegeesOrderByWithAggregationInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    PNC?: SortOrderInput | SortOrder
    RAMSAR?: SortOrderInput | SortOrder
    PNR?: SortOrderInput | SortOrder
    PNP?: SortOrderInput | SortOrder
    FOR_PRO?: SortOrderInput | SortOrder
    ZZZ?: SortOrderInput | SortOrder
    ZNIEFF2?: SortOrderInput | SortOrder
    ZNIEFF1?: SortOrderInput | SortOrder
    RNR?: SortOrderInput | SortOrder
    TOU_PRO?: SortOrderInput | SortOrder
    NATURA?: SortOrderInput | SortOrder
    ZPS?: SortOrderInput | SortOrder
    SIC?: SortOrderInput | SortOrder
    CELRL?: SortOrderInput | SortOrder
    BIO?: SortOrderInput | SortOrder
    APB?: SortOrderInput | SortOrder
    RN?: SortOrderInput | SortOrder
    RBFD?: SortOrderInput | SortOrder
    RNCFS?: SortOrderInput | SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    region?: SortOrder
    _count?: surfaces_protegeesCountOrderByAggregateInput
    _avg?: surfaces_protegeesAvgOrderByAggregateInput
    _max?: surfaces_protegeesMaxOrderByAggregateInput
    _min?: surfaces_protegeesMinOrderByAggregateInput
    _sum?: surfaces_protegeesSumOrderByAggregateInput
  }

  export type surfaces_protegeesScalarWhereWithAggregatesInput = {
    AND?: surfaces_protegeesScalarWhereWithAggregatesInput | surfaces_protegeesScalarWhereWithAggregatesInput[]
    OR?: surfaces_protegeesScalarWhereWithAggregatesInput[]
    NOT?: surfaces_protegeesScalarWhereWithAggregatesInput | surfaces_protegeesScalarWhereWithAggregatesInput[]
    index?: IntWithAggregatesFilter<"surfaces_protegees"> | number
    code_geographique?: StringWithAggregatesFilter<"surfaces_protegees"> | string
    PNC?: StringNullableWithAggregatesFilter<"surfaces_protegees"> | string | null
    RAMSAR?: StringNullableWithAggregatesFilter<"surfaces_protegees"> | string | null
    PNR?: StringNullableWithAggregatesFilter<"surfaces_protegees"> | string | null
    PNP?: StringNullableWithAggregatesFilter<"surfaces_protegees"> | string | null
    FOR_PRO?: StringNullableWithAggregatesFilter<"surfaces_protegees"> | string | null
    ZZZ?: StringNullableWithAggregatesFilter<"surfaces_protegees"> | string | null
    ZNIEFF2?: StringNullableWithAggregatesFilter<"surfaces_protegees"> | string | null
    ZNIEFF1?: StringNullableWithAggregatesFilter<"surfaces_protegees"> | string | null
    RNR?: StringNullableWithAggregatesFilter<"surfaces_protegees"> | string | null
    TOU_PRO?: StringNullableWithAggregatesFilter<"surfaces_protegees"> | string | null
    NATURA?: StringNullableWithAggregatesFilter<"surfaces_protegees"> | string | null
    ZPS?: StringNullableWithAggregatesFilter<"surfaces_protegees"> | string | null
    SIC?: StringNullableWithAggregatesFilter<"surfaces_protegees"> | string | null
    CELRL?: StringNullableWithAggregatesFilter<"surfaces_protegees"> | string | null
    BIO?: StringNullableWithAggregatesFilter<"surfaces_protegees"> | string | null
    APB?: StringNullableWithAggregatesFilter<"surfaces_protegees"> | string | null
    RN?: StringNullableWithAggregatesFilter<"surfaces_protegees"> | string | null
    RBFD?: StringNullableWithAggregatesFilter<"surfaces_protegees"> | string | null
    RNCFS?: StringNullableWithAggregatesFilter<"surfaces_protegees"> | string | null
    libelle_geographique?: StringWithAggregatesFilter<"surfaces_protegees"> | string
    epci?: StringWithAggregatesFilter<"surfaces_protegees"> | string
    libelle_epci?: StringWithAggregatesFilter<"surfaces_protegees"> | string
    departement?: StringWithAggregatesFilter<"surfaces_protegees"> | string
    region?: FloatWithAggregatesFilter<"surfaces_protegees"> | number
  }

  export type table_communeWhereInput = {
    AND?: table_communeWhereInput | table_communeWhereInput[]
    OR?: table_communeWhereInput[]
    NOT?: table_communeWhereInput | table_communeWhereInput[]
    index?: IntFilter<"table_commune"> | number
    code_geographique?: StringFilter<"table_commune"> | string
    libelle_geographique?: StringFilter<"table_commune"> | string
    epci?: StringFilter<"table_commune"> | string
    libelle_epci?: StringFilter<"table_commune"> | string
    departement?: StringFilter<"table_commune"> | string
    libelle_departement?: StringFilter<"table_commune"> | string
    region?: IntFilter<"table_commune"> | number
    ept?: StringNullableFilter<"table_commune"> | string | null
    libelle_petr?: StringNullableFilter<"table_commune"> | string | null
    code_pnr?: StringNullableFilter<"table_commune"> | string | null
    libelle_pnr?: StringNullableFilter<"table_commune"> | string | null
    atlas_biodiversite_nom?: StringNullableFilter<"table_commune"> | string | null
    atlas_biodiversite_annee_debut?: StringNullableFilter<"table_commune"> | string | null
    atlas_biodiversite_avancement?: StringNullableFilter<"table_commune"> | string | null
    type_touristique?: StringNullableFilter<"table_commune"> | string | null
    otex_12_postes?: StringNullableFilter<"table_commune"> | string | null
    part_irr_sau_2020?: StringNullableFilter<"table_commune"> | string | null
    agriculture_part_over_55?: StringNullableFilter<"table_commune"> | string | null
    couverture_lcz?: StringNullableFilter<"table_commune"> | string | null
  }

  export type table_communeOrderByWithRelationInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrderInput | SortOrder
    libelle_petr?: SortOrderInput | SortOrder
    code_pnr?: SortOrderInput | SortOrder
    libelle_pnr?: SortOrderInput | SortOrder
    atlas_biodiversite_nom?: SortOrderInput | SortOrder
    atlas_biodiversite_annee_debut?: SortOrderInput | SortOrder
    atlas_biodiversite_avancement?: SortOrderInput | SortOrder
    type_touristique?: SortOrderInput | SortOrder
    otex_12_postes?: SortOrderInput | SortOrder
    part_irr_sau_2020?: SortOrderInput | SortOrder
    agriculture_part_over_55?: SortOrderInput | SortOrder
    couverture_lcz?: SortOrderInput | SortOrder
  }

  export type table_communeWhereUniqueInput = Prisma.AtLeast<{
    index?: number
    AND?: table_communeWhereInput | table_communeWhereInput[]
    OR?: table_communeWhereInput[]
    NOT?: table_communeWhereInput | table_communeWhereInput[]
    code_geographique?: StringFilter<"table_commune"> | string
    libelle_geographique?: StringFilter<"table_commune"> | string
    epci?: StringFilter<"table_commune"> | string
    libelle_epci?: StringFilter<"table_commune"> | string
    departement?: StringFilter<"table_commune"> | string
    libelle_departement?: StringFilter<"table_commune"> | string
    region?: IntFilter<"table_commune"> | number
    ept?: StringNullableFilter<"table_commune"> | string | null
    libelle_petr?: StringNullableFilter<"table_commune"> | string | null
    code_pnr?: StringNullableFilter<"table_commune"> | string | null
    libelle_pnr?: StringNullableFilter<"table_commune"> | string | null
    atlas_biodiversite_nom?: StringNullableFilter<"table_commune"> | string | null
    atlas_biodiversite_annee_debut?: StringNullableFilter<"table_commune"> | string | null
    atlas_biodiversite_avancement?: StringNullableFilter<"table_commune"> | string | null
    type_touristique?: StringNullableFilter<"table_commune"> | string | null
    otex_12_postes?: StringNullableFilter<"table_commune"> | string | null
    part_irr_sau_2020?: StringNullableFilter<"table_commune"> | string | null
    agriculture_part_over_55?: StringNullableFilter<"table_commune"> | string | null
    couverture_lcz?: StringNullableFilter<"table_commune"> | string | null
  }, "index">

  export type table_communeOrderByWithAggregationInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrderInput | SortOrder
    libelle_petr?: SortOrderInput | SortOrder
    code_pnr?: SortOrderInput | SortOrder
    libelle_pnr?: SortOrderInput | SortOrder
    atlas_biodiversite_nom?: SortOrderInput | SortOrder
    atlas_biodiversite_annee_debut?: SortOrderInput | SortOrder
    atlas_biodiversite_avancement?: SortOrderInput | SortOrder
    type_touristique?: SortOrderInput | SortOrder
    otex_12_postes?: SortOrderInput | SortOrder
    part_irr_sau_2020?: SortOrderInput | SortOrder
    agriculture_part_over_55?: SortOrderInput | SortOrder
    couverture_lcz?: SortOrderInput | SortOrder
    _count?: table_communeCountOrderByAggregateInput
    _avg?: table_communeAvgOrderByAggregateInput
    _max?: table_communeMaxOrderByAggregateInput
    _min?: table_communeMinOrderByAggregateInput
    _sum?: table_communeSumOrderByAggregateInput
  }

  export type table_communeScalarWhereWithAggregatesInput = {
    AND?: table_communeScalarWhereWithAggregatesInput | table_communeScalarWhereWithAggregatesInput[]
    OR?: table_communeScalarWhereWithAggregatesInput[]
    NOT?: table_communeScalarWhereWithAggregatesInput | table_communeScalarWhereWithAggregatesInput[]
    index?: IntWithAggregatesFilter<"table_commune"> | number
    code_geographique?: StringWithAggregatesFilter<"table_commune"> | string
    libelle_geographique?: StringWithAggregatesFilter<"table_commune"> | string
    epci?: StringWithAggregatesFilter<"table_commune"> | string
    libelle_epci?: StringWithAggregatesFilter<"table_commune"> | string
    departement?: StringWithAggregatesFilter<"table_commune"> | string
    libelle_departement?: StringWithAggregatesFilter<"table_commune"> | string
    region?: IntWithAggregatesFilter<"table_commune"> | number
    ept?: StringNullableWithAggregatesFilter<"table_commune"> | string | null
    libelle_petr?: StringNullableWithAggregatesFilter<"table_commune"> | string | null
    code_pnr?: StringNullableWithAggregatesFilter<"table_commune"> | string | null
    libelle_pnr?: StringNullableWithAggregatesFilter<"table_commune"> | string | null
    atlas_biodiversite_nom?: StringNullableWithAggregatesFilter<"table_commune"> | string | null
    atlas_biodiversite_annee_debut?: StringNullableWithAggregatesFilter<"table_commune"> | string | null
    atlas_biodiversite_avancement?: StringNullableWithAggregatesFilter<"table_commune"> | string | null
    type_touristique?: StringNullableWithAggregatesFilter<"table_commune"> | string | null
    otex_12_postes?: StringNullableWithAggregatesFilter<"table_commune"> | string | null
    part_irr_sau_2020?: StringNullableWithAggregatesFilter<"table_commune"> | string | null
    agriculture_part_over_55?: StringNullableWithAggregatesFilter<"table_commune"> | string | null
    couverture_lcz?: StringNullableWithAggregatesFilter<"table_commune"> | string | null
  }

  export type table_territoiresWhereInput = {
    AND?: table_territoiresWhereInput | table_territoiresWhereInput[]
    OR?: table_territoiresWhereInput[]
    NOT?: table_territoiresWhereInput | table_territoiresWhereInput[]
    index?: IntFilter<"table_territoires"> | number
    code_geographique?: StringFilter<"table_territoires"> | string
    libelle_geographique?: StringFilter<"table_territoires"> | string
    epci?: StringFilter<"table_territoires"> | string
    libelle_epci?: StringFilter<"table_territoires"> | string
    departement?: StringFilter<"table_territoires"> | string
    libelle_departement?: StringFilter<"table_territoires"> | string
    region?: IntFilter<"table_territoires"> | number
    ept?: StringNullableFilter<"table_territoires"> | string | null
    libelle_petr?: StringNullableFilter<"table_territoires"> | string | null
    code_pnr?: StringNullableFilter<"table_territoires"> | string | null
    libelle_pnr?: StringNullableFilter<"table_territoires"> | string | null
  }

  export type table_territoiresOrderByWithRelationInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrderInput | SortOrder
    libelle_petr?: SortOrderInput | SortOrder
    code_pnr?: SortOrderInput | SortOrder
    libelle_pnr?: SortOrderInput | SortOrder
  }

  export type table_territoiresWhereUniqueInput = Prisma.AtLeast<{
    index?: number
    AND?: table_territoiresWhereInput | table_territoiresWhereInput[]
    OR?: table_territoiresWhereInput[]
    NOT?: table_territoiresWhereInput | table_territoiresWhereInput[]
    code_geographique?: StringFilter<"table_territoires"> | string
    libelle_geographique?: StringFilter<"table_territoires"> | string
    epci?: StringFilter<"table_territoires"> | string
    libelle_epci?: StringFilter<"table_territoires"> | string
    departement?: StringFilter<"table_territoires"> | string
    libelle_departement?: StringFilter<"table_territoires"> | string
    region?: IntFilter<"table_territoires"> | number
    ept?: StringNullableFilter<"table_territoires"> | string | null
    libelle_petr?: StringNullableFilter<"table_territoires"> | string | null
    code_pnr?: StringNullableFilter<"table_territoires"> | string | null
    libelle_pnr?: StringNullableFilter<"table_territoires"> | string | null
  }, "index">

  export type table_territoiresOrderByWithAggregationInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrderInput | SortOrder
    libelle_petr?: SortOrderInput | SortOrder
    code_pnr?: SortOrderInput | SortOrder
    libelle_pnr?: SortOrderInput | SortOrder
    _count?: table_territoiresCountOrderByAggregateInput
    _avg?: table_territoiresAvgOrderByAggregateInput
    _max?: table_territoiresMaxOrderByAggregateInput
    _min?: table_territoiresMinOrderByAggregateInput
    _sum?: table_territoiresSumOrderByAggregateInput
  }

  export type table_territoiresScalarWhereWithAggregatesInput = {
    AND?: table_territoiresScalarWhereWithAggregatesInput | table_territoiresScalarWhereWithAggregatesInput[]
    OR?: table_territoiresScalarWhereWithAggregatesInput[]
    NOT?: table_territoiresScalarWhereWithAggregatesInput | table_territoiresScalarWhereWithAggregatesInput[]
    index?: IntWithAggregatesFilter<"table_territoires"> | number
    code_geographique?: StringWithAggregatesFilter<"table_territoires"> | string
    libelle_geographique?: StringWithAggregatesFilter<"table_territoires"> | string
    epci?: StringWithAggregatesFilter<"table_territoires"> | string
    libelle_epci?: StringWithAggregatesFilter<"table_territoires"> | string
    departement?: StringWithAggregatesFilter<"table_territoires"> | string
    libelle_departement?: StringWithAggregatesFilter<"table_territoires"> | string
    region?: IntWithAggregatesFilter<"table_territoires"> | number
    ept?: StringNullableWithAggregatesFilter<"table_territoires"> | string | null
    libelle_petr?: StringNullableWithAggregatesFilter<"table_territoires"> | string | null
    code_pnr?: StringNullableWithAggregatesFilter<"table_territoires"> | string | null
    libelle_pnr?: StringNullableWithAggregatesFilter<"table_territoires"> | string | null
  }

  export type communes_dromWhereInput = {
    AND?: communes_dromWhereInput | communes_dromWhereInput[]
    OR?: communes_dromWhereInput[]
    NOT?: communes_dromWhereInput | communes_dromWhereInput[]
    pk?: IntFilter<"communes_drom"> | number
    code_geographique?: StringNullableFilter<"communes_drom"> | string | null
    libelle_geographique?: StringNullableFilter<"communes_drom"> | string | null
    epci?: StringNullableFilter<"communes_drom"> | string | null
    libelle_epci?: StringNullableFilter<"communes_drom"> | string | null
    departement?: StringNullableFilter<"communes_drom"> | string | null
    libelle_departement?: StringNullableFilter<"communes_drom"> | string | null
    region?: IntNullableFilter<"communes_drom"> | number | null
    ept?: StringNullableFilter<"communes_drom"> | string | null
    libelle_petr?: StringNullableFilter<"communes_drom"> | string | null
    code_pnr?: StringNullableFilter<"communes_drom"> | string | null
    libelle_pnr?: StringNullableFilter<"communes_drom"> | string | null
    coordinates?: StringNullableFilter<"communes_drom"> | string | null
    precarite_logement?: FloatNullableFilter<"communes_drom"> | number | null
    surface?: FloatNullableFilter<"communes_drom"> | number | null
  }

  export type communes_dromOrderByWithRelationInput = {
    pk?: SortOrder
    code_geographique?: SortOrderInput | SortOrder
    libelle_geographique?: SortOrderInput | SortOrder
    epci?: SortOrderInput | SortOrder
    libelle_epci?: SortOrderInput | SortOrder
    departement?: SortOrderInput | SortOrder
    libelle_departement?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    ept?: SortOrderInput | SortOrder
    libelle_petr?: SortOrderInput | SortOrder
    code_pnr?: SortOrderInput | SortOrder
    libelle_pnr?: SortOrderInput | SortOrder
    coordinates?: SortOrderInput | SortOrder
    precarite_logement?: SortOrderInput | SortOrder
    surface?: SortOrderInput | SortOrder
  }

  export type communes_dromWhereUniqueInput = Prisma.AtLeast<{
    pk?: number
    AND?: communes_dromWhereInput | communes_dromWhereInput[]
    OR?: communes_dromWhereInput[]
    NOT?: communes_dromWhereInput | communes_dromWhereInput[]
    code_geographique?: StringNullableFilter<"communes_drom"> | string | null
    libelle_geographique?: StringNullableFilter<"communes_drom"> | string | null
    epci?: StringNullableFilter<"communes_drom"> | string | null
    libelle_epci?: StringNullableFilter<"communes_drom"> | string | null
    departement?: StringNullableFilter<"communes_drom"> | string | null
    libelle_departement?: StringNullableFilter<"communes_drom"> | string | null
    region?: IntNullableFilter<"communes_drom"> | number | null
    ept?: StringNullableFilter<"communes_drom"> | string | null
    libelle_petr?: StringNullableFilter<"communes_drom"> | string | null
    code_pnr?: StringNullableFilter<"communes_drom"> | string | null
    libelle_pnr?: StringNullableFilter<"communes_drom"> | string | null
    coordinates?: StringNullableFilter<"communes_drom"> | string | null
    precarite_logement?: FloatNullableFilter<"communes_drom"> | number | null
    surface?: FloatNullableFilter<"communes_drom"> | number | null
  }, "pk">

  export type communes_dromOrderByWithAggregationInput = {
    pk?: SortOrder
    code_geographique?: SortOrderInput | SortOrder
    libelle_geographique?: SortOrderInput | SortOrder
    epci?: SortOrderInput | SortOrder
    libelle_epci?: SortOrderInput | SortOrder
    departement?: SortOrderInput | SortOrder
    libelle_departement?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    ept?: SortOrderInput | SortOrder
    libelle_petr?: SortOrderInput | SortOrder
    code_pnr?: SortOrderInput | SortOrder
    libelle_pnr?: SortOrderInput | SortOrder
    coordinates?: SortOrderInput | SortOrder
    precarite_logement?: SortOrderInput | SortOrder
    surface?: SortOrderInput | SortOrder
    _count?: communes_dromCountOrderByAggregateInput
    _avg?: communes_dromAvgOrderByAggregateInput
    _max?: communes_dromMaxOrderByAggregateInput
    _min?: communes_dromMinOrderByAggregateInput
    _sum?: communes_dromSumOrderByAggregateInput
  }

  export type communes_dromScalarWhereWithAggregatesInput = {
    AND?: communes_dromScalarWhereWithAggregatesInput | communes_dromScalarWhereWithAggregatesInput[]
    OR?: communes_dromScalarWhereWithAggregatesInput[]
    NOT?: communes_dromScalarWhereWithAggregatesInput | communes_dromScalarWhereWithAggregatesInput[]
    pk?: IntWithAggregatesFilter<"communes_drom"> | number
    code_geographique?: StringNullableWithAggregatesFilter<"communes_drom"> | string | null
    libelle_geographique?: StringNullableWithAggregatesFilter<"communes_drom"> | string | null
    epci?: StringNullableWithAggregatesFilter<"communes_drom"> | string | null
    libelle_epci?: StringNullableWithAggregatesFilter<"communes_drom"> | string | null
    departement?: StringNullableWithAggregatesFilter<"communes_drom"> | string | null
    libelle_departement?: StringNullableWithAggregatesFilter<"communes_drom"> | string | null
    region?: IntNullableWithAggregatesFilter<"communes_drom"> | number | null
    ept?: StringNullableWithAggregatesFilter<"communes_drom"> | string | null
    libelle_petr?: StringNullableWithAggregatesFilter<"communes_drom"> | string | null
    code_pnr?: StringNullableWithAggregatesFilter<"communes_drom"> | string | null
    libelle_pnr?: StringNullableWithAggregatesFilter<"communes_drom"> | string | null
    coordinates?: StringNullableWithAggregatesFilter<"communes_drom"> | string | null
    precarite_logement?: FloatNullableWithAggregatesFilter<"communes_drom"> | number | null
    surface?: FloatNullableWithAggregatesFilter<"communes_drom"> | number | null
  }

  export type erosion_cotiereWhereInput = {
    AND?: erosion_cotiereWhereInput | erosion_cotiereWhereInput[]
    OR?: erosion_cotiereWhereInput[]
    NOT?: erosion_cotiereWhereInput | erosion_cotiereWhereInput[]
    pk?: IntFilter<"erosion_cotiere"> | number
    taux?: FloatFilter<"erosion_cotiere"> | number
    duree?: FloatFilter<"erosion_cotiere"> | number
    tdc_ancien?: IntFilter<"erosion_cotiere"> | number
    tdc_rec?: IntFilter<"erosion_cotiere"> | number
  }

  export type erosion_cotiereOrderByWithRelationInput = {
    pk?: SortOrder
    taux?: SortOrder
    duree?: SortOrder
    tdc_ancien?: SortOrder
    tdc_rec?: SortOrder
  }

  export type erosion_cotiereWhereUniqueInput = Prisma.AtLeast<{
    pk?: number
    AND?: erosion_cotiereWhereInput | erosion_cotiereWhereInput[]
    OR?: erosion_cotiereWhereInput[]
    NOT?: erosion_cotiereWhereInput | erosion_cotiereWhereInput[]
    taux?: FloatFilter<"erosion_cotiere"> | number
    duree?: FloatFilter<"erosion_cotiere"> | number
    tdc_ancien?: IntFilter<"erosion_cotiere"> | number
    tdc_rec?: IntFilter<"erosion_cotiere"> | number
  }, "pk">

  export type erosion_cotiereOrderByWithAggregationInput = {
    pk?: SortOrder
    taux?: SortOrder
    duree?: SortOrder
    tdc_ancien?: SortOrder
    tdc_rec?: SortOrder
    _count?: erosion_cotiereCountOrderByAggregateInput
    _avg?: erosion_cotiereAvgOrderByAggregateInput
    _max?: erosion_cotiereMaxOrderByAggregateInput
    _min?: erosion_cotiereMinOrderByAggregateInput
    _sum?: erosion_cotiereSumOrderByAggregateInput
  }

  export type erosion_cotiereScalarWhereWithAggregatesInput = {
    AND?: erosion_cotiereScalarWhereWithAggregatesInput | erosion_cotiereScalarWhereWithAggregatesInput[]
    OR?: erosion_cotiereScalarWhereWithAggregatesInput[]
    NOT?: erosion_cotiereScalarWhereWithAggregatesInput | erosion_cotiereScalarWhereWithAggregatesInput[]
    pk?: IntWithAggregatesFilter<"erosion_cotiere"> | number
    taux?: FloatWithAggregatesFilter<"erosion_cotiere"> | number
    duree?: FloatWithAggregatesFilter<"erosion_cotiere"> | number
    tdc_ancien?: IntWithAggregatesFilter<"erosion_cotiere"> | number
    tdc_rec?: IntWithAggregatesFilter<"erosion_cotiere"> | number
  }

  export type etat_cours_d_eauWhereInput = {
    AND?: etat_cours_d_eauWhereInput | etat_cours_d_eauWhereInput[]
    OR?: etat_cours_d_eauWhereInput[]
    NOT?: etat_cours_d_eauWhereInput | etat_cours_d_eauWhereInput[]
    pk?: IntFilter<"etat_cours_d_eau"> | number
    name?: StringFilter<"etat_cours_d_eau"> | string
    longueur?: FloatFilter<"etat_cours_d_eau"> | number
    etateco?: StringNullableFilter<"etat_cours_d_eau"> | string | null
  }

  export type etat_cours_d_eauOrderByWithRelationInput = {
    pk?: SortOrder
    name?: SortOrder
    longueur?: SortOrder
    etateco?: SortOrderInput | SortOrder
  }

  export type etat_cours_d_eauWhereUniqueInput = Prisma.AtLeast<{
    pk?: number
    AND?: etat_cours_d_eauWhereInput | etat_cours_d_eauWhereInput[]
    OR?: etat_cours_d_eauWhereInput[]
    NOT?: etat_cours_d_eauWhereInput | etat_cours_d_eauWhereInput[]
    name?: StringFilter<"etat_cours_d_eau"> | string
    longueur?: FloatFilter<"etat_cours_d_eau"> | number
    etateco?: StringNullableFilter<"etat_cours_d_eau"> | string | null
  }, "pk">

  export type etat_cours_d_eauOrderByWithAggregationInput = {
    pk?: SortOrder
    name?: SortOrder
    longueur?: SortOrder
    etateco?: SortOrderInput | SortOrder
    _count?: etat_cours_d_eauCountOrderByAggregateInput
    _avg?: etat_cours_d_eauAvgOrderByAggregateInput
    _max?: etat_cours_d_eauMaxOrderByAggregateInput
    _min?: etat_cours_d_eauMinOrderByAggregateInput
    _sum?: etat_cours_d_eauSumOrderByAggregateInput
  }

  export type etat_cours_d_eauScalarWhereWithAggregatesInput = {
    AND?: etat_cours_d_eauScalarWhereWithAggregatesInput | etat_cours_d_eauScalarWhereWithAggregatesInput[]
    OR?: etat_cours_d_eauScalarWhereWithAggregatesInput[]
    NOT?: etat_cours_d_eauScalarWhereWithAggregatesInput | etat_cours_d_eauScalarWhereWithAggregatesInput[]
    pk?: IntWithAggregatesFilter<"etat_cours_d_eau"> | number
    name?: StringWithAggregatesFilter<"etat_cours_d_eau"> | string
    longueur?: FloatWithAggregatesFilter<"etat_cours_d_eau"> | number
    etateco?: StringNullableWithAggregatesFilter<"etat_cours_d_eau"> | string | null
  }

  export type spatial_ref_sysWhereInput = {
    AND?: spatial_ref_sysWhereInput | spatial_ref_sysWhereInput[]
    OR?: spatial_ref_sysWhereInput[]
    NOT?: spatial_ref_sysWhereInput | spatial_ref_sysWhereInput[]
    srid?: IntFilter<"spatial_ref_sys"> | number
    auth_name?: StringNullableFilter<"spatial_ref_sys"> | string | null
    auth_srid?: IntNullableFilter<"spatial_ref_sys"> | number | null
    srtext?: StringNullableFilter<"spatial_ref_sys"> | string | null
    proj4text?: StringNullableFilter<"spatial_ref_sys"> | string | null
  }

  export type spatial_ref_sysOrderByWithRelationInput = {
    srid?: SortOrder
    auth_name?: SortOrderInput | SortOrder
    auth_srid?: SortOrderInput | SortOrder
    srtext?: SortOrderInput | SortOrder
    proj4text?: SortOrderInput | SortOrder
  }

  export type spatial_ref_sysWhereUniqueInput = Prisma.AtLeast<{
    srid?: number
    AND?: spatial_ref_sysWhereInput | spatial_ref_sysWhereInput[]
    OR?: spatial_ref_sysWhereInput[]
    NOT?: spatial_ref_sysWhereInput | spatial_ref_sysWhereInput[]
    auth_name?: StringNullableFilter<"spatial_ref_sys"> | string | null
    auth_srid?: IntNullableFilter<"spatial_ref_sys"> | number | null
    srtext?: StringNullableFilter<"spatial_ref_sys"> | string | null
    proj4text?: StringNullableFilter<"spatial_ref_sys"> | string | null
  }, "srid">

  export type spatial_ref_sysOrderByWithAggregationInput = {
    srid?: SortOrder
    auth_name?: SortOrderInput | SortOrder
    auth_srid?: SortOrderInput | SortOrder
    srtext?: SortOrderInput | SortOrder
    proj4text?: SortOrderInput | SortOrder
    _count?: spatial_ref_sysCountOrderByAggregateInput
    _avg?: spatial_ref_sysAvgOrderByAggregateInput
    _max?: spatial_ref_sysMaxOrderByAggregateInput
    _min?: spatial_ref_sysMinOrderByAggregateInput
    _sum?: spatial_ref_sysSumOrderByAggregateInput
  }

  export type spatial_ref_sysScalarWhereWithAggregatesInput = {
    AND?: spatial_ref_sysScalarWhereWithAggregatesInput | spatial_ref_sysScalarWhereWithAggregatesInput[]
    OR?: spatial_ref_sysScalarWhereWithAggregatesInput[]
    NOT?: spatial_ref_sysScalarWhereWithAggregatesInput | spatial_ref_sysScalarWhereWithAggregatesInput[]
    srid?: IntWithAggregatesFilter<"spatial_ref_sys"> | number
    auth_name?: StringNullableWithAggregatesFilter<"spatial_ref_sys"> | string | null
    auth_srid?: IntNullableWithAggregatesFilter<"spatial_ref_sys"> | number | null
    srtext?: StringNullableWithAggregatesFilter<"spatial_ref_sys"> | string | null
    proj4text?: StringNullableWithAggregatesFilter<"spatial_ref_sys"> | string | null
  }

  export type north_star_metricCreateInput = {
    value: string
    date: Date | string
    pk: number
  }

  export type north_star_metricUncheckedCreateInput = {
    value: string
    date: Date | string
    pk: number
  }

  export type north_star_metricUpdateInput = {
    value?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    pk?: IntFieldUpdateOperationsInput | number
  }

  export type north_star_metricUncheckedUpdateInput = {
    value?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    pk?: IntFieldUpdateOperationsInput | number
  }

  export type north_star_metricCreateManyInput = {
    value: string
    date: Date | string
    pk: number
  }

  export type north_star_metricUpdateManyMutationInput = {
    value?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    pk?: IntFieldUpdateOperationsInput | number
  }

  export type north_star_metricUncheckedUpdateManyInput = {
    value?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    pk?: IntFieldUpdateOperationsInput | number
  }

  export type sandbox_usersCreateInput = {
    username: string
    password: string
    created_at: Date | string
  }

  export type sandbox_usersUncheckedCreateInput = {
    username: string
    pk?: number
    password: string
    created_at: Date | string
  }

  export type sandbox_usersUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sandbox_usersUncheckedUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    pk?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sandbox_usersCreateManyInput = {
    username: string
    pk?: number
    password: string
    created_at: Date | string
  }

  export type sandbox_usersUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sandbox_usersUncheckedUpdateManyInput = {
    username?: StringFieldUpdateOperationsInput | string
    pk?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersCreateInput = {
    email: string
    username: string
    password: string
    created_at: Date | string
    last_connection?: Date | string | null
    role: string
  }

  export type usersUncheckedCreateInput = {
    pk?: number
    email: string
    username: string
    password: string
    created_at: Date | string
    last_connection?: Date | string | null
    role: string
  }

  export type usersUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_connection?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
  }

  export type usersUncheckedUpdateInput = {
    pk?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_connection?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
  }

  export type usersCreateManyInput = {
    pk?: number
    email: string
    username: string
    password: string
    created_at: Date | string
    last_connection?: Date | string | null
    role: string
  }

  export type usersUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_connection?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
  }

  export type usersUncheckedUpdateManyInput = {
    pk?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_connection?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: StringFieldUpdateOperationsInput | string
  }

  export type all_autocapture_rawCreateInput = {
    id?: bigint | number
    event_timestamp: Date | string
    properties?: NullableJsonNullValueInput | InputJsonValue
    distinct_id?: string | null
    session_id?: string | null
    current_url?: string | null
    person_id?: string | null
    ingested_at?: Date | string
  }

  export type all_autocapture_rawUncheckedCreateInput = {
    id?: bigint | number
    event_timestamp: Date | string
    properties?: NullableJsonNullValueInput | InputJsonValue
    distinct_id?: string | null
    session_id?: string | null
    current_url?: string | null
    person_id?: string | null
    ingested_at?: Date | string
  }

  export type all_autocapture_rawUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    event_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: NullableJsonNullValueInput | InputJsonValue
    distinct_id?: NullableStringFieldUpdateOperationsInput | string | null
    session_id?: NullableStringFieldUpdateOperationsInput | string | null
    current_url?: NullableStringFieldUpdateOperationsInput | string | null
    person_id?: NullableStringFieldUpdateOperationsInput | string | null
    ingested_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type all_autocapture_rawUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    event_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: NullableJsonNullValueInput | InputJsonValue
    distinct_id?: NullableStringFieldUpdateOperationsInput | string | null
    session_id?: NullableStringFieldUpdateOperationsInput | string | null
    current_url?: NullableStringFieldUpdateOperationsInput | string | null
    person_id?: NullableStringFieldUpdateOperationsInput | string | null
    ingested_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type all_autocapture_rawCreateManyInput = {
    id?: bigint | number
    event_timestamp: Date | string
    properties?: NullableJsonNullValueInput | InputJsonValue
    distinct_id?: string | null
    session_id?: string | null
    current_url?: string | null
    person_id?: string | null
    ingested_at?: Date | string
  }

  export type all_autocapture_rawUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    event_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: NullableJsonNullValueInput | InputJsonValue
    distinct_id?: NullableStringFieldUpdateOperationsInput | string | null
    session_id?: NullableStringFieldUpdateOperationsInput | string | null
    current_url?: NullableStringFieldUpdateOperationsInput | string | null
    person_id?: NullableStringFieldUpdateOperationsInput | string | null
    ingested_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type all_autocapture_rawUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    event_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: NullableJsonNullValueInput | InputJsonValue
    distinct_id?: NullableStringFieldUpdateOperationsInput | string | null
    session_id?: NullableStringFieldUpdateOperationsInput | string | null
    current_url?: NullableStringFieldUpdateOperationsInput | string | null
    person_id?: NullableStringFieldUpdateOperationsInput | string | null
    ingested_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type all_pageview_rawCreateInput = {
    id?: bigint | number
    event_timestamp: Date | string
    properties?: NullableJsonNullValueInput | InputJsonValue
    distinct_id?: string | null
    session_id?: string | null
    current_url?: string | null
    person_id?: string | null
    ingested_at?: Date | string
  }

  export type all_pageview_rawUncheckedCreateInput = {
    id?: bigint | number
    event_timestamp: Date | string
    properties?: NullableJsonNullValueInput | InputJsonValue
    distinct_id?: string | null
    session_id?: string | null
    current_url?: string | null
    person_id?: string | null
    ingested_at?: Date | string
  }

  export type all_pageview_rawUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    event_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: NullableJsonNullValueInput | InputJsonValue
    distinct_id?: NullableStringFieldUpdateOperationsInput | string | null
    session_id?: NullableStringFieldUpdateOperationsInput | string | null
    current_url?: NullableStringFieldUpdateOperationsInput | string | null
    person_id?: NullableStringFieldUpdateOperationsInput | string | null
    ingested_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type all_pageview_rawUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    event_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: NullableJsonNullValueInput | InputJsonValue
    distinct_id?: NullableStringFieldUpdateOperationsInput | string | null
    session_id?: NullableStringFieldUpdateOperationsInput | string | null
    current_url?: NullableStringFieldUpdateOperationsInput | string | null
    person_id?: NullableStringFieldUpdateOperationsInput | string | null
    ingested_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type all_pageview_rawCreateManyInput = {
    id?: bigint | number
    event_timestamp: Date | string
    properties?: NullableJsonNullValueInput | InputJsonValue
    distinct_id?: string | null
    session_id?: string | null
    current_url?: string | null
    person_id?: string | null
    ingested_at?: Date | string
  }

  export type all_pageview_rawUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    event_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: NullableJsonNullValueInput | InputJsonValue
    distinct_id?: NullableStringFieldUpdateOperationsInput | string | null
    session_id?: NullableStringFieldUpdateOperationsInput | string | null
    current_url?: NullableStringFieldUpdateOperationsInput | string | null
    person_id?: NullableStringFieldUpdateOperationsInput | string | null
    ingested_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type all_pageview_rawUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    event_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: NullableJsonNullValueInput | InputJsonValue
    distinct_id?: NullableStringFieldUpdateOperationsInput | string | null
    session_id?: NullableStringFieldUpdateOperationsInput | string | null
    current_url?: NullableStringFieldUpdateOperationsInput | string | null
    person_id?: NullableStringFieldUpdateOperationsInput | string | null
    ingested_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type baserow_evenementsCreateInput = {
    id?: bigint | number
    ordre?: string | null
    nom?: string | null
    date?: string | null
    type?: NullableJsonNullValueInput | InputJsonValue
    qui_anime_evenement?: baserow_evenementsCreatequi_anime_evenementInput | string[]
    compte_rendu?: string | null
    nom_participants?: baserow_evenementsCreatenom_participantsInput | string[]
    nom_territoires?: baserow_evenementsCreatenom_territoiresInput | string[]
    propos_nom_evenement?: baserow_evenementsCreatepropos_nom_evenementInput | string[]
    campagne_test_utilisateur?: NullableJsonNullValueInput | InputJsonValue
    champs_rapporte?: baserow_evenementsCreatechamps_rapporteInput | string[]
    fichier?: baserow_evenementsCreatefichierInput | string[]
    ingested_at?: Date | string
  }

  export type baserow_evenementsUncheckedCreateInput = {
    id?: bigint | number
    ordre?: string | null
    nom?: string | null
    date?: string | null
    type?: NullableJsonNullValueInput | InputJsonValue
    qui_anime_evenement?: baserow_evenementsCreatequi_anime_evenementInput | string[]
    compte_rendu?: string | null
    nom_participants?: baserow_evenementsCreatenom_participantsInput | string[]
    nom_territoires?: baserow_evenementsCreatenom_territoiresInput | string[]
    propos_nom_evenement?: baserow_evenementsCreatepropos_nom_evenementInput | string[]
    campagne_test_utilisateur?: NullableJsonNullValueInput | InputJsonValue
    champs_rapporte?: baserow_evenementsCreatechamps_rapporteInput | string[]
    fichier?: baserow_evenementsCreatefichierInput | string[]
    ingested_at?: Date | string
  }

  export type baserow_evenementsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ordre?: NullableStringFieldUpdateOperationsInput | string | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableJsonNullValueInput | InputJsonValue
    qui_anime_evenement?: baserow_evenementsUpdatequi_anime_evenementInput | string[]
    compte_rendu?: NullableStringFieldUpdateOperationsInput | string | null
    nom_participants?: baserow_evenementsUpdatenom_participantsInput | string[]
    nom_territoires?: baserow_evenementsUpdatenom_territoiresInput | string[]
    propos_nom_evenement?: baserow_evenementsUpdatepropos_nom_evenementInput | string[]
    campagne_test_utilisateur?: NullableJsonNullValueInput | InputJsonValue
    champs_rapporte?: baserow_evenementsUpdatechamps_rapporteInput | string[]
    fichier?: baserow_evenementsUpdatefichierInput | string[]
    ingested_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type baserow_evenementsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ordre?: NullableStringFieldUpdateOperationsInput | string | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableJsonNullValueInput | InputJsonValue
    qui_anime_evenement?: baserow_evenementsUpdatequi_anime_evenementInput | string[]
    compte_rendu?: NullableStringFieldUpdateOperationsInput | string | null
    nom_participants?: baserow_evenementsUpdatenom_participantsInput | string[]
    nom_territoires?: baserow_evenementsUpdatenom_territoiresInput | string[]
    propos_nom_evenement?: baserow_evenementsUpdatepropos_nom_evenementInput | string[]
    campagne_test_utilisateur?: NullableJsonNullValueInput | InputJsonValue
    champs_rapporte?: baserow_evenementsUpdatechamps_rapporteInput | string[]
    fichier?: baserow_evenementsUpdatefichierInput | string[]
    ingested_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type baserow_evenementsCreateManyInput = {
    id?: bigint | number
    ordre?: string | null
    nom?: string | null
    date?: string | null
    type?: NullableJsonNullValueInput | InputJsonValue
    qui_anime_evenement?: baserow_evenementsCreatequi_anime_evenementInput | string[]
    compte_rendu?: string | null
    nom_participants?: baserow_evenementsCreatenom_participantsInput | string[]
    nom_territoires?: baserow_evenementsCreatenom_territoiresInput | string[]
    propos_nom_evenement?: baserow_evenementsCreatepropos_nom_evenementInput | string[]
    campagne_test_utilisateur?: NullableJsonNullValueInput | InputJsonValue
    champs_rapporte?: baserow_evenementsCreatechamps_rapporteInput | string[]
    fichier?: baserow_evenementsCreatefichierInput | string[]
    ingested_at?: Date | string
  }

  export type baserow_evenementsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ordre?: NullableStringFieldUpdateOperationsInput | string | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableJsonNullValueInput | InputJsonValue
    qui_anime_evenement?: baserow_evenementsUpdatequi_anime_evenementInput | string[]
    compte_rendu?: NullableStringFieldUpdateOperationsInput | string | null
    nom_participants?: baserow_evenementsUpdatenom_participantsInput | string[]
    nom_territoires?: baserow_evenementsUpdatenom_territoiresInput | string[]
    propos_nom_evenement?: baserow_evenementsUpdatepropos_nom_evenementInput | string[]
    campagne_test_utilisateur?: NullableJsonNullValueInput | InputJsonValue
    champs_rapporte?: baserow_evenementsUpdatechamps_rapporteInput | string[]
    fichier?: baserow_evenementsUpdatefichierInput | string[]
    ingested_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type baserow_evenementsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ordre?: NullableStringFieldUpdateOperationsInput | string | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableJsonNullValueInput | InputJsonValue
    qui_anime_evenement?: baserow_evenementsUpdatequi_anime_evenementInput | string[]
    compte_rendu?: NullableStringFieldUpdateOperationsInput | string | null
    nom_participants?: baserow_evenementsUpdatenom_participantsInput | string[]
    nom_territoires?: baserow_evenementsUpdatenom_territoiresInput | string[]
    propos_nom_evenement?: baserow_evenementsUpdatepropos_nom_evenementInput | string[]
    campagne_test_utilisateur?: NullableJsonNullValueInput | InputJsonValue
    champs_rapporte?: baserow_evenementsUpdatechamps_rapporteInput | string[]
    fichier?: baserow_evenementsUpdatefichierInput | string[]
    ingested_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type baserow_territoiresCreateInput = {
    id?: bigint | number
    ordre?: string | null
    nom_territoire?: string | null
    notes_ouvertes?: string | null
    typologie_territoire?: baserow_territoiresCreatetypologie_territoireInput | string[]
    thematique_prioritaire?: baserow_territoiresCreatethematique_prioritaireInput | string[]
    be?: boolean | null
    soumis_a_pcaet?: boolean | null
    demarches_et_programmes?: baserow_territoiresCreatedemarches_et_programmesInput | string[]
    documents_de_planification?: baserow_territoiresCreatedocuments_de_planificationInput | string[]
    avancee_sur_le_ddv?: baserow_territoiresCreateavancee_sur_le_ddvInput | string[]
    avancee_sur_la_strategie?: baserow_territoiresCreateavancee_sur_la_strategieInput | string[]
    suivi_evaluation?: boolean | null
    date_validation?: string | null
    date_revision_estimee?: string | null
    propos?: baserow_territoiresCreateproposInput | string[]
    attente_session_accueil?: baserow_territoiresCreateattente_session_accueilInput | string[]
    role_be?: baserow_territoiresCreaterole_beInput | string[]
    cdm?: baserow_territoiresCreatecdmInput | string[]
    siren?: string | null
    ingested_at?: Date | string
  }

  export type baserow_territoiresUncheckedCreateInput = {
    id?: bigint | number
    ordre?: string | null
    nom_territoire?: string | null
    notes_ouvertes?: string | null
    typologie_territoire?: baserow_territoiresCreatetypologie_territoireInput | string[]
    thematique_prioritaire?: baserow_territoiresCreatethematique_prioritaireInput | string[]
    be?: boolean | null
    soumis_a_pcaet?: boolean | null
    demarches_et_programmes?: baserow_territoiresCreatedemarches_et_programmesInput | string[]
    documents_de_planification?: baserow_territoiresCreatedocuments_de_planificationInput | string[]
    avancee_sur_le_ddv?: baserow_territoiresCreateavancee_sur_le_ddvInput | string[]
    avancee_sur_la_strategie?: baserow_territoiresCreateavancee_sur_la_strategieInput | string[]
    suivi_evaluation?: boolean | null
    date_validation?: string | null
    date_revision_estimee?: string | null
    propos?: baserow_territoiresCreateproposInput | string[]
    attente_session_accueil?: baserow_territoiresCreateattente_session_accueilInput | string[]
    role_be?: baserow_territoiresCreaterole_beInput | string[]
    cdm?: baserow_territoiresCreatecdmInput | string[]
    siren?: string | null
    ingested_at?: Date | string
  }

  export type baserow_territoiresUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ordre?: NullableStringFieldUpdateOperationsInput | string | null
    nom_territoire?: NullableStringFieldUpdateOperationsInput | string | null
    notes_ouvertes?: NullableStringFieldUpdateOperationsInput | string | null
    typologie_territoire?: baserow_territoiresUpdatetypologie_territoireInput | string[]
    thematique_prioritaire?: baserow_territoiresUpdatethematique_prioritaireInput | string[]
    be?: NullableBoolFieldUpdateOperationsInput | boolean | null
    soumis_a_pcaet?: NullableBoolFieldUpdateOperationsInput | boolean | null
    demarches_et_programmes?: baserow_territoiresUpdatedemarches_et_programmesInput | string[]
    documents_de_planification?: baserow_territoiresUpdatedocuments_de_planificationInput | string[]
    avancee_sur_le_ddv?: baserow_territoiresUpdateavancee_sur_le_ddvInput | string[]
    avancee_sur_la_strategie?: baserow_territoiresUpdateavancee_sur_la_strategieInput | string[]
    suivi_evaluation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    date_validation?: NullableStringFieldUpdateOperationsInput | string | null
    date_revision_estimee?: NullableStringFieldUpdateOperationsInput | string | null
    propos?: baserow_territoiresUpdateproposInput | string[]
    attente_session_accueil?: baserow_territoiresUpdateattente_session_accueilInput | string[]
    role_be?: baserow_territoiresUpdaterole_beInput | string[]
    cdm?: baserow_territoiresUpdatecdmInput | string[]
    siren?: NullableStringFieldUpdateOperationsInput | string | null
    ingested_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type baserow_territoiresUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ordre?: NullableStringFieldUpdateOperationsInput | string | null
    nom_territoire?: NullableStringFieldUpdateOperationsInput | string | null
    notes_ouvertes?: NullableStringFieldUpdateOperationsInput | string | null
    typologie_territoire?: baserow_territoiresUpdatetypologie_territoireInput | string[]
    thematique_prioritaire?: baserow_territoiresUpdatethematique_prioritaireInput | string[]
    be?: NullableBoolFieldUpdateOperationsInput | boolean | null
    soumis_a_pcaet?: NullableBoolFieldUpdateOperationsInput | boolean | null
    demarches_et_programmes?: baserow_territoiresUpdatedemarches_et_programmesInput | string[]
    documents_de_planification?: baserow_territoiresUpdatedocuments_de_planificationInput | string[]
    avancee_sur_le_ddv?: baserow_territoiresUpdateavancee_sur_le_ddvInput | string[]
    avancee_sur_la_strategie?: baserow_territoiresUpdateavancee_sur_la_strategieInput | string[]
    suivi_evaluation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    date_validation?: NullableStringFieldUpdateOperationsInput | string | null
    date_revision_estimee?: NullableStringFieldUpdateOperationsInput | string | null
    propos?: baserow_territoiresUpdateproposInput | string[]
    attente_session_accueil?: baserow_territoiresUpdateattente_session_accueilInput | string[]
    role_be?: baserow_territoiresUpdaterole_beInput | string[]
    cdm?: baserow_territoiresUpdatecdmInput | string[]
    siren?: NullableStringFieldUpdateOperationsInput | string | null
    ingested_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type baserow_territoiresCreateManyInput = {
    id?: bigint | number
    ordre?: string | null
    nom_territoire?: string | null
    notes_ouvertes?: string | null
    typologie_territoire?: baserow_territoiresCreatetypologie_territoireInput | string[]
    thematique_prioritaire?: baserow_territoiresCreatethematique_prioritaireInput | string[]
    be?: boolean | null
    soumis_a_pcaet?: boolean | null
    demarches_et_programmes?: baserow_territoiresCreatedemarches_et_programmesInput | string[]
    documents_de_planification?: baserow_territoiresCreatedocuments_de_planificationInput | string[]
    avancee_sur_le_ddv?: baserow_territoiresCreateavancee_sur_le_ddvInput | string[]
    avancee_sur_la_strategie?: baserow_territoiresCreateavancee_sur_la_strategieInput | string[]
    suivi_evaluation?: boolean | null
    date_validation?: string | null
    date_revision_estimee?: string | null
    propos?: baserow_territoiresCreateproposInput | string[]
    attente_session_accueil?: baserow_territoiresCreateattente_session_accueilInput | string[]
    role_be?: baserow_territoiresCreaterole_beInput | string[]
    cdm?: baserow_territoiresCreatecdmInput | string[]
    siren?: string | null
    ingested_at?: Date | string
  }

  export type baserow_territoiresUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ordre?: NullableStringFieldUpdateOperationsInput | string | null
    nom_territoire?: NullableStringFieldUpdateOperationsInput | string | null
    notes_ouvertes?: NullableStringFieldUpdateOperationsInput | string | null
    typologie_territoire?: baserow_territoiresUpdatetypologie_territoireInput | string[]
    thematique_prioritaire?: baserow_territoiresUpdatethematique_prioritaireInput | string[]
    be?: NullableBoolFieldUpdateOperationsInput | boolean | null
    soumis_a_pcaet?: NullableBoolFieldUpdateOperationsInput | boolean | null
    demarches_et_programmes?: baserow_territoiresUpdatedemarches_et_programmesInput | string[]
    documents_de_planification?: baserow_territoiresUpdatedocuments_de_planificationInput | string[]
    avancee_sur_le_ddv?: baserow_territoiresUpdateavancee_sur_le_ddvInput | string[]
    avancee_sur_la_strategie?: baserow_territoiresUpdateavancee_sur_la_strategieInput | string[]
    suivi_evaluation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    date_validation?: NullableStringFieldUpdateOperationsInput | string | null
    date_revision_estimee?: NullableStringFieldUpdateOperationsInput | string | null
    propos?: baserow_territoiresUpdateproposInput | string[]
    attente_session_accueil?: baserow_territoiresUpdateattente_session_accueilInput | string[]
    role_be?: baserow_territoiresUpdaterole_beInput | string[]
    cdm?: baserow_territoiresUpdatecdmInput | string[]
    siren?: NullableStringFieldUpdateOperationsInput | string | null
    ingested_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type baserow_territoiresUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ordre?: NullableStringFieldUpdateOperationsInput | string | null
    nom_territoire?: NullableStringFieldUpdateOperationsInput | string | null
    notes_ouvertes?: NullableStringFieldUpdateOperationsInput | string | null
    typologie_territoire?: baserow_territoiresUpdatetypologie_territoireInput | string[]
    thematique_prioritaire?: baserow_territoiresUpdatethematique_prioritaireInput | string[]
    be?: NullableBoolFieldUpdateOperationsInput | boolean | null
    soumis_a_pcaet?: NullableBoolFieldUpdateOperationsInput | boolean | null
    demarches_et_programmes?: baserow_territoiresUpdatedemarches_et_programmesInput | string[]
    documents_de_planification?: baserow_territoiresUpdatedocuments_de_planificationInput | string[]
    avancee_sur_le_ddv?: baserow_territoiresUpdateavancee_sur_le_ddvInput | string[]
    avancee_sur_la_strategie?: baserow_territoiresUpdateavancee_sur_la_strategieInput | string[]
    suivi_evaluation?: NullableBoolFieldUpdateOperationsInput | boolean | null
    date_validation?: NullableStringFieldUpdateOperationsInput | string | null
    date_revision_estimee?: NullableStringFieldUpdateOperationsInput | string | null
    propos?: baserow_territoiresUpdateproposInput | string[]
    attente_session_accueil?: baserow_territoiresUpdateattente_session_accueilInput | string[]
    role_be?: baserow_territoiresUpdaterole_beInput | string[]
    cdm?: baserow_territoiresUpdatecdmInput | string[]
    siren?: NullableStringFieldUpdateOperationsInput | string | null
    ingested_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type boutons_export_rawCreateInput = {
    id?: bigint | number
    event: string
    event_timestamp: Date | string
    session_id?: string | null
    person_id?: string | null
    code_geographique?: string | null
    libelle_geographique?: string | null
    thematique?: string | null
    ingested_at?: Date | string
  }

  export type boutons_export_rawUncheckedCreateInput = {
    id?: bigint | number
    event: string
    event_timestamp: Date | string
    session_id?: string | null
    person_id?: string | null
    code_geographique?: string | null
    libelle_geographique?: string | null
    thematique?: string | null
    ingested_at?: Date | string
  }

  export type boutons_export_rawUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    event?: StringFieldUpdateOperationsInput | string
    event_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    session_id?: NullableStringFieldUpdateOperationsInput | string | null
    person_id?: NullableStringFieldUpdateOperationsInput | string | null
    code_geographique?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_geographique?: NullableStringFieldUpdateOperationsInput | string | null
    thematique?: NullableStringFieldUpdateOperationsInput | string | null
    ingested_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type boutons_export_rawUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    event?: StringFieldUpdateOperationsInput | string
    event_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    session_id?: NullableStringFieldUpdateOperationsInput | string | null
    person_id?: NullableStringFieldUpdateOperationsInput | string | null
    code_geographique?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_geographique?: NullableStringFieldUpdateOperationsInput | string | null
    thematique?: NullableStringFieldUpdateOperationsInput | string | null
    ingested_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type boutons_export_rawCreateManyInput = {
    id?: bigint | number
    event: string
    event_timestamp: Date | string
    session_id?: string | null
    person_id?: string | null
    code_geographique?: string | null
    libelle_geographique?: string | null
    thematique?: string | null
    ingested_at?: Date | string
  }

  export type boutons_export_rawUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    event?: StringFieldUpdateOperationsInput | string
    event_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    session_id?: NullableStringFieldUpdateOperationsInput | string | null
    person_id?: NullableStringFieldUpdateOperationsInput | string | null
    code_geographique?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_geographique?: NullableStringFieldUpdateOperationsInput | string | null
    thematique?: NullableStringFieldUpdateOperationsInput | string | null
    ingested_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type boutons_export_rawUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    event?: StringFieldUpdateOperationsInput | string
    event_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    session_id?: NullableStringFieldUpdateOperationsInput | string | null
    person_id?: NullableStringFieldUpdateOperationsInput | string | null
    code_geographique?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_geographique?: NullableStringFieldUpdateOperationsInput | string | null
    thematique?: NullableStringFieldUpdateOperationsInput | string | null
    ingested_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type boutons_homepageCreateInput = {
    id?: bigint | number
    event?: string | null
    event_timestamp: Date | string
    properties?: NullableJsonNullValueInput | InputJsonValue
    distinct_id?: string | null
    session_id?: string | null
    person_id?: string | null
    ingested_at?: Date | string
  }

  export type boutons_homepageUncheckedCreateInput = {
    id?: bigint | number
    event?: string | null
    event_timestamp: Date | string
    properties?: NullableJsonNullValueInput | InputJsonValue
    distinct_id?: string | null
    session_id?: string | null
    person_id?: string | null
    ingested_at?: Date | string
  }

  export type boutons_homepageUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    event?: NullableStringFieldUpdateOperationsInput | string | null
    event_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: NullableJsonNullValueInput | InputJsonValue
    distinct_id?: NullableStringFieldUpdateOperationsInput | string | null
    session_id?: NullableStringFieldUpdateOperationsInput | string | null
    person_id?: NullableStringFieldUpdateOperationsInput | string | null
    ingested_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type boutons_homepageUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    event?: NullableStringFieldUpdateOperationsInput | string | null
    event_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: NullableJsonNullValueInput | InputJsonValue
    distinct_id?: NullableStringFieldUpdateOperationsInput | string | null
    session_id?: NullableStringFieldUpdateOperationsInput | string | null
    person_id?: NullableStringFieldUpdateOperationsInput | string | null
    ingested_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type boutons_homepageCreateManyInput = {
    id?: bigint | number
    event?: string | null
    event_timestamp: Date | string
    properties?: NullableJsonNullValueInput | InputJsonValue
    distinct_id?: string | null
    session_id?: string | null
    person_id?: string | null
    ingested_at?: Date | string
  }

  export type boutons_homepageUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    event?: NullableStringFieldUpdateOperationsInput | string | null
    event_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: NullableJsonNullValueInput | InputJsonValue
    distinct_id?: NullableStringFieldUpdateOperationsInput | string | null
    session_id?: NullableStringFieldUpdateOperationsInput | string | null
    person_id?: NullableStringFieldUpdateOperationsInput | string | null
    ingested_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type boutons_homepageUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    event?: NullableStringFieldUpdateOperationsInput | string | null
    event_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: NullableJsonNullValueInput | InputJsonValue
    distinct_id?: NullableStringFieldUpdateOperationsInput | string | null
    session_id?: NullableStringFieldUpdateOperationsInput | string | null
    person_id?: NullableStringFieldUpdateOperationsInput | string | null
    ingested_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type couverture_populationCreateInput = {
    id?: bigint | number
    date?: Date | string
    population: number
  }

  export type couverture_populationUncheckedCreateInput = {
    id?: bigint | number
    date?: Date | string
    population: number
  }

  export type couverture_populationUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    population?: IntFieldUpdateOperationsInput | number
  }

  export type couverture_populationUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    population?: IntFieldUpdateOperationsInput | number
  }

  export type couverture_populationCreateManyInput = {
    id?: bigint | number
    date?: Date | string
    population: number
  }

  export type couverture_populationUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    population?: IntFieldUpdateOperationsInput | number
  }

  export type couverture_populationUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    population?: IntFieldUpdateOperationsInput | number
  }

  export type ressources_consulteesCreateInput = {
    id?: bigint | number
    event_timestamp: Date | string
    distinct_id?: string | null
    session_id?: string | null
    person_id?: string | null
    ressource?: string | null
    ingested_at?: Date | string
  }

  export type ressources_consulteesUncheckedCreateInput = {
    id?: bigint | number
    event_timestamp: Date | string
    distinct_id?: string | null
    session_id?: string | null
    person_id?: string | null
    ressource?: string | null
    ingested_at?: Date | string
  }

  export type ressources_consulteesUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    event_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    distinct_id?: NullableStringFieldUpdateOperationsInput | string | null
    session_id?: NullableStringFieldUpdateOperationsInput | string | null
    person_id?: NullableStringFieldUpdateOperationsInput | string | null
    ressource?: NullableStringFieldUpdateOperationsInput | string | null
    ingested_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ressources_consulteesUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    event_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    distinct_id?: NullableStringFieldUpdateOperationsInput | string | null
    session_id?: NullableStringFieldUpdateOperationsInput | string | null
    person_id?: NullableStringFieldUpdateOperationsInput | string | null
    ressource?: NullableStringFieldUpdateOperationsInput | string | null
    ingested_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ressources_consulteesCreateManyInput = {
    id?: bigint | number
    event_timestamp: Date | string
    distinct_id?: string | null
    session_id?: string | null
    person_id?: string | null
    ressource?: string | null
    ingested_at?: Date | string
  }

  export type ressources_consulteesUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    event_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    distinct_id?: NullableStringFieldUpdateOperationsInput | string | null
    session_id?: NullableStringFieldUpdateOperationsInput | string | null
    person_id?: NullableStringFieldUpdateOperationsInput | string | null
    ressource?: NullableStringFieldUpdateOperationsInput | string | null
    ingested_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ressources_consulteesUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    event_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    distinct_id?: NullableStringFieldUpdateOperationsInput | string | null
    session_id?: NullableStringFieldUpdateOperationsInput | string | null
    person_id?: NullableStringFieldUpdateOperationsInput | string | null
    ressource?: NullableStringFieldUpdateOperationsInput | string | null
    ingested_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type thematiqueCreateInput = {
    id?: bigint | number
    event_timestamp: Date | string
    properties?: NullableJsonNullValueInput | InputJsonValue
    distinct_id?: string | null
    session_id?: string | null
    person_id?: string | null
    thematique?: string | null
    ingested_at?: Date | string
  }

  export type thematiqueUncheckedCreateInput = {
    id?: bigint | number
    event_timestamp: Date | string
    properties?: NullableJsonNullValueInput | InputJsonValue
    distinct_id?: string | null
    session_id?: string | null
    person_id?: string | null
    thematique?: string | null
    ingested_at?: Date | string
  }

  export type thematiqueUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    event_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: NullableJsonNullValueInput | InputJsonValue
    distinct_id?: NullableStringFieldUpdateOperationsInput | string | null
    session_id?: NullableStringFieldUpdateOperationsInput | string | null
    person_id?: NullableStringFieldUpdateOperationsInput | string | null
    thematique?: NullableStringFieldUpdateOperationsInput | string | null
    ingested_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type thematiqueUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    event_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: NullableJsonNullValueInput | InputJsonValue
    distinct_id?: NullableStringFieldUpdateOperationsInput | string | null
    session_id?: NullableStringFieldUpdateOperationsInput | string | null
    person_id?: NullableStringFieldUpdateOperationsInput | string | null
    thematique?: NullableStringFieldUpdateOperationsInput | string | null
    ingested_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type thematiqueCreateManyInput = {
    id?: bigint | number
    event_timestamp: Date | string
    properties?: NullableJsonNullValueInput | InputJsonValue
    distinct_id?: string | null
    session_id?: string | null
    person_id?: string | null
    thematique?: string | null
    ingested_at?: Date | string
  }

  export type thematiqueUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    event_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: NullableJsonNullValueInput | InputJsonValue
    distinct_id?: NullableStringFieldUpdateOperationsInput | string | null
    session_id?: NullableStringFieldUpdateOperationsInput | string | null
    person_id?: NullableStringFieldUpdateOperationsInput | string | null
    thematique?: NullableStringFieldUpdateOperationsInput | string | null
    ingested_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type thematiqueUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    event_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: NullableJsonNullValueInput | InputJsonValue
    distinct_id?: NullableStringFieldUpdateOperationsInput | string | null
    session_id?: NullableStringFieldUpdateOperationsInput | string | null
    person_id?: NullableStringFieldUpdateOperationsInput | string | null
    thematique?: NullableStringFieldUpdateOperationsInput | string | null
    ingested_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type agricultureCreateInput = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
    part_irr_SAU_2020?: number | null
    otex_12_postes: string
  }

  export type agricultureUncheckedCreateInput = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
    part_irr_SAU_2020?: number | null
    otex_12_postes: string
  }

  export type agricultureUpdateInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: FloatFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    part_irr_SAU_2020?: NullableFloatFieldUpdateOperationsInput | number | null
    otex_12_postes?: StringFieldUpdateOperationsInput | string
  }

  export type agricultureUncheckedUpdateInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: FloatFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    part_irr_SAU_2020?: NullableFloatFieldUpdateOperationsInput | number | null
    otex_12_postes?: StringFieldUpdateOperationsInput | string
  }

  export type agricultureCreateManyInput = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
    part_irr_SAU_2020?: number | null
    otex_12_postes: string
  }

  export type agricultureUpdateManyMutationInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: FloatFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    part_irr_SAU_2020?: NullableFloatFieldUpdateOperationsInput | number | null
    otex_12_postes?: StringFieldUpdateOperationsInput | string
  }

  export type agricultureUncheckedUpdateManyInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: FloatFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    part_irr_SAU_2020?: NullableFloatFieldUpdateOperationsInput | number | null
    otex_12_postes?: StringFieldUpdateOperationsInput | string
  }

  export type agriculture_bioCreateInput = {
    index: number
    epci: string
    libelle_epci: string
    VARIABLE: string
    LIBELLE_SOUS_CHAMP?: string | null
    surface_2023?: number | null
    surface_2022?: number | null
    surface_2021?: number | null
    surface_2020?: number | null
    surface_2019?: number | null
    surface_2018?: number | null
    surface_2017?: number | null
    surface_2016?: number | null
    surface_2015?: number | null
    surface_2014?: number | null
    surface_2013?: number | null
    surface_2012?: number | null
    surface_2011?: number | null
    surface_2010?: number | null
    surface_2009?: number | null
    surface_2008?: number | null
    nombre_2023?: number | null
    nombre_2022?: number | null
    nombre_2021?: number | null
    nombre_2020?: number | null
    nombre_2019?: number | null
    nombre_2018?: number | null
    nombre_2017?: number | null
    nombre_2016?: number | null
    nombre_2015?: number | null
    nombre_2014?: number | null
    nombre_2013?: number | null
    nombre_2012?: number | null
    nombre_2011?: number | null
    nombre_2010?: number | null
    nombre_2009?: number | null
    nombre_2008?: number | null
  }

  export type agriculture_bioUncheckedCreateInput = {
    index: number
    epci: string
    libelle_epci: string
    VARIABLE: string
    LIBELLE_SOUS_CHAMP?: string | null
    surface_2023?: number | null
    surface_2022?: number | null
    surface_2021?: number | null
    surface_2020?: number | null
    surface_2019?: number | null
    surface_2018?: number | null
    surface_2017?: number | null
    surface_2016?: number | null
    surface_2015?: number | null
    surface_2014?: number | null
    surface_2013?: number | null
    surface_2012?: number | null
    surface_2011?: number | null
    surface_2010?: number | null
    surface_2009?: number | null
    surface_2008?: number | null
    nombre_2023?: number | null
    nombre_2022?: number | null
    nombre_2021?: number | null
    nombre_2020?: number | null
    nombre_2019?: number | null
    nombre_2018?: number | null
    nombre_2017?: number | null
    nombre_2016?: number | null
    nombre_2015?: number | null
    nombre_2014?: number | null
    nombre_2013?: number | null
    nombre_2012?: number | null
    nombre_2011?: number | null
    nombre_2010?: number | null
    nombre_2009?: number | null
    nombre_2008?: number | null
  }

  export type agriculture_bioUpdateInput = {
    index?: IntFieldUpdateOperationsInput | number
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    VARIABLE?: StringFieldUpdateOperationsInput | string
    LIBELLE_SOUS_CHAMP?: NullableStringFieldUpdateOperationsInput | string | null
    surface_2023?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2022?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2021?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2020?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2019?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2018?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2017?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2016?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2015?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2014?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2013?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2012?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2011?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2010?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2009?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2008?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2023?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2022?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2021?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2020?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2019?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2018?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2017?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2016?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2015?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2014?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2013?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2012?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2011?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2010?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2009?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2008?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type agriculture_bioUncheckedUpdateInput = {
    index?: IntFieldUpdateOperationsInput | number
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    VARIABLE?: StringFieldUpdateOperationsInput | string
    LIBELLE_SOUS_CHAMP?: NullableStringFieldUpdateOperationsInput | string | null
    surface_2023?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2022?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2021?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2020?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2019?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2018?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2017?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2016?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2015?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2014?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2013?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2012?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2011?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2010?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2009?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2008?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2023?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2022?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2021?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2020?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2019?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2018?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2017?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2016?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2015?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2014?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2013?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2012?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2011?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2010?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2009?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2008?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type agriculture_bioCreateManyInput = {
    index: number
    epci: string
    libelle_epci: string
    VARIABLE: string
    LIBELLE_SOUS_CHAMP?: string | null
    surface_2023?: number | null
    surface_2022?: number | null
    surface_2021?: number | null
    surface_2020?: number | null
    surface_2019?: number | null
    surface_2018?: number | null
    surface_2017?: number | null
    surface_2016?: number | null
    surface_2015?: number | null
    surface_2014?: number | null
    surface_2013?: number | null
    surface_2012?: number | null
    surface_2011?: number | null
    surface_2010?: number | null
    surface_2009?: number | null
    surface_2008?: number | null
    nombre_2023?: number | null
    nombre_2022?: number | null
    nombre_2021?: number | null
    nombre_2020?: number | null
    nombre_2019?: number | null
    nombre_2018?: number | null
    nombre_2017?: number | null
    nombre_2016?: number | null
    nombre_2015?: number | null
    nombre_2014?: number | null
    nombre_2013?: number | null
    nombre_2012?: number | null
    nombre_2011?: number | null
    nombre_2010?: number | null
    nombre_2009?: number | null
    nombre_2008?: number | null
  }

  export type agriculture_bioUpdateManyMutationInput = {
    index?: IntFieldUpdateOperationsInput | number
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    VARIABLE?: StringFieldUpdateOperationsInput | string
    LIBELLE_SOUS_CHAMP?: NullableStringFieldUpdateOperationsInput | string | null
    surface_2023?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2022?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2021?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2020?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2019?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2018?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2017?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2016?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2015?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2014?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2013?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2012?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2011?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2010?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2009?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2008?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2023?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2022?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2021?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2020?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2019?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2018?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2017?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2016?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2015?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2014?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2013?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2012?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2011?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2010?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2009?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2008?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type agriculture_bioUncheckedUpdateManyInput = {
    index?: IntFieldUpdateOperationsInput | number
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    VARIABLE?: StringFieldUpdateOperationsInput | string
    LIBELLE_SOUS_CHAMP?: NullableStringFieldUpdateOperationsInput | string | null
    surface_2023?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2022?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2021?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2020?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2019?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2018?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2017?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2016?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2015?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2014?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2013?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2012?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2011?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2010?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2009?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_2008?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2023?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2022?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2021?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2020?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2019?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2018?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2017?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2016?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2015?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2014?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2013?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2012?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2011?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2010?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2009?: NullableFloatFieldUpdateOperationsInput | number | null
    nombre_2008?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type aot_40CreateInput = {
    index: number
    nom_site: string
    type_d_implantation: string
    valeur_brute: number
    Latitude: number
    Longitude: number
  }

  export type aot_40UncheckedCreateInput = {
    index: number
    nom_site: string
    type_d_implantation: string
    valeur_brute: number
    Latitude: number
    Longitude: number
  }

  export type aot_40UpdateInput = {
    index?: IntFieldUpdateOperationsInput | number
    nom_site?: StringFieldUpdateOperationsInput | string
    type_d_implantation?: StringFieldUpdateOperationsInput | string
    valeur_brute?: FloatFieldUpdateOperationsInput | number
    Latitude?: FloatFieldUpdateOperationsInput | number
    Longitude?: FloatFieldUpdateOperationsInput | number
  }

  export type aot_40UncheckedUpdateInput = {
    index?: IntFieldUpdateOperationsInput | number
    nom_site?: StringFieldUpdateOperationsInput | string
    type_d_implantation?: StringFieldUpdateOperationsInput | string
    valeur_brute?: FloatFieldUpdateOperationsInput | number
    Latitude?: FloatFieldUpdateOperationsInput | number
    Longitude?: FloatFieldUpdateOperationsInput | number
  }

  export type aot_40CreateManyInput = {
    index: number
    nom_site: string
    type_d_implantation: string
    valeur_brute: number
    Latitude: number
    Longitude: number
  }

  export type aot_40UpdateManyMutationInput = {
    index?: IntFieldUpdateOperationsInput | number
    nom_site?: StringFieldUpdateOperationsInput | string
    type_d_implantation?: StringFieldUpdateOperationsInput | string
    valeur_brute?: FloatFieldUpdateOperationsInput | number
    Latitude?: FloatFieldUpdateOperationsInput | number
    Longitude?: FloatFieldUpdateOperationsInput | number
  }

  export type aot_40UncheckedUpdateManyInput = {
    index?: IntFieldUpdateOperationsInput | number
    nom_site?: StringFieldUpdateOperationsInput | string
    type_d_implantation?: StringFieldUpdateOperationsInput | string
    valeur_brute?: FloatFieldUpdateOperationsInput | number
    Latitude?: FloatFieldUpdateOperationsInput | number
    Longitude?: FloatFieldUpdateOperationsInput | number
  }

  export type arretes_catnatCreateInput = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
    lib_risque_jo: string
    dat_deb: string
    dat_fin: string
    dat_pub_arrete: string
  }

  export type arretes_catnatUncheckedCreateInput = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
    lib_risque_jo: string
    dat_deb: string
    dat_fin: string
    dat_pub_arrete: string
  }

  export type arretes_catnatUpdateInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: FloatFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    lib_risque_jo?: StringFieldUpdateOperationsInput | string
    dat_deb?: StringFieldUpdateOperationsInput | string
    dat_fin?: StringFieldUpdateOperationsInput | string
    dat_pub_arrete?: StringFieldUpdateOperationsInput | string
  }

  export type arretes_catnatUncheckedUpdateInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: FloatFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    lib_risque_jo?: StringFieldUpdateOperationsInput | string
    dat_deb?: StringFieldUpdateOperationsInput | string
    dat_fin?: StringFieldUpdateOperationsInput | string
    dat_pub_arrete?: StringFieldUpdateOperationsInput | string
  }

  export type arretes_catnatCreateManyInput = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
    lib_risque_jo: string
    dat_deb: string
    dat_fin: string
    dat_pub_arrete: string
  }

  export type arretes_catnatUpdateManyMutationInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: FloatFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    lib_risque_jo?: StringFieldUpdateOperationsInput | string
    dat_deb?: StringFieldUpdateOperationsInput | string
    dat_fin?: StringFieldUpdateOperationsInput | string
    dat_pub_arrete?: StringFieldUpdateOperationsInput | string
  }

  export type arretes_catnatUncheckedUpdateManyInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: FloatFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    lib_risque_jo?: StringFieldUpdateOperationsInput | string
    dat_deb?: StringFieldUpdateOperationsInput | string
    dat_fin?: StringFieldUpdateOperationsInput | string
    dat_pub_arrete?: StringFieldUpdateOperationsInput | string
  }

  export type atlas_biodiversiteCreateInput = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
    nom?: string | null
    structure_porteuse?: string | null
    type_de_structure_porteuse?: string | null
    annee_debut?: number | null
    avancement?: string | null
  }

  export type atlas_biodiversiteUncheckedCreateInput = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
    nom?: string | null
    structure_porteuse?: string | null
    type_de_structure_porteuse?: string | null
    annee_debut?: number | null
    avancement?: string | null
  }

  export type atlas_biodiversiteUpdateInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: FloatFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    structure_porteuse?: NullableStringFieldUpdateOperationsInput | string | null
    type_de_structure_porteuse?: NullableStringFieldUpdateOperationsInput | string | null
    annee_debut?: NullableFloatFieldUpdateOperationsInput | number | null
    avancement?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type atlas_biodiversiteUncheckedUpdateInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: FloatFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    structure_porteuse?: NullableStringFieldUpdateOperationsInput | string | null
    type_de_structure_porteuse?: NullableStringFieldUpdateOperationsInput | string | null
    annee_debut?: NullableFloatFieldUpdateOperationsInput | number | null
    avancement?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type atlas_biodiversiteCreateManyInput = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
    nom?: string | null
    structure_porteuse?: string | null
    type_de_structure_porteuse?: string | null
    annee_debut?: number | null
    avancement?: string | null
  }

  export type atlas_biodiversiteUpdateManyMutationInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: FloatFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    structure_porteuse?: NullableStringFieldUpdateOperationsInput | string | null
    type_de_structure_porteuse?: NullableStringFieldUpdateOperationsInput | string | null
    annee_debut?: NullableFloatFieldUpdateOperationsInput | number | null
    avancement?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type atlas_biodiversiteUncheckedUpdateManyInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: FloatFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    nom?: NullableStringFieldUpdateOperationsInput | string | null
    structure_porteuse?: NullableStringFieldUpdateOperationsInput | string | null
    type_de_structure_porteuse?: NullableStringFieldUpdateOperationsInput | string | null
    annee_debut?: NullableFloatFieldUpdateOperationsInput | number | null
    avancement?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type collectivites_searchbarCreateInput = {
    index: number
    code_geographique?: string | null
    libelle_geographique?: string | null
    epci?: string | null
    libelle_epci?: string | null
    departement?: string | null
    libelle_departement?: string | null
    region?: string | null
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
    search_code?: string | null
    search_libelle: string
  }

  export type collectivites_searchbarUncheckedCreateInput = {
    index: number
    code_geographique?: string | null
    libelle_geographique?: string | null
    epci?: string | null
    libelle_epci?: string | null
    departement?: string | null
    libelle_departement?: string | null
    region?: string | null
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
    search_code?: string | null
    search_libelle: string
  }

  export type collectivites_searchbarUpdateInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_geographique?: NullableStringFieldUpdateOperationsInput | string | null
    epci?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_epci?: NullableStringFieldUpdateOperationsInput | string | null
    departement?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_departement?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    search_code?: NullableStringFieldUpdateOperationsInput | string | null
    search_libelle?: StringFieldUpdateOperationsInput | string
  }

  export type collectivites_searchbarUncheckedUpdateInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_geographique?: NullableStringFieldUpdateOperationsInput | string | null
    epci?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_epci?: NullableStringFieldUpdateOperationsInput | string | null
    departement?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_departement?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    search_code?: NullableStringFieldUpdateOperationsInput | string | null
    search_libelle?: StringFieldUpdateOperationsInput | string
  }

  export type collectivites_searchbarCreateManyInput = {
    index: number
    code_geographique?: string | null
    libelle_geographique?: string | null
    epci?: string | null
    libelle_epci?: string | null
    departement?: string | null
    libelle_departement?: string | null
    region?: string | null
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
    search_code?: string | null
    search_libelle: string
  }

  export type collectivites_searchbarUpdateManyMutationInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_geographique?: NullableStringFieldUpdateOperationsInput | string | null
    epci?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_epci?: NullableStringFieldUpdateOperationsInput | string | null
    departement?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_departement?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    search_code?: NullableStringFieldUpdateOperationsInput | string | null
    search_libelle?: StringFieldUpdateOperationsInput | string
  }

  export type collectivites_searchbarUncheckedUpdateManyInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_geographique?: NullableStringFieldUpdateOperationsInput | string | null
    epci?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_epci?: NullableStringFieldUpdateOperationsInput | string | null
    departement?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_departement?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    search_code?: NullableStringFieldUpdateOperationsInput | string | null
    search_libelle?: StringFieldUpdateOperationsInput | string
  }

  export type confort_thermiqueCreateInput = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
    age_bati_post06?: number | null
    age_bati_91_05?: number | null
    age_bati_46_90?: number | null
    age_bati_19_45?: number | null
    age_bati_pre_19?: number | null
    under_4_sum_1968?: number | null
    to_75_sum_1968?: number | null
    over_75_sum_1968?: number | null
    under_4_sum_1975?: number | null
    to_75_sum_1975?: number | null
    over_75_sum_1975?: number | null
    under_4_sum_1982?: number | null
    to_75_sum_1982?: number | null
    over_75_sum_1982?: number | null
    under_4_sum_1990?: number | null
    to_75_sum_1990?: number | null
    over_75_sum_1990?: number | null
    under_4_sum_1999?: number | null
    to_75_sum_1999?: number | null
    over_75_sum_1999?: number | null
    under_4_sum_2009?: number | null
    to_75_sum_2009?: number | null
    over_75_sum_2009?: number | null
    under_4_sum_2014?: number | null
    to_75_sum_2014?: number | null
    over_75_sum_2014?: number | null
    under_4_sum_2020?: number | null
    to_75_sum_2020?: number | null
    over_75_sum_2020?: number | null
    tee_log?: number | null
    tee_mob?: number | null
    precarite_logement?: number | null
    NA5AZ_sum?: number | null
    NA5BE_sum?: number | null
    NA5FZ_sum?: number | null
    NA5GU_sum?: number | null
    NA5OQ_sum?: number | null
    clc_1_artificialise?: number | null
    clc_2_agricole?: number | null
    clc_3_foret_semiNaturel?: number | null
    clc_4_humide?: number | null
    clc_5_eau?: number | null
    superf_choro?: number | null
  }

  export type confort_thermiqueUncheckedCreateInput = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
    age_bati_post06?: number | null
    age_bati_91_05?: number | null
    age_bati_46_90?: number | null
    age_bati_19_45?: number | null
    age_bati_pre_19?: number | null
    under_4_sum_1968?: number | null
    to_75_sum_1968?: number | null
    over_75_sum_1968?: number | null
    under_4_sum_1975?: number | null
    to_75_sum_1975?: number | null
    over_75_sum_1975?: number | null
    under_4_sum_1982?: number | null
    to_75_sum_1982?: number | null
    over_75_sum_1982?: number | null
    under_4_sum_1990?: number | null
    to_75_sum_1990?: number | null
    over_75_sum_1990?: number | null
    under_4_sum_1999?: number | null
    to_75_sum_1999?: number | null
    over_75_sum_1999?: number | null
    under_4_sum_2009?: number | null
    to_75_sum_2009?: number | null
    over_75_sum_2009?: number | null
    under_4_sum_2014?: number | null
    to_75_sum_2014?: number | null
    over_75_sum_2014?: number | null
    under_4_sum_2020?: number | null
    to_75_sum_2020?: number | null
    over_75_sum_2020?: number | null
    tee_log?: number | null
    tee_mob?: number | null
    precarite_logement?: number | null
    NA5AZ_sum?: number | null
    NA5BE_sum?: number | null
    NA5FZ_sum?: number | null
    NA5GU_sum?: number | null
    NA5OQ_sum?: number | null
    clc_1_artificialise?: number | null
    clc_2_agricole?: number | null
    clc_3_foret_semiNaturel?: number | null
    clc_4_humide?: number | null
    clc_5_eau?: number | null
    superf_choro?: number | null
  }

  export type confort_thermiqueUpdateInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: IntFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    age_bati_post06?: NullableFloatFieldUpdateOperationsInput | number | null
    age_bati_91_05?: NullableFloatFieldUpdateOperationsInput | number | null
    age_bati_46_90?: NullableFloatFieldUpdateOperationsInput | number | null
    age_bati_19_45?: NullableFloatFieldUpdateOperationsInput | number | null
    age_bati_pre_19?: NullableFloatFieldUpdateOperationsInput | number | null
    under_4_sum_1968?: NullableFloatFieldUpdateOperationsInput | number | null
    to_75_sum_1968?: NullableFloatFieldUpdateOperationsInput | number | null
    over_75_sum_1968?: NullableFloatFieldUpdateOperationsInput | number | null
    under_4_sum_1975?: NullableFloatFieldUpdateOperationsInput | number | null
    to_75_sum_1975?: NullableFloatFieldUpdateOperationsInput | number | null
    over_75_sum_1975?: NullableFloatFieldUpdateOperationsInput | number | null
    under_4_sum_1982?: NullableFloatFieldUpdateOperationsInput | number | null
    to_75_sum_1982?: NullableFloatFieldUpdateOperationsInput | number | null
    over_75_sum_1982?: NullableFloatFieldUpdateOperationsInput | number | null
    under_4_sum_1990?: NullableFloatFieldUpdateOperationsInput | number | null
    to_75_sum_1990?: NullableFloatFieldUpdateOperationsInput | number | null
    over_75_sum_1990?: NullableFloatFieldUpdateOperationsInput | number | null
    under_4_sum_1999?: NullableFloatFieldUpdateOperationsInput | number | null
    to_75_sum_1999?: NullableFloatFieldUpdateOperationsInput | number | null
    over_75_sum_1999?: NullableFloatFieldUpdateOperationsInput | number | null
    under_4_sum_2009?: NullableFloatFieldUpdateOperationsInput | number | null
    to_75_sum_2009?: NullableFloatFieldUpdateOperationsInput | number | null
    over_75_sum_2009?: NullableFloatFieldUpdateOperationsInput | number | null
    under_4_sum_2014?: NullableFloatFieldUpdateOperationsInput | number | null
    to_75_sum_2014?: NullableFloatFieldUpdateOperationsInput | number | null
    over_75_sum_2014?: NullableFloatFieldUpdateOperationsInput | number | null
    under_4_sum_2020?: NullableFloatFieldUpdateOperationsInput | number | null
    to_75_sum_2020?: NullableFloatFieldUpdateOperationsInput | number | null
    over_75_sum_2020?: NullableFloatFieldUpdateOperationsInput | number | null
    tee_log?: NullableFloatFieldUpdateOperationsInput | number | null
    tee_mob?: NullableFloatFieldUpdateOperationsInput | number | null
    precarite_logement?: NullableFloatFieldUpdateOperationsInput | number | null
    NA5AZ_sum?: NullableFloatFieldUpdateOperationsInput | number | null
    NA5BE_sum?: NullableFloatFieldUpdateOperationsInput | number | null
    NA5FZ_sum?: NullableFloatFieldUpdateOperationsInput | number | null
    NA5GU_sum?: NullableFloatFieldUpdateOperationsInput | number | null
    NA5OQ_sum?: NullableFloatFieldUpdateOperationsInput | number | null
    clc_1_artificialise?: NullableFloatFieldUpdateOperationsInput | number | null
    clc_2_agricole?: NullableFloatFieldUpdateOperationsInput | number | null
    clc_3_foret_semiNaturel?: NullableFloatFieldUpdateOperationsInput | number | null
    clc_4_humide?: NullableFloatFieldUpdateOperationsInput | number | null
    clc_5_eau?: NullableFloatFieldUpdateOperationsInput | number | null
    superf_choro?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type confort_thermiqueUncheckedUpdateInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: IntFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    age_bati_post06?: NullableFloatFieldUpdateOperationsInput | number | null
    age_bati_91_05?: NullableFloatFieldUpdateOperationsInput | number | null
    age_bati_46_90?: NullableFloatFieldUpdateOperationsInput | number | null
    age_bati_19_45?: NullableFloatFieldUpdateOperationsInput | number | null
    age_bati_pre_19?: NullableFloatFieldUpdateOperationsInput | number | null
    under_4_sum_1968?: NullableFloatFieldUpdateOperationsInput | number | null
    to_75_sum_1968?: NullableFloatFieldUpdateOperationsInput | number | null
    over_75_sum_1968?: NullableFloatFieldUpdateOperationsInput | number | null
    under_4_sum_1975?: NullableFloatFieldUpdateOperationsInput | number | null
    to_75_sum_1975?: NullableFloatFieldUpdateOperationsInput | number | null
    over_75_sum_1975?: NullableFloatFieldUpdateOperationsInput | number | null
    under_4_sum_1982?: NullableFloatFieldUpdateOperationsInput | number | null
    to_75_sum_1982?: NullableFloatFieldUpdateOperationsInput | number | null
    over_75_sum_1982?: NullableFloatFieldUpdateOperationsInput | number | null
    under_4_sum_1990?: NullableFloatFieldUpdateOperationsInput | number | null
    to_75_sum_1990?: NullableFloatFieldUpdateOperationsInput | number | null
    over_75_sum_1990?: NullableFloatFieldUpdateOperationsInput | number | null
    under_4_sum_1999?: NullableFloatFieldUpdateOperationsInput | number | null
    to_75_sum_1999?: NullableFloatFieldUpdateOperationsInput | number | null
    over_75_sum_1999?: NullableFloatFieldUpdateOperationsInput | number | null
    under_4_sum_2009?: NullableFloatFieldUpdateOperationsInput | number | null
    to_75_sum_2009?: NullableFloatFieldUpdateOperationsInput | number | null
    over_75_sum_2009?: NullableFloatFieldUpdateOperationsInput | number | null
    under_4_sum_2014?: NullableFloatFieldUpdateOperationsInput | number | null
    to_75_sum_2014?: NullableFloatFieldUpdateOperationsInput | number | null
    over_75_sum_2014?: NullableFloatFieldUpdateOperationsInput | number | null
    under_4_sum_2020?: NullableFloatFieldUpdateOperationsInput | number | null
    to_75_sum_2020?: NullableFloatFieldUpdateOperationsInput | number | null
    over_75_sum_2020?: NullableFloatFieldUpdateOperationsInput | number | null
    tee_log?: NullableFloatFieldUpdateOperationsInput | number | null
    tee_mob?: NullableFloatFieldUpdateOperationsInput | number | null
    precarite_logement?: NullableFloatFieldUpdateOperationsInput | number | null
    NA5AZ_sum?: NullableFloatFieldUpdateOperationsInput | number | null
    NA5BE_sum?: NullableFloatFieldUpdateOperationsInput | number | null
    NA5FZ_sum?: NullableFloatFieldUpdateOperationsInput | number | null
    NA5GU_sum?: NullableFloatFieldUpdateOperationsInput | number | null
    NA5OQ_sum?: NullableFloatFieldUpdateOperationsInput | number | null
    clc_1_artificialise?: NullableFloatFieldUpdateOperationsInput | number | null
    clc_2_agricole?: NullableFloatFieldUpdateOperationsInput | number | null
    clc_3_foret_semiNaturel?: NullableFloatFieldUpdateOperationsInput | number | null
    clc_4_humide?: NullableFloatFieldUpdateOperationsInput | number | null
    clc_5_eau?: NullableFloatFieldUpdateOperationsInput | number | null
    superf_choro?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type confort_thermiqueCreateManyInput = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
    age_bati_post06?: number | null
    age_bati_91_05?: number | null
    age_bati_46_90?: number | null
    age_bati_19_45?: number | null
    age_bati_pre_19?: number | null
    under_4_sum_1968?: number | null
    to_75_sum_1968?: number | null
    over_75_sum_1968?: number | null
    under_4_sum_1975?: number | null
    to_75_sum_1975?: number | null
    over_75_sum_1975?: number | null
    under_4_sum_1982?: number | null
    to_75_sum_1982?: number | null
    over_75_sum_1982?: number | null
    under_4_sum_1990?: number | null
    to_75_sum_1990?: number | null
    over_75_sum_1990?: number | null
    under_4_sum_1999?: number | null
    to_75_sum_1999?: number | null
    over_75_sum_1999?: number | null
    under_4_sum_2009?: number | null
    to_75_sum_2009?: number | null
    over_75_sum_2009?: number | null
    under_4_sum_2014?: number | null
    to_75_sum_2014?: number | null
    over_75_sum_2014?: number | null
    under_4_sum_2020?: number | null
    to_75_sum_2020?: number | null
    over_75_sum_2020?: number | null
    tee_log?: number | null
    tee_mob?: number | null
    precarite_logement?: number | null
    NA5AZ_sum?: number | null
    NA5BE_sum?: number | null
    NA5FZ_sum?: number | null
    NA5GU_sum?: number | null
    NA5OQ_sum?: number | null
    clc_1_artificialise?: number | null
    clc_2_agricole?: number | null
    clc_3_foret_semiNaturel?: number | null
    clc_4_humide?: number | null
    clc_5_eau?: number | null
    superf_choro?: number | null
  }

  export type confort_thermiqueUpdateManyMutationInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: IntFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    age_bati_post06?: NullableFloatFieldUpdateOperationsInput | number | null
    age_bati_91_05?: NullableFloatFieldUpdateOperationsInput | number | null
    age_bati_46_90?: NullableFloatFieldUpdateOperationsInput | number | null
    age_bati_19_45?: NullableFloatFieldUpdateOperationsInput | number | null
    age_bati_pre_19?: NullableFloatFieldUpdateOperationsInput | number | null
    under_4_sum_1968?: NullableFloatFieldUpdateOperationsInput | number | null
    to_75_sum_1968?: NullableFloatFieldUpdateOperationsInput | number | null
    over_75_sum_1968?: NullableFloatFieldUpdateOperationsInput | number | null
    under_4_sum_1975?: NullableFloatFieldUpdateOperationsInput | number | null
    to_75_sum_1975?: NullableFloatFieldUpdateOperationsInput | number | null
    over_75_sum_1975?: NullableFloatFieldUpdateOperationsInput | number | null
    under_4_sum_1982?: NullableFloatFieldUpdateOperationsInput | number | null
    to_75_sum_1982?: NullableFloatFieldUpdateOperationsInput | number | null
    over_75_sum_1982?: NullableFloatFieldUpdateOperationsInput | number | null
    under_4_sum_1990?: NullableFloatFieldUpdateOperationsInput | number | null
    to_75_sum_1990?: NullableFloatFieldUpdateOperationsInput | number | null
    over_75_sum_1990?: NullableFloatFieldUpdateOperationsInput | number | null
    under_4_sum_1999?: NullableFloatFieldUpdateOperationsInput | number | null
    to_75_sum_1999?: NullableFloatFieldUpdateOperationsInput | number | null
    over_75_sum_1999?: NullableFloatFieldUpdateOperationsInput | number | null
    under_4_sum_2009?: NullableFloatFieldUpdateOperationsInput | number | null
    to_75_sum_2009?: NullableFloatFieldUpdateOperationsInput | number | null
    over_75_sum_2009?: NullableFloatFieldUpdateOperationsInput | number | null
    under_4_sum_2014?: NullableFloatFieldUpdateOperationsInput | number | null
    to_75_sum_2014?: NullableFloatFieldUpdateOperationsInput | number | null
    over_75_sum_2014?: NullableFloatFieldUpdateOperationsInput | number | null
    under_4_sum_2020?: NullableFloatFieldUpdateOperationsInput | number | null
    to_75_sum_2020?: NullableFloatFieldUpdateOperationsInput | number | null
    over_75_sum_2020?: NullableFloatFieldUpdateOperationsInput | number | null
    tee_log?: NullableFloatFieldUpdateOperationsInput | number | null
    tee_mob?: NullableFloatFieldUpdateOperationsInput | number | null
    precarite_logement?: NullableFloatFieldUpdateOperationsInput | number | null
    NA5AZ_sum?: NullableFloatFieldUpdateOperationsInput | number | null
    NA5BE_sum?: NullableFloatFieldUpdateOperationsInput | number | null
    NA5FZ_sum?: NullableFloatFieldUpdateOperationsInput | number | null
    NA5GU_sum?: NullableFloatFieldUpdateOperationsInput | number | null
    NA5OQ_sum?: NullableFloatFieldUpdateOperationsInput | number | null
    clc_1_artificialise?: NullableFloatFieldUpdateOperationsInput | number | null
    clc_2_agricole?: NullableFloatFieldUpdateOperationsInput | number | null
    clc_3_foret_semiNaturel?: NullableFloatFieldUpdateOperationsInput | number | null
    clc_4_humide?: NullableFloatFieldUpdateOperationsInput | number | null
    clc_5_eau?: NullableFloatFieldUpdateOperationsInput | number | null
    superf_choro?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type confort_thermiqueUncheckedUpdateManyInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: IntFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    age_bati_post06?: NullableFloatFieldUpdateOperationsInput | number | null
    age_bati_91_05?: NullableFloatFieldUpdateOperationsInput | number | null
    age_bati_46_90?: NullableFloatFieldUpdateOperationsInput | number | null
    age_bati_19_45?: NullableFloatFieldUpdateOperationsInput | number | null
    age_bati_pre_19?: NullableFloatFieldUpdateOperationsInput | number | null
    under_4_sum_1968?: NullableFloatFieldUpdateOperationsInput | number | null
    to_75_sum_1968?: NullableFloatFieldUpdateOperationsInput | number | null
    over_75_sum_1968?: NullableFloatFieldUpdateOperationsInput | number | null
    under_4_sum_1975?: NullableFloatFieldUpdateOperationsInput | number | null
    to_75_sum_1975?: NullableFloatFieldUpdateOperationsInput | number | null
    over_75_sum_1975?: NullableFloatFieldUpdateOperationsInput | number | null
    under_4_sum_1982?: NullableFloatFieldUpdateOperationsInput | number | null
    to_75_sum_1982?: NullableFloatFieldUpdateOperationsInput | number | null
    over_75_sum_1982?: NullableFloatFieldUpdateOperationsInput | number | null
    under_4_sum_1990?: NullableFloatFieldUpdateOperationsInput | number | null
    to_75_sum_1990?: NullableFloatFieldUpdateOperationsInput | number | null
    over_75_sum_1990?: NullableFloatFieldUpdateOperationsInput | number | null
    under_4_sum_1999?: NullableFloatFieldUpdateOperationsInput | number | null
    to_75_sum_1999?: NullableFloatFieldUpdateOperationsInput | number | null
    over_75_sum_1999?: NullableFloatFieldUpdateOperationsInput | number | null
    under_4_sum_2009?: NullableFloatFieldUpdateOperationsInput | number | null
    to_75_sum_2009?: NullableFloatFieldUpdateOperationsInput | number | null
    over_75_sum_2009?: NullableFloatFieldUpdateOperationsInput | number | null
    under_4_sum_2014?: NullableFloatFieldUpdateOperationsInput | number | null
    to_75_sum_2014?: NullableFloatFieldUpdateOperationsInput | number | null
    over_75_sum_2014?: NullableFloatFieldUpdateOperationsInput | number | null
    under_4_sum_2020?: NullableFloatFieldUpdateOperationsInput | number | null
    to_75_sum_2020?: NullableFloatFieldUpdateOperationsInput | number | null
    over_75_sum_2020?: NullableFloatFieldUpdateOperationsInput | number | null
    tee_log?: NullableFloatFieldUpdateOperationsInput | number | null
    tee_mob?: NullableFloatFieldUpdateOperationsInput | number | null
    precarite_logement?: NullableFloatFieldUpdateOperationsInput | number | null
    NA5AZ_sum?: NullableFloatFieldUpdateOperationsInput | number | null
    NA5BE_sum?: NullableFloatFieldUpdateOperationsInput | number | null
    NA5FZ_sum?: NullableFloatFieldUpdateOperationsInput | number | null
    NA5GU_sum?: NullableFloatFieldUpdateOperationsInput | number | null
    NA5OQ_sum?: NullableFloatFieldUpdateOperationsInput | number | null
    clc_1_artificialise?: NullableFloatFieldUpdateOperationsInput | number | null
    clc_2_agricole?: NullableFloatFieldUpdateOperationsInput | number | null
    clc_3_foret_semiNaturel?: NullableFloatFieldUpdateOperationsInput | number | null
    clc_4_humide?: NullableFloatFieldUpdateOperationsInput | number | null
    clc_5_eau?: NullableFloatFieldUpdateOperationsInput | number | null
    superf_choro?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type consommation_espaces_nafCreateInput = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
    naf09art10?: number | null
    art09act10?: number | null
    art09hab10?: number | null
    art09mix10?: number | null
    art09rou10?: number | null
    art09fer10?: number | null
    art09inc10?: number | null
    naf10art11?: number | null
    art10act11?: number | null
    art10hab11?: number | null
    art10mix11?: number | null
    art10rou11?: number | null
    art10fer11?: number | null
    art10inc11?: number | null
    naf11art12?: number | null
    art11act12?: number | null
    art11hab12?: number | null
    art11mix12?: number | null
    art11rou12?: number | null
    art11fer12?: number | null
    art11inc12?: number | null
    naf12art13?: number | null
    art12act13?: number | null
    art12hab13?: number | null
    art12mix13?: number | null
    art12rou13?: number | null
    art12fer13?: number | null
    art12inc13?: number | null
    naf13art14?: number | null
    art13act14?: number | null
    art13hab14?: number | null
    art13mix14?: number | null
    art13rou14?: number | null
    art13fer14?: number | null
    art13inc14?: number | null
    naf14art15?: number | null
    art14act15?: number | null
    art14hab15?: number | null
    art14mix15?: number | null
    art14rou15?: number | null
    art14fer15?: number | null
    art14inc15?: number | null
    naf15art16?: number | null
    art15act16?: number | null
    art15hab16?: number | null
    art15mix16?: number | null
    art15rou16?: number | null
    art15fer16?: number | null
    art15inc16?: number | null
    naf16art17?: number | null
    art16act17?: number | null
    art16hab17?: number | null
    art16mix17?: number | null
    art16rou17?: number | null
    art16fer17?: number | null
    art16inc17?: number | null
    naf17art18?: number | null
    art17act18?: number | null
    art17hab18?: number | null
    art17mix18?: number | null
    art17rou18?: number | null
    art17fer18?: number | null
    art17inc18?: number | null
    naf18art19?: number | null
    art18act19?: number | null
    art18hab19?: number | null
    art18mix19?: number | null
    art18rou19?: number | null
    art18fer19?: number | null
    art18inc19?: number | null
    naf19art20?: number | null
    art19act20?: number | null
    art19hab20?: number | null
    art19mix20?: number | null
    art19rou20?: number | null
    art19fer20?: number | null
    art19inc20?: number | null
    naf20art21?: number | null
    art20act21?: number | null
    art20hab21?: number | null
    art20mix21?: number | null
    art20rou21?: number | null
    art20fer21?: number | null
    art20inc21?: number | null
    naf21art22?: number | null
    art21act22?: number | null
    art21hab22?: number | null
    art21mix22?: number | null
    art21rou22?: number | null
    art21fer22?: number | null
    art21inc22?: number | null
    naf22art23?: number | null
    art22act23?: number | null
    art22hab23?: number | null
    art22mix23?: number | null
    art22rou23?: number | null
    art22fer23?: number | null
    art22inc23?: number | null
    naf09art23?: number | null
    art09act23?: number | null
    art09hab23?: number | null
    art09mix23?: number | null
    art09inc23?: number | null
    art09rou23?: number | null
    art09fer23?: number | null
    artcom0923?: number | null
  }

  export type consommation_espaces_nafUncheckedCreateInput = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
    naf09art10?: number | null
    art09act10?: number | null
    art09hab10?: number | null
    art09mix10?: number | null
    art09rou10?: number | null
    art09fer10?: number | null
    art09inc10?: number | null
    naf10art11?: number | null
    art10act11?: number | null
    art10hab11?: number | null
    art10mix11?: number | null
    art10rou11?: number | null
    art10fer11?: number | null
    art10inc11?: number | null
    naf11art12?: number | null
    art11act12?: number | null
    art11hab12?: number | null
    art11mix12?: number | null
    art11rou12?: number | null
    art11fer12?: number | null
    art11inc12?: number | null
    naf12art13?: number | null
    art12act13?: number | null
    art12hab13?: number | null
    art12mix13?: number | null
    art12rou13?: number | null
    art12fer13?: number | null
    art12inc13?: number | null
    naf13art14?: number | null
    art13act14?: number | null
    art13hab14?: number | null
    art13mix14?: number | null
    art13rou14?: number | null
    art13fer14?: number | null
    art13inc14?: number | null
    naf14art15?: number | null
    art14act15?: number | null
    art14hab15?: number | null
    art14mix15?: number | null
    art14rou15?: number | null
    art14fer15?: number | null
    art14inc15?: number | null
    naf15art16?: number | null
    art15act16?: number | null
    art15hab16?: number | null
    art15mix16?: number | null
    art15rou16?: number | null
    art15fer16?: number | null
    art15inc16?: number | null
    naf16art17?: number | null
    art16act17?: number | null
    art16hab17?: number | null
    art16mix17?: number | null
    art16rou17?: number | null
    art16fer17?: number | null
    art16inc17?: number | null
    naf17art18?: number | null
    art17act18?: number | null
    art17hab18?: number | null
    art17mix18?: number | null
    art17rou18?: number | null
    art17fer18?: number | null
    art17inc18?: number | null
    naf18art19?: number | null
    art18act19?: number | null
    art18hab19?: number | null
    art18mix19?: number | null
    art18rou19?: number | null
    art18fer19?: number | null
    art18inc19?: number | null
    naf19art20?: number | null
    art19act20?: number | null
    art19hab20?: number | null
    art19mix20?: number | null
    art19rou20?: number | null
    art19fer20?: number | null
    art19inc20?: number | null
    naf20art21?: number | null
    art20act21?: number | null
    art20hab21?: number | null
    art20mix21?: number | null
    art20rou21?: number | null
    art20fer21?: number | null
    art20inc21?: number | null
    naf21art22?: number | null
    art21act22?: number | null
    art21hab22?: number | null
    art21mix22?: number | null
    art21rou22?: number | null
    art21fer22?: number | null
    art21inc22?: number | null
    naf22art23?: number | null
    art22act23?: number | null
    art22hab23?: number | null
    art22mix23?: number | null
    art22rou23?: number | null
    art22fer23?: number | null
    art22inc23?: number | null
    naf09art23?: number | null
    art09act23?: number | null
    art09hab23?: number | null
    art09mix23?: number | null
    art09inc23?: number | null
    art09rou23?: number | null
    art09fer23?: number | null
    artcom0923?: number | null
  }

  export type consommation_espaces_nafUpdateInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: FloatFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    naf09art10?: NullableFloatFieldUpdateOperationsInput | number | null
    art09act10?: NullableFloatFieldUpdateOperationsInput | number | null
    art09hab10?: NullableFloatFieldUpdateOperationsInput | number | null
    art09mix10?: NullableFloatFieldUpdateOperationsInput | number | null
    art09rou10?: NullableFloatFieldUpdateOperationsInput | number | null
    art09fer10?: NullableFloatFieldUpdateOperationsInput | number | null
    art09inc10?: NullableFloatFieldUpdateOperationsInput | number | null
    naf10art11?: NullableFloatFieldUpdateOperationsInput | number | null
    art10act11?: NullableFloatFieldUpdateOperationsInput | number | null
    art10hab11?: NullableFloatFieldUpdateOperationsInput | number | null
    art10mix11?: NullableFloatFieldUpdateOperationsInput | number | null
    art10rou11?: NullableFloatFieldUpdateOperationsInput | number | null
    art10fer11?: NullableFloatFieldUpdateOperationsInput | number | null
    art10inc11?: NullableFloatFieldUpdateOperationsInput | number | null
    naf11art12?: NullableFloatFieldUpdateOperationsInput | number | null
    art11act12?: NullableFloatFieldUpdateOperationsInput | number | null
    art11hab12?: NullableFloatFieldUpdateOperationsInput | number | null
    art11mix12?: NullableFloatFieldUpdateOperationsInput | number | null
    art11rou12?: NullableFloatFieldUpdateOperationsInput | number | null
    art11fer12?: NullableFloatFieldUpdateOperationsInput | number | null
    art11inc12?: NullableFloatFieldUpdateOperationsInput | number | null
    naf12art13?: NullableFloatFieldUpdateOperationsInput | number | null
    art12act13?: NullableFloatFieldUpdateOperationsInput | number | null
    art12hab13?: NullableFloatFieldUpdateOperationsInput | number | null
    art12mix13?: NullableFloatFieldUpdateOperationsInput | number | null
    art12rou13?: NullableFloatFieldUpdateOperationsInput | number | null
    art12fer13?: NullableFloatFieldUpdateOperationsInput | number | null
    art12inc13?: NullableFloatFieldUpdateOperationsInput | number | null
    naf13art14?: NullableFloatFieldUpdateOperationsInput | number | null
    art13act14?: NullableFloatFieldUpdateOperationsInput | number | null
    art13hab14?: NullableFloatFieldUpdateOperationsInput | number | null
    art13mix14?: NullableFloatFieldUpdateOperationsInput | number | null
    art13rou14?: NullableFloatFieldUpdateOperationsInput | number | null
    art13fer14?: NullableFloatFieldUpdateOperationsInput | number | null
    art13inc14?: NullableFloatFieldUpdateOperationsInput | number | null
    naf14art15?: NullableFloatFieldUpdateOperationsInput | number | null
    art14act15?: NullableFloatFieldUpdateOperationsInput | number | null
    art14hab15?: NullableFloatFieldUpdateOperationsInput | number | null
    art14mix15?: NullableFloatFieldUpdateOperationsInput | number | null
    art14rou15?: NullableFloatFieldUpdateOperationsInput | number | null
    art14fer15?: NullableFloatFieldUpdateOperationsInput | number | null
    art14inc15?: NullableFloatFieldUpdateOperationsInput | number | null
    naf15art16?: NullableFloatFieldUpdateOperationsInput | number | null
    art15act16?: NullableFloatFieldUpdateOperationsInput | number | null
    art15hab16?: NullableFloatFieldUpdateOperationsInput | number | null
    art15mix16?: NullableFloatFieldUpdateOperationsInput | number | null
    art15rou16?: NullableFloatFieldUpdateOperationsInput | number | null
    art15fer16?: NullableFloatFieldUpdateOperationsInput | number | null
    art15inc16?: NullableFloatFieldUpdateOperationsInput | number | null
    naf16art17?: NullableFloatFieldUpdateOperationsInput | number | null
    art16act17?: NullableFloatFieldUpdateOperationsInput | number | null
    art16hab17?: NullableFloatFieldUpdateOperationsInput | number | null
    art16mix17?: NullableFloatFieldUpdateOperationsInput | number | null
    art16rou17?: NullableFloatFieldUpdateOperationsInput | number | null
    art16fer17?: NullableFloatFieldUpdateOperationsInput | number | null
    art16inc17?: NullableFloatFieldUpdateOperationsInput | number | null
    naf17art18?: NullableFloatFieldUpdateOperationsInput | number | null
    art17act18?: NullableFloatFieldUpdateOperationsInput | number | null
    art17hab18?: NullableFloatFieldUpdateOperationsInput | number | null
    art17mix18?: NullableFloatFieldUpdateOperationsInput | number | null
    art17rou18?: NullableFloatFieldUpdateOperationsInput | number | null
    art17fer18?: NullableFloatFieldUpdateOperationsInput | number | null
    art17inc18?: NullableFloatFieldUpdateOperationsInput | number | null
    naf18art19?: NullableFloatFieldUpdateOperationsInput | number | null
    art18act19?: NullableFloatFieldUpdateOperationsInput | number | null
    art18hab19?: NullableFloatFieldUpdateOperationsInput | number | null
    art18mix19?: NullableFloatFieldUpdateOperationsInput | number | null
    art18rou19?: NullableFloatFieldUpdateOperationsInput | number | null
    art18fer19?: NullableFloatFieldUpdateOperationsInput | number | null
    art18inc19?: NullableFloatFieldUpdateOperationsInput | number | null
    naf19art20?: NullableFloatFieldUpdateOperationsInput | number | null
    art19act20?: NullableFloatFieldUpdateOperationsInput | number | null
    art19hab20?: NullableFloatFieldUpdateOperationsInput | number | null
    art19mix20?: NullableFloatFieldUpdateOperationsInput | number | null
    art19rou20?: NullableFloatFieldUpdateOperationsInput | number | null
    art19fer20?: NullableFloatFieldUpdateOperationsInput | number | null
    art19inc20?: NullableFloatFieldUpdateOperationsInput | number | null
    naf20art21?: NullableFloatFieldUpdateOperationsInput | number | null
    art20act21?: NullableFloatFieldUpdateOperationsInput | number | null
    art20hab21?: NullableFloatFieldUpdateOperationsInput | number | null
    art20mix21?: NullableFloatFieldUpdateOperationsInput | number | null
    art20rou21?: NullableFloatFieldUpdateOperationsInput | number | null
    art20fer21?: NullableFloatFieldUpdateOperationsInput | number | null
    art20inc21?: NullableFloatFieldUpdateOperationsInput | number | null
    naf21art22?: NullableFloatFieldUpdateOperationsInput | number | null
    art21act22?: NullableFloatFieldUpdateOperationsInput | number | null
    art21hab22?: NullableFloatFieldUpdateOperationsInput | number | null
    art21mix22?: NullableFloatFieldUpdateOperationsInput | number | null
    art21rou22?: NullableFloatFieldUpdateOperationsInput | number | null
    art21fer22?: NullableFloatFieldUpdateOperationsInput | number | null
    art21inc22?: NullableFloatFieldUpdateOperationsInput | number | null
    naf22art23?: NullableFloatFieldUpdateOperationsInput | number | null
    art22act23?: NullableFloatFieldUpdateOperationsInput | number | null
    art22hab23?: NullableFloatFieldUpdateOperationsInput | number | null
    art22mix23?: NullableFloatFieldUpdateOperationsInput | number | null
    art22rou23?: NullableFloatFieldUpdateOperationsInput | number | null
    art22fer23?: NullableFloatFieldUpdateOperationsInput | number | null
    art22inc23?: NullableFloatFieldUpdateOperationsInput | number | null
    naf09art23?: NullableFloatFieldUpdateOperationsInput | number | null
    art09act23?: NullableFloatFieldUpdateOperationsInput | number | null
    art09hab23?: NullableFloatFieldUpdateOperationsInput | number | null
    art09mix23?: NullableFloatFieldUpdateOperationsInput | number | null
    art09inc23?: NullableFloatFieldUpdateOperationsInput | number | null
    art09rou23?: NullableFloatFieldUpdateOperationsInput | number | null
    art09fer23?: NullableFloatFieldUpdateOperationsInput | number | null
    artcom0923?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type consommation_espaces_nafUncheckedUpdateInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: FloatFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    naf09art10?: NullableFloatFieldUpdateOperationsInput | number | null
    art09act10?: NullableFloatFieldUpdateOperationsInput | number | null
    art09hab10?: NullableFloatFieldUpdateOperationsInput | number | null
    art09mix10?: NullableFloatFieldUpdateOperationsInput | number | null
    art09rou10?: NullableFloatFieldUpdateOperationsInput | number | null
    art09fer10?: NullableFloatFieldUpdateOperationsInput | number | null
    art09inc10?: NullableFloatFieldUpdateOperationsInput | number | null
    naf10art11?: NullableFloatFieldUpdateOperationsInput | number | null
    art10act11?: NullableFloatFieldUpdateOperationsInput | number | null
    art10hab11?: NullableFloatFieldUpdateOperationsInput | number | null
    art10mix11?: NullableFloatFieldUpdateOperationsInput | number | null
    art10rou11?: NullableFloatFieldUpdateOperationsInput | number | null
    art10fer11?: NullableFloatFieldUpdateOperationsInput | number | null
    art10inc11?: NullableFloatFieldUpdateOperationsInput | number | null
    naf11art12?: NullableFloatFieldUpdateOperationsInput | number | null
    art11act12?: NullableFloatFieldUpdateOperationsInput | number | null
    art11hab12?: NullableFloatFieldUpdateOperationsInput | number | null
    art11mix12?: NullableFloatFieldUpdateOperationsInput | number | null
    art11rou12?: NullableFloatFieldUpdateOperationsInput | number | null
    art11fer12?: NullableFloatFieldUpdateOperationsInput | number | null
    art11inc12?: NullableFloatFieldUpdateOperationsInput | number | null
    naf12art13?: NullableFloatFieldUpdateOperationsInput | number | null
    art12act13?: NullableFloatFieldUpdateOperationsInput | number | null
    art12hab13?: NullableFloatFieldUpdateOperationsInput | number | null
    art12mix13?: NullableFloatFieldUpdateOperationsInput | number | null
    art12rou13?: NullableFloatFieldUpdateOperationsInput | number | null
    art12fer13?: NullableFloatFieldUpdateOperationsInput | number | null
    art12inc13?: NullableFloatFieldUpdateOperationsInput | number | null
    naf13art14?: NullableFloatFieldUpdateOperationsInput | number | null
    art13act14?: NullableFloatFieldUpdateOperationsInput | number | null
    art13hab14?: NullableFloatFieldUpdateOperationsInput | number | null
    art13mix14?: NullableFloatFieldUpdateOperationsInput | number | null
    art13rou14?: NullableFloatFieldUpdateOperationsInput | number | null
    art13fer14?: NullableFloatFieldUpdateOperationsInput | number | null
    art13inc14?: NullableFloatFieldUpdateOperationsInput | number | null
    naf14art15?: NullableFloatFieldUpdateOperationsInput | number | null
    art14act15?: NullableFloatFieldUpdateOperationsInput | number | null
    art14hab15?: NullableFloatFieldUpdateOperationsInput | number | null
    art14mix15?: NullableFloatFieldUpdateOperationsInput | number | null
    art14rou15?: NullableFloatFieldUpdateOperationsInput | number | null
    art14fer15?: NullableFloatFieldUpdateOperationsInput | number | null
    art14inc15?: NullableFloatFieldUpdateOperationsInput | number | null
    naf15art16?: NullableFloatFieldUpdateOperationsInput | number | null
    art15act16?: NullableFloatFieldUpdateOperationsInput | number | null
    art15hab16?: NullableFloatFieldUpdateOperationsInput | number | null
    art15mix16?: NullableFloatFieldUpdateOperationsInput | number | null
    art15rou16?: NullableFloatFieldUpdateOperationsInput | number | null
    art15fer16?: NullableFloatFieldUpdateOperationsInput | number | null
    art15inc16?: NullableFloatFieldUpdateOperationsInput | number | null
    naf16art17?: NullableFloatFieldUpdateOperationsInput | number | null
    art16act17?: NullableFloatFieldUpdateOperationsInput | number | null
    art16hab17?: NullableFloatFieldUpdateOperationsInput | number | null
    art16mix17?: NullableFloatFieldUpdateOperationsInput | number | null
    art16rou17?: NullableFloatFieldUpdateOperationsInput | number | null
    art16fer17?: NullableFloatFieldUpdateOperationsInput | number | null
    art16inc17?: NullableFloatFieldUpdateOperationsInput | number | null
    naf17art18?: NullableFloatFieldUpdateOperationsInput | number | null
    art17act18?: NullableFloatFieldUpdateOperationsInput | number | null
    art17hab18?: NullableFloatFieldUpdateOperationsInput | number | null
    art17mix18?: NullableFloatFieldUpdateOperationsInput | number | null
    art17rou18?: NullableFloatFieldUpdateOperationsInput | number | null
    art17fer18?: NullableFloatFieldUpdateOperationsInput | number | null
    art17inc18?: NullableFloatFieldUpdateOperationsInput | number | null
    naf18art19?: NullableFloatFieldUpdateOperationsInput | number | null
    art18act19?: NullableFloatFieldUpdateOperationsInput | number | null
    art18hab19?: NullableFloatFieldUpdateOperationsInput | number | null
    art18mix19?: NullableFloatFieldUpdateOperationsInput | number | null
    art18rou19?: NullableFloatFieldUpdateOperationsInput | number | null
    art18fer19?: NullableFloatFieldUpdateOperationsInput | number | null
    art18inc19?: NullableFloatFieldUpdateOperationsInput | number | null
    naf19art20?: NullableFloatFieldUpdateOperationsInput | number | null
    art19act20?: NullableFloatFieldUpdateOperationsInput | number | null
    art19hab20?: NullableFloatFieldUpdateOperationsInput | number | null
    art19mix20?: NullableFloatFieldUpdateOperationsInput | number | null
    art19rou20?: NullableFloatFieldUpdateOperationsInput | number | null
    art19fer20?: NullableFloatFieldUpdateOperationsInput | number | null
    art19inc20?: NullableFloatFieldUpdateOperationsInput | number | null
    naf20art21?: NullableFloatFieldUpdateOperationsInput | number | null
    art20act21?: NullableFloatFieldUpdateOperationsInput | number | null
    art20hab21?: NullableFloatFieldUpdateOperationsInput | number | null
    art20mix21?: NullableFloatFieldUpdateOperationsInput | number | null
    art20rou21?: NullableFloatFieldUpdateOperationsInput | number | null
    art20fer21?: NullableFloatFieldUpdateOperationsInput | number | null
    art20inc21?: NullableFloatFieldUpdateOperationsInput | number | null
    naf21art22?: NullableFloatFieldUpdateOperationsInput | number | null
    art21act22?: NullableFloatFieldUpdateOperationsInput | number | null
    art21hab22?: NullableFloatFieldUpdateOperationsInput | number | null
    art21mix22?: NullableFloatFieldUpdateOperationsInput | number | null
    art21rou22?: NullableFloatFieldUpdateOperationsInput | number | null
    art21fer22?: NullableFloatFieldUpdateOperationsInput | number | null
    art21inc22?: NullableFloatFieldUpdateOperationsInput | number | null
    naf22art23?: NullableFloatFieldUpdateOperationsInput | number | null
    art22act23?: NullableFloatFieldUpdateOperationsInput | number | null
    art22hab23?: NullableFloatFieldUpdateOperationsInput | number | null
    art22mix23?: NullableFloatFieldUpdateOperationsInput | number | null
    art22rou23?: NullableFloatFieldUpdateOperationsInput | number | null
    art22fer23?: NullableFloatFieldUpdateOperationsInput | number | null
    art22inc23?: NullableFloatFieldUpdateOperationsInput | number | null
    naf09art23?: NullableFloatFieldUpdateOperationsInput | number | null
    art09act23?: NullableFloatFieldUpdateOperationsInput | number | null
    art09hab23?: NullableFloatFieldUpdateOperationsInput | number | null
    art09mix23?: NullableFloatFieldUpdateOperationsInput | number | null
    art09inc23?: NullableFloatFieldUpdateOperationsInput | number | null
    art09rou23?: NullableFloatFieldUpdateOperationsInput | number | null
    art09fer23?: NullableFloatFieldUpdateOperationsInput | number | null
    artcom0923?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type consommation_espaces_nafCreateManyInput = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
    naf09art10?: number | null
    art09act10?: number | null
    art09hab10?: number | null
    art09mix10?: number | null
    art09rou10?: number | null
    art09fer10?: number | null
    art09inc10?: number | null
    naf10art11?: number | null
    art10act11?: number | null
    art10hab11?: number | null
    art10mix11?: number | null
    art10rou11?: number | null
    art10fer11?: number | null
    art10inc11?: number | null
    naf11art12?: number | null
    art11act12?: number | null
    art11hab12?: number | null
    art11mix12?: number | null
    art11rou12?: number | null
    art11fer12?: number | null
    art11inc12?: number | null
    naf12art13?: number | null
    art12act13?: number | null
    art12hab13?: number | null
    art12mix13?: number | null
    art12rou13?: number | null
    art12fer13?: number | null
    art12inc13?: number | null
    naf13art14?: number | null
    art13act14?: number | null
    art13hab14?: number | null
    art13mix14?: number | null
    art13rou14?: number | null
    art13fer14?: number | null
    art13inc14?: number | null
    naf14art15?: number | null
    art14act15?: number | null
    art14hab15?: number | null
    art14mix15?: number | null
    art14rou15?: number | null
    art14fer15?: number | null
    art14inc15?: number | null
    naf15art16?: number | null
    art15act16?: number | null
    art15hab16?: number | null
    art15mix16?: number | null
    art15rou16?: number | null
    art15fer16?: number | null
    art15inc16?: number | null
    naf16art17?: number | null
    art16act17?: number | null
    art16hab17?: number | null
    art16mix17?: number | null
    art16rou17?: number | null
    art16fer17?: number | null
    art16inc17?: number | null
    naf17art18?: number | null
    art17act18?: number | null
    art17hab18?: number | null
    art17mix18?: number | null
    art17rou18?: number | null
    art17fer18?: number | null
    art17inc18?: number | null
    naf18art19?: number | null
    art18act19?: number | null
    art18hab19?: number | null
    art18mix19?: number | null
    art18rou19?: number | null
    art18fer19?: number | null
    art18inc19?: number | null
    naf19art20?: number | null
    art19act20?: number | null
    art19hab20?: number | null
    art19mix20?: number | null
    art19rou20?: number | null
    art19fer20?: number | null
    art19inc20?: number | null
    naf20art21?: number | null
    art20act21?: number | null
    art20hab21?: number | null
    art20mix21?: number | null
    art20rou21?: number | null
    art20fer21?: number | null
    art20inc21?: number | null
    naf21art22?: number | null
    art21act22?: number | null
    art21hab22?: number | null
    art21mix22?: number | null
    art21rou22?: number | null
    art21fer22?: number | null
    art21inc22?: number | null
    naf22art23?: number | null
    art22act23?: number | null
    art22hab23?: number | null
    art22mix23?: number | null
    art22rou23?: number | null
    art22fer23?: number | null
    art22inc23?: number | null
    naf09art23?: number | null
    art09act23?: number | null
    art09hab23?: number | null
    art09mix23?: number | null
    art09inc23?: number | null
    art09rou23?: number | null
    art09fer23?: number | null
    artcom0923?: number | null
  }

  export type consommation_espaces_nafUpdateManyMutationInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: FloatFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    naf09art10?: NullableFloatFieldUpdateOperationsInput | number | null
    art09act10?: NullableFloatFieldUpdateOperationsInput | number | null
    art09hab10?: NullableFloatFieldUpdateOperationsInput | number | null
    art09mix10?: NullableFloatFieldUpdateOperationsInput | number | null
    art09rou10?: NullableFloatFieldUpdateOperationsInput | number | null
    art09fer10?: NullableFloatFieldUpdateOperationsInput | number | null
    art09inc10?: NullableFloatFieldUpdateOperationsInput | number | null
    naf10art11?: NullableFloatFieldUpdateOperationsInput | number | null
    art10act11?: NullableFloatFieldUpdateOperationsInput | number | null
    art10hab11?: NullableFloatFieldUpdateOperationsInput | number | null
    art10mix11?: NullableFloatFieldUpdateOperationsInput | number | null
    art10rou11?: NullableFloatFieldUpdateOperationsInput | number | null
    art10fer11?: NullableFloatFieldUpdateOperationsInput | number | null
    art10inc11?: NullableFloatFieldUpdateOperationsInput | number | null
    naf11art12?: NullableFloatFieldUpdateOperationsInput | number | null
    art11act12?: NullableFloatFieldUpdateOperationsInput | number | null
    art11hab12?: NullableFloatFieldUpdateOperationsInput | number | null
    art11mix12?: NullableFloatFieldUpdateOperationsInput | number | null
    art11rou12?: NullableFloatFieldUpdateOperationsInput | number | null
    art11fer12?: NullableFloatFieldUpdateOperationsInput | number | null
    art11inc12?: NullableFloatFieldUpdateOperationsInput | number | null
    naf12art13?: NullableFloatFieldUpdateOperationsInput | number | null
    art12act13?: NullableFloatFieldUpdateOperationsInput | number | null
    art12hab13?: NullableFloatFieldUpdateOperationsInput | number | null
    art12mix13?: NullableFloatFieldUpdateOperationsInput | number | null
    art12rou13?: NullableFloatFieldUpdateOperationsInput | number | null
    art12fer13?: NullableFloatFieldUpdateOperationsInput | number | null
    art12inc13?: NullableFloatFieldUpdateOperationsInput | number | null
    naf13art14?: NullableFloatFieldUpdateOperationsInput | number | null
    art13act14?: NullableFloatFieldUpdateOperationsInput | number | null
    art13hab14?: NullableFloatFieldUpdateOperationsInput | number | null
    art13mix14?: NullableFloatFieldUpdateOperationsInput | number | null
    art13rou14?: NullableFloatFieldUpdateOperationsInput | number | null
    art13fer14?: NullableFloatFieldUpdateOperationsInput | number | null
    art13inc14?: NullableFloatFieldUpdateOperationsInput | number | null
    naf14art15?: NullableFloatFieldUpdateOperationsInput | number | null
    art14act15?: NullableFloatFieldUpdateOperationsInput | number | null
    art14hab15?: NullableFloatFieldUpdateOperationsInput | number | null
    art14mix15?: NullableFloatFieldUpdateOperationsInput | number | null
    art14rou15?: NullableFloatFieldUpdateOperationsInput | number | null
    art14fer15?: NullableFloatFieldUpdateOperationsInput | number | null
    art14inc15?: NullableFloatFieldUpdateOperationsInput | number | null
    naf15art16?: NullableFloatFieldUpdateOperationsInput | number | null
    art15act16?: NullableFloatFieldUpdateOperationsInput | number | null
    art15hab16?: NullableFloatFieldUpdateOperationsInput | number | null
    art15mix16?: NullableFloatFieldUpdateOperationsInput | number | null
    art15rou16?: NullableFloatFieldUpdateOperationsInput | number | null
    art15fer16?: NullableFloatFieldUpdateOperationsInput | number | null
    art15inc16?: NullableFloatFieldUpdateOperationsInput | number | null
    naf16art17?: NullableFloatFieldUpdateOperationsInput | number | null
    art16act17?: NullableFloatFieldUpdateOperationsInput | number | null
    art16hab17?: NullableFloatFieldUpdateOperationsInput | number | null
    art16mix17?: NullableFloatFieldUpdateOperationsInput | number | null
    art16rou17?: NullableFloatFieldUpdateOperationsInput | number | null
    art16fer17?: NullableFloatFieldUpdateOperationsInput | number | null
    art16inc17?: NullableFloatFieldUpdateOperationsInput | number | null
    naf17art18?: NullableFloatFieldUpdateOperationsInput | number | null
    art17act18?: NullableFloatFieldUpdateOperationsInput | number | null
    art17hab18?: NullableFloatFieldUpdateOperationsInput | number | null
    art17mix18?: NullableFloatFieldUpdateOperationsInput | number | null
    art17rou18?: NullableFloatFieldUpdateOperationsInput | number | null
    art17fer18?: NullableFloatFieldUpdateOperationsInput | number | null
    art17inc18?: NullableFloatFieldUpdateOperationsInput | number | null
    naf18art19?: NullableFloatFieldUpdateOperationsInput | number | null
    art18act19?: NullableFloatFieldUpdateOperationsInput | number | null
    art18hab19?: NullableFloatFieldUpdateOperationsInput | number | null
    art18mix19?: NullableFloatFieldUpdateOperationsInput | number | null
    art18rou19?: NullableFloatFieldUpdateOperationsInput | number | null
    art18fer19?: NullableFloatFieldUpdateOperationsInput | number | null
    art18inc19?: NullableFloatFieldUpdateOperationsInput | number | null
    naf19art20?: NullableFloatFieldUpdateOperationsInput | number | null
    art19act20?: NullableFloatFieldUpdateOperationsInput | number | null
    art19hab20?: NullableFloatFieldUpdateOperationsInput | number | null
    art19mix20?: NullableFloatFieldUpdateOperationsInput | number | null
    art19rou20?: NullableFloatFieldUpdateOperationsInput | number | null
    art19fer20?: NullableFloatFieldUpdateOperationsInput | number | null
    art19inc20?: NullableFloatFieldUpdateOperationsInput | number | null
    naf20art21?: NullableFloatFieldUpdateOperationsInput | number | null
    art20act21?: NullableFloatFieldUpdateOperationsInput | number | null
    art20hab21?: NullableFloatFieldUpdateOperationsInput | number | null
    art20mix21?: NullableFloatFieldUpdateOperationsInput | number | null
    art20rou21?: NullableFloatFieldUpdateOperationsInput | number | null
    art20fer21?: NullableFloatFieldUpdateOperationsInput | number | null
    art20inc21?: NullableFloatFieldUpdateOperationsInput | number | null
    naf21art22?: NullableFloatFieldUpdateOperationsInput | number | null
    art21act22?: NullableFloatFieldUpdateOperationsInput | number | null
    art21hab22?: NullableFloatFieldUpdateOperationsInput | number | null
    art21mix22?: NullableFloatFieldUpdateOperationsInput | number | null
    art21rou22?: NullableFloatFieldUpdateOperationsInput | number | null
    art21fer22?: NullableFloatFieldUpdateOperationsInput | number | null
    art21inc22?: NullableFloatFieldUpdateOperationsInput | number | null
    naf22art23?: NullableFloatFieldUpdateOperationsInput | number | null
    art22act23?: NullableFloatFieldUpdateOperationsInput | number | null
    art22hab23?: NullableFloatFieldUpdateOperationsInput | number | null
    art22mix23?: NullableFloatFieldUpdateOperationsInput | number | null
    art22rou23?: NullableFloatFieldUpdateOperationsInput | number | null
    art22fer23?: NullableFloatFieldUpdateOperationsInput | number | null
    art22inc23?: NullableFloatFieldUpdateOperationsInput | number | null
    naf09art23?: NullableFloatFieldUpdateOperationsInput | number | null
    art09act23?: NullableFloatFieldUpdateOperationsInput | number | null
    art09hab23?: NullableFloatFieldUpdateOperationsInput | number | null
    art09mix23?: NullableFloatFieldUpdateOperationsInput | number | null
    art09inc23?: NullableFloatFieldUpdateOperationsInput | number | null
    art09rou23?: NullableFloatFieldUpdateOperationsInput | number | null
    art09fer23?: NullableFloatFieldUpdateOperationsInput | number | null
    artcom0923?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type consommation_espaces_nafUncheckedUpdateManyInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: FloatFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    naf09art10?: NullableFloatFieldUpdateOperationsInput | number | null
    art09act10?: NullableFloatFieldUpdateOperationsInput | number | null
    art09hab10?: NullableFloatFieldUpdateOperationsInput | number | null
    art09mix10?: NullableFloatFieldUpdateOperationsInput | number | null
    art09rou10?: NullableFloatFieldUpdateOperationsInput | number | null
    art09fer10?: NullableFloatFieldUpdateOperationsInput | number | null
    art09inc10?: NullableFloatFieldUpdateOperationsInput | number | null
    naf10art11?: NullableFloatFieldUpdateOperationsInput | number | null
    art10act11?: NullableFloatFieldUpdateOperationsInput | number | null
    art10hab11?: NullableFloatFieldUpdateOperationsInput | number | null
    art10mix11?: NullableFloatFieldUpdateOperationsInput | number | null
    art10rou11?: NullableFloatFieldUpdateOperationsInput | number | null
    art10fer11?: NullableFloatFieldUpdateOperationsInput | number | null
    art10inc11?: NullableFloatFieldUpdateOperationsInput | number | null
    naf11art12?: NullableFloatFieldUpdateOperationsInput | number | null
    art11act12?: NullableFloatFieldUpdateOperationsInput | number | null
    art11hab12?: NullableFloatFieldUpdateOperationsInput | number | null
    art11mix12?: NullableFloatFieldUpdateOperationsInput | number | null
    art11rou12?: NullableFloatFieldUpdateOperationsInput | number | null
    art11fer12?: NullableFloatFieldUpdateOperationsInput | number | null
    art11inc12?: NullableFloatFieldUpdateOperationsInput | number | null
    naf12art13?: NullableFloatFieldUpdateOperationsInput | number | null
    art12act13?: NullableFloatFieldUpdateOperationsInput | number | null
    art12hab13?: NullableFloatFieldUpdateOperationsInput | number | null
    art12mix13?: NullableFloatFieldUpdateOperationsInput | number | null
    art12rou13?: NullableFloatFieldUpdateOperationsInput | number | null
    art12fer13?: NullableFloatFieldUpdateOperationsInput | number | null
    art12inc13?: NullableFloatFieldUpdateOperationsInput | number | null
    naf13art14?: NullableFloatFieldUpdateOperationsInput | number | null
    art13act14?: NullableFloatFieldUpdateOperationsInput | number | null
    art13hab14?: NullableFloatFieldUpdateOperationsInput | number | null
    art13mix14?: NullableFloatFieldUpdateOperationsInput | number | null
    art13rou14?: NullableFloatFieldUpdateOperationsInput | number | null
    art13fer14?: NullableFloatFieldUpdateOperationsInput | number | null
    art13inc14?: NullableFloatFieldUpdateOperationsInput | number | null
    naf14art15?: NullableFloatFieldUpdateOperationsInput | number | null
    art14act15?: NullableFloatFieldUpdateOperationsInput | number | null
    art14hab15?: NullableFloatFieldUpdateOperationsInput | number | null
    art14mix15?: NullableFloatFieldUpdateOperationsInput | number | null
    art14rou15?: NullableFloatFieldUpdateOperationsInput | number | null
    art14fer15?: NullableFloatFieldUpdateOperationsInput | number | null
    art14inc15?: NullableFloatFieldUpdateOperationsInput | number | null
    naf15art16?: NullableFloatFieldUpdateOperationsInput | number | null
    art15act16?: NullableFloatFieldUpdateOperationsInput | number | null
    art15hab16?: NullableFloatFieldUpdateOperationsInput | number | null
    art15mix16?: NullableFloatFieldUpdateOperationsInput | number | null
    art15rou16?: NullableFloatFieldUpdateOperationsInput | number | null
    art15fer16?: NullableFloatFieldUpdateOperationsInput | number | null
    art15inc16?: NullableFloatFieldUpdateOperationsInput | number | null
    naf16art17?: NullableFloatFieldUpdateOperationsInput | number | null
    art16act17?: NullableFloatFieldUpdateOperationsInput | number | null
    art16hab17?: NullableFloatFieldUpdateOperationsInput | number | null
    art16mix17?: NullableFloatFieldUpdateOperationsInput | number | null
    art16rou17?: NullableFloatFieldUpdateOperationsInput | number | null
    art16fer17?: NullableFloatFieldUpdateOperationsInput | number | null
    art16inc17?: NullableFloatFieldUpdateOperationsInput | number | null
    naf17art18?: NullableFloatFieldUpdateOperationsInput | number | null
    art17act18?: NullableFloatFieldUpdateOperationsInput | number | null
    art17hab18?: NullableFloatFieldUpdateOperationsInput | number | null
    art17mix18?: NullableFloatFieldUpdateOperationsInput | number | null
    art17rou18?: NullableFloatFieldUpdateOperationsInput | number | null
    art17fer18?: NullableFloatFieldUpdateOperationsInput | number | null
    art17inc18?: NullableFloatFieldUpdateOperationsInput | number | null
    naf18art19?: NullableFloatFieldUpdateOperationsInput | number | null
    art18act19?: NullableFloatFieldUpdateOperationsInput | number | null
    art18hab19?: NullableFloatFieldUpdateOperationsInput | number | null
    art18mix19?: NullableFloatFieldUpdateOperationsInput | number | null
    art18rou19?: NullableFloatFieldUpdateOperationsInput | number | null
    art18fer19?: NullableFloatFieldUpdateOperationsInput | number | null
    art18inc19?: NullableFloatFieldUpdateOperationsInput | number | null
    naf19art20?: NullableFloatFieldUpdateOperationsInput | number | null
    art19act20?: NullableFloatFieldUpdateOperationsInput | number | null
    art19hab20?: NullableFloatFieldUpdateOperationsInput | number | null
    art19mix20?: NullableFloatFieldUpdateOperationsInput | number | null
    art19rou20?: NullableFloatFieldUpdateOperationsInput | number | null
    art19fer20?: NullableFloatFieldUpdateOperationsInput | number | null
    art19inc20?: NullableFloatFieldUpdateOperationsInput | number | null
    naf20art21?: NullableFloatFieldUpdateOperationsInput | number | null
    art20act21?: NullableFloatFieldUpdateOperationsInput | number | null
    art20hab21?: NullableFloatFieldUpdateOperationsInput | number | null
    art20mix21?: NullableFloatFieldUpdateOperationsInput | number | null
    art20rou21?: NullableFloatFieldUpdateOperationsInput | number | null
    art20fer21?: NullableFloatFieldUpdateOperationsInput | number | null
    art20inc21?: NullableFloatFieldUpdateOperationsInput | number | null
    naf21art22?: NullableFloatFieldUpdateOperationsInput | number | null
    art21act22?: NullableFloatFieldUpdateOperationsInput | number | null
    art21hab22?: NullableFloatFieldUpdateOperationsInput | number | null
    art21mix22?: NullableFloatFieldUpdateOperationsInput | number | null
    art21rou22?: NullableFloatFieldUpdateOperationsInput | number | null
    art21fer22?: NullableFloatFieldUpdateOperationsInput | number | null
    art21inc22?: NullableFloatFieldUpdateOperationsInput | number | null
    naf22art23?: NullableFloatFieldUpdateOperationsInput | number | null
    art22act23?: NullableFloatFieldUpdateOperationsInput | number | null
    art22hab23?: NullableFloatFieldUpdateOperationsInput | number | null
    art22mix23?: NullableFloatFieldUpdateOperationsInput | number | null
    art22rou23?: NullableFloatFieldUpdateOperationsInput | number | null
    art22fer23?: NullableFloatFieldUpdateOperationsInput | number | null
    art22inc23?: NullableFloatFieldUpdateOperationsInput | number | null
    naf09art23?: NullableFloatFieldUpdateOperationsInput | number | null
    art09act23?: NullableFloatFieldUpdateOperationsInput | number | null
    art09hab23?: NullableFloatFieldUpdateOperationsInput | number | null
    art09mix23?: NullableFloatFieldUpdateOperationsInput | number | null
    art09inc23?: NullableFloatFieldUpdateOperationsInput | number | null
    art09rou23?: NullableFloatFieldUpdateOperationsInput | number | null
    art09fer23?: NullableFloatFieldUpdateOperationsInput | number | null
    artcom0923?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type export_cours_d_eauCreateInput = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
    cours_d_eau: string
    etat_ecologique?: string | null
    longueur: number
  }

  export type export_cours_d_eauUncheckedCreateInput = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
    cours_d_eau: string
    etat_ecologique?: string | null
    longueur: number
  }

  export type export_cours_d_eauUpdateInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: FloatFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    cours_d_eau?: StringFieldUpdateOperationsInput | string
    etat_ecologique?: NullableStringFieldUpdateOperationsInput | string | null
    longueur?: FloatFieldUpdateOperationsInput | number
  }

  export type export_cours_d_eauUncheckedUpdateInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: FloatFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    cours_d_eau?: StringFieldUpdateOperationsInput | string
    etat_ecologique?: NullableStringFieldUpdateOperationsInput | string | null
    longueur?: FloatFieldUpdateOperationsInput | number
  }

  export type export_cours_d_eauCreateManyInput = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
    cours_d_eau: string
    etat_ecologique?: string | null
    longueur: number
  }

  export type export_cours_d_eauUpdateManyMutationInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: FloatFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    cours_d_eau?: StringFieldUpdateOperationsInput | string
    etat_ecologique?: NullableStringFieldUpdateOperationsInput | string | null
    longueur?: FloatFieldUpdateOperationsInput | number
  }

  export type export_cours_d_eauUncheckedUpdateManyInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: FloatFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    cours_d_eau?: StringFieldUpdateOperationsInput | string
    etat_ecologique?: NullableStringFieldUpdateOperationsInput | string | null
    longueur?: FloatFieldUpdateOperationsInput | number
  }

  export type feux_foretCreateInput = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
    annee: number
    nature?: string | null
    surface_parcourue: number
    surface_foret?: number | null
    surface_maquis_garrigues?: number | null
    autres_surfaces_naturelles_hors_foret?: number | null
    surfaces_agricoles?: number | null
    surfaces_non_boisees?: number | null
    surfaces_non_boisees_artificialisees?: number | null
    surfaces_non_boisees_naturelles?: number | null
    surface_autres_terres_boisees?: number | null
    autres_surfaces?: number | null
  }

  export type feux_foretUncheckedCreateInput = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
    annee: number
    nature?: string | null
    surface_parcourue: number
    surface_foret?: number | null
    surface_maquis_garrigues?: number | null
    autres_surfaces_naturelles_hors_foret?: number | null
    surfaces_agricoles?: number | null
    surfaces_non_boisees?: number | null
    surfaces_non_boisees_artificialisees?: number | null
    surfaces_non_boisees_naturelles?: number | null
    surface_autres_terres_boisees?: number | null
    autres_surfaces?: number | null
  }

  export type feux_foretUpdateInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: FloatFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    annee?: FloatFieldUpdateOperationsInput | number
    nature?: NullableStringFieldUpdateOperationsInput | string | null
    surface_parcourue?: FloatFieldUpdateOperationsInput | number
    surface_foret?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_maquis_garrigues?: NullableFloatFieldUpdateOperationsInput | number | null
    autres_surfaces_naturelles_hors_foret?: NullableFloatFieldUpdateOperationsInput | number | null
    surfaces_agricoles?: NullableFloatFieldUpdateOperationsInput | number | null
    surfaces_non_boisees?: NullableFloatFieldUpdateOperationsInput | number | null
    surfaces_non_boisees_artificialisees?: NullableFloatFieldUpdateOperationsInput | number | null
    surfaces_non_boisees_naturelles?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_autres_terres_boisees?: NullableFloatFieldUpdateOperationsInput | number | null
    autres_surfaces?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type feux_foretUncheckedUpdateInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: FloatFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    annee?: FloatFieldUpdateOperationsInput | number
    nature?: NullableStringFieldUpdateOperationsInput | string | null
    surface_parcourue?: FloatFieldUpdateOperationsInput | number
    surface_foret?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_maquis_garrigues?: NullableFloatFieldUpdateOperationsInput | number | null
    autres_surfaces_naturelles_hors_foret?: NullableFloatFieldUpdateOperationsInput | number | null
    surfaces_agricoles?: NullableFloatFieldUpdateOperationsInput | number | null
    surfaces_non_boisees?: NullableFloatFieldUpdateOperationsInput | number | null
    surfaces_non_boisees_artificialisees?: NullableFloatFieldUpdateOperationsInput | number | null
    surfaces_non_boisees_naturelles?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_autres_terres_boisees?: NullableFloatFieldUpdateOperationsInput | number | null
    autres_surfaces?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type feux_foretCreateManyInput = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
    annee: number
    nature?: string | null
    surface_parcourue: number
    surface_foret?: number | null
    surface_maquis_garrigues?: number | null
    autres_surfaces_naturelles_hors_foret?: number | null
    surfaces_agricoles?: number | null
    surfaces_non_boisees?: number | null
    surfaces_non_boisees_artificialisees?: number | null
    surfaces_non_boisees_naturelles?: number | null
    surface_autres_terres_boisees?: number | null
    autres_surfaces?: number | null
  }

  export type feux_foretUpdateManyMutationInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: FloatFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    annee?: FloatFieldUpdateOperationsInput | number
    nature?: NullableStringFieldUpdateOperationsInput | string | null
    surface_parcourue?: FloatFieldUpdateOperationsInput | number
    surface_foret?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_maquis_garrigues?: NullableFloatFieldUpdateOperationsInput | number | null
    autres_surfaces_naturelles_hors_foret?: NullableFloatFieldUpdateOperationsInput | number | null
    surfaces_agricoles?: NullableFloatFieldUpdateOperationsInput | number | null
    surfaces_non_boisees?: NullableFloatFieldUpdateOperationsInput | number | null
    surfaces_non_boisees_artificialisees?: NullableFloatFieldUpdateOperationsInput | number | null
    surfaces_non_boisees_naturelles?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_autres_terres_boisees?: NullableFloatFieldUpdateOperationsInput | number | null
    autres_surfaces?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type feux_foretUncheckedUpdateManyInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: FloatFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    annee?: FloatFieldUpdateOperationsInput | number
    nature?: NullableStringFieldUpdateOperationsInput | string | null
    surface_parcourue?: FloatFieldUpdateOperationsInput | number
    surface_foret?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_maquis_garrigues?: NullableFloatFieldUpdateOperationsInput | number | null
    autres_surfaces_naturelles_hors_foret?: NullableFloatFieldUpdateOperationsInput | number | null
    surfaces_agricoles?: NullableFloatFieldUpdateOperationsInput | number | null
    surfaces_non_boisees?: NullableFloatFieldUpdateOperationsInput | number | null
    surfaces_non_boisees_artificialisees?: NullableFloatFieldUpdateOperationsInput | number | null
    surfaces_non_boisees_naturelles?: NullableFloatFieldUpdateOperationsInput | number | null
    surface_autres_terres_boisees?: NullableFloatFieldUpdateOperationsInput | number | null
    autres_surfaces?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type lcz_couvertureCreateInput = {
    index: number
    code_geographique: string
    libelle_geographique?: string | null
    epci?: string | null
    libelle_epci?: string | null
    departement?: string | null
    libelle_departement?: string | null
    region?: number | null
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
    couverture_lcz: number
  }

  export type lcz_couvertureUncheckedCreateInput = {
    index: number
    code_geographique: string
    libelle_geographique?: string | null
    epci?: string | null
    libelle_epci?: string | null
    departement?: string | null
    libelle_departement?: string | null
    region?: number | null
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
    couverture_lcz: number
  }

  export type lcz_couvertureUpdateInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: NullableStringFieldUpdateOperationsInput | string | null
    epci?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_epci?: NullableStringFieldUpdateOperationsInput | string | null
    departement?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_departement?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableFloatFieldUpdateOperationsInput | number | null
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    couverture_lcz?: FloatFieldUpdateOperationsInput | number
  }

  export type lcz_couvertureUncheckedUpdateInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: NullableStringFieldUpdateOperationsInput | string | null
    epci?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_epci?: NullableStringFieldUpdateOperationsInput | string | null
    departement?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_departement?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableFloatFieldUpdateOperationsInput | number | null
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    couverture_lcz?: FloatFieldUpdateOperationsInput | number
  }

  export type lcz_couvertureCreateManyInput = {
    index: number
    code_geographique: string
    libelle_geographique?: string | null
    epci?: string | null
    libelle_epci?: string | null
    departement?: string | null
    libelle_departement?: string | null
    region?: number | null
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
    couverture_lcz: number
  }

  export type lcz_couvertureUpdateManyMutationInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: NullableStringFieldUpdateOperationsInput | string | null
    epci?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_epci?: NullableStringFieldUpdateOperationsInput | string | null
    departement?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_departement?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableFloatFieldUpdateOperationsInput | number | null
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    couverture_lcz?: FloatFieldUpdateOperationsInput | number
  }

  export type lcz_couvertureUncheckedUpdateManyInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: NullableStringFieldUpdateOperationsInput | string | null
    epci?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_epci?: NullableStringFieldUpdateOperationsInput | string | null
    departement?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_departement?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableFloatFieldUpdateOperationsInput | number | null
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    couverture_lcz?: FloatFieldUpdateOperationsInput | number
  }

  export type patch4cCreateInput = {
    index: number
    code_geographique: string
    niveaux_marins?: number | null
    feux_foret: number
    secheresse_sols: number
    fortes_precipitations: number
    fortes_chaleurs: number
  }

  export type patch4cUncheckedCreateInput = {
    index: number
    code_geographique: string
    niveaux_marins?: number | null
    feux_foret: number
    secheresse_sols: number
    fortes_precipitations: number
    fortes_chaleurs: number
  }

  export type patch4cUpdateInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    niveaux_marins?: NullableFloatFieldUpdateOperationsInput | number | null
    feux_foret?: FloatFieldUpdateOperationsInput | number
    secheresse_sols?: FloatFieldUpdateOperationsInput | number
    fortes_precipitations?: FloatFieldUpdateOperationsInput | number
    fortes_chaleurs?: FloatFieldUpdateOperationsInput | number
  }

  export type patch4cUncheckedUpdateInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    niveaux_marins?: NullableFloatFieldUpdateOperationsInput | number | null
    feux_foret?: FloatFieldUpdateOperationsInput | number
    secheresse_sols?: FloatFieldUpdateOperationsInput | number
    fortes_precipitations?: FloatFieldUpdateOperationsInput | number
    fortes_chaleurs?: FloatFieldUpdateOperationsInput | number
  }

  export type patch4cCreateManyInput = {
    index: number
    code_geographique: string
    niveaux_marins?: number | null
    feux_foret: number
    secheresse_sols: number
    fortes_precipitations: number
    fortes_chaleurs: number
  }

  export type patch4cUpdateManyMutationInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    niveaux_marins?: NullableFloatFieldUpdateOperationsInput | number | null
    feux_foret?: FloatFieldUpdateOperationsInput | number
    secheresse_sols?: FloatFieldUpdateOperationsInput | number
    fortes_precipitations?: FloatFieldUpdateOperationsInput | number
    fortes_chaleurs?: FloatFieldUpdateOperationsInput | number
  }

  export type patch4cUncheckedUpdateManyInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    niveaux_marins?: NullableFloatFieldUpdateOperationsInput | number | null
    feux_foret?: FloatFieldUpdateOperationsInput | number
    secheresse_sols?: FloatFieldUpdateOperationsInput | number
    fortes_precipitations?: FloatFieldUpdateOperationsInput | number
    fortes_chaleurs?: FloatFieldUpdateOperationsInput | number
  }

  export type prelevements_eauCreateInput = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
    libelle_sous_champ?: string | null
    A2020?: string | null
    A2019?: string | null
    A2018?: string | null
    A2017?: string | null
    A2016?: string | null
    A2015?: string | null
    A2014?: string | null
    A2013?: string | null
    A2012?: string | null
    A2011?: string | null
    A2010?: string | null
    A2009?: string | null
    A2008?: string | null
    sous_champ?: string | null
  }

  export type prelevements_eauUncheckedCreateInput = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
    libelle_sous_champ?: string | null
    A2020?: string | null
    A2019?: string | null
    A2018?: string | null
    A2017?: string | null
    A2016?: string | null
    A2015?: string | null
    A2014?: string | null
    A2013?: string | null
    A2012?: string | null
    A2011?: string | null
    A2010?: string | null
    A2009?: string | null
    A2008?: string | null
    sous_champ?: string | null
  }

  export type prelevements_eauUpdateInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: IntFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_sous_champ?: NullableStringFieldUpdateOperationsInput | string | null
    A2020?: NullableStringFieldUpdateOperationsInput | string | null
    A2019?: NullableStringFieldUpdateOperationsInput | string | null
    A2018?: NullableStringFieldUpdateOperationsInput | string | null
    A2017?: NullableStringFieldUpdateOperationsInput | string | null
    A2016?: NullableStringFieldUpdateOperationsInput | string | null
    A2015?: NullableStringFieldUpdateOperationsInput | string | null
    A2014?: NullableStringFieldUpdateOperationsInput | string | null
    A2013?: NullableStringFieldUpdateOperationsInput | string | null
    A2012?: NullableStringFieldUpdateOperationsInput | string | null
    A2011?: NullableStringFieldUpdateOperationsInput | string | null
    A2010?: NullableStringFieldUpdateOperationsInput | string | null
    A2009?: NullableStringFieldUpdateOperationsInput | string | null
    A2008?: NullableStringFieldUpdateOperationsInput | string | null
    sous_champ?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type prelevements_eauUncheckedUpdateInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: IntFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_sous_champ?: NullableStringFieldUpdateOperationsInput | string | null
    A2020?: NullableStringFieldUpdateOperationsInput | string | null
    A2019?: NullableStringFieldUpdateOperationsInput | string | null
    A2018?: NullableStringFieldUpdateOperationsInput | string | null
    A2017?: NullableStringFieldUpdateOperationsInput | string | null
    A2016?: NullableStringFieldUpdateOperationsInput | string | null
    A2015?: NullableStringFieldUpdateOperationsInput | string | null
    A2014?: NullableStringFieldUpdateOperationsInput | string | null
    A2013?: NullableStringFieldUpdateOperationsInput | string | null
    A2012?: NullableStringFieldUpdateOperationsInput | string | null
    A2011?: NullableStringFieldUpdateOperationsInput | string | null
    A2010?: NullableStringFieldUpdateOperationsInput | string | null
    A2009?: NullableStringFieldUpdateOperationsInput | string | null
    A2008?: NullableStringFieldUpdateOperationsInput | string | null
    sous_champ?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type prelevements_eauCreateManyInput = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
    libelle_sous_champ?: string | null
    A2020?: string | null
    A2019?: string | null
    A2018?: string | null
    A2017?: string | null
    A2016?: string | null
    A2015?: string | null
    A2014?: string | null
    A2013?: string | null
    A2012?: string | null
    A2011?: string | null
    A2010?: string | null
    A2009?: string | null
    A2008?: string | null
    sous_champ?: string | null
  }

  export type prelevements_eauUpdateManyMutationInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: IntFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_sous_champ?: NullableStringFieldUpdateOperationsInput | string | null
    A2020?: NullableStringFieldUpdateOperationsInput | string | null
    A2019?: NullableStringFieldUpdateOperationsInput | string | null
    A2018?: NullableStringFieldUpdateOperationsInput | string | null
    A2017?: NullableStringFieldUpdateOperationsInput | string | null
    A2016?: NullableStringFieldUpdateOperationsInput | string | null
    A2015?: NullableStringFieldUpdateOperationsInput | string | null
    A2014?: NullableStringFieldUpdateOperationsInput | string | null
    A2013?: NullableStringFieldUpdateOperationsInput | string | null
    A2012?: NullableStringFieldUpdateOperationsInput | string | null
    A2011?: NullableStringFieldUpdateOperationsInput | string | null
    A2010?: NullableStringFieldUpdateOperationsInput | string | null
    A2009?: NullableStringFieldUpdateOperationsInput | string | null
    A2008?: NullableStringFieldUpdateOperationsInput | string | null
    sous_champ?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type prelevements_eauUncheckedUpdateManyInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: IntFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_sous_champ?: NullableStringFieldUpdateOperationsInput | string | null
    A2020?: NullableStringFieldUpdateOperationsInput | string | null
    A2019?: NullableStringFieldUpdateOperationsInput | string | null
    A2018?: NullableStringFieldUpdateOperationsInput | string | null
    A2017?: NullableStringFieldUpdateOperationsInput | string | null
    A2016?: NullableStringFieldUpdateOperationsInput | string | null
    A2015?: NullableStringFieldUpdateOperationsInput | string | null
    A2014?: NullableStringFieldUpdateOperationsInput | string | null
    A2013?: NullableStringFieldUpdateOperationsInput | string | null
    A2012?: NullableStringFieldUpdateOperationsInput | string | null
    A2011?: NullableStringFieldUpdateOperationsInput | string | null
    A2010?: NullableStringFieldUpdateOperationsInput | string | null
    A2009?: NullableStringFieldUpdateOperationsInput | string | null
    A2008?: NullableStringFieldUpdateOperationsInput | string | null
    sous_champ?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type qualite_sites_baignadeCreateInput = {
    index: number
    DEP_NOM: string
    DEP_NUM: string
    TYPE: string
    COMMUNE: string
    POINT: string
    LONG: number
    LAT: number
    QEB_2013?: string | null
    QEB_2014?: string | null
    QEB_2015?: string | null
    QEB_2016?: string | null
    QEB_2017?: string | null
    QEB_2018?: string | null
    QEB_2019?: string | null
    QEB_2020?: string | null
  }

  export type qualite_sites_baignadeUncheckedCreateInput = {
    index: number
    DEP_NOM: string
    DEP_NUM: string
    TYPE: string
    COMMUNE: string
    POINT: string
    LONG: number
    LAT: number
    QEB_2013?: string | null
    QEB_2014?: string | null
    QEB_2015?: string | null
    QEB_2016?: string | null
    QEB_2017?: string | null
    QEB_2018?: string | null
    QEB_2019?: string | null
    QEB_2020?: string | null
  }

  export type qualite_sites_baignadeUpdateInput = {
    index?: IntFieldUpdateOperationsInput | number
    DEP_NOM?: StringFieldUpdateOperationsInput | string
    DEP_NUM?: StringFieldUpdateOperationsInput | string
    TYPE?: StringFieldUpdateOperationsInput | string
    COMMUNE?: StringFieldUpdateOperationsInput | string
    POINT?: StringFieldUpdateOperationsInput | string
    LONG?: FloatFieldUpdateOperationsInput | number
    LAT?: FloatFieldUpdateOperationsInput | number
    QEB_2013?: NullableStringFieldUpdateOperationsInput | string | null
    QEB_2014?: NullableStringFieldUpdateOperationsInput | string | null
    QEB_2015?: NullableStringFieldUpdateOperationsInput | string | null
    QEB_2016?: NullableStringFieldUpdateOperationsInput | string | null
    QEB_2017?: NullableStringFieldUpdateOperationsInput | string | null
    QEB_2018?: NullableStringFieldUpdateOperationsInput | string | null
    QEB_2019?: NullableStringFieldUpdateOperationsInput | string | null
    QEB_2020?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type qualite_sites_baignadeUncheckedUpdateInput = {
    index?: IntFieldUpdateOperationsInput | number
    DEP_NOM?: StringFieldUpdateOperationsInput | string
    DEP_NUM?: StringFieldUpdateOperationsInput | string
    TYPE?: StringFieldUpdateOperationsInput | string
    COMMUNE?: StringFieldUpdateOperationsInput | string
    POINT?: StringFieldUpdateOperationsInput | string
    LONG?: FloatFieldUpdateOperationsInput | number
    LAT?: FloatFieldUpdateOperationsInput | number
    QEB_2013?: NullableStringFieldUpdateOperationsInput | string | null
    QEB_2014?: NullableStringFieldUpdateOperationsInput | string | null
    QEB_2015?: NullableStringFieldUpdateOperationsInput | string | null
    QEB_2016?: NullableStringFieldUpdateOperationsInput | string | null
    QEB_2017?: NullableStringFieldUpdateOperationsInput | string | null
    QEB_2018?: NullableStringFieldUpdateOperationsInput | string | null
    QEB_2019?: NullableStringFieldUpdateOperationsInput | string | null
    QEB_2020?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type qualite_sites_baignadeCreateManyInput = {
    index: number
    DEP_NOM: string
    DEP_NUM: string
    TYPE: string
    COMMUNE: string
    POINT: string
    LONG: number
    LAT: number
    QEB_2013?: string | null
    QEB_2014?: string | null
    QEB_2015?: string | null
    QEB_2016?: string | null
    QEB_2017?: string | null
    QEB_2018?: string | null
    QEB_2019?: string | null
    QEB_2020?: string | null
  }

  export type qualite_sites_baignadeUpdateManyMutationInput = {
    index?: IntFieldUpdateOperationsInput | number
    DEP_NOM?: StringFieldUpdateOperationsInput | string
    DEP_NUM?: StringFieldUpdateOperationsInput | string
    TYPE?: StringFieldUpdateOperationsInput | string
    COMMUNE?: StringFieldUpdateOperationsInput | string
    POINT?: StringFieldUpdateOperationsInput | string
    LONG?: FloatFieldUpdateOperationsInput | number
    LAT?: FloatFieldUpdateOperationsInput | number
    QEB_2013?: NullableStringFieldUpdateOperationsInput | string | null
    QEB_2014?: NullableStringFieldUpdateOperationsInput | string | null
    QEB_2015?: NullableStringFieldUpdateOperationsInput | string | null
    QEB_2016?: NullableStringFieldUpdateOperationsInput | string | null
    QEB_2017?: NullableStringFieldUpdateOperationsInput | string | null
    QEB_2018?: NullableStringFieldUpdateOperationsInput | string | null
    QEB_2019?: NullableStringFieldUpdateOperationsInput | string | null
    QEB_2020?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type qualite_sites_baignadeUncheckedUpdateManyInput = {
    index?: IntFieldUpdateOperationsInput | number
    DEP_NOM?: StringFieldUpdateOperationsInput | string
    DEP_NUM?: StringFieldUpdateOperationsInput | string
    TYPE?: StringFieldUpdateOperationsInput | string
    COMMUNE?: StringFieldUpdateOperationsInput | string
    POINT?: StringFieldUpdateOperationsInput | string
    LONG?: FloatFieldUpdateOperationsInput | number
    LAT?: FloatFieldUpdateOperationsInput | number
    QEB_2013?: NullableStringFieldUpdateOperationsInput | string | null
    QEB_2014?: NullableStringFieldUpdateOperationsInput | string | null
    QEB_2015?: NullableStringFieldUpdateOperationsInput | string | null
    QEB_2016?: NullableStringFieldUpdateOperationsInput | string | null
    QEB_2017?: NullableStringFieldUpdateOperationsInput | string | null
    QEB_2018?: NullableStringFieldUpdateOperationsInput | string | null
    QEB_2019?: NullableStringFieldUpdateOperationsInput | string | null
    QEB_2020?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ressources_eauCreateInput = {
    index: number
    code_geographique: string
    LIBELLE_SOUS_CHAMP: string
    A2020: number
    A2019: number
    A2018: number
    A2017: number
    A2016: number
    A2015: number
    A2014: number
    A2013: number
    A2012: number
    A2011: number
    A2010: number
    A2009: number
    A2008: number
    SOUS_CHAMP: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
  }

  export type ressources_eauUncheckedCreateInput = {
    index: number
    code_geographique: string
    LIBELLE_SOUS_CHAMP: string
    A2020: number
    A2019: number
    A2018: number
    A2017: number
    A2016: number
    A2015: number
    A2014: number
    A2013: number
    A2012: number
    A2011: number
    A2010: number
    A2009: number
    A2008: number
    SOUS_CHAMP: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
  }

  export type ressources_eauUpdateInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    LIBELLE_SOUS_CHAMP?: StringFieldUpdateOperationsInput | string
    A2020?: FloatFieldUpdateOperationsInput | number
    A2019?: FloatFieldUpdateOperationsInput | number
    A2018?: FloatFieldUpdateOperationsInput | number
    A2017?: FloatFieldUpdateOperationsInput | number
    A2016?: FloatFieldUpdateOperationsInput | number
    A2015?: FloatFieldUpdateOperationsInput | number
    A2014?: FloatFieldUpdateOperationsInput | number
    A2013?: FloatFieldUpdateOperationsInput | number
    A2012?: FloatFieldUpdateOperationsInput | number
    A2011?: FloatFieldUpdateOperationsInput | number
    A2010?: FloatFieldUpdateOperationsInput | number
    A2009?: FloatFieldUpdateOperationsInput | number
    A2008?: FloatFieldUpdateOperationsInput | number
    SOUS_CHAMP?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: FloatFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ressources_eauUncheckedUpdateInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    LIBELLE_SOUS_CHAMP?: StringFieldUpdateOperationsInput | string
    A2020?: FloatFieldUpdateOperationsInput | number
    A2019?: FloatFieldUpdateOperationsInput | number
    A2018?: FloatFieldUpdateOperationsInput | number
    A2017?: FloatFieldUpdateOperationsInput | number
    A2016?: FloatFieldUpdateOperationsInput | number
    A2015?: FloatFieldUpdateOperationsInput | number
    A2014?: FloatFieldUpdateOperationsInput | number
    A2013?: FloatFieldUpdateOperationsInput | number
    A2012?: FloatFieldUpdateOperationsInput | number
    A2011?: FloatFieldUpdateOperationsInput | number
    A2010?: FloatFieldUpdateOperationsInput | number
    A2009?: FloatFieldUpdateOperationsInput | number
    A2008?: FloatFieldUpdateOperationsInput | number
    SOUS_CHAMP?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: FloatFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ressources_eauCreateManyInput = {
    index: number
    code_geographique: string
    LIBELLE_SOUS_CHAMP: string
    A2020: number
    A2019: number
    A2018: number
    A2017: number
    A2016: number
    A2015: number
    A2014: number
    A2013: number
    A2012: number
    A2011: number
    A2010: number
    A2009: number
    A2008: number
    SOUS_CHAMP: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
  }

  export type ressources_eauUpdateManyMutationInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    LIBELLE_SOUS_CHAMP?: StringFieldUpdateOperationsInput | string
    A2020?: FloatFieldUpdateOperationsInput | number
    A2019?: FloatFieldUpdateOperationsInput | number
    A2018?: FloatFieldUpdateOperationsInput | number
    A2017?: FloatFieldUpdateOperationsInput | number
    A2016?: FloatFieldUpdateOperationsInput | number
    A2015?: FloatFieldUpdateOperationsInput | number
    A2014?: FloatFieldUpdateOperationsInput | number
    A2013?: FloatFieldUpdateOperationsInput | number
    A2012?: FloatFieldUpdateOperationsInput | number
    A2011?: FloatFieldUpdateOperationsInput | number
    A2010?: FloatFieldUpdateOperationsInput | number
    A2009?: FloatFieldUpdateOperationsInput | number
    A2008?: FloatFieldUpdateOperationsInput | number
    SOUS_CHAMP?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: FloatFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ressources_eauUncheckedUpdateManyInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    LIBELLE_SOUS_CHAMP?: StringFieldUpdateOperationsInput | string
    A2020?: FloatFieldUpdateOperationsInput | number
    A2019?: FloatFieldUpdateOperationsInput | number
    A2018?: FloatFieldUpdateOperationsInput | number
    A2017?: FloatFieldUpdateOperationsInput | number
    A2016?: FloatFieldUpdateOperationsInput | number
    A2015?: FloatFieldUpdateOperationsInput | number
    A2014?: FloatFieldUpdateOperationsInput | number
    A2013?: FloatFieldUpdateOperationsInput | number
    A2012?: FloatFieldUpdateOperationsInput | number
    A2011?: FloatFieldUpdateOperationsInput | number
    A2010?: FloatFieldUpdateOperationsInput | number
    A2009?: FloatFieldUpdateOperationsInput | number
    A2008?: FloatFieldUpdateOperationsInput | number
    SOUS_CHAMP?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: FloatFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type rgaCreateInput = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
    nb_logement: number
    nb_logement_alea_moyen_fort: number
    nb_logement_alea_faible: number
    nb_logement_sans_alea: number
    nb_logement_alea_moyen_fort_avant_1920: number
    nb_logement_alea_moyen_fort_1920_1945: number
    nb_logement_alea_moyen_fort_1945_1975: number
    nb_logement_alea_moyen_fort_apres_1975: number
    nb_logement_alea_faible_avant_1920: number
    nb_logement_alea_faible_1920_1945: number
    nb_logement_alea_faible_1945_1975: number
    nb_logement_alea_faible_apres_1975: number
    surface_commune: number
    surface_alea_faible_commune: number
    surface_alea_moyen_fort_commune: number
    part_logement_alea_moyen_fort_avant_1920: number
    part_logement_alea_moyen_fort_1920_1945: number
    part_logement_alea_moyen_fort_1945_1975: number
    part_logement_alea_moyen_fort_apres_1975: number
    part_logement_alea_faible_avant_1920: number
    part_logement_alea_faible_1920_1945: number
    part_logement_alea_faible_1945_1975: number
    part_logement_alea_faible_apres_1975: number
    part_alea_faible_commune: number
    part_alea_moyen_fort_commune: number
  }

  export type rgaUncheckedCreateInput = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
    nb_logement: number
    nb_logement_alea_moyen_fort: number
    nb_logement_alea_faible: number
    nb_logement_sans_alea: number
    nb_logement_alea_moyen_fort_avant_1920: number
    nb_logement_alea_moyen_fort_1920_1945: number
    nb_logement_alea_moyen_fort_1945_1975: number
    nb_logement_alea_moyen_fort_apres_1975: number
    nb_logement_alea_faible_avant_1920: number
    nb_logement_alea_faible_1920_1945: number
    nb_logement_alea_faible_1945_1975: number
    nb_logement_alea_faible_apres_1975: number
    surface_commune: number
    surface_alea_faible_commune: number
    surface_alea_moyen_fort_commune: number
    part_logement_alea_moyen_fort_avant_1920: number
    part_logement_alea_moyen_fort_1920_1945: number
    part_logement_alea_moyen_fort_1945_1975: number
    part_logement_alea_moyen_fort_apres_1975: number
    part_logement_alea_faible_avant_1920: number
    part_logement_alea_faible_1920_1945: number
    part_logement_alea_faible_1945_1975: number
    part_logement_alea_faible_apres_1975: number
    part_alea_faible_commune: number
    part_alea_moyen_fort_commune: number
  }

  export type rgaUpdateInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: FloatFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    nb_logement?: IntFieldUpdateOperationsInput | number
    nb_logement_alea_moyen_fort?: IntFieldUpdateOperationsInput | number
    nb_logement_alea_faible?: IntFieldUpdateOperationsInput | number
    nb_logement_sans_alea?: IntFieldUpdateOperationsInput | number
    nb_logement_alea_moyen_fort_avant_1920?: IntFieldUpdateOperationsInput | number
    nb_logement_alea_moyen_fort_1920_1945?: IntFieldUpdateOperationsInput | number
    nb_logement_alea_moyen_fort_1945_1975?: IntFieldUpdateOperationsInput | number
    nb_logement_alea_moyen_fort_apres_1975?: IntFieldUpdateOperationsInput | number
    nb_logement_alea_faible_avant_1920?: IntFieldUpdateOperationsInput | number
    nb_logement_alea_faible_1920_1945?: IntFieldUpdateOperationsInput | number
    nb_logement_alea_faible_1945_1975?: IntFieldUpdateOperationsInput | number
    nb_logement_alea_faible_apres_1975?: IntFieldUpdateOperationsInput | number
    surface_commune?: IntFieldUpdateOperationsInput | number
    surface_alea_faible_commune?: IntFieldUpdateOperationsInput | number
    surface_alea_moyen_fort_commune?: IntFieldUpdateOperationsInput | number
    part_logement_alea_moyen_fort_avant_1920?: IntFieldUpdateOperationsInput | number
    part_logement_alea_moyen_fort_1920_1945?: IntFieldUpdateOperationsInput | number
    part_logement_alea_moyen_fort_1945_1975?: IntFieldUpdateOperationsInput | number
    part_logement_alea_moyen_fort_apres_1975?: IntFieldUpdateOperationsInput | number
    part_logement_alea_faible_avant_1920?: IntFieldUpdateOperationsInput | number
    part_logement_alea_faible_1920_1945?: IntFieldUpdateOperationsInput | number
    part_logement_alea_faible_1945_1975?: IntFieldUpdateOperationsInput | number
    part_logement_alea_faible_apres_1975?: IntFieldUpdateOperationsInput | number
    part_alea_faible_commune?: IntFieldUpdateOperationsInput | number
    part_alea_moyen_fort_commune?: IntFieldUpdateOperationsInput | number
  }

  export type rgaUncheckedUpdateInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: FloatFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    nb_logement?: IntFieldUpdateOperationsInput | number
    nb_logement_alea_moyen_fort?: IntFieldUpdateOperationsInput | number
    nb_logement_alea_faible?: IntFieldUpdateOperationsInput | number
    nb_logement_sans_alea?: IntFieldUpdateOperationsInput | number
    nb_logement_alea_moyen_fort_avant_1920?: IntFieldUpdateOperationsInput | number
    nb_logement_alea_moyen_fort_1920_1945?: IntFieldUpdateOperationsInput | number
    nb_logement_alea_moyen_fort_1945_1975?: IntFieldUpdateOperationsInput | number
    nb_logement_alea_moyen_fort_apres_1975?: IntFieldUpdateOperationsInput | number
    nb_logement_alea_faible_avant_1920?: IntFieldUpdateOperationsInput | number
    nb_logement_alea_faible_1920_1945?: IntFieldUpdateOperationsInput | number
    nb_logement_alea_faible_1945_1975?: IntFieldUpdateOperationsInput | number
    nb_logement_alea_faible_apres_1975?: IntFieldUpdateOperationsInput | number
    surface_commune?: IntFieldUpdateOperationsInput | number
    surface_alea_faible_commune?: IntFieldUpdateOperationsInput | number
    surface_alea_moyen_fort_commune?: IntFieldUpdateOperationsInput | number
    part_logement_alea_moyen_fort_avant_1920?: IntFieldUpdateOperationsInput | number
    part_logement_alea_moyen_fort_1920_1945?: IntFieldUpdateOperationsInput | number
    part_logement_alea_moyen_fort_1945_1975?: IntFieldUpdateOperationsInput | number
    part_logement_alea_moyen_fort_apres_1975?: IntFieldUpdateOperationsInput | number
    part_logement_alea_faible_avant_1920?: IntFieldUpdateOperationsInput | number
    part_logement_alea_faible_1920_1945?: IntFieldUpdateOperationsInput | number
    part_logement_alea_faible_1945_1975?: IntFieldUpdateOperationsInput | number
    part_logement_alea_faible_apres_1975?: IntFieldUpdateOperationsInput | number
    part_alea_faible_commune?: IntFieldUpdateOperationsInput | number
    part_alea_moyen_fort_commune?: IntFieldUpdateOperationsInput | number
  }

  export type rgaCreateManyInput = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
    nb_logement: number
    nb_logement_alea_moyen_fort: number
    nb_logement_alea_faible: number
    nb_logement_sans_alea: number
    nb_logement_alea_moyen_fort_avant_1920: number
    nb_logement_alea_moyen_fort_1920_1945: number
    nb_logement_alea_moyen_fort_1945_1975: number
    nb_logement_alea_moyen_fort_apres_1975: number
    nb_logement_alea_faible_avant_1920: number
    nb_logement_alea_faible_1920_1945: number
    nb_logement_alea_faible_1945_1975: number
    nb_logement_alea_faible_apres_1975: number
    surface_commune: number
    surface_alea_faible_commune: number
    surface_alea_moyen_fort_commune: number
    part_logement_alea_moyen_fort_avant_1920: number
    part_logement_alea_moyen_fort_1920_1945: number
    part_logement_alea_moyen_fort_1945_1975: number
    part_logement_alea_moyen_fort_apres_1975: number
    part_logement_alea_faible_avant_1920: number
    part_logement_alea_faible_1920_1945: number
    part_logement_alea_faible_1945_1975: number
    part_logement_alea_faible_apres_1975: number
    part_alea_faible_commune: number
    part_alea_moyen_fort_commune: number
  }

  export type rgaUpdateManyMutationInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: FloatFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    nb_logement?: IntFieldUpdateOperationsInput | number
    nb_logement_alea_moyen_fort?: IntFieldUpdateOperationsInput | number
    nb_logement_alea_faible?: IntFieldUpdateOperationsInput | number
    nb_logement_sans_alea?: IntFieldUpdateOperationsInput | number
    nb_logement_alea_moyen_fort_avant_1920?: IntFieldUpdateOperationsInput | number
    nb_logement_alea_moyen_fort_1920_1945?: IntFieldUpdateOperationsInput | number
    nb_logement_alea_moyen_fort_1945_1975?: IntFieldUpdateOperationsInput | number
    nb_logement_alea_moyen_fort_apres_1975?: IntFieldUpdateOperationsInput | number
    nb_logement_alea_faible_avant_1920?: IntFieldUpdateOperationsInput | number
    nb_logement_alea_faible_1920_1945?: IntFieldUpdateOperationsInput | number
    nb_logement_alea_faible_1945_1975?: IntFieldUpdateOperationsInput | number
    nb_logement_alea_faible_apres_1975?: IntFieldUpdateOperationsInput | number
    surface_commune?: IntFieldUpdateOperationsInput | number
    surface_alea_faible_commune?: IntFieldUpdateOperationsInput | number
    surface_alea_moyen_fort_commune?: IntFieldUpdateOperationsInput | number
    part_logement_alea_moyen_fort_avant_1920?: IntFieldUpdateOperationsInput | number
    part_logement_alea_moyen_fort_1920_1945?: IntFieldUpdateOperationsInput | number
    part_logement_alea_moyen_fort_1945_1975?: IntFieldUpdateOperationsInput | number
    part_logement_alea_moyen_fort_apres_1975?: IntFieldUpdateOperationsInput | number
    part_logement_alea_faible_avant_1920?: IntFieldUpdateOperationsInput | number
    part_logement_alea_faible_1920_1945?: IntFieldUpdateOperationsInput | number
    part_logement_alea_faible_1945_1975?: IntFieldUpdateOperationsInput | number
    part_logement_alea_faible_apres_1975?: IntFieldUpdateOperationsInput | number
    part_alea_faible_commune?: IntFieldUpdateOperationsInput | number
    part_alea_moyen_fort_commune?: IntFieldUpdateOperationsInput | number
  }

  export type rgaUncheckedUpdateManyInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: FloatFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    nb_logement?: IntFieldUpdateOperationsInput | number
    nb_logement_alea_moyen_fort?: IntFieldUpdateOperationsInput | number
    nb_logement_alea_faible?: IntFieldUpdateOperationsInput | number
    nb_logement_sans_alea?: IntFieldUpdateOperationsInput | number
    nb_logement_alea_moyen_fort_avant_1920?: IntFieldUpdateOperationsInput | number
    nb_logement_alea_moyen_fort_1920_1945?: IntFieldUpdateOperationsInput | number
    nb_logement_alea_moyen_fort_1945_1975?: IntFieldUpdateOperationsInput | number
    nb_logement_alea_moyen_fort_apres_1975?: IntFieldUpdateOperationsInput | number
    nb_logement_alea_faible_avant_1920?: IntFieldUpdateOperationsInput | number
    nb_logement_alea_faible_1920_1945?: IntFieldUpdateOperationsInput | number
    nb_logement_alea_faible_1945_1975?: IntFieldUpdateOperationsInput | number
    nb_logement_alea_faible_apres_1975?: IntFieldUpdateOperationsInput | number
    surface_commune?: IntFieldUpdateOperationsInput | number
    surface_alea_faible_commune?: IntFieldUpdateOperationsInput | number
    surface_alea_moyen_fort_commune?: IntFieldUpdateOperationsInput | number
    part_logement_alea_moyen_fort_avant_1920?: IntFieldUpdateOperationsInput | number
    part_logement_alea_moyen_fort_1920_1945?: IntFieldUpdateOperationsInput | number
    part_logement_alea_moyen_fort_1945_1975?: IntFieldUpdateOperationsInput | number
    part_logement_alea_moyen_fort_apres_1975?: IntFieldUpdateOperationsInput | number
    part_logement_alea_faible_avant_1920?: IntFieldUpdateOperationsInput | number
    part_logement_alea_faible_1920_1945?: IntFieldUpdateOperationsInput | number
    part_logement_alea_faible_1945_1975?: IntFieldUpdateOperationsInput | number
    part_logement_alea_faible_apres_1975?: IntFieldUpdateOperationsInput | number
    part_alea_faible_commune?: IntFieldUpdateOperationsInput | number
    part_alea_moyen_fort_commune?: IntFieldUpdateOperationsInput | number
  }

  export type surfaces_agricolesCreateInput = {
    index: number
    epci: string
    exploitation_sau: number
    exploitation_sau_terres_arables: number
    exploitation_sau_terres_arables_cereales: number
    exploitation_sau_terres_arables_oleagineux: number
    exploitation_sau_terres_arables_fourrageres: number
    exploitation_sau_terres_arables_tubercules: number
    exploitation_sau_terres_arables_legumes_melons_fraises: number
    exploitation_sau_terres_arables_fleurs: number
    exploitation_sau_terres_arables_autres: number
    exploitation_sau_cultures_permanentes: number
    exploitation_sau_cultures_permanentes_vigne: number
    exploitation_sau_cultures_permanentes_fruits: number
    exploitation_sau_cultures_permanentes_autres: number
    exploitation_sau_herbe: number
    exploitation_sau_herbe_prairies_productives: number
    exploitation_sau_herbe_prairies_peu_productives: number
    exploitation_sau_herbe_subventions: number
    exploitation_sau_herbe_bois_patures: number
    exploitation_sau_jardins: number
    superficie_sau: number
    superficie_sau_terres_arables: number
    superficie_sau_terres_arables_cereales: number
    superficie_sau_terres_arables_oleagineux: number
    superficie_sau_terres_arables_fourrageres: number
    superficie_sau_terres_arables_tubercules: number
    superficie_sau_terres_arables_legumes_melons_fraises: number
    superficie_sau_terres_arables_fleurs: number
    superficie_sau_terres_arables_autres: number
    superficie_sau_cultures_permanentes: number
    superficie_sau_cultures_permanentes_vigne: number
    superficie_sau_cultures_permanentes_fruits: number
    superficie_sau_cultures_permanentes_autres: number
    superficie_sau_herbe: number
    superficie_sau_herbe_prairies_productives: number
    superficie_sau_herbe_prairies_peu_productives: number
    superficie_sau_herbe_subventions: number
    superficie_sau_herbe_bois_patures: number
    superficie_sau_jardins: number
  }

  export type surfaces_agricolesUncheckedCreateInput = {
    index: number
    epci: string
    exploitation_sau: number
    exploitation_sau_terres_arables: number
    exploitation_sau_terres_arables_cereales: number
    exploitation_sau_terres_arables_oleagineux: number
    exploitation_sau_terres_arables_fourrageres: number
    exploitation_sau_terres_arables_tubercules: number
    exploitation_sau_terres_arables_legumes_melons_fraises: number
    exploitation_sau_terres_arables_fleurs: number
    exploitation_sau_terres_arables_autres: number
    exploitation_sau_cultures_permanentes: number
    exploitation_sau_cultures_permanentes_vigne: number
    exploitation_sau_cultures_permanentes_fruits: number
    exploitation_sau_cultures_permanentes_autres: number
    exploitation_sau_herbe: number
    exploitation_sau_herbe_prairies_productives: number
    exploitation_sau_herbe_prairies_peu_productives: number
    exploitation_sau_herbe_subventions: number
    exploitation_sau_herbe_bois_patures: number
    exploitation_sau_jardins: number
    superficie_sau: number
    superficie_sau_terres_arables: number
    superficie_sau_terres_arables_cereales: number
    superficie_sau_terres_arables_oleagineux: number
    superficie_sau_terres_arables_fourrageres: number
    superficie_sau_terres_arables_tubercules: number
    superficie_sau_terres_arables_legumes_melons_fraises: number
    superficie_sau_terres_arables_fleurs: number
    superficie_sau_terres_arables_autres: number
    superficie_sau_cultures_permanentes: number
    superficie_sau_cultures_permanentes_vigne: number
    superficie_sau_cultures_permanentes_fruits: number
    superficie_sau_cultures_permanentes_autres: number
    superficie_sau_herbe: number
    superficie_sau_herbe_prairies_productives: number
    superficie_sau_herbe_prairies_peu_productives: number
    superficie_sau_herbe_subventions: number
    superficie_sau_herbe_bois_patures: number
    superficie_sau_jardins: number
  }

  export type surfaces_agricolesUpdateInput = {
    index?: IntFieldUpdateOperationsInput | number
    epci?: StringFieldUpdateOperationsInput | string
    exploitation_sau?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_terres_arables?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_terres_arables_cereales?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_terres_arables_oleagineux?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_terres_arables_fourrageres?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_terres_arables_tubercules?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_terres_arables_legumes_melons_fraises?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_terres_arables_fleurs?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_terres_arables_autres?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_cultures_permanentes?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_cultures_permanentes_vigne?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_cultures_permanentes_fruits?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_cultures_permanentes_autres?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_herbe?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_herbe_prairies_productives?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_herbe_prairies_peu_productives?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_herbe_subventions?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_herbe_bois_patures?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_jardins?: FloatFieldUpdateOperationsInput | number
    superficie_sau?: FloatFieldUpdateOperationsInput | number
    superficie_sau_terres_arables?: FloatFieldUpdateOperationsInput | number
    superficie_sau_terres_arables_cereales?: FloatFieldUpdateOperationsInput | number
    superficie_sau_terres_arables_oleagineux?: FloatFieldUpdateOperationsInput | number
    superficie_sau_terres_arables_fourrageres?: FloatFieldUpdateOperationsInput | number
    superficie_sau_terres_arables_tubercules?: FloatFieldUpdateOperationsInput | number
    superficie_sau_terres_arables_legumes_melons_fraises?: FloatFieldUpdateOperationsInput | number
    superficie_sau_terres_arables_fleurs?: FloatFieldUpdateOperationsInput | number
    superficie_sau_terres_arables_autres?: FloatFieldUpdateOperationsInput | number
    superficie_sau_cultures_permanentes?: FloatFieldUpdateOperationsInput | number
    superficie_sau_cultures_permanentes_vigne?: FloatFieldUpdateOperationsInput | number
    superficie_sau_cultures_permanentes_fruits?: FloatFieldUpdateOperationsInput | number
    superficie_sau_cultures_permanentes_autres?: FloatFieldUpdateOperationsInput | number
    superficie_sau_herbe?: FloatFieldUpdateOperationsInput | number
    superficie_sau_herbe_prairies_productives?: FloatFieldUpdateOperationsInput | number
    superficie_sau_herbe_prairies_peu_productives?: FloatFieldUpdateOperationsInput | number
    superficie_sau_herbe_subventions?: FloatFieldUpdateOperationsInput | number
    superficie_sau_herbe_bois_patures?: FloatFieldUpdateOperationsInput | number
    superficie_sau_jardins?: FloatFieldUpdateOperationsInput | number
  }

  export type surfaces_agricolesUncheckedUpdateInput = {
    index?: IntFieldUpdateOperationsInput | number
    epci?: StringFieldUpdateOperationsInput | string
    exploitation_sau?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_terres_arables?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_terres_arables_cereales?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_terres_arables_oleagineux?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_terres_arables_fourrageres?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_terres_arables_tubercules?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_terres_arables_legumes_melons_fraises?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_terres_arables_fleurs?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_terres_arables_autres?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_cultures_permanentes?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_cultures_permanentes_vigne?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_cultures_permanentes_fruits?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_cultures_permanentes_autres?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_herbe?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_herbe_prairies_productives?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_herbe_prairies_peu_productives?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_herbe_subventions?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_herbe_bois_patures?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_jardins?: FloatFieldUpdateOperationsInput | number
    superficie_sau?: FloatFieldUpdateOperationsInput | number
    superficie_sau_terres_arables?: FloatFieldUpdateOperationsInput | number
    superficie_sau_terres_arables_cereales?: FloatFieldUpdateOperationsInput | number
    superficie_sau_terres_arables_oleagineux?: FloatFieldUpdateOperationsInput | number
    superficie_sau_terres_arables_fourrageres?: FloatFieldUpdateOperationsInput | number
    superficie_sau_terres_arables_tubercules?: FloatFieldUpdateOperationsInput | number
    superficie_sau_terres_arables_legumes_melons_fraises?: FloatFieldUpdateOperationsInput | number
    superficie_sau_terres_arables_fleurs?: FloatFieldUpdateOperationsInput | number
    superficie_sau_terres_arables_autres?: FloatFieldUpdateOperationsInput | number
    superficie_sau_cultures_permanentes?: FloatFieldUpdateOperationsInput | number
    superficie_sau_cultures_permanentes_vigne?: FloatFieldUpdateOperationsInput | number
    superficie_sau_cultures_permanentes_fruits?: FloatFieldUpdateOperationsInput | number
    superficie_sau_cultures_permanentes_autres?: FloatFieldUpdateOperationsInput | number
    superficie_sau_herbe?: FloatFieldUpdateOperationsInput | number
    superficie_sau_herbe_prairies_productives?: FloatFieldUpdateOperationsInput | number
    superficie_sau_herbe_prairies_peu_productives?: FloatFieldUpdateOperationsInput | number
    superficie_sau_herbe_subventions?: FloatFieldUpdateOperationsInput | number
    superficie_sau_herbe_bois_patures?: FloatFieldUpdateOperationsInput | number
    superficie_sau_jardins?: FloatFieldUpdateOperationsInput | number
  }

  export type surfaces_agricolesCreateManyInput = {
    index: number
    epci: string
    exploitation_sau: number
    exploitation_sau_terres_arables: number
    exploitation_sau_terres_arables_cereales: number
    exploitation_sau_terres_arables_oleagineux: number
    exploitation_sau_terres_arables_fourrageres: number
    exploitation_sau_terres_arables_tubercules: number
    exploitation_sau_terres_arables_legumes_melons_fraises: number
    exploitation_sau_terres_arables_fleurs: number
    exploitation_sau_terres_arables_autres: number
    exploitation_sau_cultures_permanentes: number
    exploitation_sau_cultures_permanentes_vigne: number
    exploitation_sau_cultures_permanentes_fruits: number
    exploitation_sau_cultures_permanentes_autres: number
    exploitation_sau_herbe: number
    exploitation_sau_herbe_prairies_productives: number
    exploitation_sau_herbe_prairies_peu_productives: number
    exploitation_sau_herbe_subventions: number
    exploitation_sau_herbe_bois_patures: number
    exploitation_sau_jardins: number
    superficie_sau: number
    superficie_sau_terres_arables: number
    superficie_sau_terres_arables_cereales: number
    superficie_sau_terres_arables_oleagineux: number
    superficie_sau_terres_arables_fourrageres: number
    superficie_sau_terres_arables_tubercules: number
    superficie_sau_terres_arables_legumes_melons_fraises: number
    superficie_sau_terres_arables_fleurs: number
    superficie_sau_terres_arables_autres: number
    superficie_sau_cultures_permanentes: number
    superficie_sau_cultures_permanentes_vigne: number
    superficie_sau_cultures_permanentes_fruits: number
    superficie_sau_cultures_permanentes_autres: number
    superficie_sau_herbe: number
    superficie_sau_herbe_prairies_productives: number
    superficie_sau_herbe_prairies_peu_productives: number
    superficie_sau_herbe_subventions: number
    superficie_sau_herbe_bois_patures: number
    superficie_sau_jardins: number
  }

  export type surfaces_agricolesUpdateManyMutationInput = {
    index?: IntFieldUpdateOperationsInput | number
    epci?: StringFieldUpdateOperationsInput | string
    exploitation_sau?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_terres_arables?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_terres_arables_cereales?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_terres_arables_oleagineux?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_terres_arables_fourrageres?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_terres_arables_tubercules?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_terres_arables_legumes_melons_fraises?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_terres_arables_fleurs?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_terres_arables_autres?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_cultures_permanentes?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_cultures_permanentes_vigne?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_cultures_permanentes_fruits?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_cultures_permanentes_autres?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_herbe?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_herbe_prairies_productives?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_herbe_prairies_peu_productives?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_herbe_subventions?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_herbe_bois_patures?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_jardins?: FloatFieldUpdateOperationsInput | number
    superficie_sau?: FloatFieldUpdateOperationsInput | number
    superficie_sau_terres_arables?: FloatFieldUpdateOperationsInput | number
    superficie_sau_terres_arables_cereales?: FloatFieldUpdateOperationsInput | number
    superficie_sau_terres_arables_oleagineux?: FloatFieldUpdateOperationsInput | number
    superficie_sau_terres_arables_fourrageres?: FloatFieldUpdateOperationsInput | number
    superficie_sau_terres_arables_tubercules?: FloatFieldUpdateOperationsInput | number
    superficie_sau_terres_arables_legumes_melons_fraises?: FloatFieldUpdateOperationsInput | number
    superficie_sau_terres_arables_fleurs?: FloatFieldUpdateOperationsInput | number
    superficie_sau_terres_arables_autres?: FloatFieldUpdateOperationsInput | number
    superficie_sau_cultures_permanentes?: FloatFieldUpdateOperationsInput | number
    superficie_sau_cultures_permanentes_vigne?: FloatFieldUpdateOperationsInput | number
    superficie_sau_cultures_permanentes_fruits?: FloatFieldUpdateOperationsInput | number
    superficie_sau_cultures_permanentes_autres?: FloatFieldUpdateOperationsInput | number
    superficie_sau_herbe?: FloatFieldUpdateOperationsInput | number
    superficie_sau_herbe_prairies_productives?: FloatFieldUpdateOperationsInput | number
    superficie_sau_herbe_prairies_peu_productives?: FloatFieldUpdateOperationsInput | number
    superficie_sau_herbe_subventions?: FloatFieldUpdateOperationsInput | number
    superficie_sau_herbe_bois_patures?: FloatFieldUpdateOperationsInput | number
    superficie_sau_jardins?: FloatFieldUpdateOperationsInput | number
  }

  export type surfaces_agricolesUncheckedUpdateManyInput = {
    index?: IntFieldUpdateOperationsInput | number
    epci?: StringFieldUpdateOperationsInput | string
    exploitation_sau?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_terres_arables?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_terres_arables_cereales?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_terres_arables_oleagineux?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_terres_arables_fourrageres?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_terres_arables_tubercules?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_terres_arables_legumes_melons_fraises?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_terres_arables_fleurs?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_terres_arables_autres?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_cultures_permanentes?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_cultures_permanentes_vigne?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_cultures_permanentes_fruits?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_cultures_permanentes_autres?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_herbe?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_herbe_prairies_productives?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_herbe_prairies_peu_productives?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_herbe_subventions?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_herbe_bois_patures?: FloatFieldUpdateOperationsInput | number
    exploitation_sau_jardins?: FloatFieldUpdateOperationsInput | number
    superficie_sau?: FloatFieldUpdateOperationsInput | number
    superficie_sau_terres_arables?: FloatFieldUpdateOperationsInput | number
    superficie_sau_terres_arables_cereales?: FloatFieldUpdateOperationsInput | number
    superficie_sau_terres_arables_oleagineux?: FloatFieldUpdateOperationsInput | number
    superficie_sau_terres_arables_fourrageres?: FloatFieldUpdateOperationsInput | number
    superficie_sau_terres_arables_tubercules?: FloatFieldUpdateOperationsInput | number
    superficie_sau_terres_arables_legumes_melons_fraises?: FloatFieldUpdateOperationsInput | number
    superficie_sau_terres_arables_fleurs?: FloatFieldUpdateOperationsInput | number
    superficie_sau_terres_arables_autres?: FloatFieldUpdateOperationsInput | number
    superficie_sau_cultures_permanentes?: FloatFieldUpdateOperationsInput | number
    superficie_sau_cultures_permanentes_vigne?: FloatFieldUpdateOperationsInput | number
    superficie_sau_cultures_permanentes_fruits?: FloatFieldUpdateOperationsInput | number
    superficie_sau_cultures_permanentes_autres?: FloatFieldUpdateOperationsInput | number
    superficie_sau_herbe?: FloatFieldUpdateOperationsInput | number
    superficie_sau_herbe_prairies_productives?: FloatFieldUpdateOperationsInput | number
    superficie_sau_herbe_prairies_peu_productives?: FloatFieldUpdateOperationsInput | number
    superficie_sau_herbe_subventions?: FloatFieldUpdateOperationsInput | number
    superficie_sau_herbe_bois_patures?: FloatFieldUpdateOperationsInput | number
    superficie_sau_jardins?: FloatFieldUpdateOperationsInput | number
  }

  export type surfaces_protegeesCreateInput = {
    index: number
    code_geographique: string
    PNC?: string | null
    RAMSAR?: string | null
    PNR?: string | null
    PNP?: string | null
    FOR_PRO?: string | null
    ZZZ?: string | null
    ZNIEFF2?: string | null
    ZNIEFF1?: string | null
    RNR?: string | null
    TOU_PRO?: string | null
    NATURA?: string | null
    ZPS?: string | null
    SIC?: string | null
    CELRL?: string | null
    BIO?: string | null
    APB?: string | null
    RN?: string | null
    RBFD?: string | null
    RNCFS?: string | null
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    region: number
  }

  export type surfaces_protegeesUncheckedCreateInput = {
    index: number
    code_geographique: string
    PNC?: string | null
    RAMSAR?: string | null
    PNR?: string | null
    PNP?: string | null
    FOR_PRO?: string | null
    ZZZ?: string | null
    ZNIEFF2?: string | null
    ZNIEFF1?: string | null
    RNR?: string | null
    TOU_PRO?: string | null
    NATURA?: string | null
    ZPS?: string | null
    SIC?: string | null
    CELRL?: string | null
    BIO?: string | null
    APB?: string | null
    RN?: string | null
    RBFD?: string | null
    RNCFS?: string | null
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    region: number
  }

  export type surfaces_protegeesUpdateInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    PNC?: NullableStringFieldUpdateOperationsInput | string | null
    RAMSAR?: NullableStringFieldUpdateOperationsInput | string | null
    PNR?: NullableStringFieldUpdateOperationsInput | string | null
    PNP?: NullableStringFieldUpdateOperationsInput | string | null
    FOR_PRO?: NullableStringFieldUpdateOperationsInput | string | null
    ZZZ?: NullableStringFieldUpdateOperationsInput | string | null
    ZNIEFF2?: NullableStringFieldUpdateOperationsInput | string | null
    ZNIEFF1?: NullableStringFieldUpdateOperationsInput | string | null
    RNR?: NullableStringFieldUpdateOperationsInput | string | null
    TOU_PRO?: NullableStringFieldUpdateOperationsInput | string | null
    NATURA?: NullableStringFieldUpdateOperationsInput | string | null
    ZPS?: NullableStringFieldUpdateOperationsInput | string | null
    SIC?: NullableStringFieldUpdateOperationsInput | string | null
    CELRL?: NullableStringFieldUpdateOperationsInput | string | null
    BIO?: NullableStringFieldUpdateOperationsInput | string | null
    APB?: NullableStringFieldUpdateOperationsInput | string | null
    RN?: NullableStringFieldUpdateOperationsInput | string | null
    RBFD?: NullableStringFieldUpdateOperationsInput | string | null
    RNCFS?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    region?: FloatFieldUpdateOperationsInput | number
  }

  export type surfaces_protegeesUncheckedUpdateInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    PNC?: NullableStringFieldUpdateOperationsInput | string | null
    RAMSAR?: NullableStringFieldUpdateOperationsInput | string | null
    PNR?: NullableStringFieldUpdateOperationsInput | string | null
    PNP?: NullableStringFieldUpdateOperationsInput | string | null
    FOR_PRO?: NullableStringFieldUpdateOperationsInput | string | null
    ZZZ?: NullableStringFieldUpdateOperationsInput | string | null
    ZNIEFF2?: NullableStringFieldUpdateOperationsInput | string | null
    ZNIEFF1?: NullableStringFieldUpdateOperationsInput | string | null
    RNR?: NullableStringFieldUpdateOperationsInput | string | null
    TOU_PRO?: NullableStringFieldUpdateOperationsInput | string | null
    NATURA?: NullableStringFieldUpdateOperationsInput | string | null
    ZPS?: NullableStringFieldUpdateOperationsInput | string | null
    SIC?: NullableStringFieldUpdateOperationsInput | string | null
    CELRL?: NullableStringFieldUpdateOperationsInput | string | null
    BIO?: NullableStringFieldUpdateOperationsInput | string | null
    APB?: NullableStringFieldUpdateOperationsInput | string | null
    RN?: NullableStringFieldUpdateOperationsInput | string | null
    RBFD?: NullableStringFieldUpdateOperationsInput | string | null
    RNCFS?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    region?: FloatFieldUpdateOperationsInput | number
  }

  export type surfaces_protegeesCreateManyInput = {
    index: number
    code_geographique: string
    PNC?: string | null
    RAMSAR?: string | null
    PNR?: string | null
    PNP?: string | null
    FOR_PRO?: string | null
    ZZZ?: string | null
    ZNIEFF2?: string | null
    ZNIEFF1?: string | null
    RNR?: string | null
    TOU_PRO?: string | null
    NATURA?: string | null
    ZPS?: string | null
    SIC?: string | null
    CELRL?: string | null
    BIO?: string | null
    APB?: string | null
    RN?: string | null
    RBFD?: string | null
    RNCFS?: string | null
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    region: number
  }

  export type surfaces_protegeesUpdateManyMutationInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    PNC?: NullableStringFieldUpdateOperationsInput | string | null
    RAMSAR?: NullableStringFieldUpdateOperationsInput | string | null
    PNR?: NullableStringFieldUpdateOperationsInput | string | null
    PNP?: NullableStringFieldUpdateOperationsInput | string | null
    FOR_PRO?: NullableStringFieldUpdateOperationsInput | string | null
    ZZZ?: NullableStringFieldUpdateOperationsInput | string | null
    ZNIEFF2?: NullableStringFieldUpdateOperationsInput | string | null
    ZNIEFF1?: NullableStringFieldUpdateOperationsInput | string | null
    RNR?: NullableStringFieldUpdateOperationsInput | string | null
    TOU_PRO?: NullableStringFieldUpdateOperationsInput | string | null
    NATURA?: NullableStringFieldUpdateOperationsInput | string | null
    ZPS?: NullableStringFieldUpdateOperationsInput | string | null
    SIC?: NullableStringFieldUpdateOperationsInput | string | null
    CELRL?: NullableStringFieldUpdateOperationsInput | string | null
    BIO?: NullableStringFieldUpdateOperationsInput | string | null
    APB?: NullableStringFieldUpdateOperationsInput | string | null
    RN?: NullableStringFieldUpdateOperationsInput | string | null
    RBFD?: NullableStringFieldUpdateOperationsInput | string | null
    RNCFS?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    region?: FloatFieldUpdateOperationsInput | number
  }

  export type surfaces_protegeesUncheckedUpdateManyInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    PNC?: NullableStringFieldUpdateOperationsInput | string | null
    RAMSAR?: NullableStringFieldUpdateOperationsInput | string | null
    PNR?: NullableStringFieldUpdateOperationsInput | string | null
    PNP?: NullableStringFieldUpdateOperationsInput | string | null
    FOR_PRO?: NullableStringFieldUpdateOperationsInput | string | null
    ZZZ?: NullableStringFieldUpdateOperationsInput | string | null
    ZNIEFF2?: NullableStringFieldUpdateOperationsInput | string | null
    ZNIEFF1?: NullableStringFieldUpdateOperationsInput | string | null
    RNR?: NullableStringFieldUpdateOperationsInput | string | null
    TOU_PRO?: NullableStringFieldUpdateOperationsInput | string | null
    NATURA?: NullableStringFieldUpdateOperationsInput | string | null
    ZPS?: NullableStringFieldUpdateOperationsInput | string | null
    SIC?: NullableStringFieldUpdateOperationsInput | string | null
    CELRL?: NullableStringFieldUpdateOperationsInput | string | null
    BIO?: NullableStringFieldUpdateOperationsInput | string | null
    APB?: NullableStringFieldUpdateOperationsInput | string | null
    RN?: NullableStringFieldUpdateOperationsInput | string | null
    RBFD?: NullableStringFieldUpdateOperationsInput | string | null
    RNCFS?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    region?: FloatFieldUpdateOperationsInput | number
  }

  export type table_communeCreateInput = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
    atlas_biodiversite_nom?: string | null
    atlas_biodiversite_annee_debut?: string | null
    atlas_biodiversite_avancement?: string | null
    type_touristique?: string | null
    otex_12_postes?: string | null
    part_irr_sau_2020?: string | null
    agriculture_part_over_55?: string | null
    couverture_lcz?: string | null
  }

  export type table_communeUncheckedCreateInput = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
    atlas_biodiversite_nom?: string | null
    atlas_biodiversite_annee_debut?: string | null
    atlas_biodiversite_avancement?: string | null
    type_touristique?: string | null
    otex_12_postes?: string | null
    part_irr_sau_2020?: string | null
    agriculture_part_over_55?: string | null
    couverture_lcz?: string | null
  }

  export type table_communeUpdateInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: IntFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    atlas_biodiversite_nom?: NullableStringFieldUpdateOperationsInput | string | null
    atlas_biodiversite_annee_debut?: NullableStringFieldUpdateOperationsInput | string | null
    atlas_biodiversite_avancement?: NullableStringFieldUpdateOperationsInput | string | null
    type_touristique?: NullableStringFieldUpdateOperationsInput | string | null
    otex_12_postes?: NullableStringFieldUpdateOperationsInput | string | null
    part_irr_sau_2020?: NullableStringFieldUpdateOperationsInput | string | null
    agriculture_part_over_55?: NullableStringFieldUpdateOperationsInput | string | null
    couverture_lcz?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type table_communeUncheckedUpdateInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: IntFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    atlas_biodiversite_nom?: NullableStringFieldUpdateOperationsInput | string | null
    atlas_biodiversite_annee_debut?: NullableStringFieldUpdateOperationsInput | string | null
    atlas_biodiversite_avancement?: NullableStringFieldUpdateOperationsInput | string | null
    type_touristique?: NullableStringFieldUpdateOperationsInput | string | null
    otex_12_postes?: NullableStringFieldUpdateOperationsInput | string | null
    part_irr_sau_2020?: NullableStringFieldUpdateOperationsInput | string | null
    agriculture_part_over_55?: NullableStringFieldUpdateOperationsInput | string | null
    couverture_lcz?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type table_communeCreateManyInput = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
    atlas_biodiversite_nom?: string | null
    atlas_biodiversite_annee_debut?: string | null
    atlas_biodiversite_avancement?: string | null
    type_touristique?: string | null
    otex_12_postes?: string | null
    part_irr_sau_2020?: string | null
    agriculture_part_over_55?: string | null
    couverture_lcz?: string | null
  }

  export type table_communeUpdateManyMutationInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: IntFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    atlas_biodiversite_nom?: NullableStringFieldUpdateOperationsInput | string | null
    atlas_biodiversite_annee_debut?: NullableStringFieldUpdateOperationsInput | string | null
    atlas_biodiversite_avancement?: NullableStringFieldUpdateOperationsInput | string | null
    type_touristique?: NullableStringFieldUpdateOperationsInput | string | null
    otex_12_postes?: NullableStringFieldUpdateOperationsInput | string | null
    part_irr_sau_2020?: NullableStringFieldUpdateOperationsInput | string | null
    agriculture_part_over_55?: NullableStringFieldUpdateOperationsInput | string | null
    couverture_lcz?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type table_communeUncheckedUpdateManyInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: IntFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    atlas_biodiversite_nom?: NullableStringFieldUpdateOperationsInput | string | null
    atlas_biodiversite_annee_debut?: NullableStringFieldUpdateOperationsInput | string | null
    atlas_biodiversite_avancement?: NullableStringFieldUpdateOperationsInput | string | null
    type_touristique?: NullableStringFieldUpdateOperationsInput | string | null
    otex_12_postes?: NullableStringFieldUpdateOperationsInput | string | null
    part_irr_sau_2020?: NullableStringFieldUpdateOperationsInput | string | null
    agriculture_part_over_55?: NullableStringFieldUpdateOperationsInput | string | null
    couverture_lcz?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type table_territoiresCreateInput = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
  }

  export type table_territoiresUncheckedCreateInput = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
  }

  export type table_territoiresUpdateInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: IntFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type table_territoiresUncheckedUpdateInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: IntFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type table_territoiresCreateManyInput = {
    index: number
    code_geographique: string
    libelle_geographique: string
    epci: string
    libelle_epci: string
    departement: string
    libelle_departement: string
    region: number
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
  }

  export type table_territoiresUpdateManyMutationInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: IntFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type table_territoiresUncheckedUpdateManyInput = {
    index?: IntFieldUpdateOperationsInput | number
    code_geographique?: StringFieldUpdateOperationsInput | string
    libelle_geographique?: StringFieldUpdateOperationsInput | string
    epci?: StringFieldUpdateOperationsInput | string
    libelle_epci?: StringFieldUpdateOperationsInput | string
    departement?: StringFieldUpdateOperationsInput | string
    libelle_departement?: StringFieldUpdateOperationsInput | string
    region?: IntFieldUpdateOperationsInput | number
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type communes_dromCreateInput = {
    code_geographique?: string | null
    libelle_geographique?: string | null
    epci?: string | null
    libelle_epci?: string | null
    departement?: string | null
    libelle_departement?: string | null
    region?: number | null
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
    coordinates?: string | null
    precarite_logement?: number | null
    surface?: number | null
  }

  export type communes_dromUncheckedCreateInput = {
    pk?: number
    code_geographique?: string | null
    libelle_geographique?: string | null
    epci?: string | null
    libelle_epci?: string | null
    departement?: string | null
    libelle_departement?: string | null
    region?: number | null
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
    coordinates?: string | null
    precarite_logement?: number | null
    surface?: number | null
  }

  export type communes_dromUpdateInput = {
    code_geographique?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_geographique?: NullableStringFieldUpdateOperationsInput | string | null
    epci?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_epci?: NullableStringFieldUpdateOperationsInput | string | null
    departement?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_departement?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableIntFieldUpdateOperationsInput | number | null
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    precarite_logement?: NullableFloatFieldUpdateOperationsInput | number | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type communes_dromUncheckedUpdateInput = {
    pk?: IntFieldUpdateOperationsInput | number
    code_geographique?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_geographique?: NullableStringFieldUpdateOperationsInput | string | null
    epci?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_epci?: NullableStringFieldUpdateOperationsInput | string | null
    departement?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_departement?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableIntFieldUpdateOperationsInput | number | null
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    precarite_logement?: NullableFloatFieldUpdateOperationsInput | number | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type communes_dromCreateManyInput = {
    pk?: number
    code_geographique?: string | null
    libelle_geographique?: string | null
    epci?: string | null
    libelle_epci?: string | null
    departement?: string | null
    libelle_departement?: string | null
    region?: number | null
    ept?: string | null
    libelle_petr?: string | null
    code_pnr?: string | null
    libelle_pnr?: string | null
    coordinates?: string | null
    precarite_logement?: number | null
    surface?: number | null
  }

  export type communes_dromUpdateManyMutationInput = {
    code_geographique?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_geographique?: NullableStringFieldUpdateOperationsInput | string | null
    epci?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_epci?: NullableStringFieldUpdateOperationsInput | string | null
    departement?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_departement?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableIntFieldUpdateOperationsInput | number | null
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    precarite_logement?: NullableFloatFieldUpdateOperationsInput | number | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type communes_dromUncheckedUpdateManyInput = {
    pk?: IntFieldUpdateOperationsInput | number
    code_geographique?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_geographique?: NullableStringFieldUpdateOperationsInput | string | null
    epci?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_epci?: NullableStringFieldUpdateOperationsInput | string | null
    departement?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_departement?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableIntFieldUpdateOperationsInput | number | null
    ept?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_petr?: NullableStringFieldUpdateOperationsInput | string | null
    code_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    libelle_pnr?: NullableStringFieldUpdateOperationsInput | string | null
    coordinates?: NullableStringFieldUpdateOperationsInput | string | null
    precarite_logement?: NullableFloatFieldUpdateOperationsInput | number | null
    surface?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type erosion_cotiereUpdateInput = {
    taux?: FloatFieldUpdateOperationsInput | number
    duree?: FloatFieldUpdateOperationsInput | number
    tdc_ancien?: IntFieldUpdateOperationsInput | number
    tdc_rec?: IntFieldUpdateOperationsInput | number
  }

  export type erosion_cotiereUncheckedUpdateInput = {
    pk?: IntFieldUpdateOperationsInput | number
    taux?: FloatFieldUpdateOperationsInput | number
    duree?: FloatFieldUpdateOperationsInput | number
    tdc_ancien?: IntFieldUpdateOperationsInput | number
    tdc_rec?: IntFieldUpdateOperationsInput | number
  }

  export type erosion_cotiereUpdateManyMutationInput = {
    taux?: FloatFieldUpdateOperationsInput | number
    duree?: FloatFieldUpdateOperationsInput | number
    tdc_ancien?: IntFieldUpdateOperationsInput | number
    tdc_rec?: IntFieldUpdateOperationsInput | number
  }

  export type erosion_cotiereUncheckedUpdateManyInput = {
    pk?: IntFieldUpdateOperationsInput | number
    taux?: FloatFieldUpdateOperationsInput | number
    duree?: FloatFieldUpdateOperationsInput | number
    tdc_ancien?: IntFieldUpdateOperationsInput | number
    tdc_rec?: IntFieldUpdateOperationsInput | number
  }

  export type etat_cours_d_eauUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    longueur?: FloatFieldUpdateOperationsInput | number
    etateco?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type etat_cours_d_eauUncheckedUpdateInput = {
    pk?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    longueur?: FloatFieldUpdateOperationsInput | number
    etateco?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type etat_cours_d_eauUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    longueur?: FloatFieldUpdateOperationsInput | number
    etateco?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type etat_cours_d_eauUncheckedUpdateManyInput = {
    pk?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    longueur?: FloatFieldUpdateOperationsInput | number
    etateco?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type spatial_ref_sysCreateInput = {
    srid: number
    auth_name?: string | null
    auth_srid?: number | null
    srtext?: string | null
    proj4text?: string | null
  }

  export type spatial_ref_sysUncheckedCreateInput = {
    srid: number
    auth_name?: string | null
    auth_srid?: number | null
    srtext?: string | null
    proj4text?: string | null
  }

  export type spatial_ref_sysUpdateInput = {
    srid?: IntFieldUpdateOperationsInput | number
    auth_name?: NullableStringFieldUpdateOperationsInput | string | null
    auth_srid?: NullableIntFieldUpdateOperationsInput | number | null
    srtext?: NullableStringFieldUpdateOperationsInput | string | null
    proj4text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type spatial_ref_sysUncheckedUpdateInput = {
    srid?: IntFieldUpdateOperationsInput | number
    auth_name?: NullableStringFieldUpdateOperationsInput | string | null
    auth_srid?: NullableIntFieldUpdateOperationsInput | number | null
    srtext?: NullableStringFieldUpdateOperationsInput | string | null
    proj4text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type spatial_ref_sysCreateManyInput = {
    srid: number
    auth_name?: string | null
    auth_srid?: number | null
    srtext?: string | null
    proj4text?: string | null
  }

  export type spatial_ref_sysUpdateManyMutationInput = {
    srid?: IntFieldUpdateOperationsInput | number
    auth_name?: NullableStringFieldUpdateOperationsInput | string | null
    auth_srid?: NullableIntFieldUpdateOperationsInput | number | null
    srtext?: NullableStringFieldUpdateOperationsInput | string | null
    proj4text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type spatial_ref_sysUncheckedUpdateManyInput = {
    srid?: IntFieldUpdateOperationsInput | number
    auth_name?: NullableStringFieldUpdateOperationsInput | string | null
    auth_srid?: NullableIntFieldUpdateOperationsInput | number | null
    srtext?: NullableStringFieldUpdateOperationsInput | string | null
    proj4text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type north_star_metricCountOrderByAggregateInput = {
    value?: SortOrder
    date?: SortOrder
    pk?: SortOrder
  }

  export type north_star_metricAvgOrderByAggregateInput = {
    pk?: SortOrder
  }

  export type north_star_metricMaxOrderByAggregateInput = {
    value?: SortOrder
    date?: SortOrder
    pk?: SortOrder
  }

  export type north_star_metricMinOrderByAggregateInput = {
    value?: SortOrder
    date?: SortOrder
    pk?: SortOrder
  }

  export type north_star_metricSumOrderByAggregateInput = {
    pk?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type sandbox_usersCountOrderByAggregateInput = {
    username?: SortOrder
    pk?: SortOrder
    password?: SortOrder
    created_at?: SortOrder
  }

  export type sandbox_usersAvgOrderByAggregateInput = {
    pk?: SortOrder
  }

  export type sandbox_usersMaxOrderByAggregateInput = {
    username?: SortOrder
    pk?: SortOrder
    password?: SortOrder
    created_at?: SortOrder
  }

  export type sandbox_usersMinOrderByAggregateInput = {
    username?: SortOrder
    pk?: SortOrder
    password?: SortOrder
    created_at?: SortOrder
  }

  export type sandbox_usersSumOrderByAggregateInput = {
    pk?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type usersCountOrderByAggregateInput = {
    pk?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    created_at?: SortOrder
    last_connection?: SortOrder
    role?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    pk?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    pk?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    created_at?: SortOrder
    last_connection?: SortOrder
    role?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    pk?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    created_at?: SortOrder
    last_connection?: SortOrder
    role?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    pk?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type all_autocapture_rawEvent_timestampDistinct_idSession_idCurrent_urlPerson_idCompoundUniqueInput = {
    event_timestamp: Date | string
    distinct_id: string
    session_id: string
    current_url: string
    person_id: string
  }

  export type all_autocapture_rawCountOrderByAggregateInput = {
    id?: SortOrder
    event_timestamp?: SortOrder
    properties?: SortOrder
    distinct_id?: SortOrder
    session_id?: SortOrder
    current_url?: SortOrder
    person_id?: SortOrder
    ingested_at?: SortOrder
  }

  export type all_autocapture_rawAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type all_autocapture_rawMaxOrderByAggregateInput = {
    id?: SortOrder
    event_timestamp?: SortOrder
    distinct_id?: SortOrder
    session_id?: SortOrder
    current_url?: SortOrder
    person_id?: SortOrder
    ingested_at?: SortOrder
  }

  export type all_autocapture_rawMinOrderByAggregateInput = {
    id?: SortOrder
    event_timestamp?: SortOrder
    distinct_id?: SortOrder
    session_id?: SortOrder
    current_url?: SortOrder
    person_id?: SortOrder
    ingested_at?: SortOrder
  }

  export type all_autocapture_rawSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type all_pageview_rawEvent_timestampDistinct_idSession_idCurrent_urlPerson_idCompoundUniqueInput = {
    event_timestamp: Date | string
    distinct_id: string
    session_id: string
    current_url: string
    person_id: string
  }

  export type all_pageview_rawCountOrderByAggregateInput = {
    id?: SortOrder
    event_timestamp?: SortOrder
    properties?: SortOrder
    distinct_id?: SortOrder
    session_id?: SortOrder
    current_url?: SortOrder
    person_id?: SortOrder
    ingested_at?: SortOrder
  }

  export type all_pageview_rawAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type all_pageview_rawMaxOrderByAggregateInput = {
    id?: SortOrder
    event_timestamp?: SortOrder
    distinct_id?: SortOrder
    session_id?: SortOrder
    current_url?: SortOrder
    person_id?: SortOrder
    ingested_at?: SortOrder
  }

  export type all_pageview_rawMinOrderByAggregateInput = {
    id?: SortOrder
    event_timestamp?: SortOrder
    distinct_id?: SortOrder
    session_id?: SortOrder
    current_url?: SortOrder
    person_id?: SortOrder
    ingested_at?: SortOrder
  }

  export type all_pageview_rawSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type baserow_evenementsCountOrderByAggregateInput = {
    id?: SortOrder
    ordre?: SortOrder
    nom?: SortOrder
    date?: SortOrder
    type?: SortOrder
    qui_anime_evenement?: SortOrder
    compte_rendu?: SortOrder
    nom_participants?: SortOrder
    nom_territoires?: SortOrder
    propos_nom_evenement?: SortOrder
    campagne_test_utilisateur?: SortOrder
    champs_rapporte?: SortOrder
    fichier?: SortOrder
    ingested_at?: SortOrder
  }

  export type baserow_evenementsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type baserow_evenementsMaxOrderByAggregateInput = {
    id?: SortOrder
    ordre?: SortOrder
    nom?: SortOrder
    date?: SortOrder
    compte_rendu?: SortOrder
    ingested_at?: SortOrder
  }

  export type baserow_evenementsMinOrderByAggregateInput = {
    id?: SortOrder
    ordre?: SortOrder
    nom?: SortOrder
    date?: SortOrder
    compte_rendu?: SortOrder
    ingested_at?: SortOrder
  }

  export type baserow_evenementsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type baserow_territoiresCountOrderByAggregateInput = {
    id?: SortOrder
    ordre?: SortOrder
    nom_territoire?: SortOrder
    notes_ouvertes?: SortOrder
    typologie_territoire?: SortOrder
    thematique_prioritaire?: SortOrder
    be?: SortOrder
    soumis_a_pcaet?: SortOrder
    demarches_et_programmes?: SortOrder
    documents_de_planification?: SortOrder
    avancee_sur_le_ddv?: SortOrder
    avancee_sur_la_strategie?: SortOrder
    suivi_evaluation?: SortOrder
    date_validation?: SortOrder
    date_revision_estimee?: SortOrder
    propos?: SortOrder
    attente_session_accueil?: SortOrder
    role_be?: SortOrder
    cdm?: SortOrder
    siren?: SortOrder
    ingested_at?: SortOrder
  }

  export type baserow_territoiresAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type baserow_territoiresMaxOrderByAggregateInput = {
    id?: SortOrder
    ordre?: SortOrder
    nom_territoire?: SortOrder
    notes_ouvertes?: SortOrder
    be?: SortOrder
    soumis_a_pcaet?: SortOrder
    suivi_evaluation?: SortOrder
    date_validation?: SortOrder
    date_revision_estimee?: SortOrder
    siren?: SortOrder
    ingested_at?: SortOrder
  }

  export type baserow_territoiresMinOrderByAggregateInput = {
    id?: SortOrder
    ordre?: SortOrder
    nom_territoire?: SortOrder
    notes_ouvertes?: SortOrder
    be?: SortOrder
    soumis_a_pcaet?: SortOrder
    suivi_evaluation?: SortOrder
    date_validation?: SortOrder
    date_revision_estimee?: SortOrder
    siren?: SortOrder
    ingested_at?: SortOrder
  }

  export type baserow_territoiresSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type boutons_export_rawEventEvent_timestampSession_idPerson_idCode_geographiqueLibelle_geographiqueThematiqueCompoundUniqueInput = {
    event: string
    event_timestamp: Date | string
    session_id: string
    person_id: string
    code_geographique: string
    libelle_geographique: string
    thematique: string
  }

  export type boutons_export_rawCountOrderByAggregateInput = {
    id?: SortOrder
    event?: SortOrder
    event_timestamp?: SortOrder
    session_id?: SortOrder
    person_id?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    thematique?: SortOrder
    ingested_at?: SortOrder
  }

  export type boutons_export_rawAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type boutons_export_rawMaxOrderByAggregateInput = {
    id?: SortOrder
    event?: SortOrder
    event_timestamp?: SortOrder
    session_id?: SortOrder
    person_id?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    thematique?: SortOrder
    ingested_at?: SortOrder
  }

  export type boutons_export_rawMinOrderByAggregateInput = {
    id?: SortOrder
    event?: SortOrder
    event_timestamp?: SortOrder
    session_id?: SortOrder
    person_id?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    thematique?: SortOrder
    ingested_at?: SortOrder
  }

  export type boutons_export_rawSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type boutons_homepageEvent_timestampDistinct_idSession_idPerson_idCompoundUniqueInput = {
    event_timestamp: Date | string
    distinct_id: string
    session_id: string
    person_id: string
  }

  export type boutons_homepageCountOrderByAggregateInput = {
    id?: SortOrder
    event?: SortOrder
    event_timestamp?: SortOrder
    properties?: SortOrder
    distinct_id?: SortOrder
    session_id?: SortOrder
    person_id?: SortOrder
    ingested_at?: SortOrder
  }

  export type boutons_homepageAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type boutons_homepageMaxOrderByAggregateInput = {
    id?: SortOrder
    event?: SortOrder
    event_timestamp?: SortOrder
    distinct_id?: SortOrder
    session_id?: SortOrder
    person_id?: SortOrder
    ingested_at?: SortOrder
  }

  export type boutons_homepageMinOrderByAggregateInput = {
    id?: SortOrder
    event?: SortOrder
    event_timestamp?: SortOrder
    distinct_id?: SortOrder
    session_id?: SortOrder
    person_id?: SortOrder
    ingested_at?: SortOrder
  }

  export type boutons_homepageSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type couverture_populationCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    population?: SortOrder
  }

  export type couverture_populationAvgOrderByAggregateInput = {
    id?: SortOrder
    population?: SortOrder
  }

  export type couverture_populationMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    population?: SortOrder
  }

  export type couverture_populationMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    population?: SortOrder
  }

  export type couverture_populationSumOrderByAggregateInput = {
    id?: SortOrder
    population?: SortOrder
  }

  export type ressources_consulteesEvent_timestampDistinct_idSession_idPerson_idCompoundUniqueInput = {
    event_timestamp: Date | string
    distinct_id: string
    session_id: string
    person_id: string
  }

  export type ressources_consulteesCountOrderByAggregateInput = {
    id?: SortOrder
    event_timestamp?: SortOrder
    distinct_id?: SortOrder
    session_id?: SortOrder
    person_id?: SortOrder
    ressource?: SortOrder
    ingested_at?: SortOrder
  }

  export type ressources_consulteesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ressources_consulteesMaxOrderByAggregateInput = {
    id?: SortOrder
    event_timestamp?: SortOrder
    distinct_id?: SortOrder
    session_id?: SortOrder
    person_id?: SortOrder
    ressource?: SortOrder
    ingested_at?: SortOrder
  }

  export type ressources_consulteesMinOrderByAggregateInput = {
    id?: SortOrder
    event_timestamp?: SortOrder
    distinct_id?: SortOrder
    session_id?: SortOrder
    person_id?: SortOrder
    ressource?: SortOrder
    ingested_at?: SortOrder
  }

  export type ressources_consulteesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type thematiqueEvent_timestampDistinct_idSession_idPerson_idCompoundUniqueInput = {
    event_timestamp: Date | string
    distinct_id: string
    session_id: string
    person_id: string
  }

  export type thematiqueCountOrderByAggregateInput = {
    id?: SortOrder
    event_timestamp?: SortOrder
    properties?: SortOrder
    distinct_id?: SortOrder
    session_id?: SortOrder
    person_id?: SortOrder
    thematique?: SortOrder
    ingested_at?: SortOrder
  }

  export type thematiqueAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type thematiqueMaxOrderByAggregateInput = {
    id?: SortOrder
    event_timestamp?: SortOrder
    distinct_id?: SortOrder
    session_id?: SortOrder
    person_id?: SortOrder
    thematique?: SortOrder
    ingested_at?: SortOrder
  }

  export type thematiqueMinOrderByAggregateInput = {
    id?: SortOrder
    event_timestamp?: SortOrder
    distinct_id?: SortOrder
    session_id?: SortOrder
    person_id?: SortOrder
    thematique?: SortOrder
    ingested_at?: SortOrder
  }

  export type thematiqueSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type agricultureCountOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
    part_irr_SAU_2020?: SortOrder
    otex_12_postes?: SortOrder
  }

  export type agricultureAvgOrderByAggregateInput = {
    index?: SortOrder
    region?: SortOrder
    part_irr_SAU_2020?: SortOrder
  }

  export type agricultureMaxOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
    part_irr_SAU_2020?: SortOrder
    otex_12_postes?: SortOrder
  }

  export type agricultureMinOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
    part_irr_SAU_2020?: SortOrder
    otex_12_postes?: SortOrder
  }

  export type agricultureSumOrderByAggregateInput = {
    index?: SortOrder
    region?: SortOrder
    part_irr_SAU_2020?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type agriculture_bioCountOrderByAggregateInput = {
    index?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    VARIABLE?: SortOrder
    LIBELLE_SOUS_CHAMP?: SortOrder
    surface_2023?: SortOrder
    surface_2022?: SortOrder
    surface_2021?: SortOrder
    surface_2020?: SortOrder
    surface_2019?: SortOrder
    surface_2018?: SortOrder
    surface_2017?: SortOrder
    surface_2016?: SortOrder
    surface_2015?: SortOrder
    surface_2014?: SortOrder
    surface_2013?: SortOrder
    surface_2012?: SortOrder
    surface_2011?: SortOrder
    surface_2010?: SortOrder
    surface_2009?: SortOrder
    surface_2008?: SortOrder
    nombre_2023?: SortOrder
    nombre_2022?: SortOrder
    nombre_2021?: SortOrder
    nombre_2020?: SortOrder
    nombre_2019?: SortOrder
    nombre_2018?: SortOrder
    nombre_2017?: SortOrder
    nombre_2016?: SortOrder
    nombre_2015?: SortOrder
    nombre_2014?: SortOrder
    nombre_2013?: SortOrder
    nombre_2012?: SortOrder
    nombre_2011?: SortOrder
    nombre_2010?: SortOrder
    nombre_2009?: SortOrder
    nombre_2008?: SortOrder
  }

  export type agriculture_bioAvgOrderByAggregateInput = {
    index?: SortOrder
    surface_2023?: SortOrder
    surface_2022?: SortOrder
    surface_2021?: SortOrder
    surface_2020?: SortOrder
    surface_2019?: SortOrder
    surface_2018?: SortOrder
    surface_2017?: SortOrder
    surface_2016?: SortOrder
    surface_2015?: SortOrder
    surface_2014?: SortOrder
    surface_2013?: SortOrder
    surface_2012?: SortOrder
    surface_2011?: SortOrder
    surface_2010?: SortOrder
    surface_2009?: SortOrder
    surface_2008?: SortOrder
    nombre_2023?: SortOrder
    nombre_2022?: SortOrder
    nombre_2021?: SortOrder
    nombre_2020?: SortOrder
    nombre_2019?: SortOrder
    nombre_2018?: SortOrder
    nombre_2017?: SortOrder
    nombre_2016?: SortOrder
    nombre_2015?: SortOrder
    nombre_2014?: SortOrder
    nombre_2013?: SortOrder
    nombre_2012?: SortOrder
    nombre_2011?: SortOrder
    nombre_2010?: SortOrder
    nombre_2009?: SortOrder
    nombre_2008?: SortOrder
  }

  export type agriculture_bioMaxOrderByAggregateInput = {
    index?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    VARIABLE?: SortOrder
    LIBELLE_SOUS_CHAMP?: SortOrder
    surface_2023?: SortOrder
    surface_2022?: SortOrder
    surface_2021?: SortOrder
    surface_2020?: SortOrder
    surface_2019?: SortOrder
    surface_2018?: SortOrder
    surface_2017?: SortOrder
    surface_2016?: SortOrder
    surface_2015?: SortOrder
    surface_2014?: SortOrder
    surface_2013?: SortOrder
    surface_2012?: SortOrder
    surface_2011?: SortOrder
    surface_2010?: SortOrder
    surface_2009?: SortOrder
    surface_2008?: SortOrder
    nombre_2023?: SortOrder
    nombre_2022?: SortOrder
    nombre_2021?: SortOrder
    nombre_2020?: SortOrder
    nombre_2019?: SortOrder
    nombre_2018?: SortOrder
    nombre_2017?: SortOrder
    nombre_2016?: SortOrder
    nombre_2015?: SortOrder
    nombre_2014?: SortOrder
    nombre_2013?: SortOrder
    nombre_2012?: SortOrder
    nombre_2011?: SortOrder
    nombre_2010?: SortOrder
    nombre_2009?: SortOrder
    nombre_2008?: SortOrder
  }

  export type agriculture_bioMinOrderByAggregateInput = {
    index?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    VARIABLE?: SortOrder
    LIBELLE_SOUS_CHAMP?: SortOrder
    surface_2023?: SortOrder
    surface_2022?: SortOrder
    surface_2021?: SortOrder
    surface_2020?: SortOrder
    surface_2019?: SortOrder
    surface_2018?: SortOrder
    surface_2017?: SortOrder
    surface_2016?: SortOrder
    surface_2015?: SortOrder
    surface_2014?: SortOrder
    surface_2013?: SortOrder
    surface_2012?: SortOrder
    surface_2011?: SortOrder
    surface_2010?: SortOrder
    surface_2009?: SortOrder
    surface_2008?: SortOrder
    nombre_2023?: SortOrder
    nombre_2022?: SortOrder
    nombre_2021?: SortOrder
    nombre_2020?: SortOrder
    nombre_2019?: SortOrder
    nombre_2018?: SortOrder
    nombre_2017?: SortOrder
    nombre_2016?: SortOrder
    nombre_2015?: SortOrder
    nombre_2014?: SortOrder
    nombre_2013?: SortOrder
    nombre_2012?: SortOrder
    nombre_2011?: SortOrder
    nombre_2010?: SortOrder
    nombre_2009?: SortOrder
    nombre_2008?: SortOrder
  }

  export type agriculture_bioSumOrderByAggregateInput = {
    index?: SortOrder
    surface_2023?: SortOrder
    surface_2022?: SortOrder
    surface_2021?: SortOrder
    surface_2020?: SortOrder
    surface_2019?: SortOrder
    surface_2018?: SortOrder
    surface_2017?: SortOrder
    surface_2016?: SortOrder
    surface_2015?: SortOrder
    surface_2014?: SortOrder
    surface_2013?: SortOrder
    surface_2012?: SortOrder
    surface_2011?: SortOrder
    surface_2010?: SortOrder
    surface_2009?: SortOrder
    surface_2008?: SortOrder
    nombre_2023?: SortOrder
    nombre_2022?: SortOrder
    nombre_2021?: SortOrder
    nombre_2020?: SortOrder
    nombre_2019?: SortOrder
    nombre_2018?: SortOrder
    nombre_2017?: SortOrder
    nombre_2016?: SortOrder
    nombre_2015?: SortOrder
    nombre_2014?: SortOrder
    nombre_2013?: SortOrder
    nombre_2012?: SortOrder
    nombre_2011?: SortOrder
    nombre_2010?: SortOrder
    nombre_2009?: SortOrder
    nombre_2008?: SortOrder
  }

  export type aot_40CountOrderByAggregateInput = {
    index?: SortOrder
    nom_site?: SortOrder
    type_d_implantation?: SortOrder
    valeur_brute?: SortOrder
    Latitude?: SortOrder
    Longitude?: SortOrder
  }

  export type aot_40AvgOrderByAggregateInput = {
    index?: SortOrder
    valeur_brute?: SortOrder
    Latitude?: SortOrder
    Longitude?: SortOrder
  }

  export type aot_40MaxOrderByAggregateInput = {
    index?: SortOrder
    nom_site?: SortOrder
    type_d_implantation?: SortOrder
    valeur_brute?: SortOrder
    Latitude?: SortOrder
    Longitude?: SortOrder
  }

  export type aot_40MinOrderByAggregateInput = {
    index?: SortOrder
    nom_site?: SortOrder
    type_d_implantation?: SortOrder
    valeur_brute?: SortOrder
    Latitude?: SortOrder
    Longitude?: SortOrder
  }

  export type aot_40SumOrderByAggregateInput = {
    index?: SortOrder
    valeur_brute?: SortOrder
    Latitude?: SortOrder
    Longitude?: SortOrder
  }

  export type arretes_catnatCountOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
    lib_risque_jo?: SortOrder
    dat_deb?: SortOrder
    dat_fin?: SortOrder
    dat_pub_arrete?: SortOrder
  }

  export type arretes_catnatAvgOrderByAggregateInput = {
    index?: SortOrder
    region?: SortOrder
  }

  export type arretes_catnatMaxOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
    lib_risque_jo?: SortOrder
    dat_deb?: SortOrder
    dat_fin?: SortOrder
    dat_pub_arrete?: SortOrder
  }

  export type arretes_catnatMinOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
    lib_risque_jo?: SortOrder
    dat_deb?: SortOrder
    dat_fin?: SortOrder
    dat_pub_arrete?: SortOrder
  }

  export type arretes_catnatSumOrderByAggregateInput = {
    index?: SortOrder
    region?: SortOrder
  }

  export type atlas_biodiversiteCountOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
    nom?: SortOrder
    structure_porteuse?: SortOrder
    type_de_structure_porteuse?: SortOrder
    annee_debut?: SortOrder
    avancement?: SortOrder
  }

  export type atlas_biodiversiteAvgOrderByAggregateInput = {
    index?: SortOrder
    region?: SortOrder
    annee_debut?: SortOrder
  }

  export type atlas_biodiversiteMaxOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
    nom?: SortOrder
    structure_porteuse?: SortOrder
    type_de_structure_porteuse?: SortOrder
    annee_debut?: SortOrder
    avancement?: SortOrder
  }

  export type atlas_biodiversiteMinOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
    nom?: SortOrder
    structure_porteuse?: SortOrder
    type_de_structure_porteuse?: SortOrder
    annee_debut?: SortOrder
    avancement?: SortOrder
  }

  export type atlas_biodiversiteSumOrderByAggregateInput = {
    index?: SortOrder
    region?: SortOrder
    annee_debut?: SortOrder
  }

  export type collectivites_searchbarCountOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
    search_code?: SortOrder
    search_libelle?: SortOrder
  }

  export type collectivites_searchbarAvgOrderByAggregateInput = {
    index?: SortOrder
  }

  export type collectivites_searchbarMaxOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
    search_code?: SortOrder
    search_libelle?: SortOrder
  }

  export type collectivites_searchbarMinOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
    search_code?: SortOrder
    search_libelle?: SortOrder
  }

  export type collectivites_searchbarSumOrderByAggregateInput = {
    index?: SortOrder
  }

  export type confort_thermiqueCountOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
    age_bati_post06?: SortOrder
    age_bati_91_05?: SortOrder
    age_bati_46_90?: SortOrder
    age_bati_19_45?: SortOrder
    age_bati_pre_19?: SortOrder
    under_4_sum_1968?: SortOrder
    to_75_sum_1968?: SortOrder
    over_75_sum_1968?: SortOrder
    under_4_sum_1975?: SortOrder
    to_75_sum_1975?: SortOrder
    over_75_sum_1975?: SortOrder
    under_4_sum_1982?: SortOrder
    to_75_sum_1982?: SortOrder
    over_75_sum_1982?: SortOrder
    under_4_sum_1990?: SortOrder
    to_75_sum_1990?: SortOrder
    over_75_sum_1990?: SortOrder
    under_4_sum_1999?: SortOrder
    to_75_sum_1999?: SortOrder
    over_75_sum_1999?: SortOrder
    under_4_sum_2009?: SortOrder
    to_75_sum_2009?: SortOrder
    over_75_sum_2009?: SortOrder
    under_4_sum_2014?: SortOrder
    to_75_sum_2014?: SortOrder
    over_75_sum_2014?: SortOrder
    under_4_sum_2020?: SortOrder
    to_75_sum_2020?: SortOrder
    over_75_sum_2020?: SortOrder
    tee_log?: SortOrder
    tee_mob?: SortOrder
    precarite_logement?: SortOrder
    NA5AZ_sum?: SortOrder
    NA5BE_sum?: SortOrder
    NA5FZ_sum?: SortOrder
    NA5GU_sum?: SortOrder
    NA5OQ_sum?: SortOrder
    clc_1_artificialise?: SortOrder
    clc_2_agricole?: SortOrder
    clc_3_foret_semiNaturel?: SortOrder
    clc_4_humide?: SortOrder
    clc_5_eau?: SortOrder
    superf_choro?: SortOrder
  }

  export type confort_thermiqueAvgOrderByAggregateInput = {
    index?: SortOrder
    region?: SortOrder
    age_bati_post06?: SortOrder
    age_bati_91_05?: SortOrder
    age_bati_46_90?: SortOrder
    age_bati_19_45?: SortOrder
    age_bati_pre_19?: SortOrder
    under_4_sum_1968?: SortOrder
    to_75_sum_1968?: SortOrder
    over_75_sum_1968?: SortOrder
    under_4_sum_1975?: SortOrder
    to_75_sum_1975?: SortOrder
    over_75_sum_1975?: SortOrder
    under_4_sum_1982?: SortOrder
    to_75_sum_1982?: SortOrder
    over_75_sum_1982?: SortOrder
    under_4_sum_1990?: SortOrder
    to_75_sum_1990?: SortOrder
    over_75_sum_1990?: SortOrder
    under_4_sum_1999?: SortOrder
    to_75_sum_1999?: SortOrder
    over_75_sum_1999?: SortOrder
    under_4_sum_2009?: SortOrder
    to_75_sum_2009?: SortOrder
    over_75_sum_2009?: SortOrder
    under_4_sum_2014?: SortOrder
    to_75_sum_2014?: SortOrder
    over_75_sum_2014?: SortOrder
    under_4_sum_2020?: SortOrder
    to_75_sum_2020?: SortOrder
    over_75_sum_2020?: SortOrder
    tee_log?: SortOrder
    tee_mob?: SortOrder
    precarite_logement?: SortOrder
    NA5AZ_sum?: SortOrder
    NA5BE_sum?: SortOrder
    NA5FZ_sum?: SortOrder
    NA5GU_sum?: SortOrder
    NA5OQ_sum?: SortOrder
    clc_1_artificialise?: SortOrder
    clc_2_agricole?: SortOrder
    clc_3_foret_semiNaturel?: SortOrder
    clc_4_humide?: SortOrder
    clc_5_eau?: SortOrder
    superf_choro?: SortOrder
  }

  export type confort_thermiqueMaxOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
    age_bati_post06?: SortOrder
    age_bati_91_05?: SortOrder
    age_bati_46_90?: SortOrder
    age_bati_19_45?: SortOrder
    age_bati_pre_19?: SortOrder
    under_4_sum_1968?: SortOrder
    to_75_sum_1968?: SortOrder
    over_75_sum_1968?: SortOrder
    under_4_sum_1975?: SortOrder
    to_75_sum_1975?: SortOrder
    over_75_sum_1975?: SortOrder
    under_4_sum_1982?: SortOrder
    to_75_sum_1982?: SortOrder
    over_75_sum_1982?: SortOrder
    under_4_sum_1990?: SortOrder
    to_75_sum_1990?: SortOrder
    over_75_sum_1990?: SortOrder
    under_4_sum_1999?: SortOrder
    to_75_sum_1999?: SortOrder
    over_75_sum_1999?: SortOrder
    under_4_sum_2009?: SortOrder
    to_75_sum_2009?: SortOrder
    over_75_sum_2009?: SortOrder
    under_4_sum_2014?: SortOrder
    to_75_sum_2014?: SortOrder
    over_75_sum_2014?: SortOrder
    under_4_sum_2020?: SortOrder
    to_75_sum_2020?: SortOrder
    over_75_sum_2020?: SortOrder
    tee_log?: SortOrder
    tee_mob?: SortOrder
    precarite_logement?: SortOrder
    NA5AZ_sum?: SortOrder
    NA5BE_sum?: SortOrder
    NA5FZ_sum?: SortOrder
    NA5GU_sum?: SortOrder
    NA5OQ_sum?: SortOrder
    clc_1_artificialise?: SortOrder
    clc_2_agricole?: SortOrder
    clc_3_foret_semiNaturel?: SortOrder
    clc_4_humide?: SortOrder
    clc_5_eau?: SortOrder
    superf_choro?: SortOrder
  }

  export type confort_thermiqueMinOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
    age_bati_post06?: SortOrder
    age_bati_91_05?: SortOrder
    age_bati_46_90?: SortOrder
    age_bati_19_45?: SortOrder
    age_bati_pre_19?: SortOrder
    under_4_sum_1968?: SortOrder
    to_75_sum_1968?: SortOrder
    over_75_sum_1968?: SortOrder
    under_4_sum_1975?: SortOrder
    to_75_sum_1975?: SortOrder
    over_75_sum_1975?: SortOrder
    under_4_sum_1982?: SortOrder
    to_75_sum_1982?: SortOrder
    over_75_sum_1982?: SortOrder
    under_4_sum_1990?: SortOrder
    to_75_sum_1990?: SortOrder
    over_75_sum_1990?: SortOrder
    under_4_sum_1999?: SortOrder
    to_75_sum_1999?: SortOrder
    over_75_sum_1999?: SortOrder
    under_4_sum_2009?: SortOrder
    to_75_sum_2009?: SortOrder
    over_75_sum_2009?: SortOrder
    under_4_sum_2014?: SortOrder
    to_75_sum_2014?: SortOrder
    over_75_sum_2014?: SortOrder
    under_4_sum_2020?: SortOrder
    to_75_sum_2020?: SortOrder
    over_75_sum_2020?: SortOrder
    tee_log?: SortOrder
    tee_mob?: SortOrder
    precarite_logement?: SortOrder
    NA5AZ_sum?: SortOrder
    NA5BE_sum?: SortOrder
    NA5FZ_sum?: SortOrder
    NA5GU_sum?: SortOrder
    NA5OQ_sum?: SortOrder
    clc_1_artificialise?: SortOrder
    clc_2_agricole?: SortOrder
    clc_3_foret_semiNaturel?: SortOrder
    clc_4_humide?: SortOrder
    clc_5_eau?: SortOrder
    superf_choro?: SortOrder
  }

  export type confort_thermiqueSumOrderByAggregateInput = {
    index?: SortOrder
    region?: SortOrder
    age_bati_post06?: SortOrder
    age_bati_91_05?: SortOrder
    age_bati_46_90?: SortOrder
    age_bati_19_45?: SortOrder
    age_bati_pre_19?: SortOrder
    under_4_sum_1968?: SortOrder
    to_75_sum_1968?: SortOrder
    over_75_sum_1968?: SortOrder
    under_4_sum_1975?: SortOrder
    to_75_sum_1975?: SortOrder
    over_75_sum_1975?: SortOrder
    under_4_sum_1982?: SortOrder
    to_75_sum_1982?: SortOrder
    over_75_sum_1982?: SortOrder
    under_4_sum_1990?: SortOrder
    to_75_sum_1990?: SortOrder
    over_75_sum_1990?: SortOrder
    under_4_sum_1999?: SortOrder
    to_75_sum_1999?: SortOrder
    over_75_sum_1999?: SortOrder
    under_4_sum_2009?: SortOrder
    to_75_sum_2009?: SortOrder
    over_75_sum_2009?: SortOrder
    under_4_sum_2014?: SortOrder
    to_75_sum_2014?: SortOrder
    over_75_sum_2014?: SortOrder
    under_4_sum_2020?: SortOrder
    to_75_sum_2020?: SortOrder
    over_75_sum_2020?: SortOrder
    tee_log?: SortOrder
    tee_mob?: SortOrder
    precarite_logement?: SortOrder
    NA5AZ_sum?: SortOrder
    NA5BE_sum?: SortOrder
    NA5FZ_sum?: SortOrder
    NA5GU_sum?: SortOrder
    NA5OQ_sum?: SortOrder
    clc_1_artificialise?: SortOrder
    clc_2_agricole?: SortOrder
    clc_3_foret_semiNaturel?: SortOrder
    clc_4_humide?: SortOrder
    clc_5_eau?: SortOrder
    superf_choro?: SortOrder
  }

  export type consommation_espaces_nafCountOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
    naf09art10?: SortOrder
    art09act10?: SortOrder
    art09hab10?: SortOrder
    art09mix10?: SortOrder
    art09rou10?: SortOrder
    art09fer10?: SortOrder
    art09inc10?: SortOrder
    naf10art11?: SortOrder
    art10act11?: SortOrder
    art10hab11?: SortOrder
    art10mix11?: SortOrder
    art10rou11?: SortOrder
    art10fer11?: SortOrder
    art10inc11?: SortOrder
    naf11art12?: SortOrder
    art11act12?: SortOrder
    art11hab12?: SortOrder
    art11mix12?: SortOrder
    art11rou12?: SortOrder
    art11fer12?: SortOrder
    art11inc12?: SortOrder
    naf12art13?: SortOrder
    art12act13?: SortOrder
    art12hab13?: SortOrder
    art12mix13?: SortOrder
    art12rou13?: SortOrder
    art12fer13?: SortOrder
    art12inc13?: SortOrder
    naf13art14?: SortOrder
    art13act14?: SortOrder
    art13hab14?: SortOrder
    art13mix14?: SortOrder
    art13rou14?: SortOrder
    art13fer14?: SortOrder
    art13inc14?: SortOrder
    naf14art15?: SortOrder
    art14act15?: SortOrder
    art14hab15?: SortOrder
    art14mix15?: SortOrder
    art14rou15?: SortOrder
    art14fer15?: SortOrder
    art14inc15?: SortOrder
    naf15art16?: SortOrder
    art15act16?: SortOrder
    art15hab16?: SortOrder
    art15mix16?: SortOrder
    art15rou16?: SortOrder
    art15fer16?: SortOrder
    art15inc16?: SortOrder
    naf16art17?: SortOrder
    art16act17?: SortOrder
    art16hab17?: SortOrder
    art16mix17?: SortOrder
    art16rou17?: SortOrder
    art16fer17?: SortOrder
    art16inc17?: SortOrder
    naf17art18?: SortOrder
    art17act18?: SortOrder
    art17hab18?: SortOrder
    art17mix18?: SortOrder
    art17rou18?: SortOrder
    art17fer18?: SortOrder
    art17inc18?: SortOrder
    naf18art19?: SortOrder
    art18act19?: SortOrder
    art18hab19?: SortOrder
    art18mix19?: SortOrder
    art18rou19?: SortOrder
    art18fer19?: SortOrder
    art18inc19?: SortOrder
    naf19art20?: SortOrder
    art19act20?: SortOrder
    art19hab20?: SortOrder
    art19mix20?: SortOrder
    art19rou20?: SortOrder
    art19fer20?: SortOrder
    art19inc20?: SortOrder
    naf20art21?: SortOrder
    art20act21?: SortOrder
    art20hab21?: SortOrder
    art20mix21?: SortOrder
    art20rou21?: SortOrder
    art20fer21?: SortOrder
    art20inc21?: SortOrder
    naf21art22?: SortOrder
    art21act22?: SortOrder
    art21hab22?: SortOrder
    art21mix22?: SortOrder
    art21rou22?: SortOrder
    art21fer22?: SortOrder
    art21inc22?: SortOrder
    naf22art23?: SortOrder
    art22act23?: SortOrder
    art22hab23?: SortOrder
    art22mix23?: SortOrder
    art22rou23?: SortOrder
    art22fer23?: SortOrder
    art22inc23?: SortOrder
    naf09art23?: SortOrder
    art09act23?: SortOrder
    art09hab23?: SortOrder
    art09mix23?: SortOrder
    art09inc23?: SortOrder
    art09rou23?: SortOrder
    art09fer23?: SortOrder
    artcom0923?: SortOrder
  }

  export type consommation_espaces_nafAvgOrderByAggregateInput = {
    index?: SortOrder
    region?: SortOrder
    naf09art10?: SortOrder
    art09act10?: SortOrder
    art09hab10?: SortOrder
    art09mix10?: SortOrder
    art09rou10?: SortOrder
    art09fer10?: SortOrder
    art09inc10?: SortOrder
    naf10art11?: SortOrder
    art10act11?: SortOrder
    art10hab11?: SortOrder
    art10mix11?: SortOrder
    art10rou11?: SortOrder
    art10fer11?: SortOrder
    art10inc11?: SortOrder
    naf11art12?: SortOrder
    art11act12?: SortOrder
    art11hab12?: SortOrder
    art11mix12?: SortOrder
    art11rou12?: SortOrder
    art11fer12?: SortOrder
    art11inc12?: SortOrder
    naf12art13?: SortOrder
    art12act13?: SortOrder
    art12hab13?: SortOrder
    art12mix13?: SortOrder
    art12rou13?: SortOrder
    art12fer13?: SortOrder
    art12inc13?: SortOrder
    naf13art14?: SortOrder
    art13act14?: SortOrder
    art13hab14?: SortOrder
    art13mix14?: SortOrder
    art13rou14?: SortOrder
    art13fer14?: SortOrder
    art13inc14?: SortOrder
    naf14art15?: SortOrder
    art14act15?: SortOrder
    art14hab15?: SortOrder
    art14mix15?: SortOrder
    art14rou15?: SortOrder
    art14fer15?: SortOrder
    art14inc15?: SortOrder
    naf15art16?: SortOrder
    art15act16?: SortOrder
    art15hab16?: SortOrder
    art15mix16?: SortOrder
    art15rou16?: SortOrder
    art15fer16?: SortOrder
    art15inc16?: SortOrder
    naf16art17?: SortOrder
    art16act17?: SortOrder
    art16hab17?: SortOrder
    art16mix17?: SortOrder
    art16rou17?: SortOrder
    art16fer17?: SortOrder
    art16inc17?: SortOrder
    naf17art18?: SortOrder
    art17act18?: SortOrder
    art17hab18?: SortOrder
    art17mix18?: SortOrder
    art17rou18?: SortOrder
    art17fer18?: SortOrder
    art17inc18?: SortOrder
    naf18art19?: SortOrder
    art18act19?: SortOrder
    art18hab19?: SortOrder
    art18mix19?: SortOrder
    art18rou19?: SortOrder
    art18fer19?: SortOrder
    art18inc19?: SortOrder
    naf19art20?: SortOrder
    art19act20?: SortOrder
    art19hab20?: SortOrder
    art19mix20?: SortOrder
    art19rou20?: SortOrder
    art19fer20?: SortOrder
    art19inc20?: SortOrder
    naf20art21?: SortOrder
    art20act21?: SortOrder
    art20hab21?: SortOrder
    art20mix21?: SortOrder
    art20rou21?: SortOrder
    art20fer21?: SortOrder
    art20inc21?: SortOrder
    naf21art22?: SortOrder
    art21act22?: SortOrder
    art21hab22?: SortOrder
    art21mix22?: SortOrder
    art21rou22?: SortOrder
    art21fer22?: SortOrder
    art21inc22?: SortOrder
    naf22art23?: SortOrder
    art22act23?: SortOrder
    art22hab23?: SortOrder
    art22mix23?: SortOrder
    art22rou23?: SortOrder
    art22fer23?: SortOrder
    art22inc23?: SortOrder
    naf09art23?: SortOrder
    art09act23?: SortOrder
    art09hab23?: SortOrder
    art09mix23?: SortOrder
    art09inc23?: SortOrder
    art09rou23?: SortOrder
    art09fer23?: SortOrder
    artcom0923?: SortOrder
  }

  export type consommation_espaces_nafMaxOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
    naf09art10?: SortOrder
    art09act10?: SortOrder
    art09hab10?: SortOrder
    art09mix10?: SortOrder
    art09rou10?: SortOrder
    art09fer10?: SortOrder
    art09inc10?: SortOrder
    naf10art11?: SortOrder
    art10act11?: SortOrder
    art10hab11?: SortOrder
    art10mix11?: SortOrder
    art10rou11?: SortOrder
    art10fer11?: SortOrder
    art10inc11?: SortOrder
    naf11art12?: SortOrder
    art11act12?: SortOrder
    art11hab12?: SortOrder
    art11mix12?: SortOrder
    art11rou12?: SortOrder
    art11fer12?: SortOrder
    art11inc12?: SortOrder
    naf12art13?: SortOrder
    art12act13?: SortOrder
    art12hab13?: SortOrder
    art12mix13?: SortOrder
    art12rou13?: SortOrder
    art12fer13?: SortOrder
    art12inc13?: SortOrder
    naf13art14?: SortOrder
    art13act14?: SortOrder
    art13hab14?: SortOrder
    art13mix14?: SortOrder
    art13rou14?: SortOrder
    art13fer14?: SortOrder
    art13inc14?: SortOrder
    naf14art15?: SortOrder
    art14act15?: SortOrder
    art14hab15?: SortOrder
    art14mix15?: SortOrder
    art14rou15?: SortOrder
    art14fer15?: SortOrder
    art14inc15?: SortOrder
    naf15art16?: SortOrder
    art15act16?: SortOrder
    art15hab16?: SortOrder
    art15mix16?: SortOrder
    art15rou16?: SortOrder
    art15fer16?: SortOrder
    art15inc16?: SortOrder
    naf16art17?: SortOrder
    art16act17?: SortOrder
    art16hab17?: SortOrder
    art16mix17?: SortOrder
    art16rou17?: SortOrder
    art16fer17?: SortOrder
    art16inc17?: SortOrder
    naf17art18?: SortOrder
    art17act18?: SortOrder
    art17hab18?: SortOrder
    art17mix18?: SortOrder
    art17rou18?: SortOrder
    art17fer18?: SortOrder
    art17inc18?: SortOrder
    naf18art19?: SortOrder
    art18act19?: SortOrder
    art18hab19?: SortOrder
    art18mix19?: SortOrder
    art18rou19?: SortOrder
    art18fer19?: SortOrder
    art18inc19?: SortOrder
    naf19art20?: SortOrder
    art19act20?: SortOrder
    art19hab20?: SortOrder
    art19mix20?: SortOrder
    art19rou20?: SortOrder
    art19fer20?: SortOrder
    art19inc20?: SortOrder
    naf20art21?: SortOrder
    art20act21?: SortOrder
    art20hab21?: SortOrder
    art20mix21?: SortOrder
    art20rou21?: SortOrder
    art20fer21?: SortOrder
    art20inc21?: SortOrder
    naf21art22?: SortOrder
    art21act22?: SortOrder
    art21hab22?: SortOrder
    art21mix22?: SortOrder
    art21rou22?: SortOrder
    art21fer22?: SortOrder
    art21inc22?: SortOrder
    naf22art23?: SortOrder
    art22act23?: SortOrder
    art22hab23?: SortOrder
    art22mix23?: SortOrder
    art22rou23?: SortOrder
    art22fer23?: SortOrder
    art22inc23?: SortOrder
    naf09art23?: SortOrder
    art09act23?: SortOrder
    art09hab23?: SortOrder
    art09mix23?: SortOrder
    art09inc23?: SortOrder
    art09rou23?: SortOrder
    art09fer23?: SortOrder
    artcom0923?: SortOrder
  }

  export type consommation_espaces_nafMinOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
    naf09art10?: SortOrder
    art09act10?: SortOrder
    art09hab10?: SortOrder
    art09mix10?: SortOrder
    art09rou10?: SortOrder
    art09fer10?: SortOrder
    art09inc10?: SortOrder
    naf10art11?: SortOrder
    art10act11?: SortOrder
    art10hab11?: SortOrder
    art10mix11?: SortOrder
    art10rou11?: SortOrder
    art10fer11?: SortOrder
    art10inc11?: SortOrder
    naf11art12?: SortOrder
    art11act12?: SortOrder
    art11hab12?: SortOrder
    art11mix12?: SortOrder
    art11rou12?: SortOrder
    art11fer12?: SortOrder
    art11inc12?: SortOrder
    naf12art13?: SortOrder
    art12act13?: SortOrder
    art12hab13?: SortOrder
    art12mix13?: SortOrder
    art12rou13?: SortOrder
    art12fer13?: SortOrder
    art12inc13?: SortOrder
    naf13art14?: SortOrder
    art13act14?: SortOrder
    art13hab14?: SortOrder
    art13mix14?: SortOrder
    art13rou14?: SortOrder
    art13fer14?: SortOrder
    art13inc14?: SortOrder
    naf14art15?: SortOrder
    art14act15?: SortOrder
    art14hab15?: SortOrder
    art14mix15?: SortOrder
    art14rou15?: SortOrder
    art14fer15?: SortOrder
    art14inc15?: SortOrder
    naf15art16?: SortOrder
    art15act16?: SortOrder
    art15hab16?: SortOrder
    art15mix16?: SortOrder
    art15rou16?: SortOrder
    art15fer16?: SortOrder
    art15inc16?: SortOrder
    naf16art17?: SortOrder
    art16act17?: SortOrder
    art16hab17?: SortOrder
    art16mix17?: SortOrder
    art16rou17?: SortOrder
    art16fer17?: SortOrder
    art16inc17?: SortOrder
    naf17art18?: SortOrder
    art17act18?: SortOrder
    art17hab18?: SortOrder
    art17mix18?: SortOrder
    art17rou18?: SortOrder
    art17fer18?: SortOrder
    art17inc18?: SortOrder
    naf18art19?: SortOrder
    art18act19?: SortOrder
    art18hab19?: SortOrder
    art18mix19?: SortOrder
    art18rou19?: SortOrder
    art18fer19?: SortOrder
    art18inc19?: SortOrder
    naf19art20?: SortOrder
    art19act20?: SortOrder
    art19hab20?: SortOrder
    art19mix20?: SortOrder
    art19rou20?: SortOrder
    art19fer20?: SortOrder
    art19inc20?: SortOrder
    naf20art21?: SortOrder
    art20act21?: SortOrder
    art20hab21?: SortOrder
    art20mix21?: SortOrder
    art20rou21?: SortOrder
    art20fer21?: SortOrder
    art20inc21?: SortOrder
    naf21art22?: SortOrder
    art21act22?: SortOrder
    art21hab22?: SortOrder
    art21mix22?: SortOrder
    art21rou22?: SortOrder
    art21fer22?: SortOrder
    art21inc22?: SortOrder
    naf22art23?: SortOrder
    art22act23?: SortOrder
    art22hab23?: SortOrder
    art22mix23?: SortOrder
    art22rou23?: SortOrder
    art22fer23?: SortOrder
    art22inc23?: SortOrder
    naf09art23?: SortOrder
    art09act23?: SortOrder
    art09hab23?: SortOrder
    art09mix23?: SortOrder
    art09inc23?: SortOrder
    art09rou23?: SortOrder
    art09fer23?: SortOrder
    artcom0923?: SortOrder
  }

  export type consommation_espaces_nafSumOrderByAggregateInput = {
    index?: SortOrder
    region?: SortOrder
    naf09art10?: SortOrder
    art09act10?: SortOrder
    art09hab10?: SortOrder
    art09mix10?: SortOrder
    art09rou10?: SortOrder
    art09fer10?: SortOrder
    art09inc10?: SortOrder
    naf10art11?: SortOrder
    art10act11?: SortOrder
    art10hab11?: SortOrder
    art10mix11?: SortOrder
    art10rou11?: SortOrder
    art10fer11?: SortOrder
    art10inc11?: SortOrder
    naf11art12?: SortOrder
    art11act12?: SortOrder
    art11hab12?: SortOrder
    art11mix12?: SortOrder
    art11rou12?: SortOrder
    art11fer12?: SortOrder
    art11inc12?: SortOrder
    naf12art13?: SortOrder
    art12act13?: SortOrder
    art12hab13?: SortOrder
    art12mix13?: SortOrder
    art12rou13?: SortOrder
    art12fer13?: SortOrder
    art12inc13?: SortOrder
    naf13art14?: SortOrder
    art13act14?: SortOrder
    art13hab14?: SortOrder
    art13mix14?: SortOrder
    art13rou14?: SortOrder
    art13fer14?: SortOrder
    art13inc14?: SortOrder
    naf14art15?: SortOrder
    art14act15?: SortOrder
    art14hab15?: SortOrder
    art14mix15?: SortOrder
    art14rou15?: SortOrder
    art14fer15?: SortOrder
    art14inc15?: SortOrder
    naf15art16?: SortOrder
    art15act16?: SortOrder
    art15hab16?: SortOrder
    art15mix16?: SortOrder
    art15rou16?: SortOrder
    art15fer16?: SortOrder
    art15inc16?: SortOrder
    naf16art17?: SortOrder
    art16act17?: SortOrder
    art16hab17?: SortOrder
    art16mix17?: SortOrder
    art16rou17?: SortOrder
    art16fer17?: SortOrder
    art16inc17?: SortOrder
    naf17art18?: SortOrder
    art17act18?: SortOrder
    art17hab18?: SortOrder
    art17mix18?: SortOrder
    art17rou18?: SortOrder
    art17fer18?: SortOrder
    art17inc18?: SortOrder
    naf18art19?: SortOrder
    art18act19?: SortOrder
    art18hab19?: SortOrder
    art18mix19?: SortOrder
    art18rou19?: SortOrder
    art18fer19?: SortOrder
    art18inc19?: SortOrder
    naf19art20?: SortOrder
    art19act20?: SortOrder
    art19hab20?: SortOrder
    art19mix20?: SortOrder
    art19rou20?: SortOrder
    art19fer20?: SortOrder
    art19inc20?: SortOrder
    naf20art21?: SortOrder
    art20act21?: SortOrder
    art20hab21?: SortOrder
    art20mix21?: SortOrder
    art20rou21?: SortOrder
    art20fer21?: SortOrder
    art20inc21?: SortOrder
    naf21art22?: SortOrder
    art21act22?: SortOrder
    art21hab22?: SortOrder
    art21mix22?: SortOrder
    art21rou22?: SortOrder
    art21fer22?: SortOrder
    art21inc22?: SortOrder
    naf22art23?: SortOrder
    art22act23?: SortOrder
    art22hab23?: SortOrder
    art22mix23?: SortOrder
    art22rou23?: SortOrder
    art22fer23?: SortOrder
    art22inc23?: SortOrder
    naf09art23?: SortOrder
    art09act23?: SortOrder
    art09hab23?: SortOrder
    art09mix23?: SortOrder
    art09inc23?: SortOrder
    art09rou23?: SortOrder
    art09fer23?: SortOrder
    artcom0923?: SortOrder
  }

  export type export_cours_d_eauCountOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
    cours_d_eau?: SortOrder
    etat_ecologique?: SortOrder
    longueur?: SortOrder
  }

  export type export_cours_d_eauAvgOrderByAggregateInput = {
    index?: SortOrder
    region?: SortOrder
    longueur?: SortOrder
  }

  export type export_cours_d_eauMaxOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
    cours_d_eau?: SortOrder
    etat_ecologique?: SortOrder
    longueur?: SortOrder
  }

  export type export_cours_d_eauMinOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
    cours_d_eau?: SortOrder
    etat_ecologique?: SortOrder
    longueur?: SortOrder
  }

  export type export_cours_d_eauSumOrderByAggregateInput = {
    index?: SortOrder
    region?: SortOrder
    longueur?: SortOrder
  }

  export type feux_foretCountOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
    annee?: SortOrder
    nature?: SortOrder
    surface_parcourue?: SortOrder
    surface_foret?: SortOrder
    surface_maquis_garrigues?: SortOrder
    autres_surfaces_naturelles_hors_foret?: SortOrder
    surfaces_agricoles?: SortOrder
    surfaces_non_boisees?: SortOrder
    surfaces_non_boisees_artificialisees?: SortOrder
    surfaces_non_boisees_naturelles?: SortOrder
    surface_autres_terres_boisees?: SortOrder
    autres_surfaces?: SortOrder
  }

  export type feux_foretAvgOrderByAggregateInput = {
    index?: SortOrder
    region?: SortOrder
    annee?: SortOrder
    surface_parcourue?: SortOrder
    surface_foret?: SortOrder
    surface_maquis_garrigues?: SortOrder
    autres_surfaces_naturelles_hors_foret?: SortOrder
    surfaces_agricoles?: SortOrder
    surfaces_non_boisees?: SortOrder
    surfaces_non_boisees_artificialisees?: SortOrder
    surfaces_non_boisees_naturelles?: SortOrder
    surface_autres_terres_boisees?: SortOrder
    autres_surfaces?: SortOrder
  }

  export type feux_foretMaxOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
    annee?: SortOrder
    nature?: SortOrder
    surface_parcourue?: SortOrder
    surface_foret?: SortOrder
    surface_maquis_garrigues?: SortOrder
    autres_surfaces_naturelles_hors_foret?: SortOrder
    surfaces_agricoles?: SortOrder
    surfaces_non_boisees?: SortOrder
    surfaces_non_boisees_artificialisees?: SortOrder
    surfaces_non_boisees_naturelles?: SortOrder
    surface_autres_terres_boisees?: SortOrder
    autres_surfaces?: SortOrder
  }

  export type feux_foretMinOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
    annee?: SortOrder
    nature?: SortOrder
    surface_parcourue?: SortOrder
    surface_foret?: SortOrder
    surface_maquis_garrigues?: SortOrder
    autres_surfaces_naturelles_hors_foret?: SortOrder
    surfaces_agricoles?: SortOrder
    surfaces_non_boisees?: SortOrder
    surfaces_non_boisees_artificialisees?: SortOrder
    surfaces_non_boisees_naturelles?: SortOrder
    surface_autres_terres_boisees?: SortOrder
    autres_surfaces?: SortOrder
  }

  export type feux_foretSumOrderByAggregateInput = {
    index?: SortOrder
    region?: SortOrder
    annee?: SortOrder
    surface_parcourue?: SortOrder
    surface_foret?: SortOrder
    surface_maquis_garrigues?: SortOrder
    autres_surfaces_naturelles_hors_foret?: SortOrder
    surfaces_agricoles?: SortOrder
    surfaces_non_boisees?: SortOrder
    surfaces_non_boisees_artificialisees?: SortOrder
    surfaces_non_boisees_naturelles?: SortOrder
    surface_autres_terres_boisees?: SortOrder
    autres_surfaces?: SortOrder
  }

  export type lcz_couvertureCountOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
    couverture_lcz?: SortOrder
  }

  export type lcz_couvertureAvgOrderByAggregateInput = {
    index?: SortOrder
    region?: SortOrder
    couverture_lcz?: SortOrder
  }

  export type lcz_couvertureMaxOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
    couverture_lcz?: SortOrder
  }

  export type lcz_couvertureMinOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
    couverture_lcz?: SortOrder
  }

  export type lcz_couvertureSumOrderByAggregateInput = {
    index?: SortOrder
    region?: SortOrder
    couverture_lcz?: SortOrder
  }

  export type patch4cCountOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    niveaux_marins?: SortOrder
    feux_foret?: SortOrder
    secheresse_sols?: SortOrder
    fortes_precipitations?: SortOrder
    fortes_chaleurs?: SortOrder
  }

  export type patch4cAvgOrderByAggregateInput = {
    index?: SortOrder
    niveaux_marins?: SortOrder
    feux_foret?: SortOrder
    secheresse_sols?: SortOrder
    fortes_precipitations?: SortOrder
    fortes_chaleurs?: SortOrder
  }

  export type patch4cMaxOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    niveaux_marins?: SortOrder
    feux_foret?: SortOrder
    secheresse_sols?: SortOrder
    fortes_precipitations?: SortOrder
    fortes_chaleurs?: SortOrder
  }

  export type patch4cMinOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    niveaux_marins?: SortOrder
    feux_foret?: SortOrder
    secheresse_sols?: SortOrder
    fortes_precipitations?: SortOrder
    fortes_chaleurs?: SortOrder
  }

  export type patch4cSumOrderByAggregateInput = {
    index?: SortOrder
    niveaux_marins?: SortOrder
    feux_foret?: SortOrder
    secheresse_sols?: SortOrder
    fortes_precipitations?: SortOrder
    fortes_chaleurs?: SortOrder
  }

  export type prelevements_eauCountOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
    libelle_sous_champ?: SortOrder
    A2020?: SortOrder
    A2019?: SortOrder
    A2018?: SortOrder
    A2017?: SortOrder
    A2016?: SortOrder
    A2015?: SortOrder
    A2014?: SortOrder
    A2013?: SortOrder
    A2012?: SortOrder
    A2011?: SortOrder
    A2010?: SortOrder
    A2009?: SortOrder
    A2008?: SortOrder
    sous_champ?: SortOrder
  }

  export type prelevements_eauAvgOrderByAggregateInput = {
    index?: SortOrder
    region?: SortOrder
  }

  export type prelevements_eauMaxOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
    libelle_sous_champ?: SortOrder
    A2020?: SortOrder
    A2019?: SortOrder
    A2018?: SortOrder
    A2017?: SortOrder
    A2016?: SortOrder
    A2015?: SortOrder
    A2014?: SortOrder
    A2013?: SortOrder
    A2012?: SortOrder
    A2011?: SortOrder
    A2010?: SortOrder
    A2009?: SortOrder
    A2008?: SortOrder
    sous_champ?: SortOrder
  }

  export type prelevements_eauMinOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
    libelle_sous_champ?: SortOrder
    A2020?: SortOrder
    A2019?: SortOrder
    A2018?: SortOrder
    A2017?: SortOrder
    A2016?: SortOrder
    A2015?: SortOrder
    A2014?: SortOrder
    A2013?: SortOrder
    A2012?: SortOrder
    A2011?: SortOrder
    A2010?: SortOrder
    A2009?: SortOrder
    A2008?: SortOrder
    sous_champ?: SortOrder
  }

  export type prelevements_eauSumOrderByAggregateInput = {
    index?: SortOrder
    region?: SortOrder
  }

  export type qualite_sites_baignadeCountOrderByAggregateInput = {
    index?: SortOrder
    DEP_NOM?: SortOrder
    DEP_NUM?: SortOrder
    TYPE?: SortOrder
    COMMUNE?: SortOrder
    POINT?: SortOrder
    LONG?: SortOrder
    LAT?: SortOrder
    QEB_2013?: SortOrder
    QEB_2014?: SortOrder
    QEB_2015?: SortOrder
    QEB_2016?: SortOrder
    QEB_2017?: SortOrder
    QEB_2018?: SortOrder
    QEB_2019?: SortOrder
    QEB_2020?: SortOrder
  }

  export type qualite_sites_baignadeAvgOrderByAggregateInput = {
    index?: SortOrder
    LONG?: SortOrder
    LAT?: SortOrder
  }

  export type qualite_sites_baignadeMaxOrderByAggregateInput = {
    index?: SortOrder
    DEP_NOM?: SortOrder
    DEP_NUM?: SortOrder
    TYPE?: SortOrder
    COMMUNE?: SortOrder
    POINT?: SortOrder
    LONG?: SortOrder
    LAT?: SortOrder
    QEB_2013?: SortOrder
    QEB_2014?: SortOrder
    QEB_2015?: SortOrder
    QEB_2016?: SortOrder
    QEB_2017?: SortOrder
    QEB_2018?: SortOrder
    QEB_2019?: SortOrder
    QEB_2020?: SortOrder
  }

  export type qualite_sites_baignadeMinOrderByAggregateInput = {
    index?: SortOrder
    DEP_NOM?: SortOrder
    DEP_NUM?: SortOrder
    TYPE?: SortOrder
    COMMUNE?: SortOrder
    POINT?: SortOrder
    LONG?: SortOrder
    LAT?: SortOrder
    QEB_2013?: SortOrder
    QEB_2014?: SortOrder
    QEB_2015?: SortOrder
    QEB_2016?: SortOrder
    QEB_2017?: SortOrder
    QEB_2018?: SortOrder
    QEB_2019?: SortOrder
    QEB_2020?: SortOrder
  }

  export type qualite_sites_baignadeSumOrderByAggregateInput = {
    index?: SortOrder
    LONG?: SortOrder
    LAT?: SortOrder
  }

  export type ressources_eauCountOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    LIBELLE_SOUS_CHAMP?: SortOrder
    A2020?: SortOrder
    A2019?: SortOrder
    A2018?: SortOrder
    A2017?: SortOrder
    A2016?: SortOrder
    A2015?: SortOrder
    A2014?: SortOrder
    A2013?: SortOrder
    A2012?: SortOrder
    A2011?: SortOrder
    A2010?: SortOrder
    A2009?: SortOrder
    A2008?: SortOrder
    SOUS_CHAMP?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
  }

  export type ressources_eauAvgOrderByAggregateInput = {
    index?: SortOrder
    A2020?: SortOrder
    A2019?: SortOrder
    A2018?: SortOrder
    A2017?: SortOrder
    A2016?: SortOrder
    A2015?: SortOrder
    A2014?: SortOrder
    A2013?: SortOrder
    A2012?: SortOrder
    A2011?: SortOrder
    A2010?: SortOrder
    A2009?: SortOrder
    A2008?: SortOrder
    region?: SortOrder
  }

  export type ressources_eauMaxOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    LIBELLE_SOUS_CHAMP?: SortOrder
    A2020?: SortOrder
    A2019?: SortOrder
    A2018?: SortOrder
    A2017?: SortOrder
    A2016?: SortOrder
    A2015?: SortOrder
    A2014?: SortOrder
    A2013?: SortOrder
    A2012?: SortOrder
    A2011?: SortOrder
    A2010?: SortOrder
    A2009?: SortOrder
    A2008?: SortOrder
    SOUS_CHAMP?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
  }

  export type ressources_eauMinOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    LIBELLE_SOUS_CHAMP?: SortOrder
    A2020?: SortOrder
    A2019?: SortOrder
    A2018?: SortOrder
    A2017?: SortOrder
    A2016?: SortOrder
    A2015?: SortOrder
    A2014?: SortOrder
    A2013?: SortOrder
    A2012?: SortOrder
    A2011?: SortOrder
    A2010?: SortOrder
    A2009?: SortOrder
    A2008?: SortOrder
    SOUS_CHAMP?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
  }

  export type ressources_eauSumOrderByAggregateInput = {
    index?: SortOrder
    A2020?: SortOrder
    A2019?: SortOrder
    A2018?: SortOrder
    A2017?: SortOrder
    A2016?: SortOrder
    A2015?: SortOrder
    A2014?: SortOrder
    A2013?: SortOrder
    A2012?: SortOrder
    A2011?: SortOrder
    A2010?: SortOrder
    A2009?: SortOrder
    A2008?: SortOrder
    region?: SortOrder
  }

  export type rgaCountOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
    nb_logement?: SortOrder
    nb_logement_alea_moyen_fort?: SortOrder
    nb_logement_alea_faible?: SortOrder
    nb_logement_sans_alea?: SortOrder
    nb_logement_alea_moyen_fort_avant_1920?: SortOrder
    nb_logement_alea_moyen_fort_1920_1945?: SortOrder
    nb_logement_alea_moyen_fort_1945_1975?: SortOrder
    nb_logement_alea_moyen_fort_apres_1975?: SortOrder
    nb_logement_alea_faible_avant_1920?: SortOrder
    nb_logement_alea_faible_1920_1945?: SortOrder
    nb_logement_alea_faible_1945_1975?: SortOrder
    nb_logement_alea_faible_apres_1975?: SortOrder
    surface_commune?: SortOrder
    surface_alea_faible_commune?: SortOrder
    surface_alea_moyen_fort_commune?: SortOrder
    part_logement_alea_moyen_fort_avant_1920?: SortOrder
    part_logement_alea_moyen_fort_1920_1945?: SortOrder
    part_logement_alea_moyen_fort_1945_1975?: SortOrder
    part_logement_alea_moyen_fort_apres_1975?: SortOrder
    part_logement_alea_faible_avant_1920?: SortOrder
    part_logement_alea_faible_1920_1945?: SortOrder
    part_logement_alea_faible_1945_1975?: SortOrder
    part_logement_alea_faible_apres_1975?: SortOrder
    part_alea_faible_commune?: SortOrder
    part_alea_moyen_fort_commune?: SortOrder
  }

  export type rgaAvgOrderByAggregateInput = {
    index?: SortOrder
    region?: SortOrder
    nb_logement?: SortOrder
    nb_logement_alea_moyen_fort?: SortOrder
    nb_logement_alea_faible?: SortOrder
    nb_logement_sans_alea?: SortOrder
    nb_logement_alea_moyen_fort_avant_1920?: SortOrder
    nb_logement_alea_moyen_fort_1920_1945?: SortOrder
    nb_logement_alea_moyen_fort_1945_1975?: SortOrder
    nb_logement_alea_moyen_fort_apres_1975?: SortOrder
    nb_logement_alea_faible_avant_1920?: SortOrder
    nb_logement_alea_faible_1920_1945?: SortOrder
    nb_logement_alea_faible_1945_1975?: SortOrder
    nb_logement_alea_faible_apres_1975?: SortOrder
    surface_commune?: SortOrder
    surface_alea_faible_commune?: SortOrder
    surface_alea_moyen_fort_commune?: SortOrder
    part_logement_alea_moyen_fort_avant_1920?: SortOrder
    part_logement_alea_moyen_fort_1920_1945?: SortOrder
    part_logement_alea_moyen_fort_1945_1975?: SortOrder
    part_logement_alea_moyen_fort_apres_1975?: SortOrder
    part_logement_alea_faible_avant_1920?: SortOrder
    part_logement_alea_faible_1920_1945?: SortOrder
    part_logement_alea_faible_1945_1975?: SortOrder
    part_logement_alea_faible_apres_1975?: SortOrder
    part_alea_faible_commune?: SortOrder
    part_alea_moyen_fort_commune?: SortOrder
  }

  export type rgaMaxOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
    nb_logement?: SortOrder
    nb_logement_alea_moyen_fort?: SortOrder
    nb_logement_alea_faible?: SortOrder
    nb_logement_sans_alea?: SortOrder
    nb_logement_alea_moyen_fort_avant_1920?: SortOrder
    nb_logement_alea_moyen_fort_1920_1945?: SortOrder
    nb_logement_alea_moyen_fort_1945_1975?: SortOrder
    nb_logement_alea_moyen_fort_apres_1975?: SortOrder
    nb_logement_alea_faible_avant_1920?: SortOrder
    nb_logement_alea_faible_1920_1945?: SortOrder
    nb_logement_alea_faible_1945_1975?: SortOrder
    nb_logement_alea_faible_apres_1975?: SortOrder
    surface_commune?: SortOrder
    surface_alea_faible_commune?: SortOrder
    surface_alea_moyen_fort_commune?: SortOrder
    part_logement_alea_moyen_fort_avant_1920?: SortOrder
    part_logement_alea_moyen_fort_1920_1945?: SortOrder
    part_logement_alea_moyen_fort_1945_1975?: SortOrder
    part_logement_alea_moyen_fort_apres_1975?: SortOrder
    part_logement_alea_faible_avant_1920?: SortOrder
    part_logement_alea_faible_1920_1945?: SortOrder
    part_logement_alea_faible_1945_1975?: SortOrder
    part_logement_alea_faible_apres_1975?: SortOrder
    part_alea_faible_commune?: SortOrder
    part_alea_moyen_fort_commune?: SortOrder
  }

  export type rgaMinOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
    nb_logement?: SortOrder
    nb_logement_alea_moyen_fort?: SortOrder
    nb_logement_alea_faible?: SortOrder
    nb_logement_sans_alea?: SortOrder
    nb_logement_alea_moyen_fort_avant_1920?: SortOrder
    nb_logement_alea_moyen_fort_1920_1945?: SortOrder
    nb_logement_alea_moyen_fort_1945_1975?: SortOrder
    nb_logement_alea_moyen_fort_apres_1975?: SortOrder
    nb_logement_alea_faible_avant_1920?: SortOrder
    nb_logement_alea_faible_1920_1945?: SortOrder
    nb_logement_alea_faible_1945_1975?: SortOrder
    nb_logement_alea_faible_apres_1975?: SortOrder
    surface_commune?: SortOrder
    surface_alea_faible_commune?: SortOrder
    surface_alea_moyen_fort_commune?: SortOrder
    part_logement_alea_moyen_fort_avant_1920?: SortOrder
    part_logement_alea_moyen_fort_1920_1945?: SortOrder
    part_logement_alea_moyen_fort_1945_1975?: SortOrder
    part_logement_alea_moyen_fort_apres_1975?: SortOrder
    part_logement_alea_faible_avant_1920?: SortOrder
    part_logement_alea_faible_1920_1945?: SortOrder
    part_logement_alea_faible_1945_1975?: SortOrder
    part_logement_alea_faible_apres_1975?: SortOrder
    part_alea_faible_commune?: SortOrder
    part_alea_moyen_fort_commune?: SortOrder
  }

  export type rgaSumOrderByAggregateInput = {
    index?: SortOrder
    region?: SortOrder
    nb_logement?: SortOrder
    nb_logement_alea_moyen_fort?: SortOrder
    nb_logement_alea_faible?: SortOrder
    nb_logement_sans_alea?: SortOrder
    nb_logement_alea_moyen_fort_avant_1920?: SortOrder
    nb_logement_alea_moyen_fort_1920_1945?: SortOrder
    nb_logement_alea_moyen_fort_1945_1975?: SortOrder
    nb_logement_alea_moyen_fort_apres_1975?: SortOrder
    nb_logement_alea_faible_avant_1920?: SortOrder
    nb_logement_alea_faible_1920_1945?: SortOrder
    nb_logement_alea_faible_1945_1975?: SortOrder
    nb_logement_alea_faible_apres_1975?: SortOrder
    surface_commune?: SortOrder
    surface_alea_faible_commune?: SortOrder
    surface_alea_moyen_fort_commune?: SortOrder
    part_logement_alea_moyen_fort_avant_1920?: SortOrder
    part_logement_alea_moyen_fort_1920_1945?: SortOrder
    part_logement_alea_moyen_fort_1945_1975?: SortOrder
    part_logement_alea_moyen_fort_apres_1975?: SortOrder
    part_logement_alea_faible_avant_1920?: SortOrder
    part_logement_alea_faible_1920_1945?: SortOrder
    part_logement_alea_faible_1945_1975?: SortOrder
    part_logement_alea_faible_apres_1975?: SortOrder
    part_alea_faible_commune?: SortOrder
    part_alea_moyen_fort_commune?: SortOrder
  }

  export type surfaces_agricolesCountOrderByAggregateInput = {
    index?: SortOrder
    epci?: SortOrder
    exploitation_sau?: SortOrder
    exploitation_sau_terres_arables?: SortOrder
    exploitation_sau_terres_arables_cereales?: SortOrder
    exploitation_sau_terres_arables_oleagineux?: SortOrder
    exploitation_sau_terres_arables_fourrageres?: SortOrder
    exploitation_sau_terres_arables_tubercules?: SortOrder
    exploitation_sau_terres_arables_legumes_melons_fraises?: SortOrder
    exploitation_sau_terres_arables_fleurs?: SortOrder
    exploitation_sau_terres_arables_autres?: SortOrder
    exploitation_sau_cultures_permanentes?: SortOrder
    exploitation_sau_cultures_permanentes_vigne?: SortOrder
    exploitation_sau_cultures_permanentes_fruits?: SortOrder
    exploitation_sau_cultures_permanentes_autres?: SortOrder
    exploitation_sau_herbe?: SortOrder
    exploitation_sau_herbe_prairies_productives?: SortOrder
    exploitation_sau_herbe_prairies_peu_productives?: SortOrder
    exploitation_sau_herbe_subventions?: SortOrder
    exploitation_sau_herbe_bois_patures?: SortOrder
    exploitation_sau_jardins?: SortOrder
    superficie_sau?: SortOrder
    superficie_sau_terres_arables?: SortOrder
    superficie_sau_terres_arables_cereales?: SortOrder
    superficie_sau_terres_arables_oleagineux?: SortOrder
    superficie_sau_terres_arables_fourrageres?: SortOrder
    superficie_sau_terres_arables_tubercules?: SortOrder
    superficie_sau_terres_arables_legumes_melons_fraises?: SortOrder
    superficie_sau_terres_arables_fleurs?: SortOrder
    superficie_sau_terres_arables_autres?: SortOrder
    superficie_sau_cultures_permanentes?: SortOrder
    superficie_sau_cultures_permanentes_vigne?: SortOrder
    superficie_sau_cultures_permanentes_fruits?: SortOrder
    superficie_sau_cultures_permanentes_autres?: SortOrder
    superficie_sau_herbe?: SortOrder
    superficie_sau_herbe_prairies_productives?: SortOrder
    superficie_sau_herbe_prairies_peu_productives?: SortOrder
    superficie_sau_herbe_subventions?: SortOrder
    superficie_sau_herbe_bois_patures?: SortOrder
    superficie_sau_jardins?: SortOrder
  }

  export type surfaces_agricolesAvgOrderByAggregateInput = {
    index?: SortOrder
    exploitation_sau?: SortOrder
    exploitation_sau_terres_arables?: SortOrder
    exploitation_sau_terres_arables_cereales?: SortOrder
    exploitation_sau_terres_arables_oleagineux?: SortOrder
    exploitation_sau_terres_arables_fourrageres?: SortOrder
    exploitation_sau_terres_arables_tubercules?: SortOrder
    exploitation_sau_terres_arables_legumes_melons_fraises?: SortOrder
    exploitation_sau_terres_arables_fleurs?: SortOrder
    exploitation_sau_terres_arables_autres?: SortOrder
    exploitation_sau_cultures_permanentes?: SortOrder
    exploitation_sau_cultures_permanentes_vigne?: SortOrder
    exploitation_sau_cultures_permanentes_fruits?: SortOrder
    exploitation_sau_cultures_permanentes_autres?: SortOrder
    exploitation_sau_herbe?: SortOrder
    exploitation_sau_herbe_prairies_productives?: SortOrder
    exploitation_sau_herbe_prairies_peu_productives?: SortOrder
    exploitation_sau_herbe_subventions?: SortOrder
    exploitation_sau_herbe_bois_patures?: SortOrder
    exploitation_sau_jardins?: SortOrder
    superficie_sau?: SortOrder
    superficie_sau_terres_arables?: SortOrder
    superficie_sau_terres_arables_cereales?: SortOrder
    superficie_sau_terres_arables_oleagineux?: SortOrder
    superficie_sau_terres_arables_fourrageres?: SortOrder
    superficie_sau_terres_arables_tubercules?: SortOrder
    superficie_sau_terres_arables_legumes_melons_fraises?: SortOrder
    superficie_sau_terres_arables_fleurs?: SortOrder
    superficie_sau_terres_arables_autres?: SortOrder
    superficie_sau_cultures_permanentes?: SortOrder
    superficie_sau_cultures_permanentes_vigne?: SortOrder
    superficie_sau_cultures_permanentes_fruits?: SortOrder
    superficie_sau_cultures_permanentes_autres?: SortOrder
    superficie_sau_herbe?: SortOrder
    superficie_sau_herbe_prairies_productives?: SortOrder
    superficie_sau_herbe_prairies_peu_productives?: SortOrder
    superficie_sau_herbe_subventions?: SortOrder
    superficie_sau_herbe_bois_patures?: SortOrder
    superficie_sau_jardins?: SortOrder
  }

  export type surfaces_agricolesMaxOrderByAggregateInput = {
    index?: SortOrder
    epci?: SortOrder
    exploitation_sau?: SortOrder
    exploitation_sau_terres_arables?: SortOrder
    exploitation_sau_terres_arables_cereales?: SortOrder
    exploitation_sau_terres_arables_oleagineux?: SortOrder
    exploitation_sau_terres_arables_fourrageres?: SortOrder
    exploitation_sau_terres_arables_tubercules?: SortOrder
    exploitation_sau_terres_arables_legumes_melons_fraises?: SortOrder
    exploitation_sau_terres_arables_fleurs?: SortOrder
    exploitation_sau_terres_arables_autres?: SortOrder
    exploitation_sau_cultures_permanentes?: SortOrder
    exploitation_sau_cultures_permanentes_vigne?: SortOrder
    exploitation_sau_cultures_permanentes_fruits?: SortOrder
    exploitation_sau_cultures_permanentes_autres?: SortOrder
    exploitation_sau_herbe?: SortOrder
    exploitation_sau_herbe_prairies_productives?: SortOrder
    exploitation_sau_herbe_prairies_peu_productives?: SortOrder
    exploitation_sau_herbe_subventions?: SortOrder
    exploitation_sau_herbe_bois_patures?: SortOrder
    exploitation_sau_jardins?: SortOrder
    superficie_sau?: SortOrder
    superficie_sau_terres_arables?: SortOrder
    superficie_sau_terres_arables_cereales?: SortOrder
    superficie_sau_terres_arables_oleagineux?: SortOrder
    superficie_sau_terres_arables_fourrageres?: SortOrder
    superficie_sau_terres_arables_tubercules?: SortOrder
    superficie_sau_terres_arables_legumes_melons_fraises?: SortOrder
    superficie_sau_terres_arables_fleurs?: SortOrder
    superficie_sau_terres_arables_autres?: SortOrder
    superficie_sau_cultures_permanentes?: SortOrder
    superficie_sau_cultures_permanentes_vigne?: SortOrder
    superficie_sau_cultures_permanentes_fruits?: SortOrder
    superficie_sau_cultures_permanentes_autres?: SortOrder
    superficie_sau_herbe?: SortOrder
    superficie_sau_herbe_prairies_productives?: SortOrder
    superficie_sau_herbe_prairies_peu_productives?: SortOrder
    superficie_sau_herbe_subventions?: SortOrder
    superficie_sau_herbe_bois_patures?: SortOrder
    superficie_sau_jardins?: SortOrder
  }

  export type surfaces_agricolesMinOrderByAggregateInput = {
    index?: SortOrder
    epci?: SortOrder
    exploitation_sau?: SortOrder
    exploitation_sau_terres_arables?: SortOrder
    exploitation_sau_terres_arables_cereales?: SortOrder
    exploitation_sau_terres_arables_oleagineux?: SortOrder
    exploitation_sau_terres_arables_fourrageres?: SortOrder
    exploitation_sau_terres_arables_tubercules?: SortOrder
    exploitation_sau_terres_arables_legumes_melons_fraises?: SortOrder
    exploitation_sau_terres_arables_fleurs?: SortOrder
    exploitation_sau_terres_arables_autres?: SortOrder
    exploitation_sau_cultures_permanentes?: SortOrder
    exploitation_sau_cultures_permanentes_vigne?: SortOrder
    exploitation_sau_cultures_permanentes_fruits?: SortOrder
    exploitation_sau_cultures_permanentes_autres?: SortOrder
    exploitation_sau_herbe?: SortOrder
    exploitation_sau_herbe_prairies_productives?: SortOrder
    exploitation_sau_herbe_prairies_peu_productives?: SortOrder
    exploitation_sau_herbe_subventions?: SortOrder
    exploitation_sau_herbe_bois_patures?: SortOrder
    exploitation_sau_jardins?: SortOrder
    superficie_sau?: SortOrder
    superficie_sau_terres_arables?: SortOrder
    superficie_sau_terres_arables_cereales?: SortOrder
    superficie_sau_terres_arables_oleagineux?: SortOrder
    superficie_sau_terres_arables_fourrageres?: SortOrder
    superficie_sau_terres_arables_tubercules?: SortOrder
    superficie_sau_terres_arables_legumes_melons_fraises?: SortOrder
    superficie_sau_terres_arables_fleurs?: SortOrder
    superficie_sau_terres_arables_autres?: SortOrder
    superficie_sau_cultures_permanentes?: SortOrder
    superficie_sau_cultures_permanentes_vigne?: SortOrder
    superficie_sau_cultures_permanentes_fruits?: SortOrder
    superficie_sau_cultures_permanentes_autres?: SortOrder
    superficie_sau_herbe?: SortOrder
    superficie_sau_herbe_prairies_productives?: SortOrder
    superficie_sau_herbe_prairies_peu_productives?: SortOrder
    superficie_sau_herbe_subventions?: SortOrder
    superficie_sau_herbe_bois_patures?: SortOrder
    superficie_sau_jardins?: SortOrder
  }

  export type surfaces_agricolesSumOrderByAggregateInput = {
    index?: SortOrder
    exploitation_sau?: SortOrder
    exploitation_sau_terres_arables?: SortOrder
    exploitation_sau_terres_arables_cereales?: SortOrder
    exploitation_sau_terres_arables_oleagineux?: SortOrder
    exploitation_sau_terres_arables_fourrageres?: SortOrder
    exploitation_sau_terres_arables_tubercules?: SortOrder
    exploitation_sau_terres_arables_legumes_melons_fraises?: SortOrder
    exploitation_sau_terres_arables_fleurs?: SortOrder
    exploitation_sau_terres_arables_autres?: SortOrder
    exploitation_sau_cultures_permanentes?: SortOrder
    exploitation_sau_cultures_permanentes_vigne?: SortOrder
    exploitation_sau_cultures_permanentes_fruits?: SortOrder
    exploitation_sau_cultures_permanentes_autres?: SortOrder
    exploitation_sau_herbe?: SortOrder
    exploitation_sau_herbe_prairies_productives?: SortOrder
    exploitation_sau_herbe_prairies_peu_productives?: SortOrder
    exploitation_sau_herbe_subventions?: SortOrder
    exploitation_sau_herbe_bois_patures?: SortOrder
    exploitation_sau_jardins?: SortOrder
    superficie_sau?: SortOrder
    superficie_sau_terres_arables?: SortOrder
    superficie_sau_terres_arables_cereales?: SortOrder
    superficie_sau_terres_arables_oleagineux?: SortOrder
    superficie_sau_terres_arables_fourrageres?: SortOrder
    superficie_sau_terres_arables_tubercules?: SortOrder
    superficie_sau_terres_arables_legumes_melons_fraises?: SortOrder
    superficie_sau_terres_arables_fleurs?: SortOrder
    superficie_sau_terres_arables_autres?: SortOrder
    superficie_sau_cultures_permanentes?: SortOrder
    superficie_sau_cultures_permanentes_vigne?: SortOrder
    superficie_sau_cultures_permanentes_fruits?: SortOrder
    superficie_sau_cultures_permanentes_autres?: SortOrder
    superficie_sau_herbe?: SortOrder
    superficie_sau_herbe_prairies_productives?: SortOrder
    superficie_sau_herbe_prairies_peu_productives?: SortOrder
    superficie_sau_herbe_subventions?: SortOrder
    superficie_sau_herbe_bois_patures?: SortOrder
    superficie_sau_jardins?: SortOrder
  }

  export type surfaces_protegeesCountOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    PNC?: SortOrder
    RAMSAR?: SortOrder
    PNR?: SortOrder
    PNP?: SortOrder
    FOR_PRO?: SortOrder
    ZZZ?: SortOrder
    ZNIEFF2?: SortOrder
    ZNIEFF1?: SortOrder
    RNR?: SortOrder
    TOU_PRO?: SortOrder
    NATURA?: SortOrder
    ZPS?: SortOrder
    SIC?: SortOrder
    CELRL?: SortOrder
    BIO?: SortOrder
    APB?: SortOrder
    RN?: SortOrder
    RBFD?: SortOrder
    RNCFS?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    region?: SortOrder
  }

  export type surfaces_protegeesAvgOrderByAggregateInput = {
    index?: SortOrder
    region?: SortOrder
  }

  export type surfaces_protegeesMaxOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    PNC?: SortOrder
    RAMSAR?: SortOrder
    PNR?: SortOrder
    PNP?: SortOrder
    FOR_PRO?: SortOrder
    ZZZ?: SortOrder
    ZNIEFF2?: SortOrder
    ZNIEFF1?: SortOrder
    RNR?: SortOrder
    TOU_PRO?: SortOrder
    NATURA?: SortOrder
    ZPS?: SortOrder
    SIC?: SortOrder
    CELRL?: SortOrder
    BIO?: SortOrder
    APB?: SortOrder
    RN?: SortOrder
    RBFD?: SortOrder
    RNCFS?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    region?: SortOrder
  }

  export type surfaces_protegeesMinOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    PNC?: SortOrder
    RAMSAR?: SortOrder
    PNR?: SortOrder
    PNP?: SortOrder
    FOR_PRO?: SortOrder
    ZZZ?: SortOrder
    ZNIEFF2?: SortOrder
    ZNIEFF1?: SortOrder
    RNR?: SortOrder
    TOU_PRO?: SortOrder
    NATURA?: SortOrder
    ZPS?: SortOrder
    SIC?: SortOrder
    CELRL?: SortOrder
    BIO?: SortOrder
    APB?: SortOrder
    RN?: SortOrder
    RBFD?: SortOrder
    RNCFS?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    region?: SortOrder
  }

  export type surfaces_protegeesSumOrderByAggregateInput = {
    index?: SortOrder
    region?: SortOrder
  }

  export type table_communeCountOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
    atlas_biodiversite_nom?: SortOrder
    atlas_biodiversite_annee_debut?: SortOrder
    atlas_biodiversite_avancement?: SortOrder
    type_touristique?: SortOrder
    otex_12_postes?: SortOrder
    part_irr_sau_2020?: SortOrder
    agriculture_part_over_55?: SortOrder
    couverture_lcz?: SortOrder
  }

  export type table_communeAvgOrderByAggregateInput = {
    index?: SortOrder
    region?: SortOrder
  }

  export type table_communeMaxOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
    atlas_biodiversite_nom?: SortOrder
    atlas_biodiversite_annee_debut?: SortOrder
    atlas_biodiversite_avancement?: SortOrder
    type_touristique?: SortOrder
    otex_12_postes?: SortOrder
    part_irr_sau_2020?: SortOrder
    agriculture_part_over_55?: SortOrder
    couverture_lcz?: SortOrder
  }

  export type table_communeMinOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
    atlas_biodiversite_nom?: SortOrder
    atlas_biodiversite_annee_debut?: SortOrder
    atlas_biodiversite_avancement?: SortOrder
    type_touristique?: SortOrder
    otex_12_postes?: SortOrder
    part_irr_sau_2020?: SortOrder
    agriculture_part_over_55?: SortOrder
    couverture_lcz?: SortOrder
  }

  export type table_communeSumOrderByAggregateInput = {
    index?: SortOrder
    region?: SortOrder
  }

  export type table_territoiresCountOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
  }

  export type table_territoiresAvgOrderByAggregateInput = {
    index?: SortOrder
    region?: SortOrder
  }

  export type table_territoiresMaxOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
  }

  export type table_territoiresMinOrderByAggregateInput = {
    index?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
  }

  export type table_territoiresSumOrderByAggregateInput = {
    index?: SortOrder
    region?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type communes_dromCountOrderByAggregateInput = {
    pk?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
    coordinates?: SortOrder
    precarite_logement?: SortOrder
    surface?: SortOrder
  }

  export type communes_dromAvgOrderByAggregateInput = {
    pk?: SortOrder
    region?: SortOrder
    precarite_logement?: SortOrder
    surface?: SortOrder
  }

  export type communes_dromMaxOrderByAggregateInput = {
    pk?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
    coordinates?: SortOrder
    precarite_logement?: SortOrder
    surface?: SortOrder
  }

  export type communes_dromMinOrderByAggregateInput = {
    pk?: SortOrder
    code_geographique?: SortOrder
    libelle_geographique?: SortOrder
    epci?: SortOrder
    libelle_epci?: SortOrder
    departement?: SortOrder
    libelle_departement?: SortOrder
    region?: SortOrder
    ept?: SortOrder
    libelle_petr?: SortOrder
    code_pnr?: SortOrder
    libelle_pnr?: SortOrder
    coordinates?: SortOrder
    precarite_logement?: SortOrder
    surface?: SortOrder
  }

  export type communes_dromSumOrderByAggregateInput = {
    pk?: SortOrder
    region?: SortOrder
    precarite_logement?: SortOrder
    surface?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type erosion_cotiereCountOrderByAggregateInput = {
    pk?: SortOrder
    taux?: SortOrder
    duree?: SortOrder
    tdc_ancien?: SortOrder
    tdc_rec?: SortOrder
  }

  export type erosion_cotiereAvgOrderByAggregateInput = {
    pk?: SortOrder
    taux?: SortOrder
    duree?: SortOrder
    tdc_ancien?: SortOrder
    tdc_rec?: SortOrder
  }

  export type erosion_cotiereMaxOrderByAggregateInput = {
    pk?: SortOrder
    taux?: SortOrder
    duree?: SortOrder
    tdc_ancien?: SortOrder
    tdc_rec?: SortOrder
  }

  export type erosion_cotiereMinOrderByAggregateInput = {
    pk?: SortOrder
    taux?: SortOrder
    duree?: SortOrder
    tdc_ancien?: SortOrder
    tdc_rec?: SortOrder
  }

  export type erosion_cotiereSumOrderByAggregateInput = {
    pk?: SortOrder
    taux?: SortOrder
    duree?: SortOrder
    tdc_ancien?: SortOrder
    tdc_rec?: SortOrder
  }

  export type etat_cours_d_eauCountOrderByAggregateInput = {
    pk?: SortOrder
    name?: SortOrder
    longueur?: SortOrder
    etateco?: SortOrder
  }

  export type etat_cours_d_eauAvgOrderByAggregateInput = {
    pk?: SortOrder
    longueur?: SortOrder
  }

  export type etat_cours_d_eauMaxOrderByAggregateInput = {
    pk?: SortOrder
    name?: SortOrder
    longueur?: SortOrder
    etateco?: SortOrder
  }

  export type etat_cours_d_eauMinOrderByAggregateInput = {
    pk?: SortOrder
    name?: SortOrder
    longueur?: SortOrder
    etateco?: SortOrder
  }

  export type etat_cours_d_eauSumOrderByAggregateInput = {
    pk?: SortOrder
    longueur?: SortOrder
  }

  export type spatial_ref_sysCountOrderByAggregateInput = {
    srid?: SortOrder
    auth_name?: SortOrder
    auth_srid?: SortOrder
    srtext?: SortOrder
    proj4text?: SortOrder
  }

  export type spatial_ref_sysAvgOrderByAggregateInput = {
    srid?: SortOrder
    auth_srid?: SortOrder
  }

  export type spatial_ref_sysMaxOrderByAggregateInput = {
    srid?: SortOrder
    auth_name?: SortOrder
    auth_srid?: SortOrder
    srtext?: SortOrder
    proj4text?: SortOrder
  }

  export type spatial_ref_sysMinOrderByAggregateInput = {
    srid?: SortOrder
    auth_name?: SortOrder
    auth_srid?: SortOrder
    srtext?: SortOrder
    proj4text?: SortOrder
  }

  export type spatial_ref_sysSumOrderByAggregateInput = {
    srid?: SortOrder
    auth_srid?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type baserow_evenementsCreatequi_anime_evenementInput = {
    set: string[]
  }

  export type baserow_evenementsCreatenom_participantsInput = {
    set: string[]
  }

  export type baserow_evenementsCreatenom_territoiresInput = {
    set: string[]
  }

  export type baserow_evenementsCreatepropos_nom_evenementInput = {
    set: string[]
  }

  export type baserow_evenementsCreatechamps_rapporteInput = {
    set: string[]
  }

  export type baserow_evenementsCreatefichierInput = {
    set: string[]
  }

  export type baserow_evenementsUpdatequi_anime_evenementInput = {
    set?: string[]
    push?: string | string[]
  }

  export type baserow_evenementsUpdatenom_participantsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type baserow_evenementsUpdatenom_territoiresInput = {
    set?: string[]
    push?: string | string[]
  }

  export type baserow_evenementsUpdatepropos_nom_evenementInput = {
    set?: string[]
    push?: string | string[]
  }

  export type baserow_evenementsUpdatechamps_rapporteInput = {
    set?: string[]
    push?: string | string[]
  }

  export type baserow_evenementsUpdatefichierInput = {
    set?: string[]
    push?: string | string[]
  }

  export type baserow_territoiresCreatetypologie_territoireInput = {
    set: string[]
  }

  export type baserow_territoiresCreatethematique_prioritaireInput = {
    set: string[]
  }

  export type baserow_territoiresCreatedemarches_et_programmesInput = {
    set: string[]
  }

  export type baserow_territoiresCreatedocuments_de_planificationInput = {
    set: string[]
  }

  export type baserow_territoiresCreateavancee_sur_le_ddvInput = {
    set: string[]
  }

  export type baserow_territoiresCreateavancee_sur_la_strategieInput = {
    set: string[]
  }

  export type baserow_territoiresCreateproposInput = {
    set: string[]
  }

  export type baserow_territoiresCreateattente_session_accueilInput = {
    set: string[]
  }

  export type baserow_territoiresCreaterole_beInput = {
    set: string[]
  }

  export type baserow_territoiresCreatecdmInput = {
    set: string[]
  }

  export type baserow_territoiresUpdatetypologie_territoireInput = {
    set?: string[]
    push?: string | string[]
  }

  export type baserow_territoiresUpdatethematique_prioritaireInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type baserow_territoiresUpdatedemarches_et_programmesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type baserow_territoiresUpdatedocuments_de_planificationInput = {
    set?: string[]
    push?: string | string[]
  }

  export type baserow_territoiresUpdateavancee_sur_le_ddvInput = {
    set?: string[]
    push?: string | string[]
  }

  export type baserow_territoiresUpdateavancee_sur_la_strategieInput = {
    set?: string[]
    push?: string | string[]
  }

  export type baserow_territoiresUpdateproposInput = {
    set?: string[]
    push?: string | string[]
  }

  export type baserow_territoiresUpdateattente_session_accueilInput = {
    set?: string[]
    push?: string | string[]
  }

  export type baserow_territoiresUpdaterole_beInput = {
    set?: string[]
    push?: string | string[]
  }

  export type baserow_territoiresUpdatecdmInput = {
    set?: string[]
    push?: string | string[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}